{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/uploads/avatar.jpg","path":"uploads/avatar.jpg","modified":0,"renderable":0},{"_id":"source/uploads/background.png","path":"uploads/background.png","modified":0,"renderable":0},{"_id":"source/uploads/wechat-reward-image.jpeg","path":"uploads/wechat-reward-image.jpeg","modified":0,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/LICENSE","path":"vendors/fastclick/LICENSE","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/README.md","path":"vendors/fastclick/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/bower.json","path":"vendors/fastclick/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/bower.json","path":"vendors/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/HELP-US-OUT.txt","path":"vendors/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/CONTRIBUTING.md","path":"vendors/jquery_lazyload/CONTRIBUTING.md","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/README.md","path":"vendors/jquery_lazyload/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/bower.json","path":"vendors/jquery_lazyload/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.lazyload.js","path":"vendors/jquery_lazyload/jquery.lazyload.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.scrollstop.js","path":"vendors/jquery_lazyload/jquery.scrollstop.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/velocity/bower.json","path":"vendors/velocity/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/velocity/velocity.min.js","path":"vendors/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/velocity/velocity.ui.js","path":"vendors/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/velocity/velocity.ui.min.js","path":"vendors/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/jquery/index.js","path":"vendors/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/blank.gif","path":"vendors/fancybox/source/blank.gif","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading@2x.gif","path":"vendors/fancybox/source/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading.gif","path":"vendors/fancybox/source/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_overlay.png","path":"vendors/fancybox/source/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite.png","path":"vendors/fancybox/source/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite@2x.png","path":"vendors/fancybox/source/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.css","path":"vendors/fancybox/source/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.js","path":"vendors/fancybox/source/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.pack.js","path":"vendors/fancybox/source/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.js","path":"vendors/fastclick/lib/fastclick.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.min.js","path":"vendors/fastclick/lib/fastclick.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css","path":"vendors/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css.map","path":"vendors/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.min.css","path":"vendors/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff2","path":"vendors/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/ua-parser-js/dist/ua-parser.pack.js","path":"vendors/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/ua-parser-js/dist/ua-parser.min.js","path":"vendors/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/FontAwesome.otf","path":"vendors/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.eot","path":"vendors/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff","path":"vendors/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/velocity/velocity.js","path":"vendors/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/fancybox_buttons.png","path":"vendors/fancybox/source/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-media.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.ttf","path":"vendors/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.svg","path":"vendors/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"d42a9024ea6b27a39dcb9f51916cb4d29d17699a","modified":1718357133673},{"_id":"themes/next/.bowerrc","hash":"80e096fdc1cf912ee85dd9f7e6e77fd40cf60f10","modified":1718357133721},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1718357133722},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1718357133722},{"_id":"themes/next/.javascript_ignore","hash":"d619ee13031908cd72666e4ff652d2ea3483b1c3","modified":1718357133722},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1718357133722},{"_id":"themes/next/README.en.md","hash":"565ba52b3825b85a9f05b41183caca7f18b741d4","modified":1718357133722},{"_id":"themes/next/README.md","hash":"500b5606eb6a09c979d16128f8b00f4bf9bc95ac","modified":1718357133723},{"_id":"themes/next/_config.yml","hash":"10704524c5174a75b11a8b6fc9f4ad4dfc061d51","modified":1718357133723},{"_id":"themes/next/bower.json","hash":"f89c6700a11d81e067cc97273ca6bf96cb88c8f9","modified":1718357133723},{"_id":"themes/next/gulpfile.coffee","hash":"26e5b1b945704c8bc78b928feede895c4c111c95","modified":1718357133723},{"_id":"themes/next/package.json","hash":"63e9c0f1dd9e5d7f51b4ae383981ef939a2ed45d","modified":1718357133742},{"_id":"source/_posts/Activity启动流程分析.md","hash":"f11ae67467310d8a64f8ac35b18650eb5c113e92","modified":1718357133674},{"_id":"source/_posts/Activity启动流程分析2.md","hash":"767b9548dd8c9412df6ff21129a1595b6171068d","modified":1718357133675},{"_id":"source/_posts/Activity启动流程番外篇.md","hash":"d233bd91b430330eaf4ee91fc5952eb2872100e3","modified":1718357133675},{"_id":"source/_posts/Activity管理结构及源码分析.md","hash":"6733c64186626b3c0ea18ef770f783aee2623cbe","modified":1718357133675},{"_id":"source/_posts/AndroidNDK使用简介.md","hash":"0301b774dbe94f6dc3cb8fac3bcfb398858cdb0c","modified":1718357133676},{"_id":"source/_posts/Proguard指南.md","hash":"236045f3f86894e3d32579cc62a9cd27457a3899","modified":1718357133676},{"_id":"source/_posts/SpringMVC从request到controller过程详解.md","hash":"a605a675e798445f9bc9aa29065fd2a5e90ef307","modified":1718357133676},{"_id":"source/_posts/SpringMVC对象绑定自定义名称对应关系.md","hash":"d6436898de4d6b92c7ec3c9a84ffdbb40f21e21f","modified":1718357133677},{"_id":"source/_posts/Tensorflow入门2-使用CNN网络识别股票自选股图片.md","hash":"f999f325c25c0d5cb096b5dfbbab1833b878c99a","modified":1718678568918},{"_id":"source/_posts/Tensorflow入门.md","hash":"f199ee733484c6bee8ff07a8c7e458b758814827","modified":1718357133677},{"_id":"source/_posts/fastjson使用过程中的坑.md","hash":"22b910379bbdceea64914bda9e0dfc7fbadf1c23","modified":1718357133678},{"_id":"source/_posts/分类模型优劣评估.md","hash":"1f7d2215c5670fe1c54a31250f06a97707d96d45","modified":1718357133678},{"_id":"source/_posts/基于LinkMap分析iOSAPP各模块体积.md","hash":"2ae88cc7535024da3ae93c5b924abbe8a3694a8e","modified":1718357133678},{"_id":"source/_posts/基于SpringMVC4-3-2-Spring4-3-2-MyBatis3-4-1搭建SSM框架.md","hash":"f1058abbbb427e9c4350e3f490d5f9023874eb5b","modified":1718357133679},{"_id":"source/_posts/基于struts2-5-2-hibernate5-2-2-spring4-3-2搭建SSH框架v2.md","hash":"daed70457d8e36330c60b291fb030d51bacc337b","modified":1718357133679},{"_id":"source/_posts/实现类知乎android客户端关注和取消关注的按钮点击效果v2.md","hash":"65b0495c47950c692b9f4a627c46dab00dacb58b","modified":1718357133680},{"_id":"source/_posts/密码字典生成工具.md","hash":"8fb81bf5b08b44f169bad6a2b21a5756f20a02b0","modified":1718357133680},{"_id":"source/_posts/搭建SpringMVC-Spring4-3-2-Hibernate5-2-2框架.md","hash":"a972c9405b9f266314598f941d347fc66746103d","modified":1718357133680},{"_id":"source/_posts/用自己的服务器搭建Hexo.md","hash":"8ac9eb6d53c09289b5c33cc38346113c39d422f0","modified":1718357133680},{"_id":"source/_posts/蒙哥马利算法详解.md","hash":"0b28b6470d048827300a0e7bd075bc8c1ab91751","modified":1718357133681},{"_id":"source/about/index.md","hash":"cf7c9a42a2faa72ab4b459291b57b2296560ceb7","modified":1718357133682},{"_id":"source/_posts/记一次android程序反编译并二次打包的过程v2.md","hash":"2bc68a348ea028bcc9337734e4424e956559d026","modified":1718357133681},{"_id":"source/categories/index.md","hash":"33ca5998326d894e1c1dccfb4d1da7c5d70e881e","modified":1718357133682},{"_id":"source/tags/index.md","hash":"0d43283c8660da87234db4d5a4f96575d72f5101","modified":1718357133682},{"_id":"source/uploads/avatar.jpg","hash":"d70b3b2bb48a816266e77994d770e7a3c067aeff","modified":1718357133683},{"_id":"source/uploads/background.png","hash":"ba5223e46bfd45025382d62f2a80c57c13ffc675","modified":1718357133683},{"_id":"source/uploads/wechat-reward-image.jpeg","hash":"2f4b4676663d0958f8f591aad828e373e12235a9","modified":1718357133684},{"_id":"themes/next/languages/de.yml","hash":"786afba25cfc98845a20d9901823ebeebcd1cbbf","modified":1718357133724},{"_id":"themes/next/languages/default.yml","hash":"9db835c0543ade5a89bc80ec5a898203227cf3d8","modified":1718357133724},{"_id":"themes/next/languages/en.yml","hash":"f03799cbdb5a33064ead080bcac4baca1f6bc5f9","modified":1718357133724},{"_id":"themes/next/languages/fr-FR.yml","hash":"1a084623c39de74301f3e92f9388a3a815a542ca","modified":1718357133724},{"_id":"themes/next/languages/id.yml","hash":"147c01e41b931085ad14250fa900c2249dcbbdd7","modified":1718357133725},{"_id":"themes/next/languages/ja.yml","hash":"a2c7b6301b5474aab798946fb700289df237c3cf","modified":1718357133725},{"_id":"themes/next/languages/ko.yml","hash":"ce8b047c89daae77c03482fc76f16ffec6bdbf2d","modified":1718357133725},{"_id":"themes/next/languages/pt-BR.yml","hash":"462aa865ca3d479bcf6b363cba61247b50f230ff","modified":1718357133725},{"_id":"themes/next/languages/pt.yml","hash":"ca239b39bf65c9462e59d51b12f0fe566d453197","modified":1718357133725},{"_id":"themes/next/languages/ru.yml","hash":"cc7b964a46587aea0e57b0a5269d8fd25570858e","modified":1718357133726},{"_id":"themes/next/languages/zh-Hans.yml","hash":"bea452bc49aed171a210d09bd6cddc4e846ea8ab","modified":1718357133726},{"_id":"themes/next/languages/zh-hk.yml","hash":"519ab3d817ec3bc5bfc91159c494b6b3c170bea7","modified":1718357133726},{"_id":"themes/next/languages/zh-tw.yml","hash":"6b1f345aaefc13e6723dc8a6741b59ac05c20dfd","modified":1718357133726},{"_id":"themes/next/layout/_layout.swig","hash":"bd6c4cfbb08dd69b4bd68030f464bef4a0823d28","modified":1718357133727},{"_id":"themes/next/layout/archive.swig","hash":"b5b59d70fc1563f482fa07afd435752774ad5981","modified":1718357133740},{"_id":"themes/next/layout/category.swig","hash":"6422d196ceaff4220d54b8af770e7e957f3364ad","modified":1718357133740},{"_id":"themes/next/layout/index.swig","hash":"427d0b95b854e311ae363088ab39a393bf8fdc8b","modified":1718357133741},{"_id":"themes/next/layout/page.swig","hash":"8019d02232a6dd1a665b6a4d2daef8e5dd2f0049","modified":1718357133741},{"_id":"themes/next/layout/post.swig","hash":"e2e512142961ddfe77eba29eaa88f4a2ee43ae18","modified":1718357133741},{"_id":"themes/next/layout/tag.swig","hash":"07cf49c49c39a14dfbe9ce8e7d7eea3d4d0a4911","modified":1718357133742},{"_id":"themes/next/scripts/merge-configs.js","hash":"0c56be2e85c694247cfa327ea6d627b99ca265e8","modified":1718357133742},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1718357133795},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1718357133795},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1718357133795},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1718357133767},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"43c3433155ccd9abcbe7dce2e6bfa1f3a66af18b","modified":1718357133727},{"_id":"themes/next/layout/_macro/post.swig","hash":"f3895bf44a9fb7c462f2e57b9a914703c2f152ba","modified":1718357133727},{"_id":"themes/next/layout/_macro/reward.swig","hash":"37e5b7c42ec17b9b6b786c5512bcc481a21c974e","modified":1718357133727},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"1a77843ce5eac62151dc3d38f0a36c43e19e1a74","modified":1718357133728},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"14e785adeb0e671ba0ff9a553e6f0d8def6c670c","modified":1718357133728},{"_id":"themes/next/layout/_partials/comments.swig","hash":"9805cbbdbba881cec00ce4f1e74d525af27d6027","modified":1718357133729},{"_id":"themes/next/layout/_partials/footer.swig","hash":"ca6c96051f7894fc3eef45aaa5039f40770262b6","modified":1718357133729},{"_id":"themes/next/layout/_partials/head.swig","hash":"6b0c495b8154ef8b2d2cb0a554e164ff22cdc962","modified":1718357133729},{"_id":"themes/next/layout/_partials/header.swig","hash":"eb028685cb3c329537bbced06c063d23e6a33817","modified":1718357133730},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1718357133730},{"_id":"themes/next/layout/_partials/search.swig","hash":"011b9d6c9f0a2f4654908ea20b9391f9b7981271","modified":1718357133730},{"_id":"themes/next/layout/_scripts/baidu-push.swig","hash":"82d060fe055d6e423bbc9199f82dfe5c68e74779","modified":1718357133733},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1718357133733},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1718357133734},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"0b91cadecead8e0b5211cc42b085998d94af503a","modified":1718357133740},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1718357133743},{"_id":"themes/next/scripts/tags/full-image.js","hash":"3acce36db0feb11a982c6c799aa6b6b47df2827c","modified":1718357133743},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1718357133743},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1718357133767},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1718357133767},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1718357133768},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1718357133768},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1718357133768},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1718357133768},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1718357133768},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1718357133769},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1718357133769},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1718357133769},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1718357133769},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1718357133769},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1718357133770},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1718357133770},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1718357133734},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1718357133734},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1718357133760},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1718357133760},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1718357133761},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1718357133766},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1718357133767},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1718357133730},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"ff5523d5dacaa77a55a24e50e6e6530c3b98bfad","modified":1718357133731},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1718357133731},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1718357133731},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"c07f7b2f264e5215b8ed42d67e8cef2477558364","modified":1718357133732},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"7ca5cb4daa58b3504e17f3e02975e794bc634658","modified":1718357133732},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1718357133732},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"63315fcf210799f894208c9f512737096df84962","modified":1718357133733},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1718357133734},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1718357133735},{"_id":"themes/next/layout/_scripts/third-party/analytics.swig","hash":"0a89c04055bade7baa5962f1d5aefe438d83a244","modified":1718357133735},{"_id":"themes/next/layout/_scripts/third-party/comments.swig","hash":"907b931d775d32405d02a25b3b0a3ac03bf804d0","modified":1718357133737},{"_id":"themes/next/layout/_scripts/third-party/lean-analytics.swig","hash":"92dc60821307fc9769bea9b2d60adaeb798342af","modified":1718357133738},{"_id":"themes/next/layout/_scripts/third-party/localsearch.swig","hash":"7f7148c8f52e4d3cfc070d964160362179fa8e91","modified":1718357133739},{"_id":"themes/next/layout/_scripts/third-party/mathjax.swig","hash":"5bafc33f57508d1d04a9930165240f6e9efa8d6d","modified":1718357133739},{"_id":"themes/next/layout/_scripts/third-party/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1718357133739},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1718357133760},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"715d5b40dc52f319fe4bff0325beb874774d9bd9","modified":1718357133761},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"78a83c38f69a8747bb74e420e6c9eeef1ea76525","modified":1718357133761},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"c8d35a6b9e3bff6d8fdb66de853065af9d37562d","modified":1718357133766},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"3ead77befa064d6327dc7afd0a5af7be59a5f196","modified":1718357133766},{"_id":"themes/next/source/css/_variables/base.styl","hash":"17624186f7a1f28daddea258d044f8e03b2f4bea","modified":1718357133766},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1718357133770},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"39bf93769d9080fa01a9a875183b43198f79bc19","modified":1718357133770},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1718357133771},{"_id":"themes/next/source/js/src/motion.js","hash":"269414e84df544a4ccb88519f6abae4943db3c67","modified":1718357133771},{"_id":"themes/next/source/js/src/post-details.js","hash":"2038f54e289b6da5def09689e69f623187147be5","modified":1718357133771},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1718357133772},{"_id":"themes/next/source/js/src/utils.js","hash":"e5cb720894c4bc28ca8f10b33df127fb394018d9","modified":1718357133772},{"_id":"themes/next/source/vendors/fancybox/.bower.json","hash":"cc40a9b11e52348e554c84e4a5c058056f6b7aeb","modified":1718357133772},{"_id":"themes/next/source/vendors/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1718357133773},{"_id":"themes/next/source/vendors/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1718357133776},{"_id":"themes/next/source/vendors/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1718357133777},{"_id":"themes/next/source/vendors/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1718357133777},{"_id":"themes/next/source/vendors/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1718357133777},{"_id":"themes/next/source/vendors/font-awesome/.bower.json","hash":"7da985a99674e54f514d4fd9fcd3bcea6e7e41d5","modified":1718357133778},{"_id":"themes/next/source/vendors/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1718357133778},{"_id":"themes/next/source/vendors/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1718357133778},{"_id":"themes/next/source/vendors/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1718357133779},{"_id":"themes/next/source/vendors/font-awesome/HELP-US-OUT.txt","hash":"69a4c537d167b68a0ccf1c6febd138aeffca60d6","modified":1718357133778},{"_id":"themes/next/source/vendors/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1718357133788},{"_id":"themes/next/source/vendors/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1718357133789},{"_id":"themes/next/source/vendors/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1718357133789},{"_id":"themes/next/source/vendors/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1718357133789},{"_id":"themes/next/source/vendors/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1718357133790},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1718357133790},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1718357133790},{"_id":"themes/next/source/vendors/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1718357133791},{"_id":"themes/next/source/vendors/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1718357133792},{"_id":"themes/next/source/vendors/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1718357133794},{"_id":"themes/next/source/vendors/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1718357133794},{"_id":"themes/next/source/vendors/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1718357133794},{"_id":"themes/next/source/vendors/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1718357133788},{"_id":"themes/next/layout/_scripts/third-party/analytics/baidu-analytics.swig","hash":"bfabff7d23e1ac705e0091bca5fe716f10ad2c3b","modified":1718357133736},{"_id":"themes/next/layout/_scripts/third-party/analytics/busuanzi-counter.swig","hash":"4fcbf57c4918528ab51d3d042cff92cf5aefb599","modified":1718357133736},{"_id":"themes/next/layout/_scripts/third-party/analytics/cnzz-analytics.swig","hash":"1e3e1c6231408e18e8485a8e0e59e8880349b210","modified":1718357133736},{"_id":"themes/next/layout/_scripts/third-party/analytics/facebook-sdk.swig","hash":"394d008e5e94575280407ad8a1607a028026cbc3","modified":1718357133737},{"_id":"themes/next/layout/_scripts/third-party/analytics/google-analytics.swig","hash":"30a23fa7e816496fdec0e932aa42e2d13098a9c2","modified":1718357133737},{"_id":"themes/next/layout/_scripts/third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1718357133737},{"_id":"themes/next/layout/_scripts/third-party/comments/disqus.swig","hash":"bff3b18f56175c53f3bc6d733166c4d998e08732","modified":1718357133738},{"_id":"themes/next/layout/_scripts/third-party/comments/duoshuo.swig","hash":"696666141cdd204fd8818ac2ad18f05e320f8587","modified":1718357133738},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1718357133758},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"b49efc66bd055a2d0be7deabfcb02ee72a9a28c8","modified":1718357133744},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"0dfb4b3ba3180d7285e66f270e1d3fa0f132c3d2","modified":1718357133744},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1718357133744},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"10994990d6e0b4d965a728a22cf7f6ee29cae9f6","modified":1718357133745},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"711c8830886619d4f4a0598b0cde5499dce50c62","modified":1718357133748},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1718357133754},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"5304f99581da3a31de3ecec959b7adf9002fde83","modified":1718357133759},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"54c90cf7bdbf5c596179d8dae6e671bad1292662","modified":1718357133759},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1718357133759},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"013619c472c7e4b08311c464fcbe9fcf5edde603","modified":1718357133759},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1718357133760},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1718357133761},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1718357133761},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1718357133762},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1718357133762},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1718357133762},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"4303776991ef28f5742ca51c7dffe6f12f0acf34","modified":1718357133762},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1718357133762},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"6ed60cc621bac096c0ed7534fa25b1a52dc571d4","modified":1718357133763},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1718357133763},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"c2c6c4f6434b4f94aac2af5861cd769427f0ee10","modified":1718357133764},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1718357133764},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1718357133764},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"be22ad34f546a07f6d56b424338cdd898683eea4","modified":1718357133764},{"_id":"themes/next/source/css/_schemes/Pisces/_full-image.styl","hash":"938d39eedc6e3d33918c1145a5bf1e79991d3fcf","modified":1718357133765},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"8d7cecde4933900c7df2db9d0a98f5f82f88dc93","modified":1718357133765},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"10ababca52991c19837c0a2e567142cb0c3b4bed","modified":1718357133765},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1718357133765},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"d4b7bd610ca03dbb2f5b66631c0e84a79fb4660b","modified":1718357133765},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"d09280e5b79f3b573edb30f30c7a5f03ac640986","modified":1718357133765},{"_id":"themes/next/source/vendors/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1718357133773},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"7506e7490c69a200831393c38d25e91c156bd471","modified":1718357133771},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1718357133773},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1718357133773},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1718357133774},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1718357133774},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1718357133774},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1718357133775},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1718357133776},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1718357133776},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1718357133777},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1718357133778},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css","hash":"3b87c2560832748cd06f9bfd2fd6ea8edbdae8c7","modified":1718357133779},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1718357133779},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.min.css","hash":"05ea25bc9b3ac48993e1fee322d3bc94b49a6e22","modified":1718357133780},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff2","hash":"574ea2698c03ae9477db2ea3baf460ee32f1a7ea","modified":1718357133786},{"_id":"themes/next/source/vendors/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1718357133791},{"_id":"themes/next/source/vendors/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1718357133791},{"_id":"themes/next/source/vendors/font-awesome/fonts/FontAwesome.otf","hash":"0112e96f327d413938d37c1693806f468ffdbace","modified":1718357133781},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.eot","hash":"b3c2f08e73320135b69c23a3908b87a12053a2f6","modified":1718357133781},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff","hash":"507970402e328b2baeb05bde73bf9ded4e2c3a2d","modified":1718357133785},{"_id":"themes/next/source/vendors/velocity/velocity.js","hash":"e63dc7cea055ca60a95d286f32349d88b10c5a4d","modified":1718357133792},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"542c0b6236bd761320e7e896b10f069d2396c226","modified":1718357133745},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1718357133745},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1718357133745},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"c890ce7fe933abad7baf39764a01894924854e92","modified":1718357133746},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1718357133746},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1718357133746},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"4da051c7f3924fa2db1e73c55b2baf1c2c150255","modified":1718357133746},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"90f8f9706cd7fe829cf06e9959a65fd3f8b994fa","modified":1718357133746},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"7778920dd105fa4de3a7ab206eeba30b1a7bac45","modified":1718357133747},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1718357133747},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"3c46efd6601e268093ce6d7b1471d18501878f0d","modified":1718357133747},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1718357133748},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"8fae54591877a73dff0b29b2be2e8935e3c63575","modified":1718357133748},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1718357133749},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"b25132fe6a7ad67059a2c3afc60feabb479bdd75","modified":1718357133749},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1718357133749},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"d543d1377c1f61b70e3adb6da0eb12797552e5f2","modified":1718357133750},{"_id":"themes/next/source/css/_common/components/post/post-more-link.styl","hash":"15063d79b5befc21820baf05d6f20cc1c1787477","modified":1718357133750},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"cbca4842a54950e2934b3b8f3cd940f122111aef","modified":1718357133750},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"e792c8dc41561c96d128e9b421187f1c3dc978a0","modified":1718357133750},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1718357133751},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1718357133751},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"963105a531403d7aad6d9e5e23e3bfabb8ec065a","modified":1718357133751},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"4eb18b12fa0ea6c35925d9a64f64e2a7dae8c7fd","modified":1718357133752},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1718357133752},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"2e7ec9aaa3293941106b1bdd09055246aa3c3dc6","modified":1718357133752},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"c44f6a553ec7ea5508f2054a13be33a62a15d3a9","modified":1718357133752},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1718357133753},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1718357133753},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"7690b9596ec3a49befbe529a5a2649abec0faf76","modified":1718357133753},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"2d3abbc85b979a648e0e579e45f16a6eba49d1e7","modified":1718357133754},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"234facd038f144bd0fe09a31ed1357c5d74c517f","modified":1718357133754},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1718357133754},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1718357133755},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1718357133755},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"618f73450cf541f88a4fddc3d22898aee49d105d","modified":1718357133755},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"8e66c2635d48e11de616bb29c4b1323698eebc0a","modified":1718357133756},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"b03f891883446f3a5548b7cc90d29c77e62f1053","modified":1718357133756},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"8571d167a8769cd6bfc95c8a08406f49ed401ba4","modified":1718357133757},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1718357133757},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1718357133756},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"795d94561888d31cb7a6ff4a125596809ea69b7d","modified":1718357133757},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"3afc459442c132c480d1d832f1a872f1070bb048","modified":1718357133758},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1718357133763},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"8b8e8cbce98a9296c8fd77f512ae85d945f65d40","modified":1718357133763},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"8b8e8cbce98a9296c8fd77f512ae85d945f65d40","modified":1718357133764},{"_id":"themes/next/source/vendors/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1718357133774},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1718357133775},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1718357133775},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1718357133775},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1718357133775},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1718357133775},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.ttf","hash":"27cf1f2ec59aece6938c7bb2feb0e287ea778ff9","modified":1718357133784},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.svg","hash":"2b3c8ba7008cc014d8fb37abc6f9f49aeda83824","modified":1718357133782}],"Category":[{"name":"Android","_id":"clxjsxtvt0004lq6gzmz08pkq"},{"name":"服务端开发","_id":"clxjsxtw2000llq6g2pz7y2ig"},{"name":"AI","_id":"clxjsxtw70010lq6gncf9vrqt"},{"name":"iOS","_id":"clxjsxtwb001elq6g3xuyx7kw"},{"name":"安全","_id":"clxjsxtwe001mlq6g4rtbiic0"},{"name":"密码学","_id":"clxjsxtwf001qlq6g0rztgrxr"}],"Data":[],"Page":[{"title":"about","date":"2016-09-23T06:28:32.000Z","type":"about","comments":0,"_content":"花名： 轩辕\n\n道场： 蚂蚁金服\n\n暂居地：杭州\n\n人生格言：没有什么人生格言","source":"about/index.md","raw":"---\ntitle: about\ndate: 2016-09-23 14:28:32\ntype: \"about\"\ncomments: false\n---\n花名： 轩辕\n\n道场： 蚂蚁金服\n\n暂居地：杭州\n\n人生格言：没有什么人生格言","updated":"2024-06-14T09:25:33.682Z","path":"about/index.html","layout":"page","_id":"clxjsxtvp0001lq6gcvc0pjah","content":"<p>花名： 轩辕</p>\n<p>道场： 蚂蚁金服</p>\n<p>暂居地：杭州</p>\n<p>人生格言：没有什么人生格言</p>\n","excerpt":"","more":"<p>花名： 轩辕</p>\n<p>道场： 蚂蚁金服</p>\n<p>暂居地：杭州</p>\n<p>人生格言：没有什么人生格言</p>\n"},{"title":"categories","date":"2016-09-23T02:09:52.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2016-09-23 10:09:52\ntype: \"categories\"\ncomments: false\n---\n","updated":"2024-06-14T09:25:33.682Z","path":"categories/index.html","layout":"page","_id":"clxjsxtvr0003lq6g5m85hp63","content":"","excerpt":"","more":""},{"title":"tags","date":"2016-09-23T02:09:33.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2016-09-23 10:09:33\ntype: \"tags\"\ncomments: false\n---\n","updated":"2024-06-14T09:25:33.682Z","path":"tags/index.html","layout":"page","_id":"clxjsxtvv0007lq6gcplv62hl","content":"","excerpt":"","more":""}],"Post":[{"title":"Activity启动流程分析","date":"2016-10-09T06:08:25.000Z","_content":"广告时间，大家喜欢我的文章，可以关注我的博客[zwgeek.com](zwgeek.com)\n\n今天想和大家一起分享一下Activity的启动流程。这起源于我发现了一个好的现象，其实不知道大家发现没有，随着Android的发展，这几年Android开发者的素质也越来越高，我说的素质指的是对问题深度的理解，对Android总体的运行原理的分析，而不仅仅局限在应用开发层面了。还记得最开始接触Android的时候，那时候不管面试还是干嘛的，上来就问你生命周期，生命周期。感觉能说清楚生命周期已经是一件很厉害的事了。我也曾一度觉得开发者只要清楚onCreate什么时候调用就可以了，onCreate就是开发者能接触的最上层的内容了。根本没有考虑过程序应该有个入口，onCreate到底是怎么被调用的，更不用说还想着去看看源码。而现在，好像大家比起关心生命周期，关心起了更深层的问题，也就是一个Android程序是怎么被启动的，然后才是它的生命周期是怎么被调用的。我最先意识到这个现象时，是很开心的，这说明Android开发者越来越高级，也就意味着现在开发者不光使用Android，而且也能为Android社区做一些力所能及的贡献了。\n\n这篇文章的目标是总结网上各种对Activity启动流程的分析。现在网上对Activity启动流程的分析已经多如牛毛了。那么我为什么还觉得有必要再写一次呢。一是自己边分析边写更有利于理解。二是我发现网上的分析习惯性的忽略细节，只着眼于一条大的主线，也不是说这样不好，这样确实比较容易理解，我希望我这篇文章能关注到每个细节点，每个方法的作用。\n\n整个过程准备分为三篇文章来写\n- 程序调用startActivity后发生的操作，也就是这篇文章。\n- 如果被startActivity的程序是需要重新启动的程序，程序在最开始初始化时发生的操作。例如在Launcher中启动一个程序或启动另外的程序。已经完成，可查阅[Activity启动流程分析（二）](http://zwgeek.com/2016/10/25/Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%902/)\n- 如果被startActivity的程序是已经启动的程序，发生的操作。例如程序自己调用startActivity启动一个自己程序中的Activity\n\n\n整个分析过程中，希望读者带着这样一些问题\n- getApplication() ，getApplicationContext()，getBaseContext()分别有什么区别？\n- 单个进程中能存在多个application么？\n- 为什么不能使用service或者application作为创建dialog的context参数？\n\n讲了这么多，我们可以看代码吧，从哪里开始看呢，就从Activity的startActivity方法作为起点吧。也就是这个方法\n\n![这里写图片描述](http://img.blog.csdn.net/20161009143617855)\nBundle为空的情况，又调用了带Bundle的同名方法，bundle传null，如下\n\n![这里写图片描述](http://img.blog.csdn.net/20161009143857577)\n\nstartActivity方法本质其实是调用startActivityForResult的，requestCode传了-1，这个倒是我之前没想到的，一直以为这两个方法是分开的。所以requestCode为-1的情况应该是被系统默认忽略的（后面的分析过程中也发现requestCode为负都是被忽略的）。startActivityForResult的两个方法跟startActivity一样，最终也是进到了带Bundle的方法。\n\n这里先看下这个方法的注释\n![这里写图片描述](http://img.blog.csdn.net/20161009145144243)\n\n- requestCode为负数时无效，跟调startActivity一样\n- 这个方法仅仅试用于能够在当前Task（关于Task是什么，后面也会讲到，暂时可以考虑成是一个Activity的集合）启动的Activity，只有在这个集合中的Activity才能互相传递Result，如果Activity不能在当前Task启动，则这个方法会立即返回失败\n- 在onCreate和onResume中调用startActivity时，前一个Activiyt不会显示，直到后面启动的Activity关闭返回结果，这是为了防止前一个Activity显示造成的闪烁\n- 方法会抛出一个ActivityNotFoundException\n\n![这里写图片描述](http://img.blog.csdn.net/20161009152006663)\n\n这个方法一共有两种情况，mParent为null和不为null，mParent其实是指的ActivityGroup，但是这种用法现在已经被弃用了，所以这条线可以不用关注。无伤大雅，我们顺便来看一下吧。\n\n先看一下下个启动过程，当mParent不为null的时候，直接调用mParent的startActivityFromChild方法，如下\n![这里写图片描述](http://img.blog.csdn.net/20161009153000134)\n\n在startActivityFromChild中又通过mInstrumentation调用了其中的execStartActivity方法。\n\n在继续之前，有两个小插曲，先说一下startActivityForResult的最后一步，mActivityTransitionState.startExitOutTransition方法，处理退出当前Activity的相关事宜，这个不太用关注。\n\n然后是mInstrumentation，看过网上文章的同学应该熟悉Instrumentation这个类，Instrumentation这个类是一个管家类，所有跟Activity有关的实际操作都交给它做，恩，与其说大管家，不如说是打杂的。这样有什么好处呢，这个类可以做一些统计工作，因为它知道Activity有关的所有事情。\n\n然后，我们继续，回过头来看mParent为null时候的调用，其实也是调用了mInstrumentation的execStartActivity方法。可以看出，这两个分支最后殊途同归，到了execStartActivity方法，只是有两个参数不同，这就值得我们去看下这两个参数有什么影响，第一个和第四个，两个Activity类型的参数。其实这里mToken也是不一样的，mToken相当于activity的唯一标识符，这个token关系到后面新创建的Activity加入到哪个task栈中。这三个参数体会一下，后面也会遇到一些关于Activity的问题基本都和这里传递的参数有关。\n\n```java\nif (mParent == null)\nmInstrumentation.execStartActivity(this, mMainThread.getApplicationThread(), mToken, this,\n                    intent, requestCode, options);\n```\n\n```java\nif(mParent != null)\nmInstrumentation.execStartActivity(this, mMainThread.getApplicationThread(), mToken, child,\n                intent, requestCode, options);\n```\n\n这里先调用mInstrumentation的execStartActivity方法，返回一个ActivityResult。如果ActivityResult不为空，调用mMainThread的sendActivityResult方法。这其实是关于Activity通过startActivityForResult启动Activity然后返回Result的过程，这部分准备单独拉一篇文章来讲，这里就不多说了。\n\n然后mMainThread是一个ActivityThread类型的，说起ActivityThread可厉害了，这个类其实就是应用程序的入口，main方法就在这个类里，我们的第二篇文章就主要是对这个类的分析。\n\n然后这里mMainThread.sendActivityResult方法的作用就是调用onActivityResult，其实看到这里我不太明白，onActivityResult应该是新启动的Activity关闭后才调用。为什么这里execStartActivity之后就调用了，道理上这里Activity才启动，并没有关闭啊。我能想到的原因之一是execStartActivity是一个阻塞方法，只有当Activity关闭之后才会返回结果，然后继续往下执行，不知道我想的对不对，后面分析验证。\n\n关于sendActivityResult是怎么调到onActivityResult的，和所有生命周期方法的调用一样，通过Handler，这个后面会统一讲一下。\n\n下面我们去看Instrumentation的execStartActivity方法了。例行先看一下注释\n![这里写图片描述](http://img.blog.csdn.net/20161009162711191)\n\n这个方法执行一个有应用程序发出的startActivity的请求，默认的实现会更新所有ActivityMonitor的信息，你可以用这个类监控activity的启动情况，并且做一些额外操作，这也是前面提到的可以在Instrumentation中监控每个Activity的启动情况。\n\n当ActivityMonitor想要中断Activity启动时，这个方法依然会返回一个正确的ActivityResult。结合下面的代码，我前面提到的那个问题就明白了，这个方法并不阻塞，而且正常流程情况下也不会返回result，触发onActivityResult。只有当你设置了一个监控器，并且监控器是想阻止这个Acitivity启动的时候，这个方法不会真正去启动一个Activity，但是还是会正常返回Result值。\n\n另外前面也提到，有两个参数要重点看下，第一个参数Context，是正在启动的Activity属于哪个Context，这个参数永远都是Parent，当没有Parent的时候是自己。第四个参数Activity，是具体执行startActivity任务的那个Activity，同时这个Activity负责处理onActivityResult。明白了这两个参数后，我们来看具体的代码。\n\n![这里写图片描述](http://img.blog.csdn.net/20161009165506838)\n\n基本都在注释里写清楚了，核心方法是调了ActivityManagerNative.getDefault().startActivity方法getDefault是用系统提供的单例方法构造的一个单例对象，感觉这个方法也挺有意思，下次可以研究下。\n\n![这里写图片描述](http://img.blog.csdn.net/20161009170243301)\n\n然后我们看ActivityManagerNative类中的startActivity方法\n![这里写图片描述](http://img.blog.csdn.net/20161009170645365)\n\n我们来看ActivityManagerNative这个类，会发现它继承了Binder，如果你对Android的Binder体系熟悉的话，你应该能明显的看出来，这个方法是一个调用远端进程方法，封装数据，然后调用了Remote的transact方法。Binder也是Android中可以拖出来讲很久的一个体系，后面也会拖一篇文章来讲这个。所以ActivityManagerNative就是一个Binder对象，我们需要找到他对应的远端Service。追一下mRemote赋值的地方，会发现是在创建的时候。\n\n![这里写图片描述](http://img.blog.csdn.net/20161009171802041)\n\n\n插播一句，这里Singleton类是java中实现的单例模式，具体这个单例实现的效果如果，然后有什么优化，不是很清楚，准备有空分析下这个类。但是想想系统实现的应该不会太差，所以写单例模式的时候也可以用这个类来。\n\n我们回归正题，这个IBinder也可以跟到，简单来说，ActivityManagerNative的远端服务就是ActivityManagerService。整个Android程序其实是一个C/S结构，本地程序是一个Client，还一个Service端负责所有的程序调度。启动Activity肯定是系统的事啊，所以这里程序就把整个工作推给系统来做了。通过Binder模式，我们调到了远端Service的startActivity方法，来看这个方法。\n\n![这里写图片描述](http://img.blog.csdn.net/20161009172405939)\n\n继续跟startActivityAsUser方法\n![这里写图片描述](http://img.blog.csdn.net/20161009172721029)\n\n首先会检查，当前进程是否是孤立进程。孤立进程是Service的一个属性。\n\n```java\nandroid:isolatedProcess\n```\n\n如果Service设置了这个属性，那么这个Service将运行在一个特殊的进程中，这个进程和系统其他进程是分开的。这个进程没有任何权限。和这样的Service进行交互就只能通过系统API（也就是bind和start）。\n\n简单来说，非孤立进程可以被拿来重用，重新运行新的app，孤立进程由于权限等问题，不能被重用，只能被销毁。所以在执行启动操作的时候要判断当前进程是否孤立进程，如果是，则不允许做start的操作。\n\n回到正题，startActivityAsUser方法调用了StackSupervisor的startActivityMayWait方法，StackSupervisor是一个Activity栈的管理器，Activity栈是用来存储已经生成的的Activity对象的。这个我们会在后面说明。来看下StackSupervisor的startActivityMayWait方法。我看了一下整个流程，前面处理了Intent，AcitivtyStack等，为startActivity做准备，后面返回Result，都不是很重要。所以我们继续往下追，只寻找关于startActivity的部分。startActivityMayWait中的这一句\n\n![这里写图片描述](http://img.blog.csdn.net/20161009180248576)\n\n调用了startActivityLocked方法，startActivityLocked中，也是先进行了一系列的检查，包括intent中各种flag的判定，以一个err命令贯穿整个方法，如果中间有任何异常err就会被改变，就不能继续往下进行。\n\n![这里写图片描述](http://img.blog.csdn.net/20161009180410115)\n\n\n然后，调用到startActivityUncheckedLocked中，这个方法也是一个超级长的方法，对startActivity做了各种检查和准备， 主要是对Activity分各种Flag进行相应的处理。这个方法里面就有我们常见的Activity的各种启动模式的配置。如图\n\n![这里写图片描述](http://img.blog.csdn.net/20161025140715881)\n\n前面说到startActivityForResult的时候，提过必须在一个task中，处理也是这里。如果不是一个task，会response一个异常码。\n\n![这里写图片描述](http://img.blog.csdn.net/20161025140911557)\n\n这里其他代码的处理太细节化了，我们抓一下主线，生成一个ActivityStack，并\n调用Stack的startActivityLocked方法\n![这里写图片描述](http://img.blog.csdn.net/20161009180849750)\n\n这样我们就到了ActivityStack类里面，但是没过多久，startActivityLocked通过调用resumeTopActivitiesLocked又回到了ActivityStackSupervisor。\n\n![这里写图片描述](http://img.blog.csdn.net/20161025143058036)\n\n![这里写图片描述](http://img.blog.csdn.net/20161025143315259)\n\n![这里写图片描述](http://img.blog.csdn.net/20161025143426099)\n\n做了一些检查，然后调到了resumeTopActivityInnerLocked，在resumeTopActivityInnerLocked中，因为thread和app都为null，所以执行了startSpecificActivityLocked方法，这就重新回到了ActivityStackSupervisor中\n\n![这里写图片描述](http://img.blog.csdn.net/20161025144451400)\n\n\n![这里写图片描述](http://img.blog.csdn.net/20161009182225273)\n\n\n![这里写图片描述](http://img.blog.csdn.net/20161009182516474)\n\n我们可以看到startSpecificActivityLocked中，如果app和thread为null，会调用startProcessLocked启动一个新的线程。后面也会说到，新线程启动后还会回到这里，去调用真正的realStartActivityLocked，我们可以发现源码里的名字起的也是相当到位。\n\n这里暂时thread和app都是null，所以通知ActivityManagerService的startProcessLocked方法启动一个进程\n\n在ActivityManagerService的startProcessLocked方法中，前面处理了一下线程重用等的优化，用processRecord记录了要启动的进程的信息\n\n![这里写图片描述](http://img.blog.csdn.net/20161025145835484)\n\n然后调了同名的startProcessLocked方法，但是参数由String的processName变成了ProcessRecord\n\n![这里写图片描述](http://img.blog.csdn.net/20161009183016089)\n\n在这个方法中，通过Process.start启动了一个进程，并指定了进程的入口，也就是ActivityThread类的main方法。至于这个进程的启动过程涉及到Android内核层的东西了，这篇文章暂时不看这么细，我们就简单的理解为，新进程启动后，就会去调用指定的ActivityThread的main方法就好。\n\n![这里写图片描述](http://img.blog.csdn.net/20161009183252014)\n\n最后总结一下这个过程，如果你不想关注太多的细节，只是提炼调用顺序的话，整个过程是这样的。\n\n![这里写图片描述](http://img.blog.csdn.net/20161025165024179)\n\n这篇文章大概就到这里了。\n\n最开始的时候提到，这篇文章介绍的是从头启动一个程序的流程，所以到目前为止，我们可以看到，AMS侧的准备工作已经做好了也记录了Activity的所有信息，但是，Activity包括运行Activity的线程其实还没有正式启动。下一篇文章中我们会详细说明一个Application启动后的流程，也就是main方法中做了什么。\n\n例行广告，大家喜欢我的文章，可以关注我的博客[zwgeek.com](zwgeek.com)\n\n","source":"_posts/Activity启动流程分析.md","raw":"---\ntitle: Activity启动流程分析\ndate: 2016-10-09 14:08:25\ntags:\n  - Android\n  - Activity启动\n  - 系统\ncategories: Android\n---\n广告时间，大家喜欢我的文章，可以关注我的博客[zwgeek.com](zwgeek.com)\n\n今天想和大家一起分享一下Activity的启动流程。这起源于我发现了一个好的现象，其实不知道大家发现没有，随着Android的发展，这几年Android开发者的素质也越来越高，我说的素质指的是对问题深度的理解，对Android总体的运行原理的分析，而不仅仅局限在应用开发层面了。还记得最开始接触Android的时候，那时候不管面试还是干嘛的，上来就问你生命周期，生命周期。感觉能说清楚生命周期已经是一件很厉害的事了。我也曾一度觉得开发者只要清楚onCreate什么时候调用就可以了，onCreate就是开发者能接触的最上层的内容了。根本没有考虑过程序应该有个入口，onCreate到底是怎么被调用的，更不用说还想着去看看源码。而现在，好像大家比起关心生命周期，关心起了更深层的问题，也就是一个Android程序是怎么被启动的，然后才是它的生命周期是怎么被调用的。我最先意识到这个现象时，是很开心的，这说明Android开发者越来越高级，也就意味着现在开发者不光使用Android，而且也能为Android社区做一些力所能及的贡献了。\n\n这篇文章的目标是总结网上各种对Activity启动流程的分析。现在网上对Activity启动流程的分析已经多如牛毛了。那么我为什么还觉得有必要再写一次呢。一是自己边分析边写更有利于理解。二是我发现网上的分析习惯性的忽略细节，只着眼于一条大的主线，也不是说这样不好，这样确实比较容易理解，我希望我这篇文章能关注到每个细节点，每个方法的作用。\n\n整个过程准备分为三篇文章来写\n- 程序调用startActivity后发生的操作，也就是这篇文章。\n- 如果被startActivity的程序是需要重新启动的程序，程序在最开始初始化时发生的操作。例如在Launcher中启动一个程序或启动另外的程序。已经完成，可查阅[Activity启动流程分析（二）](http://zwgeek.com/2016/10/25/Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%902/)\n- 如果被startActivity的程序是已经启动的程序，发生的操作。例如程序自己调用startActivity启动一个自己程序中的Activity\n\n\n整个分析过程中，希望读者带着这样一些问题\n- getApplication() ，getApplicationContext()，getBaseContext()分别有什么区别？\n- 单个进程中能存在多个application么？\n- 为什么不能使用service或者application作为创建dialog的context参数？\n\n讲了这么多，我们可以看代码吧，从哪里开始看呢，就从Activity的startActivity方法作为起点吧。也就是这个方法\n\n![这里写图片描述](http://img.blog.csdn.net/20161009143617855)\nBundle为空的情况，又调用了带Bundle的同名方法，bundle传null，如下\n\n![这里写图片描述](http://img.blog.csdn.net/20161009143857577)\n\nstartActivity方法本质其实是调用startActivityForResult的，requestCode传了-1，这个倒是我之前没想到的，一直以为这两个方法是分开的。所以requestCode为-1的情况应该是被系统默认忽略的（后面的分析过程中也发现requestCode为负都是被忽略的）。startActivityForResult的两个方法跟startActivity一样，最终也是进到了带Bundle的方法。\n\n这里先看下这个方法的注释\n![这里写图片描述](http://img.blog.csdn.net/20161009145144243)\n\n- requestCode为负数时无效，跟调startActivity一样\n- 这个方法仅仅试用于能够在当前Task（关于Task是什么，后面也会讲到，暂时可以考虑成是一个Activity的集合）启动的Activity，只有在这个集合中的Activity才能互相传递Result，如果Activity不能在当前Task启动，则这个方法会立即返回失败\n- 在onCreate和onResume中调用startActivity时，前一个Activiyt不会显示，直到后面启动的Activity关闭返回结果，这是为了防止前一个Activity显示造成的闪烁\n- 方法会抛出一个ActivityNotFoundException\n\n![这里写图片描述](http://img.blog.csdn.net/20161009152006663)\n\n这个方法一共有两种情况，mParent为null和不为null，mParent其实是指的ActivityGroup，但是这种用法现在已经被弃用了，所以这条线可以不用关注。无伤大雅，我们顺便来看一下吧。\n\n先看一下下个启动过程，当mParent不为null的时候，直接调用mParent的startActivityFromChild方法，如下\n![这里写图片描述](http://img.blog.csdn.net/20161009153000134)\n\n在startActivityFromChild中又通过mInstrumentation调用了其中的execStartActivity方法。\n\n在继续之前，有两个小插曲，先说一下startActivityForResult的最后一步，mActivityTransitionState.startExitOutTransition方法，处理退出当前Activity的相关事宜，这个不太用关注。\n\n然后是mInstrumentation，看过网上文章的同学应该熟悉Instrumentation这个类，Instrumentation这个类是一个管家类，所有跟Activity有关的实际操作都交给它做，恩，与其说大管家，不如说是打杂的。这样有什么好处呢，这个类可以做一些统计工作，因为它知道Activity有关的所有事情。\n\n然后，我们继续，回过头来看mParent为null时候的调用，其实也是调用了mInstrumentation的execStartActivity方法。可以看出，这两个分支最后殊途同归，到了execStartActivity方法，只是有两个参数不同，这就值得我们去看下这两个参数有什么影响，第一个和第四个，两个Activity类型的参数。其实这里mToken也是不一样的，mToken相当于activity的唯一标识符，这个token关系到后面新创建的Activity加入到哪个task栈中。这三个参数体会一下，后面也会遇到一些关于Activity的问题基本都和这里传递的参数有关。\n\n```java\nif (mParent == null)\nmInstrumentation.execStartActivity(this, mMainThread.getApplicationThread(), mToken, this,\n                    intent, requestCode, options);\n```\n\n```java\nif(mParent != null)\nmInstrumentation.execStartActivity(this, mMainThread.getApplicationThread(), mToken, child,\n                intent, requestCode, options);\n```\n\n这里先调用mInstrumentation的execStartActivity方法，返回一个ActivityResult。如果ActivityResult不为空，调用mMainThread的sendActivityResult方法。这其实是关于Activity通过startActivityForResult启动Activity然后返回Result的过程，这部分准备单独拉一篇文章来讲，这里就不多说了。\n\n然后mMainThread是一个ActivityThread类型的，说起ActivityThread可厉害了，这个类其实就是应用程序的入口，main方法就在这个类里，我们的第二篇文章就主要是对这个类的分析。\n\n然后这里mMainThread.sendActivityResult方法的作用就是调用onActivityResult，其实看到这里我不太明白，onActivityResult应该是新启动的Activity关闭后才调用。为什么这里execStartActivity之后就调用了，道理上这里Activity才启动，并没有关闭啊。我能想到的原因之一是execStartActivity是一个阻塞方法，只有当Activity关闭之后才会返回结果，然后继续往下执行，不知道我想的对不对，后面分析验证。\n\n关于sendActivityResult是怎么调到onActivityResult的，和所有生命周期方法的调用一样，通过Handler，这个后面会统一讲一下。\n\n下面我们去看Instrumentation的execStartActivity方法了。例行先看一下注释\n![这里写图片描述](http://img.blog.csdn.net/20161009162711191)\n\n这个方法执行一个有应用程序发出的startActivity的请求，默认的实现会更新所有ActivityMonitor的信息，你可以用这个类监控activity的启动情况，并且做一些额外操作，这也是前面提到的可以在Instrumentation中监控每个Activity的启动情况。\n\n当ActivityMonitor想要中断Activity启动时，这个方法依然会返回一个正确的ActivityResult。结合下面的代码，我前面提到的那个问题就明白了，这个方法并不阻塞，而且正常流程情况下也不会返回result，触发onActivityResult。只有当你设置了一个监控器，并且监控器是想阻止这个Acitivity启动的时候，这个方法不会真正去启动一个Activity，但是还是会正常返回Result值。\n\n另外前面也提到，有两个参数要重点看下，第一个参数Context，是正在启动的Activity属于哪个Context，这个参数永远都是Parent，当没有Parent的时候是自己。第四个参数Activity，是具体执行startActivity任务的那个Activity，同时这个Activity负责处理onActivityResult。明白了这两个参数后，我们来看具体的代码。\n\n![这里写图片描述](http://img.blog.csdn.net/20161009165506838)\n\n基本都在注释里写清楚了，核心方法是调了ActivityManagerNative.getDefault().startActivity方法getDefault是用系统提供的单例方法构造的一个单例对象，感觉这个方法也挺有意思，下次可以研究下。\n\n![这里写图片描述](http://img.blog.csdn.net/20161009170243301)\n\n然后我们看ActivityManagerNative类中的startActivity方法\n![这里写图片描述](http://img.blog.csdn.net/20161009170645365)\n\n我们来看ActivityManagerNative这个类，会发现它继承了Binder，如果你对Android的Binder体系熟悉的话，你应该能明显的看出来，这个方法是一个调用远端进程方法，封装数据，然后调用了Remote的transact方法。Binder也是Android中可以拖出来讲很久的一个体系，后面也会拖一篇文章来讲这个。所以ActivityManagerNative就是一个Binder对象，我们需要找到他对应的远端Service。追一下mRemote赋值的地方，会发现是在创建的时候。\n\n![这里写图片描述](http://img.blog.csdn.net/20161009171802041)\n\n\n插播一句，这里Singleton类是java中实现的单例模式，具体这个单例实现的效果如果，然后有什么优化，不是很清楚，准备有空分析下这个类。但是想想系统实现的应该不会太差，所以写单例模式的时候也可以用这个类来。\n\n我们回归正题，这个IBinder也可以跟到，简单来说，ActivityManagerNative的远端服务就是ActivityManagerService。整个Android程序其实是一个C/S结构，本地程序是一个Client，还一个Service端负责所有的程序调度。启动Activity肯定是系统的事啊，所以这里程序就把整个工作推给系统来做了。通过Binder模式，我们调到了远端Service的startActivity方法，来看这个方法。\n\n![这里写图片描述](http://img.blog.csdn.net/20161009172405939)\n\n继续跟startActivityAsUser方法\n![这里写图片描述](http://img.blog.csdn.net/20161009172721029)\n\n首先会检查，当前进程是否是孤立进程。孤立进程是Service的一个属性。\n\n```java\nandroid:isolatedProcess\n```\n\n如果Service设置了这个属性，那么这个Service将运行在一个特殊的进程中，这个进程和系统其他进程是分开的。这个进程没有任何权限。和这样的Service进行交互就只能通过系统API（也就是bind和start）。\n\n简单来说，非孤立进程可以被拿来重用，重新运行新的app，孤立进程由于权限等问题，不能被重用，只能被销毁。所以在执行启动操作的时候要判断当前进程是否孤立进程，如果是，则不允许做start的操作。\n\n回到正题，startActivityAsUser方法调用了StackSupervisor的startActivityMayWait方法，StackSupervisor是一个Activity栈的管理器，Activity栈是用来存储已经生成的的Activity对象的。这个我们会在后面说明。来看下StackSupervisor的startActivityMayWait方法。我看了一下整个流程，前面处理了Intent，AcitivtyStack等，为startActivity做准备，后面返回Result，都不是很重要。所以我们继续往下追，只寻找关于startActivity的部分。startActivityMayWait中的这一句\n\n![这里写图片描述](http://img.blog.csdn.net/20161009180248576)\n\n调用了startActivityLocked方法，startActivityLocked中，也是先进行了一系列的检查，包括intent中各种flag的判定，以一个err命令贯穿整个方法，如果中间有任何异常err就会被改变，就不能继续往下进行。\n\n![这里写图片描述](http://img.blog.csdn.net/20161009180410115)\n\n\n然后，调用到startActivityUncheckedLocked中，这个方法也是一个超级长的方法，对startActivity做了各种检查和准备， 主要是对Activity分各种Flag进行相应的处理。这个方法里面就有我们常见的Activity的各种启动模式的配置。如图\n\n![这里写图片描述](http://img.blog.csdn.net/20161025140715881)\n\n前面说到startActivityForResult的时候，提过必须在一个task中，处理也是这里。如果不是一个task，会response一个异常码。\n\n![这里写图片描述](http://img.blog.csdn.net/20161025140911557)\n\n这里其他代码的处理太细节化了，我们抓一下主线，生成一个ActivityStack，并\n调用Stack的startActivityLocked方法\n![这里写图片描述](http://img.blog.csdn.net/20161009180849750)\n\n这样我们就到了ActivityStack类里面，但是没过多久，startActivityLocked通过调用resumeTopActivitiesLocked又回到了ActivityStackSupervisor。\n\n![这里写图片描述](http://img.blog.csdn.net/20161025143058036)\n\n![这里写图片描述](http://img.blog.csdn.net/20161025143315259)\n\n![这里写图片描述](http://img.blog.csdn.net/20161025143426099)\n\n做了一些检查，然后调到了resumeTopActivityInnerLocked，在resumeTopActivityInnerLocked中，因为thread和app都为null，所以执行了startSpecificActivityLocked方法，这就重新回到了ActivityStackSupervisor中\n\n![这里写图片描述](http://img.blog.csdn.net/20161025144451400)\n\n\n![这里写图片描述](http://img.blog.csdn.net/20161009182225273)\n\n\n![这里写图片描述](http://img.blog.csdn.net/20161009182516474)\n\n我们可以看到startSpecificActivityLocked中，如果app和thread为null，会调用startProcessLocked启动一个新的线程。后面也会说到，新线程启动后还会回到这里，去调用真正的realStartActivityLocked，我们可以发现源码里的名字起的也是相当到位。\n\n这里暂时thread和app都是null，所以通知ActivityManagerService的startProcessLocked方法启动一个进程\n\n在ActivityManagerService的startProcessLocked方法中，前面处理了一下线程重用等的优化，用processRecord记录了要启动的进程的信息\n\n![这里写图片描述](http://img.blog.csdn.net/20161025145835484)\n\n然后调了同名的startProcessLocked方法，但是参数由String的processName变成了ProcessRecord\n\n![这里写图片描述](http://img.blog.csdn.net/20161009183016089)\n\n在这个方法中，通过Process.start启动了一个进程，并指定了进程的入口，也就是ActivityThread类的main方法。至于这个进程的启动过程涉及到Android内核层的东西了，这篇文章暂时不看这么细，我们就简单的理解为，新进程启动后，就会去调用指定的ActivityThread的main方法就好。\n\n![这里写图片描述](http://img.blog.csdn.net/20161009183252014)\n\n最后总结一下这个过程，如果你不想关注太多的细节，只是提炼调用顺序的话，整个过程是这样的。\n\n![这里写图片描述](http://img.blog.csdn.net/20161025165024179)\n\n这篇文章大概就到这里了。\n\n最开始的时候提到，这篇文章介绍的是从头启动一个程序的流程，所以到目前为止，我们可以看到，AMS侧的准备工作已经做好了也记录了Activity的所有信息，但是，Activity包括运行Activity的线程其实还没有正式启动。下一篇文章中我们会详细说明一个Application启动后的流程，也就是main方法中做了什么。\n\n例行广告，大家喜欢我的文章，可以关注我的博客[zwgeek.com](zwgeek.com)\n\n","slug":"Activity启动流程分析","published":1,"updated":"2024-06-14T09:25:33.674Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clxjsxtvl0000lq6gqxoxdldw","content":"<p>广告时间，大家喜欢我的文章，可以关注我的博客<a href=\"zwgeek.com\">zwgeek.com</a></p>\n<p>今天想和大家一起分享一下Activity的启动流程。这起源于我发现了一个好的现象，其实不知道大家发现没有，随着Android的发展，这几年Android开发者的素质也越来越高，我说的素质指的是对问题深度的理解，对Android总体的运行原理的分析，而不仅仅局限在应用开发层面了。还记得最开始接触Android的时候，那时候不管面试还是干嘛的，上来就问你生命周期，生命周期。感觉能说清楚生命周期已经是一件很厉害的事了。我也曾一度觉得开发者只要清楚onCreate什么时候调用就可以了，onCreate就是开发者能接触的最上层的内容了。根本没有考虑过程序应该有个入口，onCreate到底是怎么被调用的，更不用说还想着去看看源码。而现在，好像大家比起关心生命周期，关心起了更深层的问题，也就是一个Android程序是怎么被启动的，然后才是它的生命周期是怎么被调用的。我最先意识到这个现象时，是很开心的，这说明Android开发者越来越高级，也就意味着现在开发者不光使用Android，而且也能为Android社区做一些力所能及的贡献了。</p>\n<p>这篇文章的目标是总结网上各种对Activity启动流程的分析。现在网上对Activity启动流程的分析已经多如牛毛了。那么我为什么还觉得有必要再写一次呢。一是自己边分析边写更有利于理解。二是我发现网上的分析习惯性的忽略细节，只着眼于一条大的主线，也不是说这样不好，这样确实比较容易理解，我希望我这篇文章能关注到每个细节点，每个方法的作用。</p>\n<p>整个过程准备分为三篇文章来写</p>\n<ul>\n<li>程序调用startActivity后发生的操作，也就是这篇文章。</li>\n<li>如果被startActivity的程序是需要重新启动的程序，程序在最开始初始化时发生的操作。例如在Launcher中启动一个程序或启动另外的程序。已经完成，可查阅<a href=\"http://zwgeek.com/2016/10/25/Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%902/\">Activity启动流程分析（二）</a></li>\n<li>如果被startActivity的程序是已经启动的程序，发生的操作。例如程序自己调用startActivity启动一个自己程序中的Activity</li>\n</ul>\n<p>整个分析过程中，希望读者带着这样一些问题</p>\n<ul>\n<li>getApplication() ，getApplicationContext()，getBaseContext()分别有什么区别？</li>\n<li>单个进程中能存在多个application么？</li>\n<li>为什么不能使用service或者application作为创建dialog的context参数？</li>\n</ul>\n<p>讲了这么多，我们可以看代码吧，从哪里开始看呢，就从Activity的startActivity方法作为起点吧。也就是这个方法</p>\n<p><img src=\"http://img.blog.csdn.net/20161009143617855\" alt=\"这里写图片描述\"><br>Bundle为空的情况，又调用了带Bundle的同名方法，bundle传null，如下</p>\n<p><img src=\"http://img.blog.csdn.net/20161009143857577\" alt=\"这里写图片描述\"></p>\n<p>startActivity方法本质其实是调用startActivityForResult的，requestCode传了-1，这个倒是我之前没想到的，一直以为这两个方法是分开的。所以requestCode为-1的情况应该是被系统默认忽略的（后面的分析过程中也发现requestCode为负都是被忽略的）。startActivityForResult的两个方法跟startActivity一样，最终也是进到了带Bundle的方法。</p>\n<p>这里先看下这个方法的注释<br><img src=\"http://img.blog.csdn.net/20161009145144243\" alt=\"这里写图片描述\"></p>\n<ul>\n<li>requestCode为负数时无效，跟调startActivity一样</li>\n<li>这个方法仅仅试用于能够在当前Task（关于Task是什么，后面也会讲到，暂时可以考虑成是一个Activity的集合）启动的Activity，只有在这个集合中的Activity才能互相传递Result，如果Activity不能在当前Task启动，则这个方法会立即返回失败</li>\n<li>在onCreate和onResume中调用startActivity时，前一个Activiyt不会显示，直到后面启动的Activity关闭返回结果，这是为了防止前一个Activity显示造成的闪烁</li>\n<li>方法会抛出一个ActivityNotFoundException</li>\n</ul>\n<p><img src=\"http://img.blog.csdn.net/20161009152006663\" alt=\"这里写图片描述\"></p>\n<p>这个方法一共有两种情况，mParent为null和不为null，mParent其实是指的ActivityGroup，但是这种用法现在已经被弃用了，所以这条线可以不用关注。无伤大雅，我们顺便来看一下吧。</p>\n<p>先看一下下个启动过程，当mParent不为null的时候，直接调用mParent的startActivityFromChild方法，如下<br><img src=\"http://img.blog.csdn.net/20161009153000134\" alt=\"这里写图片描述\"></p>\n<p>在startActivityFromChild中又通过mInstrumentation调用了其中的execStartActivity方法。</p>\n<p>在继续之前，有两个小插曲，先说一下startActivityForResult的最后一步，mActivityTransitionState.startExitOutTransition方法，处理退出当前Activity的相关事宜，这个不太用关注。</p>\n<p>然后是mInstrumentation，看过网上文章的同学应该熟悉Instrumentation这个类，Instrumentation这个类是一个管家类，所有跟Activity有关的实际操作都交给它做，恩，与其说大管家，不如说是打杂的。这样有什么好处呢，这个类可以做一些统计工作，因为它知道Activity有关的所有事情。</p>\n<p>然后，我们继续，回过头来看mParent为null时候的调用，其实也是调用了mInstrumentation的execStartActivity方法。可以看出，这两个分支最后殊途同归，到了execStartActivity方法，只是有两个参数不同，这就值得我们去看下这两个参数有什么影响，第一个和第四个，两个Activity类型的参数。其实这里mToken也是不一样的，mToken相当于activity的唯一标识符，这个token关系到后面新创建的Activity加入到哪个task栈中。这三个参数体会一下，后面也会遇到一些关于Activity的问题基本都和这里传递的参数有关。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (mParent == <span class=\"keyword\">null</span>)</div><div class=\"line\">mInstrumentation.execStartActivity(<span class=\"keyword\">this</span>, mMainThread.getApplicationThread(), mToken, <span class=\"keyword\">this</span>,</div><div class=\"line\">                    intent, requestCode, options);</div></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(mParent != <span class=\"keyword\">null</span>)</div><div class=\"line\">mInstrumentation.execStartActivity(<span class=\"keyword\">this</span>, mMainThread.getApplicationThread(), mToken, child,</div><div class=\"line\">                intent, requestCode, options);</div></pre></td></tr></table></figure>\n<p>这里先调用mInstrumentation的execStartActivity方法，返回一个ActivityResult。如果ActivityResult不为空，调用mMainThread的sendActivityResult方法。这其实是关于Activity通过startActivityForResult启动Activity然后返回Result的过程，这部分准备单独拉一篇文章来讲，这里就不多说了。</p>\n<p>然后mMainThread是一个ActivityThread类型的，说起ActivityThread可厉害了，这个类其实就是应用程序的入口，main方法就在这个类里，我们的第二篇文章就主要是对这个类的分析。</p>\n<p>然后这里mMainThread.sendActivityResult方法的作用就是调用onActivityResult，其实看到这里我不太明白，onActivityResult应该是新启动的Activity关闭后才调用。为什么这里execStartActivity之后就调用了，道理上这里Activity才启动，并没有关闭啊。我能想到的原因之一是execStartActivity是一个阻塞方法，只有当Activity关闭之后才会返回结果，然后继续往下执行，不知道我想的对不对，后面分析验证。</p>\n<p>关于sendActivityResult是怎么调到onActivityResult的，和所有生命周期方法的调用一样，通过Handler，这个后面会统一讲一下。</p>\n<p>下面我们去看Instrumentation的execStartActivity方法了。例行先看一下注释<br><img src=\"http://img.blog.csdn.net/20161009162711191\" alt=\"这里写图片描述\"></p>\n<p>这个方法执行一个有应用程序发出的startActivity的请求，默认的实现会更新所有ActivityMonitor的信息，你可以用这个类监控activity的启动情况，并且做一些额外操作，这也是前面提到的可以在Instrumentation中监控每个Activity的启动情况。</p>\n<p>当ActivityMonitor想要中断Activity启动时，这个方法依然会返回一个正确的ActivityResult。结合下面的代码，我前面提到的那个问题就明白了，这个方法并不阻塞，而且正常流程情况下也不会返回result，触发onActivityResult。只有当你设置了一个监控器，并且监控器是想阻止这个Acitivity启动的时候，这个方法不会真正去启动一个Activity，但是还是会正常返回Result值。</p>\n<p>另外前面也提到，有两个参数要重点看下，第一个参数Context，是正在启动的Activity属于哪个Context，这个参数永远都是Parent，当没有Parent的时候是自己。第四个参数Activity，是具体执行startActivity任务的那个Activity，同时这个Activity负责处理onActivityResult。明白了这两个参数后，我们来看具体的代码。</p>\n<p><img src=\"http://img.blog.csdn.net/20161009165506838\" alt=\"这里写图片描述\"></p>\n<p>基本都在注释里写清楚了，核心方法是调了ActivityManagerNative.getDefault().startActivity方法getDefault是用系统提供的单例方法构造的一个单例对象，感觉这个方法也挺有意思，下次可以研究下。</p>\n<p><img src=\"http://img.blog.csdn.net/20161009170243301\" alt=\"这里写图片描述\"></p>\n<p>然后我们看ActivityManagerNative类中的startActivity方法<br><img src=\"http://img.blog.csdn.net/20161009170645365\" alt=\"这里写图片描述\"></p>\n<p>我们来看ActivityManagerNative这个类，会发现它继承了Binder，如果你对Android的Binder体系熟悉的话，你应该能明显的看出来，这个方法是一个调用远端进程方法，封装数据，然后调用了Remote的transact方法。Binder也是Android中可以拖出来讲很久的一个体系，后面也会拖一篇文章来讲这个。所以ActivityManagerNative就是一个Binder对象，我们需要找到他对应的远端Service。追一下mRemote赋值的地方，会发现是在创建的时候。</p>\n<p><img src=\"http://img.blog.csdn.net/20161009171802041\" alt=\"这里写图片描述\"></p>\n<p>插播一句，这里Singleton类是java中实现的单例模式，具体这个单例实现的效果如果，然后有什么优化，不是很清楚，准备有空分析下这个类。但是想想系统实现的应该不会太差，所以写单例模式的时候也可以用这个类来。</p>\n<p>我们回归正题，这个IBinder也可以跟到，简单来说，ActivityManagerNative的远端服务就是ActivityManagerService。整个Android程序其实是一个C/S结构，本地程序是一个Client，还一个Service端负责所有的程序调度。启动Activity肯定是系统的事啊，所以这里程序就把整个工作推给系统来做了。通过Binder模式，我们调到了远端Service的startActivity方法，来看这个方法。</p>\n<p><img src=\"http://img.blog.csdn.net/20161009172405939\" alt=\"这里写图片描述\"></p>\n<p>继续跟startActivityAsUser方法<br><img src=\"http://img.blog.csdn.net/20161009172721029\" alt=\"这里写图片描述\"></p>\n<p>首先会检查，当前进程是否是孤立进程。孤立进程是Service的一个属性。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">android:isolatedProcess</div></pre></td></tr></table></figure>\n<p>如果Service设置了这个属性，那么这个Service将运行在一个特殊的进程中，这个进程和系统其他进程是分开的。这个进程没有任何权限。和这样的Service进行交互就只能通过系统API（也就是bind和start）。</p>\n<p>简单来说，非孤立进程可以被拿来重用，重新运行新的app，孤立进程由于权限等问题，不能被重用，只能被销毁。所以在执行启动操作的时候要判断当前进程是否孤立进程，如果是，则不允许做start的操作。</p>\n<p>回到正题，startActivityAsUser方法调用了StackSupervisor的startActivityMayWait方法，StackSupervisor是一个Activity栈的管理器，Activity栈是用来存储已经生成的的Activity对象的。这个我们会在后面说明。来看下StackSupervisor的startActivityMayWait方法。我看了一下整个流程，前面处理了Intent，AcitivtyStack等，为startActivity做准备，后面返回Result，都不是很重要。所以我们继续往下追，只寻找关于startActivity的部分。startActivityMayWait中的这一句</p>\n<p><img src=\"http://img.blog.csdn.net/20161009180248576\" alt=\"这里写图片描述\"></p>\n<p>调用了startActivityLocked方法，startActivityLocked中，也是先进行了一系列的检查，包括intent中各种flag的判定，以一个err命令贯穿整个方法，如果中间有任何异常err就会被改变，就不能继续往下进行。</p>\n<p><img src=\"http://img.blog.csdn.net/20161009180410115\" alt=\"这里写图片描述\"></p>\n<p>然后，调用到startActivityUncheckedLocked中，这个方法也是一个超级长的方法，对startActivity做了各种检查和准备， 主要是对Activity分各种Flag进行相应的处理。这个方法里面就有我们常见的Activity的各种启动模式的配置。如图</p>\n<p><img src=\"http://img.blog.csdn.net/20161025140715881\" alt=\"这里写图片描述\"></p>\n<p>前面说到startActivityForResult的时候，提过必须在一个task中，处理也是这里。如果不是一个task，会response一个异常码。</p>\n<p><img src=\"http://img.blog.csdn.net/20161025140911557\" alt=\"这里写图片描述\"></p>\n<p>这里其他代码的处理太细节化了，我们抓一下主线，生成一个ActivityStack，并<br>调用Stack的startActivityLocked方法<br><img src=\"http://img.blog.csdn.net/20161009180849750\" alt=\"这里写图片描述\"></p>\n<p>这样我们就到了ActivityStack类里面，但是没过多久，startActivityLocked通过调用resumeTopActivitiesLocked又回到了ActivityStackSupervisor。</p>\n<p><img src=\"http://img.blog.csdn.net/20161025143058036\" alt=\"这里写图片描述\"></p>\n<p><img src=\"http://img.blog.csdn.net/20161025143315259\" alt=\"这里写图片描述\"></p>\n<p><img src=\"http://img.blog.csdn.net/20161025143426099\" alt=\"这里写图片描述\"></p>\n<p>做了一些检查，然后调到了resumeTopActivityInnerLocked，在resumeTopActivityInnerLocked中，因为thread和app都为null，所以执行了startSpecificActivityLocked方法，这就重新回到了ActivityStackSupervisor中</p>\n<p><img src=\"http://img.blog.csdn.net/20161025144451400\" alt=\"这里写图片描述\"></p>\n<p><img src=\"http://img.blog.csdn.net/20161009182225273\" alt=\"这里写图片描述\"></p>\n<p><img src=\"http://img.blog.csdn.net/20161009182516474\" alt=\"这里写图片描述\"></p>\n<p>我们可以看到startSpecificActivityLocked中，如果app和thread为null，会调用startProcessLocked启动一个新的线程。后面也会说到，新线程启动后还会回到这里，去调用真正的realStartActivityLocked，我们可以发现源码里的名字起的也是相当到位。</p>\n<p>这里暂时thread和app都是null，所以通知ActivityManagerService的startProcessLocked方法启动一个进程</p>\n<p>在ActivityManagerService的startProcessLocked方法中，前面处理了一下线程重用等的优化，用processRecord记录了要启动的进程的信息</p>\n<p><img src=\"http://img.blog.csdn.net/20161025145835484\" alt=\"这里写图片描述\"></p>\n<p>然后调了同名的startProcessLocked方法，但是参数由String的processName变成了ProcessRecord</p>\n<p><img src=\"http://img.blog.csdn.net/20161009183016089\" alt=\"这里写图片描述\"></p>\n<p>在这个方法中，通过Process.start启动了一个进程，并指定了进程的入口，也就是ActivityThread类的main方法。至于这个进程的启动过程涉及到Android内核层的东西了，这篇文章暂时不看这么细，我们就简单的理解为，新进程启动后，就会去调用指定的ActivityThread的main方法就好。</p>\n<p><img src=\"http://img.blog.csdn.net/20161009183252014\" alt=\"这里写图片描述\"></p>\n<p>最后总结一下这个过程，如果你不想关注太多的细节，只是提炼调用顺序的话，整个过程是这样的。</p>\n<p><img src=\"http://img.blog.csdn.net/20161025165024179\" alt=\"这里写图片描述\"></p>\n<p>这篇文章大概就到这里了。</p>\n<p>最开始的时候提到，这篇文章介绍的是从头启动一个程序的流程，所以到目前为止，我们可以看到，AMS侧的准备工作已经做好了也记录了Activity的所有信息，但是，Activity包括运行Activity的线程其实还没有正式启动。下一篇文章中我们会详细说明一个Application启动后的流程，也就是main方法中做了什么。</p>\n<p>例行广告，大家喜欢我的文章，可以关注我的博客<a href=\"zwgeek.com\">zwgeek.com</a></p>\n","excerpt":"","more":"<p>广告时间，大家喜欢我的文章，可以关注我的博客<a href=\"zwgeek.com\">zwgeek.com</a></p>\n<p>今天想和大家一起分享一下Activity的启动流程。这起源于我发现了一个好的现象，其实不知道大家发现没有，随着Android的发展，这几年Android开发者的素质也越来越高，我说的素质指的是对问题深度的理解，对Android总体的运行原理的分析，而不仅仅局限在应用开发层面了。还记得最开始接触Android的时候，那时候不管面试还是干嘛的，上来就问你生命周期，生命周期。感觉能说清楚生命周期已经是一件很厉害的事了。我也曾一度觉得开发者只要清楚onCreate什么时候调用就可以了，onCreate就是开发者能接触的最上层的内容了。根本没有考虑过程序应该有个入口，onCreate到底是怎么被调用的，更不用说还想着去看看源码。而现在，好像大家比起关心生命周期，关心起了更深层的问题，也就是一个Android程序是怎么被启动的，然后才是它的生命周期是怎么被调用的。我最先意识到这个现象时，是很开心的，这说明Android开发者越来越高级，也就意味着现在开发者不光使用Android，而且也能为Android社区做一些力所能及的贡献了。</p>\n<p>这篇文章的目标是总结网上各种对Activity启动流程的分析。现在网上对Activity启动流程的分析已经多如牛毛了。那么我为什么还觉得有必要再写一次呢。一是自己边分析边写更有利于理解。二是我发现网上的分析习惯性的忽略细节，只着眼于一条大的主线，也不是说这样不好，这样确实比较容易理解，我希望我这篇文章能关注到每个细节点，每个方法的作用。</p>\n<p>整个过程准备分为三篇文章来写</p>\n<ul>\n<li>程序调用startActivity后发生的操作，也就是这篇文章。</li>\n<li>如果被startActivity的程序是需要重新启动的程序，程序在最开始初始化时发生的操作。例如在Launcher中启动一个程序或启动另外的程序。已经完成，可查阅<a href=\"http://zwgeek.com/2016/10/25/Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%902/\">Activity启动流程分析（二）</a></li>\n<li>如果被startActivity的程序是已经启动的程序，发生的操作。例如程序自己调用startActivity启动一个自己程序中的Activity</li>\n</ul>\n<p>整个分析过程中，希望读者带着这样一些问题</p>\n<ul>\n<li>getApplication() ，getApplicationContext()，getBaseContext()分别有什么区别？</li>\n<li>单个进程中能存在多个application么？</li>\n<li>为什么不能使用service或者application作为创建dialog的context参数？</li>\n</ul>\n<p>讲了这么多，我们可以看代码吧，从哪里开始看呢，就从Activity的startActivity方法作为起点吧。也就是这个方法</p>\n<p><img src=\"http://img.blog.csdn.net/20161009143617855\" alt=\"这里写图片描述\"><br>Bundle为空的情况，又调用了带Bundle的同名方法，bundle传null，如下</p>\n<p><img src=\"http://img.blog.csdn.net/20161009143857577\" alt=\"这里写图片描述\"></p>\n<p>startActivity方法本质其实是调用startActivityForResult的，requestCode传了-1，这个倒是我之前没想到的，一直以为这两个方法是分开的。所以requestCode为-1的情况应该是被系统默认忽略的（后面的分析过程中也发现requestCode为负都是被忽略的）。startActivityForResult的两个方法跟startActivity一样，最终也是进到了带Bundle的方法。</p>\n<p>这里先看下这个方法的注释<br><img src=\"http://img.blog.csdn.net/20161009145144243\" alt=\"这里写图片描述\"></p>\n<ul>\n<li>requestCode为负数时无效，跟调startActivity一样</li>\n<li>这个方法仅仅试用于能够在当前Task（关于Task是什么，后面也会讲到，暂时可以考虑成是一个Activity的集合）启动的Activity，只有在这个集合中的Activity才能互相传递Result，如果Activity不能在当前Task启动，则这个方法会立即返回失败</li>\n<li>在onCreate和onResume中调用startActivity时，前一个Activiyt不会显示，直到后面启动的Activity关闭返回结果，这是为了防止前一个Activity显示造成的闪烁</li>\n<li>方法会抛出一个ActivityNotFoundException</li>\n</ul>\n<p><img src=\"http://img.blog.csdn.net/20161009152006663\" alt=\"这里写图片描述\"></p>\n<p>这个方法一共有两种情况，mParent为null和不为null，mParent其实是指的ActivityGroup，但是这种用法现在已经被弃用了，所以这条线可以不用关注。无伤大雅，我们顺便来看一下吧。</p>\n<p>先看一下下个启动过程，当mParent不为null的时候，直接调用mParent的startActivityFromChild方法，如下<br><img src=\"http://img.blog.csdn.net/20161009153000134\" alt=\"这里写图片描述\"></p>\n<p>在startActivityFromChild中又通过mInstrumentation调用了其中的execStartActivity方法。</p>\n<p>在继续之前，有两个小插曲，先说一下startActivityForResult的最后一步，mActivityTransitionState.startExitOutTransition方法，处理退出当前Activity的相关事宜，这个不太用关注。</p>\n<p>然后是mInstrumentation，看过网上文章的同学应该熟悉Instrumentation这个类，Instrumentation这个类是一个管家类，所有跟Activity有关的实际操作都交给它做，恩，与其说大管家，不如说是打杂的。这样有什么好处呢，这个类可以做一些统计工作，因为它知道Activity有关的所有事情。</p>\n<p>然后，我们继续，回过头来看mParent为null时候的调用，其实也是调用了mInstrumentation的execStartActivity方法。可以看出，这两个分支最后殊途同归，到了execStartActivity方法，只是有两个参数不同，这就值得我们去看下这两个参数有什么影响，第一个和第四个，两个Activity类型的参数。其实这里mToken也是不一样的，mToken相当于activity的唯一标识符，这个token关系到后面新创建的Activity加入到哪个task栈中。这三个参数体会一下，后面也会遇到一些关于Activity的问题基本都和这里传递的参数有关。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (mParent == <span class=\"keyword\">null</span>)</div><div class=\"line\">mInstrumentation.execStartActivity(<span class=\"keyword\">this</span>, mMainThread.getApplicationThread(), mToken, <span class=\"keyword\">this</span>,</div><div class=\"line\">                    intent, requestCode, options);</div></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(mParent != <span class=\"keyword\">null</span>)</div><div class=\"line\">mInstrumentation.execStartActivity(<span class=\"keyword\">this</span>, mMainThread.getApplicationThread(), mToken, child,</div><div class=\"line\">                intent, requestCode, options);</div></pre></td></tr></table></figure>\n<p>这里先调用mInstrumentation的execStartActivity方法，返回一个ActivityResult。如果ActivityResult不为空，调用mMainThread的sendActivityResult方法。这其实是关于Activity通过startActivityForResult启动Activity然后返回Result的过程，这部分准备单独拉一篇文章来讲，这里就不多说了。</p>\n<p>然后mMainThread是一个ActivityThread类型的，说起ActivityThread可厉害了，这个类其实就是应用程序的入口，main方法就在这个类里，我们的第二篇文章就主要是对这个类的分析。</p>\n<p>然后这里mMainThread.sendActivityResult方法的作用就是调用onActivityResult，其实看到这里我不太明白，onActivityResult应该是新启动的Activity关闭后才调用。为什么这里execStartActivity之后就调用了，道理上这里Activity才启动，并没有关闭啊。我能想到的原因之一是execStartActivity是一个阻塞方法，只有当Activity关闭之后才会返回结果，然后继续往下执行，不知道我想的对不对，后面分析验证。</p>\n<p>关于sendActivityResult是怎么调到onActivityResult的，和所有生命周期方法的调用一样，通过Handler，这个后面会统一讲一下。</p>\n<p>下面我们去看Instrumentation的execStartActivity方法了。例行先看一下注释<br><img src=\"http://img.blog.csdn.net/20161009162711191\" alt=\"这里写图片描述\"></p>\n<p>这个方法执行一个有应用程序发出的startActivity的请求，默认的实现会更新所有ActivityMonitor的信息，你可以用这个类监控activity的启动情况，并且做一些额外操作，这也是前面提到的可以在Instrumentation中监控每个Activity的启动情况。</p>\n<p>当ActivityMonitor想要中断Activity启动时，这个方法依然会返回一个正确的ActivityResult。结合下面的代码，我前面提到的那个问题就明白了，这个方法并不阻塞，而且正常流程情况下也不会返回result，触发onActivityResult。只有当你设置了一个监控器，并且监控器是想阻止这个Acitivity启动的时候，这个方法不会真正去启动一个Activity，但是还是会正常返回Result值。</p>\n<p>另外前面也提到，有两个参数要重点看下，第一个参数Context，是正在启动的Activity属于哪个Context，这个参数永远都是Parent，当没有Parent的时候是自己。第四个参数Activity，是具体执行startActivity任务的那个Activity，同时这个Activity负责处理onActivityResult。明白了这两个参数后，我们来看具体的代码。</p>\n<p><img src=\"http://img.blog.csdn.net/20161009165506838\" alt=\"这里写图片描述\"></p>\n<p>基本都在注释里写清楚了，核心方法是调了ActivityManagerNative.getDefault().startActivity方法getDefault是用系统提供的单例方法构造的一个单例对象，感觉这个方法也挺有意思，下次可以研究下。</p>\n<p><img src=\"http://img.blog.csdn.net/20161009170243301\" alt=\"这里写图片描述\"></p>\n<p>然后我们看ActivityManagerNative类中的startActivity方法<br><img src=\"http://img.blog.csdn.net/20161009170645365\" alt=\"这里写图片描述\"></p>\n<p>我们来看ActivityManagerNative这个类，会发现它继承了Binder，如果你对Android的Binder体系熟悉的话，你应该能明显的看出来，这个方法是一个调用远端进程方法，封装数据，然后调用了Remote的transact方法。Binder也是Android中可以拖出来讲很久的一个体系，后面也会拖一篇文章来讲这个。所以ActivityManagerNative就是一个Binder对象，我们需要找到他对应的远端Service。追一下mRemote赋值的地方，会发现是在创建的时候。</p>\n<p><img src=\"http://img.blog.csdn.net/20161009171802041\" alt=\"这里写图片描述\"></p>\n<p>插播一句，这里Singleton类是java中实现的单例模式，具体这个单例实现的效果如果，然后有什么优化，不是很清楚，准备有空分析下这个类。但是想想系统实现的应该不会太差，所以写单例模式的时候也可以用这个类来。</p>\n<p>我们回归正题，这个IBinder也可以跟到，简单来说，ActivityManagerNative的远端服务就是ActivityManagerService。整个Android程序其实是一个C/S结构，本地程序是一个Client，还一个Service端负责所有的程序调度。启动Activity肯定是系统的事啊，所以这里程序就把整个工作推给系统来做了。通过Binder模式，我们调到了远端Service的startActivity方法，来看这个方法。</p>\n<p><img src=\"http://img.blog.csdn.net/20161009172405939\" alt=\"这里写图片描述\"></p>\n<p>继续跟startActivityAsUser方法<br><img src=\"http://img.blog.csdn.net/20161009172721029\" alt=\"这里写图片描述\"></p>\n<p>首先会检查，当前进程是否是孤立进程。孤立进程是Service的一个属性。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">android:isolatedProcess</div></pre></td></tr></table></figure>\n<p>如果Service设置了这个属性，那么这个Service将运行在一个特殊的进程中，这个进程和系统其他进程是分开的。这个进程没有任何权限。和这样的Service进行交互就只能通过系统API（也就是bind和start）。</p>\n<p>简单来说，非孤立进程可以被拿来重用，重新运行新的app，孤立进程由于权限等问题，不能被重用，只能被销毁。所以在执行启动操作的时候要判断当前进程是否孤立进程，如果是，则不允许做start的操作。</p>\n<p>回到正题，startActivityAsUser方法调用了StackSupervisor的startActivityMayWait方法，StackSupervisor是一个Activity栈的管理器，Activity栈是用来存储已经生成的的Activity对象的。这个我们会在后面说明。来看下StackSupervisor的startActivityMayWait方法。我看了一下整个流程，前面处理了Intent，AcitivtyStack等，为startActivity做准备，后面返回Result，都不是很重要。所以我们继续往下追，只寻找关于startActivity的部分。startActivityMayWait中的这一句</p>\n<p><img src=\"http://img.blog.csdn.net/20161009180248576\" alt=\"这里写图片描述\"></p>\n<p>调用了startActivityLocked方法，startActivityLocked中，也是先进行了一系列的检查，包括intent中各种flag的判定，以一个err命令贯穿整个方法，如果中间有任何异常err就会被改变，就不能继续往下进行。</p>\n<p><img src=\"http://img.blog.csdn.net/20161009180410115\" alt=\"这里写图片描述\"></p>\n<p>然后，调用到startActivityUncheckedLocked中，这个方法也是一个超级长的方法，对startActivity做了各种检查和准备， 主要是对Activity分各种Flag进行相应的处理。这个方法里面就有我们常见的Activity的各种启动模式的配置。如图</p>\n<p><img src=\"http://img.blog.csdn.net/20161025140715881\" alt=\"这里写图片描述\"></p>\n<p>前面说到startActivityForResult的时候，提过必须在一个task中，处理也是这里。如果不是一个task，会response一个异常码。</p>\n<p><img src=\"http://img.blog.csdn.net/20161025140911557\" alt=\"这里写图片描述\"></p>\n<p>这里其他代码的处理太细节化了，我们抓一下主线，生成一个ActivityStack，并<br>调用Stack的startActivityLocked方法<br><img src=\"http://img.blog.csdn.net/20161009180849750\" alt=\"这里写图片描述\"></p>\n<p>这样我们就到了ActivityStack类里面，但是没过多久，startActivityLocked通过调用resumeTopActivitiesLocked又回到了ActivityStackSupervisor。</p>\n<p><img src=\"http://img.blog.csdn.net/20161025143058036\" alt=\"这里写图片描述\"></p>\n<p><img src=\"http://img.blog.csdn.net/20161025143315259\" alt=\"这里写图片描述\"></p>\n<p><img src=\"http://img.blog.csdn.net/20161025143426099\" alt=\"这里写图片描述\"></p>\n<p>做了一些检查，然后调到了resumeTopActivityInnerLocked，在resumeTopActivityInnerLocked中，因为thread和app都为null，所以执行了startSpecificActivityLocked方法，这就重新回到了ActivityStackSupervisor中</p>\n<p><img src=\"http://img.blog.csdn.net/20161025144451400\" alt=\"这里写图片描述\"></p>\n<p><img src=\"http://img.blog.csdn.net/20161009182225273\" alt=\"这里写图片描述\"></p>\n<p><img src=\"http://img.blog.csdn.net/20161009182516474\" alt=\"这里写图片描述\"></p>\n<p>我们可以看到startSpecificActivityLocked中，如果app和thread为null，会调用startProcessLocked启动一个新的线程。后面也会说到，新线程启动后还会回到这里，去调用真正的realStartActivityLocked，我们可以发现源码里的名字起的也是相当到位。</p>\n<p>这里暂时thread和app都是null，所以通知ActivityManagerService的startProcessLocked方法启动一个进程</p>\n<p>在ActivityManagerService的startProcessLocked方法中，前面处理了一下线程重用等的优化，用processRecord记录了要启动的进程的信息</p>\n<p><img src=\"http://img.blog.csdn.net/20161025145835484\" alt=\"这里写图片描述\"></p>\n<p>然后调了同名的startProcessLocked方法，但是参数由String的processName变成了ProcessRecord</p>\n<p><img src=\"http://img.blog.csdn.net/20161009183016089\" alt=\"这里写图片描述\"></p>\n<p>在这个方法中，通过Process.start启动了一个进程，并指定了进程的入口，也就是ActivityThread类的main方法。至于这个进程的启动过程涉及到Android内核层的东西了，这篇文章暂时不看这么细，我们就简单的理解为，新进程启动后，就会去调用指定的ActivityThread的main方法就好。</p>\n<p><img src=\"http://img.blog.csdn.net/20161009183252014\" alt=\"这里写图片描述\"></p>\n<p>最后总结一下这个过程，如果你不想关注太多的细节，只是提炼调用顺序的话，整个过程是这样的。</p>\n<p><img src=\"http://img.blog.csdn.net/20161025165024179\" alt=\"这里写图片描述\"></p>\n<p>这篇文章大概就到这里了。</p>\n<p>最开始的时候提到，这篇文章介绍的是从头启动一个程序的流程，所以到目前为止，我们可以看到，AMS侧的准备工作已经做好了也记录了Activity的所有信息，但是，Activity包括运行Activity的线程其实还没有正式启动。下一篇文章中我们会详细说明一个Application启动后的流程，也就是main方法中做了什么。</p>\n<p>例行广告，大家喜欢我的文章，可以关注我的博客<a href=\"zwgeek.com\">zwgeek.com</a></p>\n"},{"title":"Activity启动流程分析（二）","date":"2016-10-25T09:03:13.000Z","_content":"\n广告时间，大家喜欢我的文章，可以关注我的博客[http://zwgeek.com](http://zwgeek.com)\n\n前面说到，希望分析一下Activity的启动流程，整个过程准备分为三篇文章来写\n- 程序调用startActivity后发生的操作\n- 如果被startActivity的程序是需要启动的程序，程序在最开始初始化时发生的操作。例如在Launcher中启动一个程序。\n- 如果被startActivity的程序是已经启动的程序，发生的操作。例如程序自己调用startActivity启动一个自己程序中的Activity\n\n第一篇文章也已经讲完了程序调用startActivity之后发生的事情。\n\n还没有读过的同学可以看这里[Activity启动流程分析](http://zwgeek.com/2016/10/09/Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/)\n\n这篇文章就来讲第二个部分，一个程序被启动之后发生的事情。第一篇文章中还提到了几个问题，也会在这篇文章中做出解答。\n\n- getApplication() ，getApplicationContext()，getBaseContext()分别有什么区别？\n- 单个进程中能存在多个application么？\n- 为什么不能使用service或者application作为创建dialog的context参数？\n\n第一篇文章最后讲到了Process.start方法，说到了这个方法会启动一个线程，并且运行ActivityThread的main方法来正式开启一个Android程序。所以，很显然，这篇文章就要从ActivityThread的main方法来开始。\n\n首先，来看一下这个Android程序的起点方法，一睹芳容。\n\n![这里写图片描述](http://img.blog.csdn.net/20161025184513316)\n\n这个方法重要的是在Looper prepare之后的部分，Handler跟loop的机制比较简单，可以先百度一下，我后面可能也会写篇文章说一下。简单来说loop就是一个无限循环，通过循环去去查询有没有handler发过来命令，如果有就处理，没有就继续循环。\n\n这样的话，我们就能看出，主进程在做了一个初始化工作之后就把自己放在了一个loop循环中，要跟这个程序打交道，怎么办呢，就是通过获取它的handler，然后发命令，比如现在需要调用onResume方法，通过handler告诉主进程looper要调用onResume，looper就会做相应的处理了。当然这个是关于Android生命周期方法的调用问题，我们也是要单独拉出来讲的，这里就不细说了。\n\n其实这篇文章的重点是这一句话，thread.attach(false)，ActivityThread的初始化操作。来看下这个方法具体做了什么操作。\n\n![这里写图片描述](http://img.blog.csdn.net/20161025191248464)\n\n这个方法看下来还好，也都是配置一些监听器，像ViewRoot监听，内存监听，等等。重要的还是我选中的这一段，首先创建了一个ApplicationThread，然后把这个ApplicationThread交给了RuntimeInit，很多人开发过程中最头痛的就是RuntimeException，其实这里就是异常监控的初始化过程。然后创建了一个ActivityManagerNative，第一篇文章中就提过，ActivityManagerNative在创建的时候就会和ActivityManagerService绑定。接下来程序就可以通过AMN来访问AMS了。可是大家有想过，Client可以通过AMN来访问AMS，但是Server端怎么访问Client端呢，看这句话attachApplication，其实这里就是程序把自己的一个控制器交给了Server端，然后Server端就可以通过这个控制器来操作Client端了。不信我们来看下ApplicationThread的方法。\n\n![这里写图片描述](http://img.blog.csdn.net/20161026103756562)\n\n是不是看到很多控制生命周期的方法，是的，AMS就是通过这个ApplicationThread来控制Client端的。\n\n那么我们来总结一下这里，程序通过AMN来绑定AMS后，自己创建了一个桥梁applicationThread，然后把这个桥梁交给AMS，意思就是说，这是我小弟，以后联系我可以通过他。另一方面，在这个attach中client的各种初始化已经完成了。接下来的工作就通过attachApplication这个方法移交给AMS端了。\n\n那接下来我们来看AMS端的attachApplication方法\n\n![这里写图片描述](http://img.blog.csdn.net/20161026104634204)\n\nAMS端先通过Binder查询到程序的pid，然后调用attachApplicationLocked，继续往下看，这个方法就是AMS在接到“一个新进程启动了”这件事之后做了一些工作，很复杂，但AMS毕竟是老板，多做一些是正常的。\n\n![这里写图片描述](http://img.blog.csdn.net/20161026110532870)\n\n![这里写图片描述](http://img.blog.csdn.net/20161026110642120)\n\n先是用一个ProcessRecord来记录所有和Process有关的信息。\n\n![这里写图片描述](http://img.blog.csdn.net/20161026110745261)\n\n这里有一个generateProvider的操作，但是我感觉应该不是生成程序的ContentProvider，因为此时Manifest文件还没有被解析，这里应该是为Application生成一些系统必要的ContentProvider。至于对不对，后面再验证吧。\n\n后面做了一些配置工作后，调用了这个方法\n\n![这里写图片描述](http://img.blog.csdn.net/20161026111207622)\n\n是的，这个方法才是主线剧情。通过这个方法，AMS将自己初始化的一些成果，告诉了Client端，并将控制权重新交回给Client端。在看bindApplication之前，我们看下AMS后面的工作。\n\n![这里写图片描述](http://img.blog.csdn.net/20161026111410272)\n\n源码的注释写的比较清楚了，判断有没有其他组件在等这个进程启动，如果有，那么这个进程已经启动了，就该通知他们做事了。这不关我们的事，回到正题吧，看看控制权回到Client那边后，又做了什么。不过这里我们也再一次验证了AMS通过ApplicationThread这个类来和Client端打交道。\n\n好，老板做完事情了，工作又回到小弟手中了。什么？你说老板其实什么都没做，你可以去财务领工资了。\n\n但是ApplicationThread毕竟是个桥梁，实际的工作还是得给app的老大ActivityThread来做，所以这个bindApplication方法也是记录了一些AMS传回来的信息之后，又把工作给了ActivityThread。\n\n我们来看下这个bindApplication做了什么，首先记录了一些配置信息\n\n![这里写图片描述](http://img.blog.csdn.net/20161026112941262)\n\n然后在VM中注册APP的信息\n\n![这里写图片描述](http://img.blog.csdn.net/20161026113020966)\n\n这里注释也说了，有两种情况，两个package是共享runtime的。\n\n- 设置了shareUserId\n- 设置了ProcessName\n\n在share的情况下是不用再VM中注册的，我的理解是，share的组件并不是一个完整的app，而他所属的原来的app其实已经注册过了。\n\n这里有个问题是，工作是怎么给ActivityThread的呢？看bindApplication的第三部分\n\n![这里写图片描述](http://img.blog.csdn.net/20161026113436006)\n\nApplicationThread是ActivityThread的内部类，内部类代表什么呢，它其实是持有一个外部类ActivityThread的对象引用的。可以这么说在ApplicationThread中其实是可以调到ActivityThread的所有方法的。那么它为什么要用这种sendMessage，然后通过Handler处理的这种方式呢。我们来想一下Handler的一个作用是什么。切换线程，在任何情况下，不管bindApplication这个方法运行在哪个线程中，只要通过handler这种方式，都可以回到ActivityThread所在的线程，也就是主线程。这就保证了什么呢，保证了Android的所有生命周期方法都是运行在主线程的，也就是我们常说的UI线程。\n\n简单跟下sendMessage\n\n![这里写图片描述](http://img.blog.csdn.net/20161026125950474)\n\n![这里写图片描述](http://img.blog.csdn.net/20161026130023435)\n\n![这里写图片描述](http://img.blog.csdn.net/20161026130056888)\n\nmH是一个H类型的对象，这个H就是ActivityThread内部的Handler\n\n![这里写图片描述](http://img.blog.csdn.net/20161026130144586)\n\n看下这个Handler的handleMessage方法，跟下对BIND_APPLICATION消息的处理。\n\n![这里写图片描述](http://img.blog.csdn.net/20161026130314369)\n\n进到了handleBIndApplication方法，这里就是Application的启动过程了，让我们来仔细看下这个方法处理的步骤\n\n![这里写图片描述](http://img.blog.csdn.net/20161026133403057)\n\n国际惯例，前面也是各种记录，配置，初始化的工作，我们可以完全忽略。\n\n![这里写图片描述](http://img.blog.csdn.net/20161026133429604)\n\n这个地方是一个小的知识点，在3.1以前的版本上，AsyncTask会改变默认的executor，我们看下改变之后的executor是什么样的。\n\n![这里写图片描述](http://img.blog.csdn.net/20161026133859665)\n\n而默认的executor是这样的\n\n![这里写图片描述](http://img.blog.csdn.net/20161026133929525)\n\n所以3.1以前版本的AsyncTask是并行执行任务的，而3.1以后版本反而是顺序执行任务的，当然，这个配置可以通过AsyncTask的参数而改变。\n\n然后我们回到handleBindApplication，后面会继续设置时区，位置，屏幕参数等。\n\n![这里写图片描述](http://img.blog.csdn.net/20161026134148091)\n\n之后创建了一个Context对象，注意，这是我们到目前位置接触到的第一个Context。我们知道在Android中Application，Activity等等其实都是Context的子类，但是他们又是不同的。这里创建的这个context对应的是我们开发过程中的哪个呢，让我们继续往下看。\n\n![这里写图片描述](http://img.blog.csdn.net/20161026134554910)\n\n然后又是一堆配置，其中包括UI线程不能执行网络操作的配置\n\n![这里写图片描述](http://img.blog.csdn.net/20161026134728344)\n\n然后是关于调试的相关配置，开启一个调试端口，其实关于调试也是需要讲很多的，调试本身也是C/S结构的，客户端开一个端口，等着服务端来连接进行调试，这里就是客户端打开端口的操作。\n\n![这里写图片描述](http://img.blog.csdn.net/20161026134924665)\n\n设置了一个默认的HTTP代理\n\n![这里写图片描述](http://img.blog.csdn.net/20161026135017838)\n\n后面一段是创建了一个Instrumentation对象，这里不截图的。之前第一篇文章我们也提到过，跟ActivityStart有关的操作都是由Instrumentation这个类管理的，被我们亲切的称为大管家，其实是为了监视我们的操作。。。\n\n然后，这个方法讲了这么多，前面大家基本可以忽略，到现在才是重点。\n\n![这里写图片描述](http://img.blog.csdn.net/20161026135315421)\n\n这一段，首先创建了一个Application，恩，我们开发过程中遇见的Application就是这里生成的。后面一段是初始化ContentProvider，这个我们后面讲ContentProvider启动过程的时候会看到，不过这里能知道的一个点就是ContentProvider的启动时间是相当早的，在Application的onCreate之前。然后这里的providers确实是之前我们说到的AMS生成的，然后一路传过来的。恩，先不细看了，因为这篇文章主要想说Activity的启动过程。\n\n后面调用了Instrumentation的onCreate方法，是个空方法，可Override，再后面看到吗，通过Instrumentation大管家呼叫了Application的OnCreate方法\n\n![这里写图片描述](http://img.blog.csdn.net/20161026135758475)\n\n至此，我们开发者接触到的Android生命周期中的第一个方法，Application的onCreate被执行了。至于前面生成的Context，我看了一下，传给了Instrumentation成为了Instrumentation中的appContext，但是我并没有找到跟Application对象结合的方法。这个继续往后看吧。\n\n到此为止，这个handleBindApplication方法就结束了，创建了一个appContext，一个Instrumentation，一个Application，并且调用了Application的onCreate。中间还涉及到ContentProvider的初始化操作，我们先忽略。那么Activity在哪里，为什么感觉自己被带偏了。我又一路往前找。终于在AMS的attachApplicationLocked中，我看到了这一步。\n\n![这里写图片描述](http://img.blog.csdn.net/20161026141040256)\n\nbindApplication在执行完我们上面说的那一堆之后，调用了StackSupervisor的attachApplicationLocked，好，我们来看一下。同时，这里的调用顺序也保证了Application的onCreate方法在Activity之前进行。\n\n![这里写图片描述](http://img.blog.csdn.net/20161026141633514)\n\n方法中有一个realStartActivity的方法，名字很形象，前面我们调用过那么多次的startActivity，但是真正的Activity在这里才生成。\n\n这个realStartActivity嘟噜嘟噜的扯了好多，不知道在干吗，但是终于看到了一个熟悉的影子\n\n![这里写图片描述](http://img.blog.csdn.net/20161026150656396)\n\n就这样控制权又回到了ActivityThread\n\n![这里写图片描述](http://img.blog.csdn.net/20161026151007131)\n\n这里先创建了一个ActivityClientRecord，这个就是Client端管理生成的activity对象的包装类，后面生成的Activity类都会被ActivityClientRecord包装一层，然后保存到ActivityThread的mActivities中。\n\n![这里写图片描述](http://img.blog.csdn.net/20161026151225913)\n\n跟Application那边一样，scheduleLaunchActivity最终会被handleLaunchActivity处理，我们略过中间过程，直接看handleLaunchActivity吧。\n\n![这里写图片描述](http://img.blog.csdn.net/20161026151527821)\n\n这个方法触发了Activity的两个生命周期方法，分别是我标出来的onCreate的onResume，然后后面那一段我的理解是Activity被创建出来，并且调用了onResume之后并没有被显示，那么就立刻调用onPause，但其实不是很懂这个地方。让我想想再回来补充吧。\n\n接下来看performLaunchActivity吧\n\n![这里写图片描述](http://img.blog.csdn.net/20161026152020367)\n\n首先更新了ActivityClientRecord的信息，包括ActivityInfo，ComponentName等，我们开发过程中也是经常用到，这些信息都是存在ActivityClientRecord中的。\n\n![这里写图片描述](http://img.blog.csdn.net/20161026152153386)\n\n接下来创建了一个Activity，天哪，我们分析了这么久，终于看到Activity了。创建过程很简单，通过反射new了一个类出来，这个时候的Activity是还没有生命周期的。需要把Activity托管给AMS，才能有生命周期。\n\n![这里写图片描述](http://img.blog.csdn.net/20161026152429639)\n\n接着，我们获取到之前创建的那个Application，为Activity创建了一个Context，然后通过Activity的attach方法把这些绑定起来。\n\n![这里写图片描述](http://img.blog.csdn.net/20161026152636325)\n\n生成Context的方法和之前为Instrumentation生成Context的方法差不多，返回的是一个ContextImpl类型的对象，保存了Activity的上下文。\n\n![这里写图片描述](http://img.blog.csdn.net/20161026152944396)\n\nattach方法将所有的对象包括Instrumentation，Application, ActivityThread等等全部在Activity中保存了一份。\n\n![这里写图片描述](http://img.blog.csdn.net/20161026153551690)\n\n回到performLaunchActivity，attach之后通过Instrumentation大管家调用了Activity的onCreate方法\n\n![这里写图片描述](http://img.blog.csdn.net/20161026154101442)\n\n然后将生成的activity交给ActivityClientRecord，并保存在mActivities中，这就完成了Activity的生成，并托管给系统，之后系统都可以在适当的时候通过token来获取到相应的Activity，并调用其生命周期。\n\n这样performLaunchActivity就结束了，我们返回上一层handleLaunchActivity继续往下看，Activity在生成之后是会立刻调用onResume的。这两个生命周期有什么区别呢， 其实就在于onCreate跟onResume之间执行的这几句话，说实话，在创建的时候区别不大。不同的是onResume未来还会被调用，但是onCreate只有创建的时候才会被调用。\n\n![这里写图片描述](http://img.blog.csdn.net/20161026154453198)\n\n其实到这来一个Activity的启动流程就已经结束了，但是我们顺便来看下handleResumeActivity的工作吧\n\n![这里写图片描述](http://img.blog.csdn.net/20161026154706405)\n\n看这来，从mActivities中根据token获取了ActivityClientRecord，并进一步获得了里面的activity，然后执行了onResume方法，我刚想说，咦，这次调用没有通过大管家哎，然后看了一下performResume方法里面，其实还是通过Instrumentation调用的。\n\n![这里写图片描述](http://img.blog.csdn.net/20161026154913320)\n\n然后，还更新了ActivityClientRecord的相关信息等。\n\n其实到这里onResume已经调用完成了，那么handleResumeActivity后面的这一堆在干什么呢？\n\n![这里写图片描述](http://img.blog.csdn.net/20161026155148379)\n\n通过方法名我们知道，Activity在onResume之后才开始处理显示的逻辑，这里就是通知AMS，Activity onResume已经调用完了，接下来要显示了，那么AMS就会通知WindowManger来显示Activity，这就是另外一件事了，我们在这里就不细细讨论了。\n\n呼~终于写完了，整个流程主线还是很清楚的，AMS和AMN的分工明确。 \n\n整个流程总结一下，是下面这种关系\n\n![这里写图片描述](http://img.blog.csdn.net/20161026165138600)\n\n最后还是广告时间，如果喜欢这篇文章，可以关注我的博客[http://zwgeek.com](http://zwgeek.com)\n\n\n","source":"_posts/Activity启动流程分析2.md","raw":"---\ntitle: Activity启动流程分析（二）\ndate: 2016-10-25 17:03:13\ntags:\n  - Android\n  - Activity启动\n  - 系统\ncategories: Android\n---\n\n广告时间，大家喜欢我的文章，可以关注我的博客[http://zwgeek.com](http://zwgeek.com)\n\n前面说到，希望分析一下Activity的启动流程，整个过程准备分为三篇文章来写\n- 程序调用startActivity后发生的操作\n- 如果被startActivity的程序是需要启动的程序，程序在最开始初始化时发生的操作。例如在Launcher中启动一个程序。\n- 如果被startActivity的程序是已经启动的程序，发生的操作。例如程序自己调用startActivity启动一个自己程序中的Activity\n\n第一篇文章也已经讲完了程序调用startActivity之后发生的事情。\n\n还没有读过的同学可以看这里[Activity启动流程分析](http://zwgeek.com/2016/10/09/Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/)\n\n这篇文章就来讲第二个部分，一个程序被启动之后发生的事情。第一篇文章中还提到了几个问题，也会在这篇文章中做出解答。\n\n- getApplication() ，getApplicationContext()，getBaseContext()分别有什么区别？\n- 单个进程中能存在多个application么？\n- 为什么不能使用service或者application作为创建dialog的context参数？\n\n第一篇文章最后讲到了Process.start方法，说到了这个方法会启动一个线程，并且运行ActivityThread的main方法来正式开启一个Android程序。所以，很显然，这篇文章就要从ActivityThread的main方法来开始。\n\n首先，来看一下这个Android程序的起点方法，一睹芳容。\n\n![这里写图片描述](http://img.blog.csdn.net/20161025184513316)\n\n这个方法重要的是在Looper prepare之后的部分，Handler跟loop的机制比较简单，可以先百度一下，我后面可能也会写篇文章说一下。简单来说loop就是一个无限循环，通过循环去去查询有没有handler发过来命令，如果有就处理，没有就继续循环。\n\n这样的话，我们就能看出，主进程在做了一个初始化工作之后就把自己放在了一个loop循环中，要跟这个程序打交道，怎么办呢，就是通过获取它的handler，然后发命令，比如现在需要调用onResume方法，通过handler告诉主进程looper要调用onResume，looper就会做相应的处理了。当然这个是关于Android生命周期方法的调用问题，我们也是要单独拉出来讲的，这里就不细说了。\n\n其实这篇文章的重点是这一句话，thread.attach(false)，ActivityThread的初始化操作。来看下这个方法具体做了什么操作。\n\n![这里写图片描述](http://img.blog.csdn.net/20161025191248464)\n\n这个方法看下来还好，也都是配置一些监听器，像ViewRoot监听，内存监听，等等。重要的还是我选中的这一段，首先创建了一个ApplicationThread，然后把这个ApplicationThread交给了RuntimeInit，很多人开发过程中最头痛的就是RuntimeException，其实这里就是异常监控的初始化过程。然后创建了一个ActivityManagerNative，第一篇文章中就提过，ActivityManagerNative在创建的时候就会和ActivityManagerService绑定。接下来程序就可以通过AMN来访问AMS了。可是大家有想过，Client可以通过AMN来访问AMS，但是Server端怎么访问Client端呢，看这句话attachApplication，其实这里就是程序把自己的一个控制器交给了Server端，然后Server端就可以通过这个控制器来操作Client端了。不信我们来看下ApplicationThread的方法。\n\n![这里写图片描述](http://img.blog.csdn.net/20161026103756562)\n\n是不是看到很多控制生命周期的方法，是的，AMS就是通过这个ApplicationThread来控制Client端的。\n\n那么我们来总结一下这里，程序通过AMN来绑定AMS后，自己创建了一个桥梁applicationThread，然后把这个桥梁交给AMS，意思就是说，这是我小弟，以后联系我可以通过他。另一方面，在这个attach中client的各种初始化已经完成了。接下来的工作就通过attachApplication这个方法移交给AMS端了。\n\n那接下来我们来看AMS端的attachApplication方法\n\n![这里写图片描述](http://img.blog.csdn.net/20161026104634204)\n\nAMS端先通过Binder查询到程序的pid，然后调用attachApplicationLocked，继续往下看，这个方法就是AMS在接到“一个新进程启动了”这件事之后做了一些工作，很复杂，但AMS毕竟是老板，多做一些是正常的。\n\n![这里写图片描述](http://img.blog.csdn.net/20161026110532870)\n\n![这里写图片描述](http://img.blog.csdn.net/20161026110642120)\n\n先是用一个ProcessRecord来记录所有和Process有关的信息。\n\n![这里写图片描述](http://img.blog.csdn.net/20161026110745261)\n\n这里有一个generateProvider的操作，但是我感觉应该不是生成程序的ContentProvider，因为此时Manifest文件还没有被解析，这里应该是为Application生成一些系统必要的ContentProvider。至于对不对，后面再验证吧。\n\n后面做了一些配置工作后，调用了这个方法\n\n![这里写图片描述](http://img.blog.csdn.net/20161026111207622)\n\n是的，这个方法才是主线剧情。通过这个方法，AMS将自己初始化的一些成果，告诉了Client端，并将控制权重新交回给Client端。在看bindApplication之前，我们看下AMS后面的工作。\n\n![这里写图片描述](http://img.blog.csdn.net/20161026111410272)\n\n源码的注释写的比较清楚了，判断有没有其他组件在等这个进程启动，如果有，那么这个进程已经启动了，就该通知他们做事了。这不关我们的事，回到正题吧，看看控制权回到Client那边后，又做了什么。不过这里我们也再一次验证了AMS通过ApplicationThread这个类来和Client端打交道。\n\n好，老板做完事情了，工作又回到小弟手中了。什么？你说老板其实什么都没做，你可以去财务领工资了。\n\n但是ApplicationThread毕竟是个桥梁，实际的工作还是得给app的老大ActivityThread来做，所以这个bindApplication方法也是记录了一些AMS传回来的信息之后，又把工作给了ActivityThread。\n\n我们来看下这个bindApplication做了什么，首先记录了一些配置信息\n\n![这里写图片描述](http://img.blog.csdn.net/20161026112941262)\n\n然后在VM中注册APP的信息\n\n![这里写图片描述](http://img.blog.csdn.net/20161026113020966)\n\n这里注释也说了，有两种情况，两个package是共享runtime的。\n\n- 设置了shareUserId\n- 设置了ProcessName\n\n在share的情况下是不用再VM中注册的，我的理解是，share的组件并不是一个完整的app，而他所属的原来的app其实已经注册过了。\n\n这里有个问题是，工作是怎么给ActivityThread的呢？看bindApplication的第三部分\n\n![这里写图片描述](http://img.blog.csdn.net/20161026113436006)\n\nApplicationThread是ActivityThread的内部类，内部类代表什么呢，它其实是持有一个外部类ActivityThread的对象引用的。可以这么说在ApplicationThread中其实是可以调到ActivityThread的所有方法的。那么它为什么要用这种sendMessage，然后通过Handler处理的这种方式呢。我们来想一下Handler的一个作用是什么。切换线程，在任何情况下，不管bindApplication这个方法运行在哪个线程中，只要通过handler这种方式，都可以回到ActivityThread所在的线程，也就是主线程。这就保证了什么呢，保证了Android的所有生命周期方法都是运行在主线程的，也就是我们常说的UI线程。\n\n简单跟下sendMessage\n\n![这里写图片描述](http://img.blog.csdn.net/20161026125950474)\n\n![这里写图片描述](http://img.blog.csdn.net/20161026130023435)\n\n![这里写图片描述](http://img.blog.csdn.net/20161026130056888)\n\nmH是一个H类型的对象，这个H就是ActivityThread内部的Handler\n\n![这里写图片描述](http://img.blog.csdn.net/20161026130144586)\n\n看下这个Handler的handleMessage方法，跟下对BIND_APPLICATION消息的处理。\n\n![这里写图片描述](http://img.blog.csdn.net/20161026130314369)\n\n进到了handleBIndApplication方法，这里就是Application的启动过程了，让我们来仔细看下这个方法处理的步骤\n\n![这里写图片描述](http://img.blog.csdn.net/20161026133403057)\n\n国际惯例，前面也是各种记录，配置，初始化的工作，我们可以完全忽略。\n\n![这里写图片描述](http://img.blog.csdn.net/20161026133429604)\n\n这个地方是一个小的知识点，在3.1以前的版本上，AsyncTask会改变默认的executor，我们看下改变之后的executor是什么样的。\n\n![这里写图片描述](http://img.blog.csdn.net/20161026133859665)\n\n而默认的executor是这样的\n\n![这里写图片描述](http://img.blog.csdn.net/20161026133929525)\n\n所以3.1以前版本的AsyncTask是并行执行任务的，而3.1以后版本反而是顺序执行任务的，当然，这个配置可以通过AsyncTask的参数而改变。\n\n然后我们回到handleBindApplication，后面会继续设置时区，位置，屏幕参数等。\n\n![这里写图片描述](http://img.blog.csdn.net/20161026134148091)\n\n之后创建了一个Context对象，注意，这是我们到目前位置接触到的第一个Context。我们知道在Android中Application，Activity等等其实都是Context的子类，但是他们又是不同的。这里创建的这个context对应的是我们开发过程中的哪个呢，让我们继续往下看。\n\n![这里写图片描述](http://img.blog.csdn.net/20161026134554910)\n\n然后又是一堆配置，其中包括UI线程不能执行网络操作的配置\n\n![这里写图片描述](http://img.blog.csdn.net/20161026134728344)\n\n然后是关于调试的相关配置，开启一个调试端口，其实关于调试也是需要讲很多的，调试本身也是C/S结构的，客户端开一个端口，等着服务端来连接进行调试，这里就是客户端打开端口的操作。\n\n![这里写图片描述](http://img.blog.csdn.net/20161026134924665)\n\n设置了一个默认的HTTP代理\n\n![这里写图片描述](http://img.blog.csdn.net/20161026135017838)\n\n后面一段是创建了一个Instrumentation对象，这里不截图的。之前第一篇文章我们也提到过，跟ActivityStart有关的操作都是由Instrumentation这个类管理的，被我们亲切的称为大管家，其实是为了监视我们的操作。。。\n\n然后，这个方法讲了这么多，前面大家基本可以忽略，到现在才是重点。\n\n![这里写图片描述](http://img.blog.csdn.net/20161026135315421)\n\n这一段，首先创建了一个Application，恩，我们开发过程中遇见的Application就是这里生成的。后面一段是初始化ContentProvider，这个我们后面讲ContentProvider启动过程的时候会看到，不过这里能知道的一个点就是ContentProvider的启动时间是相当早的，在Application的onCreate之前。然后这里的providers确实是之前我们说到的AMS生成的，然后一路传过来的。恩，先不细看了，因为这篇文章主要想说Activity的启动过程。\n\n后面调用了Instrumentation的onCreate方法，是个空方法，可Override，再后面看到吗，通过Instrumentation大管家呼叫了Application的OnCreate方法\n\n![这里写图片描述](http://img.blog.csdn.net/20161026135758475)\n\n至此，我们开发者接触到的Android生命周期中的第一个方法，Application的onCreate被执行了。至于前面生成的Context，我看了一下，传给了Instrumentation成为了Instrumentation中的appContext，但是我并没有找到跟Application对象结合的方法。这个继续往后看吧。\n\n到此为止，这个handleBindApplication方法就结束了，创建了一个appContext，一个Instrumentation，一个Application，并且调用了Application的onCreate。中间还涉及到ContentProvider的初始化操作，我们先忽略。那么Activity在哪里，为什么感觉自己被带偏了。我又一路往前找。终于在AMS的attachApplicationLocked中，我看到了这一步。\n\n![这里写图片描述](http://img.blog.csdn.net/20161026141040256)\n\nbindApplication在执行完我们上面说的那一堆之后，调用了StackSupervisor的attachApplicationLocked，好，我们来看一下。同时，这里的调用顺序也保证了Application的onCreate方法在Activity之前进行。\n\n![这里写图片描述](http://img.blog.csdn.net/20161026141633514)\n\n方法中有一个realStartActivity的方法，名字很形象，前面我们调用过那么多次的startActivity，但是真正的Activity在这里才生成。\n\n这个realStartActivity嘟噜嘟噜的扯了好多，不知道在干吗，但是终于看到了一个熟悉的影子\n\n![这里写图片描述](http://img.blog.csdn.net/20161026150656396)\n\n就这样控制权又回到了ActivityThread\n\n![这里写图片描述](http://img.blog.csdn.net/20161026151007131)\n\n这里先创建了一个ActivityClientRecord，这个就是Client端管理生成的activity对象的包装类，后面生成的Activity类都会被ActivityClientRecord包装一层，然后保存到ActivityThread的mActivities中。\n\n![这里写图片描述](http://img.blog.csdn.net/20161026151225913)\n\n跟Application那边一样，scheduleLaunchActivity最终会被handleLaunchActivity处理，我们略过中间过程，直接看handleLaunchActivity吧。\n\n![这里写图片描述](http://img.blog.csdn.net/20161026151527821)\n\n这个方法触发了Activity的两个生命周期方法，分别是我标出来的onCreate的onResume，然后后面那一段我的理解是Activity被创建出来，并且调用了onResume之后并没有被显示，那么就立刻调用onPause，但其实不是很懂这个地方。让我想想再回来补充吧。\n\n接下来看performLaunchActivity吧\n\n![这里写图片描述](http://img.blog.csdn.net/20161026152020367)\n\n首先更新了ActivityClientRecord的信息，包括ActivityInfo，ComponentName等，我们开发过程中也是经常用到，这些信息都是存在ActivityClientRecord中的。\n\n![这里写图片描述](http://img.blog.csdn.net/20161026152153386)\n\n接下来创建了一个Activity，天哪，我们分析了这么久，终于看到Activity了。创建过程很简单，通过反射new了一个类出来，这个时候的Activity是还没有生命周期的。需要把Activity托管给AMS，才能有生命周期。\n\n![这里写图片描述](http://img.blog.csdn.net/20161026152429639)\n\n接着，我们获取到之前创建的那个Application，为Activity创建了一个Context，然后通过Activity的attach方法把这些绑定起来。\n\n![这里写图片描述](http://img.blog.csdn.net/20161026152636325)\n\n生成Context的方法和之前为Instrumentation生成Context的方法差不多，返回的是一个ContextImpl类型的对象，保存了Activity的上下文。\n\n![这里写图片描述](http://img.blog.csdn.net/20161026152944396)\n\nattach方法将所有的对象包括Instrumentation，Application, ActivityThread等等全部在Activity中保存了一份。\n\n![这里写图片描述](http://img.blog.csdn.net/20161026153551690)\n\n回到performLaunchActivity，attach之后通过Instrumentation大管家调用了Activity的onCreate方法\n\n![这里写图片描述](http://img.blog.csdn.net/20161026154101442)\n\n然后将生成的activity交给ActivityClientRecord，并保存在mActivities中，这就完成了Activity的生成，并托管给系统，之后系统都可以在适当的时候通过token来获取到相应的Activity，并调用其生命周期。\n\n这样performLaunchActivity就结束了，我们返回上一层handleLaunchActivity继续往下看，Activity在生成之后是会立刻调用onResume的。这两个生命周期有什么区别呢， 其实就在于onCreate跟onResume之间执行的这几句话，说实话，在创建的时候区别不大。不同的是onResume未来还会被调用，但是onCreate只有创建的时候才会被调用。\n\n![这里写图片描述](http://img.blog.csdn.net/20161026154453198)\n\n其实到这来一个Activity的启动流程就已经结束了，但是我们顺便来看下handleResumeActivity的工作吧\n\n![这里写图片描述](http://img.blog.csdn.net/20161026154706405)\n\n看这来，从mActivities中根据token获取了ActivityClientRecord，并进一步获得了里面的activity，然后执行了onResume方法，我刚想说，咦，这次调用没有通过大管家哎，然后看了一下performResume方法里面，其实还是通过Instrumentation调用的。\n\n![这里写图片描述](http://img.blog.csdn.net/20161026154913320)\n\n然后，还更新了ActivityClientRecord的相关信息等。\n\n其实到这里onResume已经调用完成了，那么handleResumeActivity后面的这一堆在干什么呢？\n\n![这里写图片描述](http://img.blog.csdn.net/20161026155148379)\n\n通过方法名我们知道，Activity在onResume之后才开始处理显示的逻辑，这里就是通知AMS，Activity onResume已经调用完了，接下来要显示了，那么AMS就会通知WindowManger来显示Activity，这就是另外一件事了，我们在这里就不细细讨论了。\n\n呼~终于写完了，整个流程主线还是很清楚的，AMS和AMN的分工明确。 \n\n整个流程总结一下，是下面这种关系\n\n![这里写图片描述](http://img.blog.csdn.net/20161026165138600)\n\n最后还是广告时间，如果喜欢这篇文章，可以关注我的博客[http://zwgeek.com](http://zwgeek.com)\n\n\n","slug":"Activity启动流程分析2","published":1,"updated":"2024-06-14T09:25:33.675Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clxjsxtvr0002lq6gsfiyn355","content":"<p>广告时间，大家喜欢我的文章，可以关注我的博客<a href=\"http://zwgeek.com\">http://zwgeek.com</a></p>\n<p>前面说到，希望分析一下Activity的启动流程，整个过程准备分为三篇文章来写</p>\n<ul>\n<li>程序调用startActivity后发生的操作</li>\n<li>如果被startActivity的程序是需要启动的程序，程序在最开始初始化时发生的操作。例如在Launcher中启动一个程序。</li>\n<li>如果被startActivity的程序是已经启动的程序，发生的操作。例如程序自己调用startActivity启动一个自己程序中的Activity</li>\n</ul>\n<p>第一篇文章也已经讲完了程序调用startActivity之后发生的事情。</p>\n<p>还没有读过的同学可以看这里<a href=\"http://zwgeek.com/2016/10/09/Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/\">Activity启动流程分析</a></p>\n<p>这篇文章就来讲第二个部分，一个程序被启动之后发生的事情。第一篇文章中还提到了几个问题，也会在这篇文章中做出解答。</p>\n<ul>\n<li>getApplication() ，getApplicationContext()，getBaseContext()分别有什么区别？</li>\n<li>单个进程中能存在多个application么？</li>\n<li>为什么不能使用service或者application作为创建dialog的context参数？</li>\n</ul>\n<p>第一篇文章最后讲到了Process.start方法，说到了这个方法会启动一个线程，并且运行ActivityThread的main方法来正式开启一个Android程序。所以，很显然，这篇文章就要从ActivityThread的main方法来开始。</p>\n<p>首先，来看一下这个Android程序的起点方法，一睹芳容。</p>\n<p><img src=\"http://img.blog.csdn.net/20161025184513316\" alt=\"这里写图片描述\"></p>\n<p>这个方法重要的是在Looper prepare之后的部分，Handler跟loop的机制比较简单，可以先百度一下，我后面可能也会写篇文章说一下。简单来说loop就是一个无限循环，通过循环去去查询有没有handler发过来命令，如果有就处理，没有就继续循环。</p>\n<p>这样的话，我们就能看出，主进程在做了一个初始化工作之后就把自己放在了一个loop循环中，要跟这个程序打交道，怎么办呢，就是通过获取它的handler，然后发命令，比如现在需要调用onResume方法，通过handler告诉主进程looper要调用onResume，looper就会做相应的处理了。当然这个是关于Android生命周期方法的调用问题，我们也是要单独拉出来讲的，这里就不细说了。</p>\n<p>其实这篇文章的重点是这一句话，thread.attach(false)，ActivityThread的初始化操作。来看下这个方法具体做了什么操作。</p>\n<p><img src=\"http://img.blog.csdn.net/20161025191248464\" alt=\"这里写图片描述\"></p>\n<p>这个方法看下来还好，也都是配置一些监听器，像ViewRoot监听，内存监听，等等。重要的还是我选中的这一段，首先创建了一个ApplicationThread，然后把这个ApplicationThread交给了RuntimeInit，很多人开发过程中最头痛的就是RuntimeException，其实这里就是异常监控的初始化过程。然后创建了一个ActivityManagerNative，第一篇文章中就提过，ActivityManagerNative在创建的时候就会和ActivityManagerService绑定。接下来程序就可以通过AMN来访问AMS了。可是大家有想过，Client可以通过AMN来访问AMS，但是Server端怎么访问Client端呢，看这句话attachApplication，其实这里就是程序把自己的一个控制器交给了Server端，然后Server端就可以通过这个控制器来操作Client端了。不信我们来看下ApplicationThread的方法。</p>\n<p><img src=\"http://img.blog.csdn.net/20161026103756562\" alt=\"这里写图片描述\"></p>\n<p>是不是看到很多控制生命周期的方法，是的，AMS就是通过这个ApplicationThread来控制Client端的。</p>\n<p>那么我们来总结一下这里，程序通过AMN来绑定AMS后，自己创建了一个桥梁applicationThread，然后把这个桥梁交给AMS，意思就是说，这是我小弟，以后联系我可以通过他。另一方面，在这个attach中client的各种初始化已经完成了。接下来的工作就通过attachApplication这个方法移交给AMS端了。</p>\n<p>那接下来我们来看AMS端的attachApplication方法</p>\n<p><img src=\"http://img.blog.csdn.net/20161026104634204\" alt=\"这里写图片描述\"></p>\n<p>AMS端先通过Binder查询到程序的pid，然后调用attachApplicationLocked，继续往下看，这个方法就是AMS在接到“一个新进程启动了”这件事之后做了一些工作，很复杂，但AMS毕竟是老板，多做一些是正常的。</p>\n<p><img src=\"http://img.blog.csdn.net/20161026110532870\" alt=\"这里写图片描述\"></p>\n<p><img src=\"http://img.blog.csdn.net/20161026110642120\" alt=\"这里写图片描述\"></p>\n<p>先是用一个ProcessRecord来记录所有和Process有关的信息。</p>\n<p><img src=\"http://img.blog.csdn.net/20161026110745261\" alt=\"这里写图片描述\"></p>\n<p>这里有一个generateProvider的操作，但是我感觉应该不是生成程序的ContentProvider，因为此时Manifest文件还没有被解析，这里应该是为Application生成一些系统必要的ContentProvider。至于对不对，后面再验证吧。</p>\n<p>后面做了一些配置工作后，调用了这个方法</p>\n<p><img src=\"http://img.blog.csdn.net/20161026111207622\" alt=\"这里写图片描述\"></p>\n<p>是的，这个方法才是主线剧情。通过这个方法，AMS将自己初始化的一些成果，告诉了Client端，并将控制权重新交回给Client端。在看bindApplication之前，我们看下AMS后面的工作。</p>\n<p><img src=\"http://img.blog.csdn.net/20161026111410272\" alt=\"这里写图片描述\"></p>\n<p>源码的注释写的比较清楚了，判断有没有其他组件在等这个进程启动，如果有，那么这个进程已经启动了，就该通知他们做事了。这不关我们的事，回到正题吧，看看控制权回到Client那边后，又做了什么。不过这里我们也再一次验证了AMS通过ApplicationThread这个类来和Client端打交道。</p>\n<p>好，老板做完事情了，工作又回到小弟手中了。什么？你说老板其实什么都没做，你可以去财务领工资了。</p>\n<p>但是ApplicationThread毕竟是个桥梁，实际的工作还是得给app的老大ActivityThread来做，所以这个bindApplication方法也是记录了一些AMS传回来的信息之后，又把工作给了ActivityThread。</p>\n<p>我们来看下这个bindApplication做了什么，首先记录了一些配置信息</p>\n<p><img src=\"http://img.blog.csdn.net/20161026112941262\" alt=\"这里写图片描述\"></p>\n<p>然后在VM中注册APP的信息</p>\n<p><img src=\"http://img.blog.csdn.net/20161026113020966\" alt=\"这里写图片描述\"></p>\n<p>这里注释也说了，有两种情况，两个package是共享runtime的。</p>\n<ul>\n<li>设置了shareUserId</li>\n<li>设置了ProcessName</li>\n</ul>\n<p>在share的情况下是不用再VM中注册的，我的理解是，share的组件并不是一个完整的app，而他所属的原来的app其实已经注册过了。</p>\n<p>这里有个问题是，工作是怎么给ActivityThread的呢？看bindApplication的第三部分</p>\n<p><img src=\"http://img.blog.csdn.net/20161026113436006\" alt=\"这里写图片描述\"></p>\n<p>ApplicationThread是ActivityThread的内部类，内部类代表什么呢，它其实是持有一个外部类ActivityThread的对象引用的。可以这么说在ApplicationThread中其实是可以调到ActivityThread的所有方法的。那么它为什么要用这种sendMessage，然后通过Handler处理的这种方式呢。我们来想一下Handler的一个作用是什么。切换线程，在任何情况下，不管bindApplication这个方法运行在哪个线程中，只要通过handler这种方式，都可以回到ActivityThread所在的线程，也就是主线程。这就保证了什么呢，保证了Android的所有生命周期方法都是运行在主线程的，也就是我们常说的UI线程。</p>\n<p>简单跟下sendMessage</p>\n<p><img src=\"http://img.blog.csdn.net/20161026125950474\" alt=\"这里写图片描述\"></p>\n<p><img src=\"http://img.blog.csdn.net/20161026130023435\" alt=\"这里写图片描述\"></p>\n<p><img src=\"http://img.blog.csdn.net/20161026130056888\" alt=\"这里写图片描述\"></p>\n<p>mH是一个H类型的对象，这个H就是ActivityThread内部的Handler</p>\n<p><img src=\"http://img.blog.csdn.net/20161026130144586\" alt=\"这里写图片描述\"></p>\n<p>看下这个Handler的handleMessage方法，跟下对BIND_APPLICATION消息的处理。</p>\n<p><img src=\"http://img.blog.csdn.net/20161026130314369\" alt=\"这里写图片描述\"></p>\n<p>进到了handleBIndApplication方法，这里就是Application的启动过程了，让我们来仔细看下这个方法处理的步骤</p>\n<p><img src=\"http://img.blog.csdn.net/20161026133403057\" alt=\"这里写图片描述\"></p>\n<p>国际惯例，前面也是各种记录，配置，初始化的工作，我们可以完全忽略。</p>\n<p><img src=\"http://img.blog.csdn.net/20161026133429604\" alt=\"这里写图片描述\"></p>\n<p>这个地方是一个小的知识点，在3.1以前的版本上，AsyncTask会改变默认的executor，我们看下改变之后的executor是什么样的。</p>\n<p><img src=\"http://img.blog.csdn.net/20161026133859665\" alt=\"这里写图片描述\"></p>\n<p>而默认的executor是这样的</p>\n<p><img src=\"http://img.blog.csdn.net/20161026133929525\" alt=\"这里写图片描述\"></p>\n<p>所以3.1以前版本的AsyncTask是并行执行任务的，而3.1以后版本反而是顺序执行任务的，当然，这个配置可以通过AsyncTask的参数而改变。</p>\n<p>然后我们回到handleBindApplication，后面会继续设置时区，位置，屏幕参数等。</p>\n<p><img src=\"http://img.blog.csdn.net/20161026134148091\" alt=\"这里写图片描述\"></p>\n<p>之后创建了一个Context对象，注意，这是我们到目前位置接触到的第一个Context。我们知道在Android中Application，Activity等等其实都是Context的子类，但是他们又是不同的。这里创建的这个context对应的是我们开发过程中的哪个呢，让我们继续往下看。</p>\n<p><img src=\"http://img.blog.csdn.net/20161026134554910\" alt=\"这里写图片描述\"></p>\n<p>然后又是一堆配置，其中包括UI线程不能执行网络操作的配置</p>\n<p><img src=\"http://img.blog.csdn.net/20161026134728344\" alt=\"这里写图片描述\"></p>\n<p>然后是关于调试的相关配置，开启一个调试端口，其实关于调试也是需要讲很多的，调试本身也是C/S结构的，客户端开一个端口，等着服务端来连接进行调试，这里就是客户端打开端口的操作。</p>\n<p><img src=\"http://img.blog.csdn.net/20161026134924665\" alt=\"这里写图片描述\"></p>\n<p>设置了一个默认的HTTP代理</p>\n<p><img src=\"http://img.blog.csdn.net/20161026135017838\" alt=\"这里写图片描述\"></p>\n<p>后面一段是创建了一个Instrumentation对象，这里不截图的。之前第一篇文章我们也提到过，跟ActivityStart有关的操作都是由Instrumentation这个类管理的，被我们亲切的称为大管家，其实是为了监视我们的操作。。。</p>\n<p>然后，这个方法讲了这么多，前面大家基本可以忽略，到现在才是重点。</p>\n<p><img src=\"http://img.blog.csdn.net/20161026135315421\" alt=\"这里写图片描述\"></p>\n<p>这一段，首先创建了一个Application，恩，我们开发过程中遇见的Application就是这里生成的。后面一段是初始化ContentProvider，这个我们后面讲ContentProvider启动过程的时候会看到，不过这里能知道的一个点就是ContentProvider的启动时间是相当早的，在Application的onCreate之前。然后这里的providers确实是之前我们说到的AMS生成的，然后一路传过来的。恩，先不细看了，因为这篇文章主要想说Activity的启动过程。</p>\n<p>后面调用了Instrumentation的onCreate方法，是个空方法，可Override，再后面看到吗，通过Instrumentation大管家呼叫了Application的OnCreate方法</p>\n<p><img src=\"http://img.blog.csdn.net/20161026135758475\" alt=\"这里写图片描述\"></p>\n<p>至此，我们开发者接触到的Android生命周期中的第一个方法，Application的onCreate被执行了。至于前面生成的Context，我看了一下，传给了Instrumentation成为了Instrumentation中的appContext，但是我并没有找到跟Application对象结合的方法。这个继续往后看吧。</p>\n<p>到此为止，这个handleBindApplication方法就结束了，创建了一个appContext，一个Instrumentation，一个Application，并且调用了Application的onCreate。中间还涉及到ContentProvider的初始化操作，我们先忽略。那么Activity在哪里，为什么感觉自己被带偏了。我又一路往前找。终于在AMS的attachApplicationLocked中，我看到了这一步。</p>\n<p><img src=\"http://img.blog.csdn.net/20161026141040256\" alt=\"这里写图片描述\"></p>\n<p>bindApplication在执行完我们上面说的那一堆之后，调用了StackSupervisor的attachApplicationLocked，好，我们来看一下。同时，这里的调用顺序也保证了Application的onCreate方法在Activity之前进行。</p>\n<p><img src=\"http://img.blog.csdn.net/20161026141633514\" alt=\"这里写图片描述\"></p>\n<p>方法中有一个realStartActivity的方法，名字很形象，前面我们调用过那么多次的startActivity，但是真正的Activity在这里才生成。</p>\n<p>这个realStartActivity嘟噜嘟噜的扯了好多，不知道在干吗，但是终于看到了一个熟悉的影子</p>\n<p><img src=\"http://img.blog.csdn.net/20161026150656396\" alt=\"这里写图片描述\"></p>\n<p>就这样控制权又回到了ActivityThread</p>\n<p><img src=\"http://img.blog.csdn.net/20161026151007131\" alt=\"这里写图片描述\"></p>\n<p>这里先创建了一个ActivityClientRecord，这个就是Client端管理生成的activity对象的包装类，后面生成的Activity类都会被ActivityClientRecord包装一层，然后保存到ActivityThread的mActivities中。</p>\n<p><img src=\"http://img.blog.csdn.net/20161026151225913\" alt=\"这里写图片描述\"></p>\n<p>跟Application那边一样，scheduleLaunchActivity最终会被handleLaunchActivity处理，我们略过中间过程，直接看handleLaunchActivity吧。</p>\n<p><img src=\"http://img.blog.csdn.net/20161026151527821\" alt=\"这里写图片描述\"></p>\n<p>这个方法触发了Activity的两个生命周期方法，分别是我标出来的onCreate的onResume，然后后面那一段我的理解是Activity被创建出来，并且调用了onResume之后并没有被显示，那么就立刻调用onPause，但其实不是很懂这个地方。让我想想再回来补充吧。</p>\n<p>接下来看performLaunchActivity吧</p>\n<p><img src=\"http://img.blog.csdn.net/20161026152020367\" alt=\"这里写图片描述\"></p>\n<p>首先更新了ActivityClientRecord的信息，包括ActivityInfo，ComponentName等，我们开发过程中也是经常用到，这些信息都是存在ActivityClientRecord中的。</p>\n<p><img src=\"http://img.blog.csdn.net/20161026152153386\" alt=\"这里写图片描述\"></p>\n<p>接下来创建了一个Activity，天哪，我们分析了这么久，终于看到Activity了。创建过程很简单，通过反射new了一个类出来，这个时候的Activity是还没有生命周期的。需要把Activity托管给AMS，才能有生命周期。</p>\n<p><img src=\"http://img.blog.csdn.net/20161026152429639\" alt=\"这里写图片描述\"></p>\n<p>接着，我们获取到之前创建的那个Application，为Activity创建了一个Context，然后通过Activity的attach方法把这些绑定起来。</p>\n<p><img src=\"http://img.blog.csdn.net/20161026152636325\" alt=\"这里写图片描述\"></p>\n<p>生成Context的方法和之前为Instrumentation生成Context的方法差不多，返回的是一个ContextImpl类型的对象，保存了Activity的上下文。</p>\n<p><img src=\"http://img.blog.csdn.net/20161026152944396\" alt=\"这里写图片描述\"></p>\n<p>attach方法将所有的对象包括Instrumentation，Application, ActivityThread等等全部在Activity中保存了一份。</p>\n<p><img src=\"http://img.blog.csdn.net/20161026153551690\" alt=\"这里写图片描述\"></p>\n<p>回到performLaunchActivity，attach之后通过Instrumentation大管家调用了Activity的onCreate方法</p>\n<p><img src=\"http://img.blog.csdn.net/20161026154101442\" alt=\"这里写图片描述\"></p>\n<p>然后将生成的activity交给ActivityClientRecord，并保存在mActivities中，这就完成了Activity的生成，并托管给系统，之后系统都可以在适当的时候通过token来获取到相应的Activity，并调用其生命周期。</p>\n<p>这样performLaunchActivity就结束了，我们返回上一层handleLaunchActivity继续往下看，Activity在生成之后是会立刻调用onResume的。这两个生命周期有什么区别呢， 其实就在于onCreate跟onResume之间执行的这几句话，说实话，在创建的时候区别不大。不同的是onResume未来还会被调用，但是onCreate只有创建的时候才会被调用。</p>\n<p><img src=\"http://img.blog.csdn.net/20161026154453198\" alt=\"这里写图片描述\"></p>\n<p>其实到这来一个Activity的启动流程就已经结束了，但是我们顺便来看下handleResumeActivity的工作吧</p>\n<p><img src=\"http://img.blog.csdn.net/20161026154706405\" alt=\"这里写图片描述\"></p>\n<p>看这来，从mActivities中根据token获取了ActivityClientRecord，并进一步获得了里面的activity，然后执行了onResume方法，我刚想说，咦，这次调用没有通过大管家哎，然后看了一下performResume方法里面，其实还是通过Instrumentation调用的。</p>\n<p><img src=\"http://img.blog.csdn.net/20161026154913320\" alt=\"这里写图片描述\"></p>\n<p>然后，还更新了ActivityClientRecord的相关信息等。</p>\n<p>其实到这里onResume已经调用完成了，那么handleResumeActivity后面的这一堆在干什么呢？</p>\n<p><img src=\"http://img.blog.csdn.net/20161026155148379\" alt=\"这里写图片描述\"></p>\n<p>通过方法名我们知道，Activity在onResume之后才开始处理显示的逻辑，这里就是通知AMS，Activity onResume已经调用完了，接下来要显示了，那么AMS就会通知WindowManger来显示Activity，这就是另外一件事了，我们在这里就不细细讨论了。</p>\n<p>呼~终于写完了，整个流程主线还是很清楚的，AMS和AMN的分工明确。 </p>\n<p>整个流程总结一下，是下面这种关系</p>\n<p><img src=\"http://img.blog.csdn.net/20161026165138600\" alt=\"这里写图片描述\"></p>\n<p>最后还是广告时间，如果喜欢这篇文章，可以关注我的博客<a href=\"http://zwgeek.com\">http://zwgeek.com</a></p>\n","excerpt":"","more":"<p>广告时间，大家喜欢我的文章，可以关注我的博客<a href=\"http://zwgeek.com\">http://zwgeek.com</a></p>\n<p>前面说到，希望分析一下Activity的启动流程，整个过程准备分为三篇文章来写</p>\n<ul>\n<li>程序调用startActivity后发生的操作</li>\n<li>如果被startActivity的程序是需要启动的程序，程序在最开始初始化时发生的操作。例如在Launcher中启动一个程序。</li>\n<li>如果被startActivity的程序是已经启动的程序，发生的操作。例如程序自己调用startActivity启动一个自己程序中的Activity</li>\n</ul>\n<p>第一篇文章也已经讲完了程序调用startActivity之后发生的事情。</p>\n<p>还没有读过的同学可以看这里<a href=\"http://zwgeek.com/2016/10/09/Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/\">Activity启动流程分析</a></p>\n<p>这篇文章就来讲第二个部分，一个程序被启动之后发生的事情。第一篇文章中还提到了几个问题，也会在这篇文章中做出解答。</p>\n<ul>\n<li>getApplication() ，getApplicationContext()，getBaseContext()分别有什么区别？</li>\n<li>单个进程中能存在多个application么？</li>\n<li>为什么不能使用service或者application作为创建dialog的context参数？</li>\n</ul>\n<p>第一篇文章最后讲到了Process.start方法，说到了这个方法会启动一个线程，并且运行ActivityThread的main方法来正式开启一个Android程序。所以，很显然，这篇文章就要从ActivityThread的main方法来开始。</p>\n<p>首先，来看一下这个Android程序的起点方法，一睹芳容。</p>\n<p><img src=\"http://img.blog.csdn.net/20161025184513316\" alt=\"这里写图片描述\"></p>\n<p>这个方法重要的是在Looper prepare之后的部分，Handler跟loop的机制比较简单，可以先百度一下，我后面可能也会写篇文章说一下。简单来说loop就是一个无限循环，通过循环去去查询有没有handler发过来命令，如果有就处理，没有就继续循环。</p>\n<p>这样的话，我们就能看出，主进程在做了一个初始化工作之后就把自己放在了一个loop循环中，要跟这个程序打交道，怎么办呢，就是通过获取它的handler，然后发命令，比如现在需要调用onResume方法，通过handler告诉主进程looper要调用onResume，looper就会做相应的处理了。当然这个是关于Android生命周期方法的调用问题，我们也是要单独拉出来讲的，这里就不细说了。</p>\n<p>其实这篇文章的重点是这一句话，thread.attach(false)，ActivityThread的初始化操作。来看下这个方法具体做了什么操作。</p>\n<p><img src=\"http://img.blog.csdn.net/20161025191248464\" alt=\"这里写图片描述\"></p>\n<p>这个方法看下来还好，也都是配置一些监听器，像ViewRoot监听，内存监听，等等。重要的还是我选中的这一段，首先创建了一个ApplicationThread，然后把这个ApplicationThread交给了RuntimeInit，很多人开发过程中最头痛的就是RuntimeException，其实这里就是异常监控的初始化过程。然后创建了一个ActivityManagerNative，第一篇文章中就提过，ActivityManagerNative在创建的时候就会和ActivityManagerService绑定。接下来程序就可以通过AMN来访问AMS了。可是大家有想过，Client可以通过AMN来访问AMS，但是Server端怎么访问Client端呢，看这句话attachApplication，其实这里就是程序把自己的一个控制器交给了Server端，然后Server端就可以通过这个控制器来操作Client端了。不信我们来看下ApplicationThread的方法。</p>\n<p><img src=\"http://img.blog.csdn.net/20161026103756562\" alt=\"这里写图片描述\"></p>\n<p>是不是看到很多控制生命周期的方法，是的，AMS就是通过这个ApplicationThread来控制Client端的。</p>\n<p>那么我们来总结一下这里，程序通过AMN来绑定AMS后，自己创建了一个桥梁applicationThread，然后把这个桥梁交给AMS，意思就是说，这是我小弟，以后联系我可以通过他。另一方面，在这个attach中client的各种初始化已经完成了。接下来的工作就通过attachApplication这个方法移交给AMS端了。</p>\n<p>那接下来我们来看AMS端的attachApplication方法</p>\n<p><img src=\"http://img.blog.csdn.net/20161026104634204\" alt=\"这里写图片描述\"></p>\n<p>AMS端先通过Binder查询到程序的pid，然后调用attachApplicationLocked，继续往下看，这个方法就是AMS在接到“一个新进程启动了”这件事之后做了一些工作，很复杂，但AMS毕竟是老板，多做一些是正常的。</p>\n<p><img src=\"http://img.blog.csdn.net/20161026110532870\" alt=\"这里写图片描述\"></p>\n<p><img src=\"http://img.blog.csdn.net/20161026110642120\" alt=\"这里写图片描述\"></p>\n<p>先是用一个ProcessRecord来记录所有和Process有关的信息。</p>\n<p><img src=\"http://img.blog.csdn.net/20161026110745261\" alt=\"这里写图片描述\"></p>\n<p>这里有一个generateProvider的操作，但是我感觉应该不是生成程序的ContentProvider，因为此时Manifest文件还没有被解析，这里应该是为Application生成一些系统必要的ContentProvider。至于对不对，后面再验证吧。</p>\n<p>后面做了一些配置工作后，调用了这个方法</p>\n<p><img src=\"http://img.blog.csdn.net/20161026111207622\" alt=\"这里写图片描述\"></p>\n<p>是的，这个方法才是主线剧情。通过这个方法，AMS将自己初始化的一些成果，告诉了Client端，并将控制权重新交回给Client端。在看bindApplication之前，我们看下AMS后面的工作。</p>\n<p><img src=\"http://img.blog.csdn.net/20161026111410272\" alt=\"这里写图片描述\"></p>\n<p>源码的注释写的比较清楚了，判断有没有其他组件在等这个进程启动，如果有，那么这个进程已经启动了，就该通知他们做事了。这不关我们的事，回到正题吧，看看控制权回到Client那边后，又做了什么。不过这里我们也再一次验证了AMS通过ApplicationThread这个类来和Client端打交道。</p>\n<p>好，老板做完事情了，工作又回到小弟手中了。什么？你说老板其实什么都没做，你可以去财务领工资了。</p>\n<p>但是ApplicationThread毕竟是个桥梁，实际的工作还是得给app的老大ActivityThread来做，所以这个bindApplication方法也是记录了一些AMS传回来的信息之后，又把工作给了ActivityThread。</p>\n<p>我们来看下这个bindApplication做了什么，首先记录了一些配置信息</p>\n<p><img src=\"http://img.blog.csdn.net/20161026112941262\" alt=\"这里写图片描述\"></p>\n<p>然后在VM中注册APP的信息</p>\n<p><img src=\"http://img.blog.csdn.net/20161026113020966\" alt=\"这里写图片描述\"></p>\n<p>这里注释也说了，有两种情况，两个package是共享runtime的。</p>\n<ul>\n<li>设置了shareUserId</li>\n<li>设置了ProcessName</li>\n</ul>\n<p>在share的情况下是不用再VM中注册的，我的理解是，share的组件并不是一个完整的app，而他所属的原来的app其实已经注册过了。</p>\n<p>这里有个问题是，工作是怎么给ActivityThread的呢？看bindApplication的第三部分</p>\n<p><img src=\"http://img.blog.csdn.net/20161026113436006\" alt=\"这里写图片描述\"></p>\n<p>ApplicationThread是ActivityThread的内部类，内部类代表什么呢，它其实是持有一个外部类ActivityThread的对象引用的。可以这么说在ApplicationThread中其实是可以调到ActivityThread的所有方法的。那么它为什么要用这种sendMessage，然后通过Handler处理的这种方式呢。我们来想一下Handler的一个作用是什么。切换线程，在任何情况下，不管bindApplication这个方法运行在哪个线程中，只要通过handler这种方式，都可以回到ActivityThread所在的线程，也就是主线程。这就保证了什么呢，保证了Android的所有生命周期方法都是运行在主线程的，也就是我们常说的UI线程。</p>\n<p>简单跟下sendMessage</p>\n<p><img src=\"http://img.blog.csdn.net/20161026125950474\" alt=\"这里写图片描述\"></p>\n<p><img src=\"http://img.blog.csdn.net/20161026130023435\" alt=\"这里写图片描述\"></p>\n<p><img src=\"http://img.blog.csdn.net/20161026130056888\" alt=\"这里写图片描述\"></p>\n<p>mH是一个H类型的对象，这个H就是ActivityThread内部的Handler</p>\n<p><img src=\"http://img.blog.csdn.net/20161026130144586\" alt=\"这里写图片描述\"></p>\n<p>看下这个Handler的handleMessage方法，跟下对BIND_APPLICATION消息的处理。</p>\n<p><img src=\"http://img.blog.csdn.net/20161026130314369\" alt=\"这里写图片描述\"></p>\n<p>进到了handleBIndApplication方法，这里就是Application的启动过程了，让我们来仔细看下这个方法处理的步骤</p>\n<p><img src=\"http://img.blog.csdn.net/20161026133403057\" alt=\"这里写图片描述\"></p>\n<p>国际惯例，前面也是各种记录，配置，初始化的工作，我们可以完全忽略。</p>\n<p><img src=\"http://img.blog.csdn.net/20161026133429604\" alt=\"这里写图片描述\"></p>\n<p>这个地方是一个小的知识点，在3.1以前的版本上，AsyncTask会改变默认的executor，我们看下改变之后的executor是什么样的。</p>\n<p><img src=\"http://img.blog.csdn.net/20161026133859665\" alt=\"这里写图片描述\"></p>\n<p>而默认的executor是这样的</p>\n<p><img src=\"http://img.blog.csdn.net/20161026133929525\" alt=\"这里写图片描述\"></p>\n<p>所以3.1以前版本的AsyncTask是并行执行任务的，而3.1以后版本反而是顺序执行任务的，当然，这个配置可以通过AsyncTask的参数而改变。</p>\n<p>然后我们回到handleBindApplication，后面会继续设置时区，位置，屏幕参数等。</p>\n<p><img src=\"http://img.blog.csdn.net/20161026134148091\" alt=\"这里写图片描述\"></p>\n<p>之后创建了一个Context对象，注意，这是我们到目前位置接触到的第一个Context。我们知道在Android中Application，Activity等等其实都是Context的子类，但是他们又是不同的。这里创建的这个context对应的是我们开发过程中的哪个呢，让我们继续往下看。</p>\n<p><img src=\"http://img.blog.csdn.net/20161026134554910\" alt=\"这里写图片描述\"></p>\n<p>然后又是一堆配置，其中包括UI线程不能执行网络操作的配置</p>\n<p><img src=\"http://img.blog.csdn.net/20161026134728344\" alt=\"这里写图片描述\"></p>\n<p>然后是关于调试的相关配置，开启一个调试端口，其实关于调试也是需要讲很多的，调试本身也是C/S结构的，客户端开一个端口，等着服务端来连接进行调试，这里就是客户端打开端口的操作。</p>\n<p><img src=\"http://img.blog.csdn.net/20161026134924665\" alt=\"这里写图片描述\"></p>\n<p>设置了一个默认的HTTP代理</p>\n<p><img src=\"http://img.blog.csdn.net/20161026135017838\" alt=\"这里写图片描述\"></p>\n<p>后面一段是创建了一个Instrumentation对象，这里不截图的。之前第一篇文章我们也提到过，跟ActivityStart有关的操作都是由Instrumentation这个类管理的，被我们亲切的称为大管家，其实是为了监视我们的操作。。。</p>\n<p>然后，这个方法讲了这么多，前面大家基本可以忽略，到现在才是重点。</p>\n<p><img src=\"http://img.blog.csdn.net/20161026135315421\" alt=\"这里写图片描述\"></p>\n<p>这一段，首先创建了一个Application，恩，我们开发过程中遇见的Application就是这里生成的。后面一段是初始化ContentProvider，这个我们后面讲ContentProvider启动过程的时候会看到，不过这里能知道的一个点就是ContentProvider的启动时间是相当早的，在Application的onCreate之前。然后这里的providers确实是之前我们说到的AMS生成的，然后一路传过来的。恩，先不细看了，因为这篇文章主要想说Activity的启动过程。</p>\n<p>后面调用了Instrumentation的onCreate方法，是个空方法，可Override，再后面看到吗，通过Instrumentation大管家呼叫了Application的OnCreate方法</p>\n<p><img src=\"http://img.blog.csdn.net/20161026135758475\" alt=\"这里写图片描述\"></p>\n<p>至此，我们开发者接触到的Android生命周期中的第一个方法，Application的onCreate被执行了。至于前面生成的Context，我看了一下，传给了Instrumentation成为了Instrumentation中的appContext，但是我并没有找到跟Application对象结合的方法。这个继续往后看吧。</p>\n<p>到此为止，这个handleBindApplication方法就结束了，创建了一个appContext，一个Instrumentation，一个Application，并且调用了Application的onCreate。中间还涉及到ContentProvider的初始化操作，我们先忽略。那么Activity在哪里，为什么感觉自己被带偏了。我又一路往前找。终于在AMS的attachApplicationLocked中，我看到了这一步。</p>\n<p><img src=\"http://img.blog.csdn.net/20161026141040256\" alt=\"这里写图片描述\"></p>\n<p>bindApplication在执行完我们上面说的那一堆之后，调用了StackSupervisor的attachApplicationLocked，好，我们来看一下。同时，这里的调用顺序也保证了Application的onCreate方法在Activity之前进行。</p>\n<p><img src=\"http://img.blog.csdn.net/20161026141633514\" alt=\"这里写图片描述\"></p>\n<p>方法中有一个realStartActivity的方法，名字很形象，前面我们调用过那么多次的startActivity，但是真正的Activity在这里才生成。</p>\n<p>这个realStartActivity嘟噜嘟噜的扯了好多，不知道在干吗，但是终于看到了一个熟悉的影子</p>\n<p><img src=\"http://img.blog.csdn.net/20161026150656396\" alt=\"这里写图片描述\"></p>\n<p>就这样控制权又回到了ActivityThread</p>\n<p><img src=\"http://img.blog.csdn.net/20161026151007131\" alt=\"这里写图片描述\"></p>\n<p>这里先创建了一个ActivityClientRecord，这个就是Client端管理生成的activity对象的包装类，后面生成的Activity类都会被ActivityClientRecord包装一层，然后保存到ActivityThread的mActivities中。</p>\n<p><img src=\"http://img.blog.csdn.net/20161026151225913\" alt=\"这里写图片描述\"></p>\n<p>跟Application那边一样，scheduleLaunchActivity最终会被handleLaunchActivity处理，我们略过中间过程，直接看handleLaunchActivity吧。</p>\n<p><img src=\"http://img.blog.csdn.net/20161026151527821\" alt=\"这里写图片描述\"></p>\n<p>这个方法触发了Activity的两个生命周期方法，分别是我标出来的onCreate的onResume，然后后面那一段我的理解是Activity被创建出来，并且调用了onResume之后并没有被显示，那么就立刻调用onPause，但其实不是很懂这个地方。让我想想再回来补充吧。</p>\n<p>接下来看performLaunchActivity吧</p>\n<p><img src=\"http://img.blog.csdn.net/20161026152020367\" alt=\"这里写图片描述\"></p>\n<p>首先更新了ActivityClientRecord的信息，包括ActivityInfo，ComponentName等，我们开发过程中也是经常用到，这些信息都是存在ActivityClientRecord中的。</p>\n<p><img src=\"http://img.blog.csdn.net/20161026152153386\" alt=\"这里写图片描述\"></p>\n<p>接下来创建了一个Activity，天哪，我们分析了这么久，终于看到Activity了。创建过程很简单，通过反射new了一个类出来，这个时候的Activity是还没有生命周期的。需要把Activity托管给AMS，才能有生命周期。</p>\n<p><img src=\"http://img.blog.csdn.net/20161026152429639\" alt=\"这里写图片描述\"></p>\n<p>接着，我们获取到之前创建的那个Application，为Activity创建了一个Context，然后通过Activity的attach方法把这些绑定起来。</p>\n<p><img src=\"http://img.blog.csdn.net/20161026152636325\" alt=\"这里写图片描述\"></p>\n<p>生成Context的方法和之前为Instrumentation生成Context的方法差不多，返回的是一个ContextImpl类型的对象，保存了Activity的上下文。</p>\n<p><img src=\"http://img.blog.csdn.net/20161026152944396\" alt=\"这里写图片描述\"></p>\n<p>attach方法将所有的对象包括Instrumentation，Application, ActivityThread等等全部在Activity中保存了一份。</p>\n<p><img src=\"http://img.blog.csdn.net/20161026153551690\" alt=\"这里写图片描述\"></p>\n<p>回到performLaunchActivity，attach之后通过Instrumentation大管家调用了Activity的onCreate方法</p>\n<p><img src=\"http://img.blog.csdn.net/20161026154101442\" alt=\"这里写图片描述\"></p>\n<p>然后将生成的activity交给ActivityClientRecord，并保存在mActivities中，这就完成了Activity的生成，并托管给系统，之后系统都可以在适当的时候通过token来获取到相应的Activity，并调用其生命周期。</p>\n<p>这样performLaunchActivity就结束了，我们返回上一层handleLaunchActivity继续往下看，Activity在生成之后是会立刻调用onResume的。这两个生命周期有什么区别呢， 其实就在于onCreate跟onResume之间执行的这几句话，说实话，在创建的时候区别不大。不同的是onResume未来还会被调用，但是onCreate只有创建的时候才会被调用。</p>\n<p><img src=\"http://img.blog.csdn.net/20161026154453198\" alt=\"这里写图片描述\"></p>\n<p>其实到这来一个Activity的启动流程就已经结束了，但是我们顺便来看下handleResumeActivity的工作吧</p>\n<p><img src=\"http://img.blog.csdn.net/20161026154706405\" alt=\"这里写图片描述\"></p>\n<p>看这来，从mActivities中根据token获取了ActivityClientRecord，并进一步获得了里面的activity，然后执行了onResume方法，我刚想说，咦，这次调用没有通过大管家哎，然后看了一下performResume方法里面，其实还是通过Instrumentation调用的。</p>\n<p><img src=\"http://img.blog.csdn.net/20161026154913320\" alt=\"这里写图片描述\"></p>\n<p>然后，还更新了ActivityClientRecord的相关信息等。</p>\n<p>其实到这里onResume已经调用完成了，那么handleResumeActivity后面的这一堆在干什么呢？</p>\n<p><img src=\"http://img.blog.csdn.net/20161026155148379\" alt=\"这里写图片描述\"></p>\n<p>通过方法名我们知道，Activity在onResume之后才开始处理显示的逻辑，这里就是通知AMS，Activity onResume已经调用完了，接下来要显示了，那么AMS就会通知WindowManger来显示Activity，这就是另外一件事了，我们在这里就不细细讨论了。</p>\n<p>呼~终于写完了，整个流程主线还是很清楚的，AMS和AMN的分工明确。 </p>\n<p>整个流程总结一下，是下面这种关系</p>\n<p><img src=\"http://img.blog.csdn.net/20161026165138600\" alt=\"这里写图片描述\"></p>\n<p>最后还是广告时间，如果喜欢这篇文章，可以关注我的博客<a href=\"http://zwgeek.com\">http://zwgeek.com</a></p>\n"},{"title":"Activity启动流程番外篇","date":"2016-10-26T09:29:01.000Z","_content":"\n前两篇文章分析了Activity的启动流程的大部分。\n\n第一篇文章讲了程序在调用startActivity之后发生的一些操作[Activity启动流程分析](http://zwgeek.com/2016/10/09/Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/)\n\n第二篇文章讲了一个Android程序从最开始启动到一个Activity呈现到用户之间发生的一些操作[Activity启动流程分析（二）](http://zwgeek.com/2016/10/25/Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%902/)\n\n在这两篇文章之前，我就提出了三个问题，前面也分析的差不多了，准备在这篇文章中来回答这三个问题，所以如果你还没有看前两篇文章，还是希望你能大概读一下之前两篇文章再来看这篇番外篇。\n\n好，回归正题，提了三个问题，分别是哪三个问题呢。\n\n- getApplication() ，getApplicationContext()，getBaseContext()分别有什么区别？\n- 单个进程中能存在多个application么？\n- 为什么不能使用service或者application作为创建dialog的context参数？\n\n\n\n\n#### 第一个问题\ngetApplication() ，getApplicationContext()，getBaseContext()分别有什么区别？\n\n对于这个问题，我们首先看一下这三个方法返回的对象分别是什么。\n\ngetApplication()\n![这里写图片描述](http://img.blog.csdn.net/20161026174737355)\n\ngetApplication返回的是Activity中的mApplication对象，这个对象是在attach的时候赋给Activity的\n\n![这里写图片描述](http://img.blog.csdn.net/20161026174850543)\n\n第二篇文章中也讲到了attach的调用是在ActivityThread的performLaunchActivity中，传递的Application是通过makeApplication生成的。\n\n![这里写图片描述](http://img.blog.csdn.net/20161026175138524)\n\n我们来看下makeApplication\n\n![这里写图片描述](http://img.blog.csdn.net/20161026175239338)\n\n方法中我们可以发现makeApplication是会返回当前的mApplication的，那当前的这个mApplication到底是不是程序最开始创建的那个Application呢，也就是在bindApplicaiton中生成的Application。\n\n![这里写图片描述](http://img.blog.csdn.net/20161026175707140)\n\n要看这两个Application是否相同，我们可以跟踪创建它的LoadApk类，也就是这里的data.info和前面的r.packageInfo\n\n好吧，继续追吧，看看能不能看到这两个对象的源头data.info是在handleBindApplication方法中通过getPackageInfoNoCheck获取到的。\n\n![这里写图片描述](http://img.blog.csdn.net/20161026180630012)\n\ngetPackageInfoNoCheck调用了getPackageInfo方法。看下这个方法\n\n![这里写图片描述](http://img.blog.csdn.net/20161026180758006)\n\n这里可以很明显的看出，PackageInfo在ActivityThread中是单例的，这个对象跟packageName挂钩，那么我们也知道，一个Android程序的packageName是唯一的。所以基本可以确定前面两个创建Application的packageInfo是一样的，为了保险起见，我们再追一下另外一个packageInfo吧，也就是r.packageInfo。\n\n![这里写图片描述](http://img.blog.csdn.net/20161026181449946)\n\n看到了吧，也是调用前面的getPackageInfoNoCheck方法获取到的。所以正确流程下，一个Android程序中Application是唯一的，getApplication返回的就是这个对象。为什么说是正常流程下呢，这对应的是我们的第二个问题，后面会做出解答。\n\n第二个方法getApplicationContext()\n这个方法是在ContextWrapper中的，Activity是继承在这个类的。\n\n![这里写图片描述](http://img.blog.csdn.net/20161026181724666)\n\n这里又关系到mBase这个对象，这个对象其实也是在Activity attch的时候绑定进来的，就是图中这个地方创建的appContext，这个对象是ContextImpl类型的。\n\n![这里写图片描述](http://img.blog.csdn.net/20161026181855572)\n\n我们进去看下它的getApplicationContext方法\n\n![这里写图片描述](http://img.blog.csdn.net/20161026182021733)\n\n如果packageInfo不为null，那么返回packageInfo的Application，否则返回mainThread的Application\n\n![这里写图片描述](http://img.blog.csdn.net/20161026182206188)\n\n创建这个ContextImpl的packageInfo其实就是前面分析的r.packageInfo，所以这个ApplicationContext跟前面的Application是完全一样的。如果packageInfo是空，返回的是ActivityThread中的Application，而ActivityThread中的Application是handleBindApplication中生成的那个，跟前面也是一样的。\n\n综上所述，getApplicationContext跟getApplication是相同的，接下来我们再看下getBaseContext()\n\n![这里写图片描述](http://img.blog.csdn.net/20161026182544622)\n\n这里返回的就是前面说的mBase，这个mBase是一个ContextImpl类型的对象，是为Activity专门创建的，与Application就不一样了。\n\n好，这就是第一个问题的答案。\n\n#### 第二个问题\n单个进程中能存在多个application么？\n\n忽然意识到第二个问题其实在第一个问题中已经做了部分回答，一个LoadedApk中只能存在一个application。\n\n但是事实是这样吗，我们来看下ActivityThread中创建Application的地方。正如第一个问题分析的，虽然在第一句话的时候，限制了mApplication的单例性，但是请注意后面对Application的管理。\n\n![这里写图片描述](http://img.blog.csdn.net/20161031110946531)\n\n![这里写图片描述](http://img.blog.csdn.net/20161031110409263)\n\nActivityThread是一个进程，这里很明显我们已经能看出，Android中一个进程是允许存在多个Application的，但是正常情况下，是不会出现多个Application的，那么不正常的情况是什么呢，你可以通过反射得到这个mAllApplications，然后手动把自己的Application放进去。为了什么？当然是一些奇技淫巧了，后面有机会讲到插件化实现的时候会说到。\n\n反正这里你知道一个结论就行了，一个进程是允许多个Application的，但是Android的正常流程下，一个进程只有一个Application。\n\n#### 第三个问题\n为什么不能使用service或者application作为创建dialog的context参数？\n\n用service或者Application启动dialog的时候会报错\n\n```java\nCaused by: android.view.WindowManager$BadTokenException: Unable to add window -- token null is not for an application\n                           at android.view.ViewRootImpl.setView(ViewRootImpl.java:685)\n                           at android.view.WindowManagerGlobal.addView(WindowManagerGlobal.java:342)\n                           at android.view.WindowManagerImpl.addView(WindowManagerImpl.java:93)\n                           at android.app.Dialog.show(Dialog.java:316)\n\n```\n我们来看一下这个错误是哪里报出的，是在ViewRootImpl的setView中\n\n![这里写图片描述](http://img.blog.csdn.net/20161026184204831)\n\n对res进行判断，而这个res是这句话返回的，既然异常是关于token的，也就是说在addToDisplay的时候对当前view的token进行了检查。\n\n![这里写图片描述](http://img.blog.csdn.net/20161027112934008)\n\nmWindowSession是一个Session类型的，addToDidplay代码如下\n\n![这里写图片描述](http://img.blog.csdn.net/20161028150931848)\n\n其实如果你分析的多了，不用看也知道mService肯定是WindowManagerService，这个Service和ActivityManagerService一样，在Framework层是很重要的一个类，负责窗口绘制等。\n\n异常报出的case是ADD_NOT_APP_TOKEN，找一下\n\n![这里写图片描述](http://img.blog.csdn.net/20161028151340745)\n\n所以看得出来，报出这个异常有两个条件，一是type是APPLICATION_WINDOW，二是要有APPWindowToken。\n\n先看看这个TYPE吧\n\n![这里写图片描述](http://img.blog.csdn.net/20161028151709929)\n\n通过看这个类的注释，大概知道什么意思，WINDOW分为几大类\n1-99是Application window\n1000-1999是sub window\n2000-2999是system window\n\n挨个来看注释\n\n##### Application Window\n![这里写图片描述](http://img.blog.csdn.net/20161028152220400)\n\nApplication Window就是普通的应用程序window，像Activity，Dialog都属于这一类\n\n##### Sub Window\n\n![这里写图片描述](http://img.blog.csdn.net/20161028152438321)\n\nSubWIndow，从注释可以看出，这类window必须有一个可依附的其他Window，然后在坐标轴Z上它是它所依附的Window的下一个，然后它的坐标体系也依附于它所依附的Window的坐标。\n\n下面指出了一些Sub Window，Panel，media等等。\n\n##### SYSTEM WINDOW\n\n![这里写图片描述](http://img.blog.csdn.net/20161028152806777)\n\n注释说这是系统window，一般不是由程序创建的，而在下面它给出的几类中，我们也看到了很多熟悉的身影。\n\n![这里写图片描述](http://img.blog.csdn.net/20161028152932700)\n\n状态栏，搜索栏，Toast都是SYSTEM WINDOW\n\n这只是一个小插曲，我们回归正题，那么很明显Dialog应该是一个Application Window，不然它就不会报错了，我们从代码验证一下。\n\n讲真，我有点打脸，因为我没有找到代码，Dialog的构造函数是这样的。\n\n![这里写图片描述](http://img.blog.csdn.net/20161028155113014)\n\n创建Window的代码在PolicyManager中，代码如下\n\n![这里写图片描述](http://img.blog.csdn.net/20161028155158458)\n\n这里感觉有点打脸了，难道代码跟不下去了？网上查了一些资料，看到一个比较合理的解释是，因为我的源码是SDK的源码，而不是真正编译系统的源码，所以这块内容被屏蔽掉了。没关系，万能的百度说正确的代码是下面这个样子的。\n\n![这里写图片描述](http://img.blog.csdn.net/20161028162358849)\n\n看到了静态区动态加载了Policy，这就好说了，我们去看Policy的makeNewWindow吧。\n\n![这里写图片描述](http://img.blog.csdn.net/20161028162517980)\n\n返回的是一个PhoneWindow，我没有从代码中找到明确把PhoneWindow设置类型为TYPE_APPLICATION的地方，于是想看一下Window的默认Type是什么。\n\n![这里写图片描述](http://img.blog.csdn.net/20161028170422891)\n\n![这里写图片描述](http://img.blog.csdn.net/20161028170435500)\n\n![这里写图片描述](http://img.blog.csdn.net/20161028170445195)\n\n所以，默认type是TYPE_APPLICATION类型的。PhoneWindow也就是TYPE APPLICATION类型的。\n\n然后我们再看下一点，Dialog的Token是什么\nDialog的Token是null，这个可以从代码上看出来。第二个参数设置的就是token。\n\n![这里写图片描述](http://img.blog.csdn.net/20161028165305907)\n\n只是如果View的Token是null，WindowManager又会怎么操作呢。我们从异常处反向追一下代码。前面说到了，异常是从WindowManagerService的addWindow方法报出来的，检验的是Token是否是AppToken。\n\n![这里写图片描述](http://img.blog.csdn.net/20161031102436168)\n\naddWindow的调用链是这样的，我正向来说一下比较好理解，Dialog的show方法时，调用了mWindowManager的addView方法。\n\n![这里写图片描述](http://img.blog.csdn.net/20161031102800676)\n\nmWindowManager的实现是WindowManagerImpl，调用的是WindowManagerGlobal的addView\n\n![这里写图片描述](http://img.blog.csdn.net/20161031102949037)\n\nWindowManagerGlobal的addView方法调到了ViewRootImpl的setView\n\n![这里写图片描述](http://img.blog.csdn.net/20161031103246376)\n\n然后正如前面说到的，setView方法调到了通过WindowSession调用了WindowManagerService的addWindow，检查Token并报出异常。\n\n这样就很明确了，这个token跟Dialog中的mWindowManager有关，初始化的时候已经看到mWindowManger跟Context有关。\n\n![这里写图片描述](http://img.blog.csdn.net/20161031103849988)\n\n如果这个Context是Activity，我们看下mWindowManager是如何表现的。在Activity中，如果要获取WindowService，Activity会把自己的mWindowManager返回过去。\n\n![这里写图片描述](http://img.blog.csdn.net/20161031104032942)\n\n而这个WindowManager的初始化是在Activity的attach方法中，从以下代码中我们看到，这个WIndowManager设置过appToken。\n\n![这里写图片描述](http://img.blog.csdn.net/20161031104348943)\n\n否则的话，如果Dialog的Context是其他，如Application，因为这几个Context没有重写getSystemService方法，所以调用的是父类ContextWrapper中的getSystemService。\n\n![这里写图片描述](http://img.blog.csdn.net/20161031104822710)\n\n在第二篇文章[Activity启动流程分析（二）](http://zwgeek.com/2016/10/25/Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%902/) 中分析过，ContextWrapper中的mBase是ContextImpl类型的。\n\nContextImpl中的getSystemtService获取的是SYSTEM_SERVICE_MAP中的Service。\n\n![这里写图片描述](http://img.blog.csdn.net/20161031105217598)\n\n这个map中的service是在static块中放进去的\n\n![这里写图片描述](http://img.blog.csdn.net/20161031105401819)\n\n其中也包括Window Service\n\n![这里写图片描述](http://img.blog.csdn.net/20161031105444244)\n\n这里很简单，就是返回了一个WindowManagerImpl的实例，而我们知道WindowManagerImpl的实例中是没有AppToken的。\n\n综上所述，只有Activity的WindowManager是设置过AppToken的，所以，只有Context是Activity的时候，才能保证Dialog的show方法不返回异常。\n\n为什么创建一个Dialog一定要带AppToken呢，其实不是什么技术上有问题，而是android的一种安全措施，原因在注释中也写的很清楚。\n\n![这里写图片描述](http://img.blog.csdn.net/20161031113058149)\n\n一个TYPE_APPLICATION类型的window必须带APPTOKEN，已区别它显示在哪个窗口上，这就限制了Dialog只能显示在创建它的Activity上，是一种安全措施。\n\nok，之前分析文章提出的三个问题已经作答完毕。\n\n例行广告，喜欢这篇文章的同学可以关注我的博客[http://zwgeek.com](http://zwgeek.com)\n\n\n","source":"_posts/Activity启动流程番外篇.md","raw":"---\ntitle: Activity启动流程番外篇\ndate: 2016-10-26 17:29:01\ntags:\n  - Android\n  - Activity启动\n  - 系统\ncategories: Android\n---\n\n前两篇文章分析了Activity的启动流程的大部分。\n\n第一篇文章讲了程序在调用startActivity之后发生的一些操作[Activity启动流程分析](http://zwgeek.com/2016/10/09/Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/)\n\n第二篇文章讲了一个Android程序从最开始启动到一个Activity呈现到用户之间发生的一些操作[Activity启动流程分析（二）](http://zwgeek.com/2016/10/25/Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%902/)\n\n在这两篇文章之前，我就提出了三个问题，前面也分析的差不多了，准备在这篇文章中来回答这三个问题，所以如果你还没有看前两篇文章，还是希望你能大概读一下之前两篇文章再来看这篇番外篇。\n\n好，回归正题，提了三个问题，分别是哪三个问题呢。\n\n- getApplication() ，getApplicationContext()，getBaseContext()分别有什么区别？\n- 单个进程中能存在多个application么？\n- 为什么不能使用service或者application作为创建dialog的context参数？\n\n\n\n\n#### 第一个问题\ngetApplication() ，getApplicationContext()，getBaseContext()分别有什么区别？\n\n对于这个问题，我们首先看一下这三个方法返回的对象分别是什么。\n\ngetApplication()\n![这里写图片描述](http://img.blog.csdn.net/20161026174737355)\n\ngetApplication返回的是Activity中的mApplication对象，这个对象是在attach的时候赋给Activity的\n\n![这里写图片描述](http://img.blog.csdn.net/20161026174850543)\n\n第二篇文章中也讲到了attach的调用是在ActivityThread的performLaunchActivity中，传递的Application是通过makeApplication生成的。\n\n![这里写图片描述](http://img.blog.csdn.net/20161026175138524)\n\n我们来看下makeApplication\n\n![这里写图片描述](http://img.blog.csdn.net/20161026175239338)\n\n方法中我们可以发现makeApplication是会返回当前的mApplication的，那当前的这个mApplication到底是不是程序最开始创建的那个Application呢，也就是在bindApplicaiton中生成的Application。\n\n![这里写图片描述](http://img.blog.csdn.net/20161026175707140)\n\n要看这两个Application是否相同，我们可以跟踪创建它的LoadApk类，也就是这里的data.info和前面的r.packageInfo\n\n好吧，继续追吧，看看能不能看到这两个对象的源头data.info是在handleBindApplication方法中通过getPackageInfoNoCheck获取到的。\n\n![这里写图片描述](http://img.blog.csdn.net/20161026180630012)\n\ngetPackageInfoNoCheck调用了getPackageInfo方法。看下这个方法\n\n![这里写图片描述](http://img.blog.csdn.net/20161026180758006)\n\n这里可以很明显的看出，PackageInfo在ActivityThread中是单例的，这个对象跟packageName挂钩，那么我们也知道，一个Android程序的packageName是唯一的。所以基本可以确定前面两个创建Application的packageInfo是一样的，为了保险起见，我们再追一下另外一个packageInfo吧，也就是r.packageInfo。\n\n![这里写图片描述](http://img.blog.csdn.net/20161026181449946)\n\n看到了吧，也是调用前面的getPackageInfoNoCheck方法获取到的。所以正确流程下，一个Android程序中Application是唯一的，getApplication返回的就是这个对象。为什么说是正常流程下呢，这对应的是我们的第二个问题，后面会做出解答。\n\n第二个方法getApplicationContext()\n这个方法是在ContextWrapper中的，Activity是继承在这个类的。\n\n![这里写图片描述](http://img.blog.csdn.net/20161026181724666)\n\n这里又关系到mBase这个对象，这个对象其实也是在Activity attch的时候绑定进来的，就是图中这个地方创建的appContext，这个对象是ContextImpl类型的。\n\n![这里写图片描述](http://img.blog.csdn.net/20161026181855572)\n\n我们进去看下它的getApplicationContext方法\n\n![这里写图片描述](http://img.blog.csdn.net/20161026182021733)\n\n如果packageInfo不为null，那么返回packageInfo的Application，否则返回mainThread的Application\n\n![这里写图片描述](http://img.blog.csdn.net/20161026182206188)\n\n创建这个ContextImpl的packageInfo其实就是前面分析的r.packageInfo，所以这个ApplicationContext跟前面的Application是完全一样的。如果packageInfo是空，返回的是ActivityThread中的Application，而ActivityThread中的Application是handleBindApplication中生成的那个，跟前面也是一样的。\n\n综上所述，getApplicationContext跟getApplication是相同的，接下来我们再看下getBaseContext()\n\n![这里写图片描述](http://img.blog.csdn.net/20161026182544622)\n\n这里返回的就是前面说的mBase，这个mBase是一个ContextImpl类型的对象，是为Activity专门创建的，与Application就不一样了。\n\n好，这就是第一个问题的答案。\n\n#### 第二个问题\n单个进程中能存在多个application么？\n\n忽然意识到第二个问题其实在第一个问题中已经做了部分回答，一个LoadedApk中只能存在一个application。\n\n但是事实是这样吗，我们来看下ActivityThread中创建Application的地方。正如第一个问题分析的，虽然在第一句话的时候，限制了mApplication的单例性，但是请注意后面对Application的管理。\n\n![这里写图片描述](http://img.blog.csdn.net/20161031110946531)\n\n![这里写图片描述](http://img.blog.csdn.net/20161031110409263)\n\nActivityThread是一个进程，这里很明显我们已经能看出，Android中一个进程是允许存在多个Application的，但是正常情况下，是不会出现多个Application的，那么不正常的情况是什么呢，你可以通过反射得到这个mAllApplications，然后手动把自己的Application放进去。为了什么？当然是一些奇技淫巧了，后面有机会讲到插件化实现的时候会说到。\n\n反正这里你知道一个结论就行了，一个进程是允许多个Application的，但是Android的正常流程下，一个进程只有一个Application。\n\n#### 第三个问题\n为什么不能使用service或者application作为创建dialog的context参数？\n\n用service或者Application启动dialog的时候会报错\n\n```java\nCaused by: android.view.WindowManager$BadTokenException: Unable to add window -- token null is not for an application\n                           at android.view.ViewRootImpl.setView(ViewRootImpl.java:685)\n                           at android.view.WindowManagerGlobal.addView(WindowManagerGlobal.java:342)\n                           at android.view.WindowManagerImpl.addView(WindowManagerImpl.java:93)\n                           at android.app.Dialog.show(Dialog.java:316)\n\n```\n我们来看一下这个错误是哪里报出的，是在ViewRootImpl的setView中\n\n![这里写图片描述](http://img.blog.csdn.net/20161026184204831)\n\n对res进行判断，而这个res是这句话返回的，既然异常是关于token的，也就是说在addToDisplay的时候对当前view的token进行了检查。\n\n![这里写图片描述](http://img.blog.csdn.net/20161027112934008)\n\nmWindowSession是一个Session类型的，addToDidplay代码如下\n\n![这里写图片描述](http://img.blog.csdn.net/20161028150931848)\n\n其实如果你分析的多了，不用看也知道mService肯定是WindowManagerService，这个Service和ActivityManagerService一样，在Framework层是很重要的一个类，负责窗口绘制等。\n\n异常报出的case是ADD_NOT_APP_TOKEN，找一下\n\n![这里写图片描述](http://img.blog.csdn.net/20161028151340745)\n\n所以看得出来，报出这个异常有两个条件，一是type是APPLICATION_WINDOW，二是要有APPWindowToken。\n\n先看看这个TYPE吧\n\n![这里写图片描述](http://img.blog.csdn.net/20161028151709929)\n\n通过看这个类的注释，大概知道什么意思，WINDOW分为几大类\n1-99是Application window\n1000-1999是sub window\n2000-2999是system window\n\n挨个来看注释\n\n##### Application Window\n![这里写图片描述](http://img.blog.csdn.net/20161028152220400)\n\nApplication Window就是普通的应用程序window，像Activity，Dialog都属于这一类\n\n##### Sub Window\n\n![这里写图片描述](http://img.blog.csdn.net/20161028152438321)\n\nSubWIndow，从注释可以看出，这类window必须有一个可依附的其他Window，然后在坐标轴Z上它是它所依附的Window的下一个，然后它的坐标体系也依附于它所依附的Window的坐标。\n\n下面指出了一些Sub Window，Panel，media等等。\n\n##### SYSTEM WINDOW\n\n![这里写图片描述](http://img.blog.csdn.net/20161028152806777)\n\n注释说这是系统window，一般不是由程序创建的，而在下面它给出的几类中，我们也看到了很多熟悉的身影。\n\n![这里写图片描述](http://img.blog.csdn.net/20161028152932700)\n\n状态栏，搜索栏，Toast都是SYSTEM WINDOW\n\n这只是一个小插曲，我们回归正题，那么很明显Dialog应该是一个Application Window，不然它就不会报错了，我们从代码验证一下。\n\n讲真，我有点打脸，因为我没有找到代码，Dialog的构造函数是这样的。\n\n![这里写图片描述](http://img.blog.csdn.net/20161028155113014)\n\n创建Window的代码在PolicyManager中，代码如下\n\n![这里写图片描述](http://img.blog.csdn.net/20161028155158458)\n\n这里感觉有点打脸了，难道代码跟不下去了？网上查了一些资料，看到一个比较合理的解释是，因为我的源码是SDK的源码，而不是真正编译系统的源码，所以这块内容被屏蔽掉了。没关系，万能的百度说正确的代码是下面这个样子的。\n\n![这里写图片描述](http://img.blog.csdn.net/20161028162358849)\n\n看到了静态区动态加载了Policy，这就好说了，我们去看Policy的makeNewWindow吧。\n\n![这里写图片描述](http://img.blog.csdn.net/20161028162517980)\n\n返回的是一个PhoneWindow，我没有从代码中找到明确把PhoneWindow设置类型为TYPE_APPLICATION的地方，于是想看一下Window的默认Type是什么。\n\n![这里写图片描述](http://img.blog.csdn.net/20161028170422891)\n\n![这里写图片描述](http://img.blog.csdn.net/20161028170435500)\n\n![这里写图片描述](http://img.blog.csdn.net/20161028170445195)\n\n所以，默认type是TYPE_APPLICATION类型的。PhoneWindow也就是TYPE APPLICATION类型的。\n\n然后我们再看下一点，Dialog的Token是什么\nDialog的Token是null，这个可以从代码上看出来。第二个参数设置的就是token。\n\n![这里写图片描述](http://img.blog.csdn.net/20161028165305907)\n\n只是如果View的Token是null，WindowManager又会怎么操作呢。我们从异常处反向追一下代码。前面说到了，异常是从WindowManagerService的addWindow方法报出来的，检验的是Token是否是AppToken。\n\n![这里写图片描述](http://img.blog.csdn.net/20161031102436168)\n\naddWindow的调用链是这样的，我正向来说一下比较好理解，Dialog的show方法时，调用了mWindowManager的addView方法。\n\n![这里写图片描述](http://img.blog.csdn.net/20161031102800676)\n\nmWindowManager的实现是WindowManagerImpl，调用的是WindowManagerGlobal的addView\n\n![这里写图片描述](http://img.blog.csdn.net/20161031102949037)\n\nWindowManagerGlobal的addView方法调到了ViewRootImpl的setView\n\n![这里写图片描述](http://img.blog.csdn.net/20161031103246376)\n\n然后正如前面说到的，setView方法调到了通过WindowSession调用了WindowManagerService的addWindow，检查Token并报出异常。\n\n这样就很明确了，这个token跟Dialog中的mWindowManager有关，初始化的时候已经看到mWindowManger跟Context有关。\n\n![这里写图片描述](http://img.blog.csdn.net/20161031103849988)\n\n如果这个Context是Activity，我们看下mWindowManager是如何表现的。在Activity中，如果要获取WindowService，Activity会把自己的mWindowManager返回过去。\n\n![这里写图片描述](http://img.blog.csdn.net/20161031104032942)\n\n而这个WindowManager的初始化是在Activity的attach方法中，从以下代码中我们看到，这个WIndowManager设置过appToken。\n\n![这里写图片描述](http://img.blog.csdn.net/20161031104348943)\n\n否则的话，如果Dialog的Context是其他，如Application，因为这几个Context没有重写getSystemService方法，所以调用的是父类ContextWrapper中的getSystemService。\n\n![这里写图片描述](http://img.blog.csdn.net/20161031104822710)\n\n在第二篇文章[Activity启动流程分析（二）](http://zwgeek.com/2016/10/25/Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%902/) 中分析过，ContextWrapper中的mBase是ContextImpl类型的。\n\nContextImpl中的getSystemtService获取的是SYSTEM_SERVICE_MAP中的Service。\n\n![这里写图片描述](http://img.blog.csdn.net/20161031105217598)\n\n这个map中的service是在static块中放进去的\n\n![这里写图片描述](http://img.blog.csdn.net/20161031105401819)\n\n其中也包括Window Service\n\n![这里写图片描述](http://img.blog.csdn.net/20161031105444244)\n\n这里很简单，就是返回了一个WindowManagerImpl的实例，而我们知道WindowManagerImpl的实例中是没有AppToken的。\n\n综上所述，只有Activity的WindowManager是设置过AppToken的，所以，只有Context是Activity的时候，才能保证Dialog的show方法不返回异常。\n\n为什么创建一个Dialog一定要带AppToken呢，其实不是什么技术上有问题，而是android的一种安全措施，原因在注释中也写的很清楚。\n\n![这里写图片描述](http://img.blog.csdn.net/20161031113058149)\n\n一个TYPE_APPLICATION类型的window必须带APPTOKEN，已区别它显示在哪个窗口上，这就限制了Dialog只能显示在创建它的Activity上，是一种安全措施。\n\nok，之前分析文章提出的三个问题已经作答完毕。\n\n例行广告，喜欢这篇文章的同学可以关注我的博客[http://zwgeek.com](http://zwgeek.com)\n\n\n","slug":"Activity启动流程番外篇","published":1,"updated":"2024-06-14T09:25:33.675Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clxjsxtvu0006lq6gwwfn2q22","content":"<p>前两篇文章分析了Activity的启动流程的大部分。</p>\n<p>第一篇文章讲了程序在调用startActivity之后发生的一些操作<a href=\"http://zwgeek.com/2016/10/09/Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/\">Activity启动流程分析</a></p>\n<p>第二篇文章讲了一个Android程序从最开始启动到一个Activity呈现到用户之间发生的一些操作<a href=\"http://zwgeek.com/2016/10/25/Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%902/\">Activity启动流程分析（二）</a></p>\n<p>在这两篇文章之前，我就提出了三个问题，前面也分析的差不多了，准备在这篇文章中来回答这三个问题，所以如果你还没有看前两篇文章，还是希望你能大概读一下之前两篇文章再来看这篇番外篇。</p>\n<p>好，回归正题，提了三个问题，分别是哪三个问题呢。</p>\n<ul>\n<li>getApplication() ，getApplicationContext()，getBaseContext()分别有什么区别？</li>\n<li>单个进程中能存在多个application么？</li>\n<li>为什么不能使用service或者application作为创建dialog的context参数？</li>\n</ul>\n<h4 id=\"第一个问题\"><a href=\"#第一个问题\" class=\"headerlink\" title=\"第一个问题\"></a>第一个问题</h4><p>getApplication() ，getApplicationContext()，getBaseContext()分别有什么区别？</p>\n<p>对于这个问题，我们首先看一下这三个方法返回的对象分别是什么。</p>\n<p>getApplication()<br><img src=\"http://img.blog.csdn.net/20161026174737355\" alt=\"这里写图片描述\"></p>\n<p>getApplication返回的是Activity中的mApplication对象，这个对象是在attach的时候赋给Activity的</p>\n<p><img src=\"http://img.blog.csdn.net/20161026174850543\" alt=\"这里写图片描述\"></p>\n<p>第二篇文章中也讲到了attach的调用是在ActivityThread的performLaunchActivity中，传递的Application是通过makeApplication生成的。</p>\n<p><img src=\"http://img.blog.csdn.net/20161026175138524\" alt=\"这里写图片描述\"></p>\n<p>我们来看下makeApplication</p>\n<p><img src=\"http://img.blog.csdn.net/20161026175239338\" alt=\"这里写图片描述\"></p>\n<p>方法中我们可以发现makeApplication是会返回当前的mApplication的，那当前的这个mApplication到底是不是程序最开始创建的那个Application呢，也就是在bindApplicaiton中生成的Application。</p>\n<p><img src=\"http://img.blog.csdn.net/20161026175707140\" alt=\"这里写图片描述\"></p>\n<p>要看这两个Application是否相同，我们可以跟踪创建它的LoadApk类，也就是这里的data.info和前面的r.packageInfo</p>\n<p>好吧，继续追吧，看看能不能看到这两个对象的源头data.info是在handleBindApplication方法中通过getPackageInfoNoCheck获取到的。</p>\n<p><img src=\"http://img.blog.csdn.net/20161026180630012\" alt=\"这里写图片描述\"></p>\n<p>getPackageInfoNoCheck调用了getPackageInfo方法。看下这个方法</p>\n<p><img src=\"http://img.blog.csdn.net/20161026180758006\" alt=\"这里写图片描述\"></p>\n<p>这里可以很明显的看出，PackageInfo在ActivityThread中是单例的，这个对象跟packageName挂钩，那么我们也知道，一个Android程序的packageName是唯一的。所以基本可以确定前面两个创建Application的packageInfo是一样的，为了保险起见，我们再追一下另外一个packageInfo吧，也就是r.packageInfo。</p>\n<p><img src=\"http://img.blog.csdn.net/20161026181449946\" alt=\"这里写图片描述\"></p>\n<p>看到了吧，也是调用前面的getPackageInfoNoCheck方法获取到的。所以正确流程下，一个Android程序中Application是唯一的，getApplication返回的就是这个对象。为什么说是正常流程下呢，这对应的是我们的第二个问题，后面会做出解答。</p>\n<p>第二个方法getApplicationContext()<br>这个方法是在ContextWrapper中的，Activity是继承在这个类的。</p>\n<p><img src=\"http://img.blog.csdn.net/20161026181724666\" alt=\"这里写图片描述\"></p>\n<p>这里又关系到mBase这个对象，这个对象其实也是在Activity attch的时候绑定进来的，就是图中这个地方创建的appContext，这个对象是ContextImpl类型的。</p>\n<p><img src=\"http://img.blog.csdn.net/20161026181855572\" alt=\"这里写图片描述\"></p>\n<p>我们进去看下它的getApplicationContext方法</p>\n<p><img src=\"http://img.blog.csdn.net/20161026182021733\" alt=\"这里写图片描述\"></p>\n<p>如果packageInfo不为null，那么返回packageInfo的Application，否则返回mainThread的Application</p>\n<p><img src=\"http://img.blog.csdn.net/20161026182206188\" alt=\"这里写图片描述\"></p>\n<p>创建这个ContextImpl的packageInfo其实就是前面分析的r.packageInfo，所以这个ApplicationContext跟前面的Application是完全一样的。如果packageInfo是空，返回的是ActivityThread中的Application，而ActivityThread中的Application是handleBindApplication中生成的那个，跟前面也是一样的。</p>\n<p>综上所述，getApplicationContext跟getApplication是相同的，接下来我们再看下getBaseContext()</p>\n<p><img src=\"http://img.blog.csdn.net/20161026182544622\" alt=\"这里写图片描述\"></p>\n<p>这里返回的就是前面说的mBase，这个mBase是一个ContextImpl类型的对象，是为Activity专门创建的，与Application就不一样了。</p>\n<p>好，这就是第一个问题的答案。</p>\n<h4 id=\"第二个问题\"><a href=\"#第二个问题\" class=\"headerlink\" title=\"第二个问题\"></a>第二个问题</h4><p>单个进程中能存在多个application么？</p>\n<p>忽然意识到第二个问题其实在第一个问题中已经做了部分回答，一个LoadedApk中只能存在一个application。</p>\n<p>但是事实是这样吗，我们来看下ActivityThread中创建Application的地方。正如第一个问题分析的，虽然在第一句话的时候，限制了mApplication的单例性，但是请注意后面对Application的管理。</p>\n<p><img src=\"http://img.blog.csdn.net/20161031110946531\" alt=\"这里写图片描述\"></p>\n<p><img src=\"http://img.blog.csdn.net/20161031110409263\" alt=\"这里写图片描述\"></p>\n<p>ActivityThread是一个进程，这里很明显我们已经能看出，Android中一个进程是允许存在多个Application的，但是正常情况下，是不会出现多个Application的，那么不正常的情况是什么呢，你可以通过反射得到这个mAllApplications，然后手动把自己的Application放进去。为了什么？当然是一些奇技淫巧了，后面有机会讲到插件化实现的时候会说到。</p>\n<p>反正这里你知道一个结论就行了，一个进程是允许多个Application的，但是Android的正常流程下，一个进程只有一个Application。</p>\n<h4 id=\"第三个问题\"><a href=\"#第三个问题\" class=\"headerlink\" title=\"第三个问题\"></a>第三个问题</h4><p>为什么不能使用service或者application作为创建dialog的context参数？</p>\n<p>用service或者Application启动dialog的时候会报错</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">Caused by: android.view.WindowManager$BadTokenException: Unable to add window -- token <span class=\"keyword\">null</span> is not <span class=\"keyword\">for</span> an application</div><div class=\"line\">                           at android.view.ViewRootImpl.setView(ViewRootImpl.java:<span class=\"number\">685</span>)</div><div class=\"line\">                           at android.view.WindowManagerGlobal.addView(WindowManagerGlobal.java:<span class=\"number\">342</span>)</div><div class=\"line\">                           at android.view.WindowManagerImpl.addView(WindowManagerImpl.java:<span class=\"number\">93</span>)</div><div class=\"line\">                           at android.app.Dialog.show(Dialog.java:<span class=\"number\">316</span>)</div></pre></td></tr></table></figure>\n<p>我们来看一下这个错误是哪里报出的，是在ViewRootImpl的setView中</p>\n<p><img src=\"http://img.blog.csdn.net/20161026184204831\" alt=\"这里写图片描述\"></p>\n<p>对res进行判断，而这个res是这句话返回的，既然异常是关于token的，也就是说在addToDisplay的时候对当前view的token进行了检查。</p>\n<p><img src=\"http://img.blog.csdn.net/20161027112934008\" alt=\"这里写图片描述\"></p>\n<p>mWindowSession是一个Session类型的，addToDidplay代码如下</p>\n<p><img src=\"http://img.blog.csdn.net/20161028150931848\" alt=\"这里写图片描述\"></p>\n<p>其实如果你分析的多了，不用看也知道mService肯定是WindowManagerService，这个Service和ActivityManagerService一样，在Framework层是很重要的一个类，负责窗口绘制等。</p>\n<p>异常报出的case是ADD_NOT_APP_TOKEN，找一下</p>\n<p><img src=\"http://img.blog.csdn.net/20161028151340745\" alt=\"这里写图片描述\"></p>\n<p>所以看得出来，报出这个异常有两个条件，一是type是APPLICATION_WINDOW，二是要有APPWindowToken。</p>\n<p>先看看这个TYPE吧</p>\n<p><img src=\"http://img.blog.csdn.net/20161028151709929\" alt=\"这里写图片描述\"></p>\n<p>通过看这个类的注释，大概知道什么意思，WINDOW分为几大类<br>1-99是Application window<br>1000-1999是sub window<br>2000-2999是system window</p>\n<p>挨个来看注释</p>\n<h5 id=\"Application-Window\"><a href=\"#Application-Window\" class=\"headerlink\" title=\"Application Window\"></a>Application Window</h5><p><img src=\"http://img.blog.csdn.net/20161028152220400\" alt=\"这里写图片描述\"></p>\n<p>Application Window就是普通的应用程序window，像Activity，Dialog都属于这一类</p>\n<h5 id=\"Sub-Window\"><a href=\"#Sub-Window\" class=\"headerlink\" title=\"Sub Window\"></a>Sub Window</h5><p><img src=\"http://img.blog.csdn.net/20161028152438321\" alt=\"这里写图片描述\"></p>\n<p>SubWIndow，从注释可以看出，这类window必须有一个可依附的其他Window，然后在坐标轴Z上它是它所依附的Window的下一个，然后它的坐标体系也依附于它所依附的Window的坐标。</p>\n<p>下面指出了一些Sub Window，Panel，media等等。</p>\n<h5 id=\"SYSTEM-WINDOW\"><a href=\"#SYSTEM-WINDOW\" class=\"headerlink\" title=\"SYSTEM WINDOW\"></a>SYSTEM WINDOW</h5><p><img src=\"http://img.blog.csdn.net/20161028152806777\" alt=\"这里写图片描述\"></p>\n<p>注释说这是系统window，一般不是由程序创建的，而在下面它给出的几类中，我们也看到了很多熟悉的身影。</p>\n<p><img src=\"http://img.blog.csdn.net/20161028152932700\" alt=\"这里写图片描述\"></p>\n<p>状态栏，搜索栏，Toast都是SYSTEM WINDOW</p>\n<p>这只是一个小插曲，我们回归正题，那么很明显Dialog应该是一个Application Window，不然它就不会报错了，我们从代码验证一下。</p>\n<p>讲真，我有点打脸，因为我没有找到代码，Dialog的构造函数是这样的。</p>\n<p><img src=\"http://img.blog.csdn.net/20161028155113014\" alt=\"这里写图片描述\"></p>\n<p>创建Window的代码在PolicyManager中，代码如下</p>\n<p><img src=\"http://img.blog.csdn.net/20161028155158458\" alt=\"这里写图片描述\"></p>\n<p>这里感觉有点打脸了，难道代码跟不下去了？网上查了一些资料，看到一个比较合理的解释是，因为我的源码是SDK的源码，而不是真正编译系统的源码，所以这块内容被屏蔽掉了。没关系，万能的百度说正确的代码是下面这个样子的。</p>\n<p><img src=\"http://img.blog.csdn.net/20161028162358849\" alt=\"这里写图片描述\"></p>\n<p>看到了静态区动态加载了Policy，这就好说了，我们去看Policy的makeNewWindow吧。</p>\n<p><img src=\"http://img.blog.csdn.net/20161028162517980\" alt=\"这里写图片描述\"></p>\n<p>返回的是一个PhoneWindow，我没有从代码中找到明确把PhoneWindow设置类型为TYPE_APPLICATION的地方，于是想看一下Window的默认Type是什么。</p>\n<p><img src=\"http://img.blog.csdn.net/20161028170422891\" alt=\"这里写图片描述\"></p>\n<p><img src=\"http://img.blog.csdn.net/20161028170435500\" alt=\"这里写图片描述\"></p>\n<p><img src=\"http://img.blog.csdn.net/20161028170445195\" alt=\"这里写图片描述\"></p>\n<p>所以，默认type是TYPE_APPLICATION类型的。PhoneWindow也就是TYPE APPLICATION类型的。</p>\n<p>然后我们再看下一点，Dialog的Token是什么<br>Dialog的Token是null，这个可以从代码上看出来。第二个参数设置的就是token。</p>\n<p><img src=\"http://img.blog.csdn.net/20161028165305907\" alt=\"这里写图片描述\"></p>\n<p>只是如果View的Token是null，WindowManager又会怎么操作呢。我们从异常处反向追一下代码。前面说到了，异常是从WindowManagerService的addWindow方法报出来的，检验的是Token是否是AppToken。</p>\n<p><img src=\"http://img.blog.csdn.net/20161031102436168\" alt=\"这里写图片描述\"></p>\n<p>addWindow的调用链是这样的，我正向来说一下比较好理解，Dialog的show方法时，调用了mWindowManager的addView方法。</p>\n<p><img src=\"http://img.blog.csdn.net/20161031102800676\" alt=\"这里写图片描述\"></p>\n<p>mWindowManager的实现是WindowManagerImpl，调用的是WindowManagerGlobal的addView</p>\n<p><img src=\"http://img.blog.csdn.net/20161031102949037\" alt=\"这里写图片描述\"></p>\n<p>WindowManagerGlobal的addView方法调到了ViewRootImpl的setView</p>\n<p><img src=\"http://img.blog.csdn.net/20161031103246376\" alt=\"这里写图片描述\"></p>\n<p>然后正如前面说到的，setView方法调到了通过WindowSession调用了WindowManagerService的addWindow，检查Token并报出异常。</p>\n<p>这样就很明确了，这个token跟Dialog中的mWindowManager有关，初始化的时候已经看到mWindowManger跟Context有关。</p>\n<p><img src=\"http://img.blog.csdn.net/20161031103849988\" alt=\"这里写图片描述\"></p>\n<p>如果这个Context是Activity，我们看下mWindowManager是如何表现的。在Activity中，如果要获取WindowService，Activity会把自己的mWindowManager返回过去。</p>\n<p><img src=\"http://img.blog.csdn.net/20161031104032942\" alt=\"这里写图片描述\"></p>\n<p>而这个WindowManager的初始化是在Activity的attach方法中，从以下代码中我们看到，这个WIndowManager设置过appToken。</p>\n<p><img src=\"http://img.blog.csdn.net/20161031104348943\" alt=\"这里写图片描述\"></p>\n<p>否则的话，如果Dialog的Context是其他，如Application，因为这几个Context没有重写getSystemService方法，所以调用的是父类ContextWrapper中的getSystemService。</p>\n<p><img src=\"http://img.blog.csdn.net/20161031104822710\" alt=\"这里写图片描述\"></p>\n<p>在第二篇文章<a href=\"http://zwgeek.com/2016/10/25/Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%902/\">Activity启动流程分析（二）</a> 中分析过，ContextWrapper中的mBase是ContextImpl类型的。</p>\n<p>ContextImpl中的getSystemtService获取的是SYSTEM_SERVICE_MAP中的Service。</p>\n<p><img src=\"http://img.blog.csdn.net/20161031105217598\" alt=\"这里写图片描述\"></p>\n<p>这个map中的service是在static块中放进去的</p>\n<p><img src=\"http://img.blog.csdn.net/20161031105401819\" alt=\"这里写图片描述\"></p>\n<p>其中也包括Window Service</p>\n<p><img src=\"http://img.blog.csdn.net/20161031105444244\" alt=\"这里写图片描述\"></p>\n<p>这里很简单，就是返回了一个WindowManagerImpl的实例，而我们知道WindowManagerImpl的实例中是没有AppToken的。</p>\n<p>综上所述，只有Activity的WindowManager是设置过AppToken的，所以，只有Context是Activity的时候，才能保证Dialog的show方法不返回异常。</p>\n<p>为什么创建一个Dialog一定要带AppToken呢，其实不是什么技术上有问题，而是android的一种安全措施，原因在注释中也写的很清楚。</p>\n<p><img src=\"http://img.blog.csdn.net/20161031113058149\" alt=\"这里写图片描述\"></p>\n<p>一个TYPE_APPLICATION类型的window必须带APPTOKEN，已区别它显示在哪个窗口上，这就限制了Dialog只能显示在创建它的Activity上，是一种安全措施。</p>\n<p>ok，之前分析文章提出的三个问题已经作答完毕。</p>\n<p>例行广告，喜欢这篇文章的同学可以关注我的博客<a href=\"http://zwgeek.com\">http://zwgeek.com</a></p>\n","excerpt":"","more":"<p>前两篇文章分析了Activity的启动流程的大部分。</p>\n<p>第一篇文章讲了程序在调用startActivity之后发生的一些操作<a href=\"http://zwgeek.com/2016/10/09/Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/\">Activity启动流程分析</a></p>\n<p>第二篇文章讲了一个Android程序从最开始启动到一个Activity呈现到用户之间发生的一些操作<a href=\"http://zwgeek.com/2016/10/25/Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%902/\">Activity启动流程分析（二）</a></p>\n<p>在这两篇文章之前，我就提出了三个问题，前面也分析的差不多了，准备在这篇文章中来回答这三个问题，所以如果你还没有看前两篇文章，还是希望你能大概读一下之前两篇文章再来看这篇番外篇。</p>\n<p>好，回归正题，提了三个问题，分别是哪三个问题呢。</p>\n<ul>\n<li>getApplication() ，getApplicationContext()，getBaseContext()分别有什么区别？</li>\n<li>单个进程中能存在多个application么？</li>\n<li>为什么不能使用service或者application作为创建dialog的context参数？</li>\n</ul>\n<h4 id=\"第一个问题\"><a href=\"#第一个问题\" class=\"headerlink\" title=\"第一个问题\"></a>第一个问题</h4><p>getApplication() ，getApplicationContext()，getBaseContext()分别有什么区别？</p>\n<p>对于这个问题，我们首先看一下这三个方法返回的对象分别是什么。</p>\n<p>getApplication()<br><img src=\"http://img.blog.csdn.net/20161026174737355\" alt=\"这里写图片描述\"></p>\n<p>getApplication返回的是Activity中的mApplication对象，这个对象是在attach的时候赋给Activity的</p>\n<p><img src=\"http://img.blog.csdn.net/20161026174850543\" alt=\"这里写图片描述\"></p>\n<p>第二篇文章中也讲到了attach的调用是在ActivityThread的performLaunchActivity中，传递的Application是通过makeApplication生成的。</p>\n<p><img src=\"http://img.blog.csdn.net/20161026175138524\" alt=\"这里写图片描述\"></p>\n<p>我们来看下makeApplication</p>\n<p><img src=\"http://img.blog.csdn.net/20161026175239338\" alt=\"这里写图片描述\"></p>\n<p>方法中我们可以发现makeApplication是会返回当前的mApplication的，那当前的这个mApplication到底是不是程序最开始创建的那个Application呢，也就是在bindApplicaiton中生成的Application。</p>\n<p><img src=\"http://img.blog.csdn.net/20161026175707140\" alt=\"这里写图片描述\"></p>\n<p>要看这两个Application是否相同，我们可以跟踪创建它的LoadApk类，也就是这里的data.info和前面的r.packageInfo</p>\n<p>好吧，继续追吧，看看能不能看到这两个对象的源头data.info是在handleBindApplication方法中通过getPackageInfoNoCheck获取到的。</p>\n<p><img src=\"http://img.blog.csdn.net/20161026180630012\" alt=\"这里写图片描述\"></p>\n<p>getPackageInfoNoCheck调用了getPackageInfo方法。看下这个方法</p>\n<p><img src=\"http://img.blog.csdn.net/20161026180758006\" alt=\"这里写图片描述\"></p>\n<p>这里可以很明显的看出，PackageInfo在ActivityThread中是单例的，这个对象跟packageName挂钩，那么我们也知道，一个Android程序的packageName是唯一的。所以基本可以确定前面两个创建Application的packageInfo是一样的，为了保险起见，我们再追一下另外一个packageInfo吧，也就是r.packageInfo。</p>\n<p><img src=\"http://img.blog.csdn.net/20161026181449946\" alt=\"这里写图片描述\"></p>\n<p>看到了吧，也是调用前面的getPackageInfoNoCheck方法获取到的。所以正确流程下，一个Android程序中Application是唯一的，getApplication返回的就是这个对象。为什么说是正常流程下呢，这对应的是我们的第二个问题，后面会做出解答。</p>\n<p>第二个方法getApplicationContext()<br>这个方法是在ContextWrapper中的，Activity是继承在这个类的。</p>\n<p><img src=\"http://img.blog.csdn.net/20161026181724666\" alt=\"这里写图片描述\"></p>\n<p>这里又关系到mBase这个对象，这个对象其实也是在Activity attch的时候绑定进来的，就是图中这个地方创建的appContext，这个对象是ContextImpl类型的。</p>\n<p><img src=\"http://img.blog.csdn.net/20161026181855572\" alt=\"这里写图片描述\"></p>\n<p>我们进去看下它的getApplicationContext方法</p>\n<p><img src=\"http://img.blog.csdn.net/20161026182021733\" alt=\"这里写图片描述\"></p>\n<p>如果packageInfo不为null，那么返回packageInfo的Application，否则返回mainThread的Application</p>\n<p><img src=\"http://img.blog.csdn.net/20161026182206188\" alt=\"这里写图片描述\"></p>\n<p>创建这个ContextImpl的packageInfo其实就是前面分析的r.packageInfo，所以这个ApplicationContext跟前面的Application是完全一样的。如果packageInfo是空，返回的是ActivityThread中的Application，而ActivityThread中的Application是handleBindApplication中生成的那个，跟前面也是一样的。</p>\n<p>综上所述，getApplicationContext跟getApplication是相同的，接下来我们再看下getBaseContext()</p>\n<p><img src=\"http://img.blog.csdn.net/20161026182544622\" alt=\"这里写图片描述\"></p>\n<p>这里返回的就是前面说的mBase，这个mBase是一个ContextImpl类型的对象，是为Activity专门创建的，与Application就不一样了。</p>\n<p>好，这就是第一个问题的答案。</p>\n<h4 id=\"第二个问题\"><a href=\"#第二个问题\" class=\"headerlink\" title=\"第二个问题\"></a>第二个问题</h4><p>单个进程中能存在多个application么？</p>\n<p>忽然意识到第二个问题其实在第一个问题中已经做了部分回答，一个LoadedApk中只能存在一个application。</p>\n<p>但是事实是这样吗，我们来看下ActivityThread中创建Application的地方。正如第一个问题分析的，虽然在第一句话的时候，限制了mApplication的单例性，但是请注意后面对Application的管理。</p>\n<p><img src=\"http://img.blog.csdn.net/20161031110946531\" alt=\"这里写图片描述\"></p>\n<p><img src=\"http://img.blog.csdn.net/20161031110409263\" alt=\"这里写图片描述\"></p>\n<p>ActivityThread是一个进程，这里很明显我们已经能看出，Android中一个进程是允许存在多个Application的，但是正常情况下，是不会出现多个Application的，那么不正常的情况是什么呢，你可以通过反射得到这个mAllApplications，然后手动把自己的Application放进去。为了什么？当然是一些奇技淫巧了，后面有机会讲到插件化实现的时候会说到。</p>\n<p>反正这里你知道一个结论就行了，一个进程是允许多个Application的，但是Android的正常流程下，一个进程只有一个Application。</p>\n<h4 id=\"第三个问题\"><a href=\"#第三个问题\" class=\"headerlink\" title=\"第三个问题\"></a>第三个问题</h4><p>为什么不能使用service或者application作为创建dialog的context参数？</p>\n<p>用service或者Application启动dialog的时候会报错</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">Caused by: android.view.WindowManager$BadTokenException: Unable to add window -- token <span class=\"keyword\">null</span> is not <span class=\"keyword\">for</span> an application</div><div class=\"line\">                           at android.view.ViewRootImpl.setView(ViewRootImpl.java:<span class=\"number\">685</span>)</div><div class=\"line\">                           at android.view.WindowManagerGlobal.addView(WindowManagerGlobal.java:<span class=\"number\">342</span>)</div><div class=\"line\">                           at android.view.WindowManagerImpl.addView(WindowManagerImpl.java:<span class=\"number\">93</span>)</div><div class=\"line\">                           at android.app.Dialog.show(Dialog.java:<span class=\"number\">316</span>)</div></pre></td></tr></table></figure>\n<p>我们来看一下这个错误是哪里报出的，是在ViewRootImpl的setView中</p>\n<p><img src=\"http://img.blog.csdn.net/20161026184204831\" alt=\"这里写图片描述\"></p>\n<p>对res进行判断，而这个res是这句话返回的，既然异常是关于token的，也就是说在addToDisplay的时候对当前view的token进行了检查。</p>\n<p><img src=\"http://img.blog.csdn.net/20161027112934008\" alt=\"这里写图片描述\"></p>\n<p>mWindowSession是一个Session类型的，addToDidplay代码如下</p>\n<p><img src=\"http://img.blog.csdn.net/20161028150931848\" alt=\"这里写图片描述\"></p>\n<p>其实如果你分析的多了，不用看也知道mService肯定是WindowManagerService，这个Service和ActivityManagerService一样，在Framework层是很重要的一个类，负责窗口绘制等。</p>\n<p>异常报出的case是ADD_NOT_APP_TOKEN，找一下</p>\n<p><img src=\"http://img.blog.csdn.net/20161028151340745\" alt=\"这里写图片描述\"></p>\n<p>所以看得出来，报出这个异常有两个条件，一是type是APPLICATION_WINDOW，二是要有APPWindowToken。</p>\n<p>先看看这个TYPE吧</p>\n<p><img src=\"http://img.blog.csdn.net/20161028151709929\" alt=\"这里写图片描述\"></p>\n<p>通过看这个类的注释，大概知道什么意思，WINDOW分为几大类<br>1-99是Application window<br>1000-1999是sub window<br>2000-2999是system window</p>\n<p>挨个来看注释</p>\n<h5 id=\"Application-Window\"><a href=\"#Application-Window\" class=\"headerlink\" title=\"Application Window\"></a>Application Window</h5><p><img src=\"http://img.blog.csdn.net/20161028152220400\" alt=\"这里写图片描述\"></p>\n<p>Application Window就是普通的应用程序window，像Activity，Dialog都属于这一类</p>\n<h5 id=\"Sub-Window\"><a href=\"#Sub-Window\" class=\"headerlink\" title=\"Sub Window\"></a>Sub Window</h5><p><img src=\"http://img.blog.csdn.net/20161028152438321\" alt=\"这里写图片描述\"></p>\n<p>SubWIndow，从注释可以看出，这类window必须有一个可依附的其他Window，然后在坐标轴Z上它是它所依附的Window的下一个，然后它的坐标体系也依附于它所依附的Window的坐标。</p>\n<p>下面指出了一些Sub Window，Panel，media等等。</p>\n<h5 id=\"SYSTEM-WINDOW\"><a href=\"#SYSTEM-WINDOW\" class=\"headerlink\" title=\"SYSTEM WINDOW\"></a>SYSTEM WINDOW</h5><p><img src=\"http://img.blog.csdn.net/20161028152806777\" alt=\"这里写图片描述\"></p>\n<p>注释说这是系统window，一般不是由程序创建的，而在下面它给出的几类中，我们也看到了很多熟悉的身影。</p>\n<p><img src=\"http://img.blog.csdn.net/20161028152932700\" alt=\"这里写图片描述\"></p>\n<p>状态栏，搜索栏，Toast都是SYSTEM WINDOW</p>\n<p>这只是一个小插曲，我们回归正题，那么很明显Dialog应该是一个Application Window，不然它就不会报错了，我们从代码验证一下。</p>\n<p>讲真，我有点打脸，因为我没有找到代码，Dialog的构造函数是这样的。</p>\n<p><img src=\"http://img.blog.csdn.net/20161028155113014\" alt=\"这里写图片描述\"></p>\n<p>创建Window的代码在PolicyManager中，代码如下</p>\n<p><img src=\"http://img.blog.csdn.net/20161028155158458\" alt=\"这里写图片描述\"></p>\n<p>这里感觉有点打脸了，难道代码跟不下去了？网上查了一些资料，看到一个比较合理的解释是，因为我的源码是SDK的源码，而不是真正编译系统的源码，所以这块内容被屏蔽掉了。没关系，万能的百度说正确的代码是下面这个样子的。</p>\n<p><img src=\"http://img.blog.csdn.net/20161028162358849\" alt=\"这里写图片描述\"></p>\n<p>看到了静态区动态加载了Policy，这就好说了，我们去看Policy的makeNewWindow吧。</p>\n<p><img src=\"http://img.blog.csdn.net/20161028162517980\" alt=\"这里写图片描述\"></p>\n<p>返回的是一个PhoneWindow，我没有从代码中找到明确把PhoneWindow设置类型为TYPE_APPLICATION的地方，于是想看一下Window的默认Type是什么。</p>\n<p><img src=\"http://img.blog.csdn.net/20161028170422891\" alt=\"这里写图片描述\"></p>\n<p><img src=\"http://img.blog.csdn.net/20161028170435500\" alt=\"这里写图片描述\"></p>\n<p><img src=\"http://img.blog.csdn.net/20161028170445195\" alt=\"这里写图片描述\"></p>\n<p>所以，默认type是TYPE_APPLICATION类型的。PhoneWindow也就是TYPE APPLICATION类型的。</p>\n<p>然后我们再看下一点，Dialog的Token是什么<br>Dialog的Token是null，这个可以从代码上看出来。第二个参数设置的就是token。</p>\n<p><img src=\"http://img.blog.csdn.net/20161028165305907\" alt=\"这里写图片描述\"></p>\n<p>只是如果View的Token是null，WindowManager又会怎么操作呢。我们从异常处反向追一下代码。前面说到了，异常是从WindowManagerService的addWindow方法报出来的，检验的是Token是否是AppToken。</p>\n<p><img src=\"http://img.blog.csdn.net/20161031102436168\" alt=\"这里写图片描述\"></p>\n<p>addWindow的调用链是这样的，我正向来说一下比较好理解，Dialog的show方法时，调用了mWindowManager的addView方法。</p>\n<p><img src=\"http://img.blog.csdn.net/20161031102800676\" alt=\"这里写图片描述\"></p>\n<p>mWindowManager的实现是WindowManagerImpl，调用的是WindowManagerGlobal的addView</p>\n<p><img src=\"http://img.blog.csdn.net/20161031102949037\" alt=\"这里写图片描述\"></p>\n<p>WindowManagerGlobal的addView方法调到了ViewRootImpl的setView</p>\n<p><img src=\"http://img.blog.csdn.net/20161031103246376\" alt=\"这里写图片描述\"></p>\n<p>然后正如前面说到的，setView方法调到了通过WindowSession调用了WindowManagerService的addWindow，检查Token并报出异常。</p>\n<p>这样就很明确了，这个token跟Dialog中的mWindowManager有关，初始化的时候已经看到mWindowManger跟Context有关。</p>\n<p><img src=\"http://img.blog.csdn.net/20161031103849988\" alt=\"这里写图片描述\"></p>\n<p>如果这个Context是Activity，我们看下mWindowManager是如何表现的。在Activity中，如果要获取WindowService，Activity会把自己的mWindowManager返回过去。</p>\n<p><img src=\"http://img.blog.csdn.net/20161031104032942\" alt=\"这里写图片描述\"></p>\n<p>而这个WindowManager的初始化是在Activity的attach方法中，从以下代码中我们看到，这个WIndowManager设置过appToken。</p>\n<p><img src=\"http://img.blog.csdn.net/20161031104348943\" alt=\"这里写图片描述\"></p>\n<p>否则的话，如果Dialog的Context是其他，如Application，因为这几个Context没有重写getSystemService方法，所以调用的是父类ContextWrapper中的getSystemService。</p>\n<p><img src=\"http://img.blog.csdn.net/20161031104822710\" alt=\"这里写图片描述\"></p>\n<p>在第二篇文章<a href=\"http://zwgeek.com/2016/10/25/Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%902/\">Activity启动流程分析（二）</a> 中分析过，ContextWrapper中的mBase是ContextImpl类型的。</p>\n<p>ContextImpl中的getSystemtService获取的是SYSTEM_SERVICE_MAP中的Service。</p>\n<p><img src=\"http://img.blog.csdn.net/20161031105217598\" alt=\"这里写图片描述\"></p>\n<p>这个map中的service是在static块中放进去的</p>\n<p><img src=\"http://img.blog.csdn.net/20161031105401819\" alt=\"这里写图片描述\"></p>\n<p>其中也包括Window Service</p>\n<p><img src=\"http://img.blog.csdn.net/20161031105444244\" alt=\"这里写图片描述\"></p>\n<p>这里很简单，就是返回了一个WindowManagerImpl的实例，而我们知道WindowManagerImpl的实例中是没有AppToken的。</p>\n<p>综上所述，只有Activity的WindowManager是设置过AppToken的，所以，只有Context是Activity的时候，才能保证Dialog的show方法不返回异常。</p>\n<p>为什么创建一个Dialog一定要带AppToken呢，其实不是什么技术上有问题，而是android的一种安全措施，原因在注释中也写的很清楚。</p>\n<p><img src=\"http://img.blog.csdn.net/20161031113058149\" alt=\"这里写图片描述\"></p>\n<p>一个TYPE_APPLICATION类型的window必须带APPTOKEN，已区别它显示在哪个窗口上，这就限制了Dialog只能显示在创建它的Activity上，是一种安全措施。</p>\n<p>ok，之前分析文章提出的三个问题已经作答完毕。</p>\n<p>例行广告，喜欢这篇文章的同学可以关注我的博客<a href=\"http://zwgeek.com\">http://zwgeek.com</a></p>\n"},{"title":"Activity的管理结构分析及源码解析","date":"2016-11-02T09:03:13.000Z","_content":"\n\n例行广告，喜欢这篇文章的朋友可以关注我的博客[http://zwgeek.com](http://zwgeek.com)\n\n之前几篇文章分析了Activity的启动流程，当时因为要抓启动的主线，所以中间涉及到一些类之间的关系都一笔带过了。后来再重新看前面文章的时候发现没有这部分的讲解，很影响理解，所以今天准备把这些详细拿出来讲一下。\n\n没看过Activity启动流程分析的同学可以去看一下，因为这篇文章中会直接引用启动流程中已经说过的一些点。以下是传送门。\n\n[Activity启动流程分析](http://zwgeek.com/2016/10/09/Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/)\n\n[Activity启动流程分析(二)](http://zwgeek.com/2016/10/25/Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%902/)\n\n[Activity启动流程番外篇](http://zwgeek.com/2016/10/26/Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E7%95%AA%E5%A4%96%E7%AF%87/)\n\n这篇文章是带着这样一个问题来讲的，我们知道Android分为Server和Client两部分，那么Activity在这两部分中是怎么被组织被管理的。管理Activity的各部分组件又是什么时候生成的，并且在管理过程中起到了什么作用。\n\n### Activity的管理结构\n\n先放一张结果图\n\n![这里写图片描述](http://img.blog.csdn.net/20161102165944689)\n\n这就是整个Android中对Activity的管理结构，左边是Client端也就是APP部分，右边是Server端也就是Android System部分。\n\n我们先来看Server端，在Server端跟Activity有关系的最大的类就是ActivityManagerService了，但是它更像是一个上帝类，而不是管理结构中的一部分，所以我就没有把它列在图上。\n\n那么我们依次来看图上的部分\nActivityStackSupervisor，这个类像是一个工具类，会封装一些管理Activity的操作，但相信我，真正做事情的肯定不是它。\n\n下面就是管理结构了，最外层是ActivityStack，直译过来是Activity栈，但却不是我们通常意义上理解的Activity栈，因为这个ActivityStack在Android中只有两个，HomeStack和FocusStack，跟Launcher有关的Activity都在HomeStack中，其他所有Activity都在FocusStack中。\n\n然后ActivityStack中有TaskRecord，这个TaskRecord才是我们理解的Activity栈，一系列有关的Activity都在一个TaskRecord中，并且只有在一个TaskRecord中的Activity才能调用startActivityForResult，这个是前面提到的。这个TaskRecord跟两个参数息息相关。\n\n- FLAG_ACTIVITY_NEW_TASK\n- affinity\n\n这两个参数熟悉开发的朋友应该都很熟悉吧。\n\n然后在TaskRecord中有ActivityRecord，这个ActivityRecord在Server端就对应着一个Activity。是的，在Server端并没有真正的Activity实例，而只有Activity的token，而这个token就是存在ActivityRecord中的appToken，ActivityRecord还记录了一些其他的必要信息。\n\nToken的类型是IApplicationToken.Stub，也是个Binder对象，服务端只存储Activity对应的Token。而真正的Activity实例是存储在Client端的。Server端就是通过token去Client端找到对应的Activity实例的。\n\n接下来我们看Client端，在Client端也不是直接存储Activity的，因为还有一些Activity的信息要记录，所以Client端存的是Activity的包装类ActivityClientRecord，在ActivityClientRecord中包含有真正的Activity实例。\n\n整个管理结构就是这样的，其实很简单。但是要从Android那繁杂错乱的源码中梳理出这层关系，还真是花了我好长时间。下面我们从源码中来验证这层管理关系。\n\n#### 1. ActivityStackSupervisor\n\n```java\n/** The stack containing the launcher app. Assumed to always be attached to\n     * Display.DEFAULT_DISPLAY. */\n    private ActivityStack mHomeStack;\n\n    /** The stack currently receiving input or launching the next activity. */\n    private ActivityStack mFocusedStack;\n\n    /** If this is the same as mFocusedStack then the activity on the top of the focused stack has\n     * been resumed. If stacks are changing position this will hold the old stack until the new\n     * stack becomes resumed after which it will be set to mFocusedStack. */\n    private ActivityStack mLastFocusedStack;\n```\n\nActivityStackSupervisor中就这三个ActivityStack，正如前面说的mHomeStack是存所有与Launcher有关的Activity。mFocusStack是存所有其他的Activity。mLastFocusedStack是一个备份用的，从注释可以看出，是用来备份mFocusStack的。\n\n至于为什么这样做，当然为了用户体验了，用户可以随时回到桌面就是因为这种管理结构。\n\n#### 2. ActivityStack\n\n```java\n/**\n     * The back history of all previous (and possibly still\n     * running) activities.  It contains #TaskRecord objects.\n     */\n    private ArrayList<TaskRecord> mTaskHistory = new ArrayList<TaskRecord>();\n```\n\nActivityStack中存有一个TaskRecord的List，不同的TaskRecord就保存在这个List中。\n\n另外，为了方便调用，AMS中这些类都持有它上一级管理者的引用，比如在ActivityStack代码中你就可以看到这样的引用。\n\n```java\n  /** Run all ActivityStacks through this */\n    final ActivityStackSupervisor mStackSupervisor;\n```\n\n#### 3. TaskRecord\n\n```java\n/** List of all activities in the task arranged in history order */\n    final ArrayList<ActivityRecord> mActivities;\n```\n\nTaskRecord中存的是一个ActivityRecord的List，这个List就是我们传统意义上理解的Activity栈，这个List中Activity的顺序也就是Activity在屏幕上被启动的顺序。\n\n同样的，TaskRecord也持有它的上一级管理器ActivityStack的引用。\n\n```java\n/** Current stack */\n    ActivityStack stack;\n```\n\n#### 4. ActivityRecord\n在AMS这边的Activity，就是ActivityRecord了，它的变量中有真正Activity对应的token。\n\n```java\nfinal IApplicationToken.Stub appToken; // window manager token\n```\n\n同时，他也持有它父管理器的一些引用\n```java\nTaskRecord task;        // the task this is in.\n```\n\n```java\nfinal ActivityManagerService service; // owner\n```\n\n以上就是Server端对Activity的管理结构，接下来我们看Client端的管理结构\n\n#### 5. ActivityThread\nClient这边最大的类是ActivityThread，我们知道，在ActivityThread中就管理着所有的Acitivity。\n\n```java\nfinal ArrayMap<IBinder, ActivityClientRecord> mActivities\n            = new ArrayMap<IBinder, ActivityClientRecord>();\n```\n\nActivityThread中有一个ActivityClientRecord的Map，Map的key就是Activity的token。\n\n#### 6. ActivityClientRecord\n\n在ActivityClientRecord中，存有真正的Activity实例和他对应的token。\n\n```java\nIBinder token;\nActivity activity;\n```\n\n#### 7. 相互调用\n接下来我们用一小段代码来说明一下Server端是怎么查找到Activity的。\n\n```java\n//调用onResume              next.app.thread.scheduleResumeActivity(next.appToken, next.app.repProcState,mService.isNextTransitionForward(), resumeAnimOptions);\n```\n\n这是在ActivityStack中的一段调用Resume的方法，看了前面的Activity启动流程分析，我们知道scheduleResumeActivity最终会被ActivityThread的handleResumeActivity处理。\n\nhandleResumeActivity又交给了performResumeActivity去处理这件事，我们看performResumeActivity的代码。\n\n```java\n public final ActivityClientRecord performResumeActivity(IBinder token,\n            boolean clearHide) {\n        ActivityClientRecord r = mActivities.get(token);\n        ...\n        r.activity.performResume();\n```\n\n看，Client端会首先根据token从mActivities中找到ActivityClientRecord，然后取出AcitivityClientRecord中的Activity，去调用它的onResume方法。\n\n\n\n### 管理结构的创建时间点\n\n好的，已经讲完了Activity的管理结构，我们知道在Activity的启动过程中，这个管理结构的类会被依次创建，那么他们是在什么时间点被创建的呢？\n\n前面分析Activity的时候我没有特别去讲解这个结构的创建，这里就补充一下这个点。我会说每个结构是在哪个方法中被创建的，但是方法是在什么时候调用的， 不清楚的同学可以去查阅Activity启动流程分析。\n\nActivityStackSupervisor因为很重要，所以在ActivityManagerService构造函数的时候就创建了。\n\n```java\n public ActivityManagerService(Context systemContext) {\n        ...\n        mStackSupervisor = new ActivityStackSupervisor(this);\n        ...\n }\n```\n\nActivityRecord是在ActivityStackSupervisor的startActivityLocked中被创建的，如下图\n\n![这里写图片描述](http://img.blog.csdn.net/20161102175329326)\n\n然后ActivityStack和TaskRecord在同个类的startActivityUncheckedlocked方法中被创建，如下图。\n\n![这里写图片描述](http://img.blog.csdn.net/20161102175501924)\n\nadjustStackFocus中会创建ActivityStack，但是正如前面说的，只有当mFocusStack没有被创建的时候才会重新创建，如果mFocusStack已经有啦，那么，就用mFocusStack。\n\n至此，Server端这边的结构都被创建出来了，然后再看Client端的结构。\n\nActivityClientRecord是在ActivityThread的scheduleLaunchActivity，如图\n\n![这里写图片描述](http://img.blog.csdn.net/20161102175850425)\n\n注意，这个时候Activity实例还没有被创建出来。而Activity的创建是在什么点呢。\n\n![这里写图片描述](http://img.blog.csdn.net/20161102180002769)\n\n\n在performLaunchActivity中，并且创建完了之后把自己加入到ActivityClientRecord中，然后把ActivityCLientRecord加入到mActivities中。\n\n至此，所有的管理结构都创建完成，Activity也基本启动完成了。\n\n例行广告，喜欢这篇文章的朋友可以关注我的博客[http://zwgeek.com](http://zwgeek.com)\n\n\n\n\n","source":"_posts/Activity管理结构及源码分析.md","raw":"---\ntitle: Activity的管理结构分析及源码解析\ndate: 2016-11-02 17:03:13\ntags:\n  - Android\n  - Activity启动\n  - 系统\ncategories: Android\n---\n\n\n例行广告，喜欢这篇文章的朋友可以关注我的博客[http://zwgeek.com](http://zwgeek.com)\n\n之前几篇文章分析了Activity的启动流程，当时因为要抓启动的主线，所以中间涉及到一些类之间的关系都一笔带过了。后来再重新看前面文章的时候发现没有这部分的讲解，很影响理解，所以今天准备把这些详细拿出来讲一下。\n\n没看过Activity启动流程分析的同学可以去看一下，因为这篇文章中会直接引用启动流程中已经说过的一些点。以下是传送门。\n\n[Activity启动流程分析](http://zwgeek.com/2016/10/09/Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/)\n\n[Activity启动流程分析(二)](http://zwgeek.com/2016/10/25/Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%902/)\n\n[Activity启动流程番外篇](http://zwgeek.com/2016/10/26/Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E7%95%AA%E5%A4%96%E7%AF%87/)\n\n这篇文章是带着这样一个问题来讲的，我们知道Android分为Server和Client两部分，那么Activity在这两部分中是怎么被组织被管理的。管理Activity的各部分组件又是什么时候生成的，并且在管理过程中起到了什么作用。\n\n### Activity的管理结构\n\n先放一张结果图\n\n![这里写图片描述](http://img.blog.csdn.net/20161102165944689)\n\n这就是整个Android中对Activity的管理结构，左边是Client端也就是APP部分，右边是Server端也就是Android System部分。\n\n我们先来看Server端，在Server端跟Activity有关系的最大的类就是ActivityManagerService了，但是它更像是一个上帝类，而不是管理结构中的一部分，所以我就没有把它列在图上。\n\n那么我们依次来看图上的部分\nActivityStackSupervisor，这个类像是一个工具类，会封装一些管理Activity的操作，但相信我，真正做事情的肯定不是它。\n\n下面就是管理结构了，最外层是ActivityStack，直译过来是Activity栈，但却不是我们通常意义上理解的Activity栈，因为这个ActivityStack在Android中只有两个，HomeStack和FocusStack，跟Launcher有关的Activity都在HomeStack中，其他所有Activity都在FocusStack中。\n\n然后ActivityStack中有TaskRecord，这个TaskRecord才是我们理解的Activity栈，一系列有关的Activity都在一个TaskRecord中，并且只有在一个TaskRecord中的Activity才能调用startActivityForResult，这个是前面提到的。这个TaskRecord跟两个参数息息相关。\n\n- FLAG_ACTIVITY_NEW_TASK\n- affinity\n\n这两个参数熟悉开发的朋友应该都很熟悉吧。\n\n然后在TaskRecord中有ActivityRecord，这个ActivityRecord在Server端就对应着一个Activity。是的，在Server端并没有真正的Activity实例，而只有Activity的token，而这个token就是存在ActivityRecord中的appToken，ActivityRecord还记录了一些其他的必要信息。\n\nToken的类型是IApplicationToken.Stub，也是个Binder对象，服务端只存储Activity对应的Token。而真正的Activity实例是存储在Client端的。Server端就是通过token去Client端找到对应的Activity实例的。\n\n接下来我们看Client端，在Client端也不是直接存储Activity的，因为还有一些Activity的信息要记录，所以Client端存的是Activity的包装类ActivityClientRecord，在ActivityClientRecord中包含有真正的Activity实例。\n\n整个管理结构就是这样的，其实很简单。但是要从Android那繁杂错乱的源码中梳理出这层关系，还真是花了我好长时间。下面我们从源码中来验证这层管理关系。\n\n#### 1. ActivityStackSupervisor\n\n```java\n/** The stack containing the launcher app. Assumed to always be attached to\n     * Display.DEFAULT_DISPLAY. */\n    private ActivityStack mHomeStack;\n\n    /** The stack currently receiving input or launching the next activity. */\n    private ActivityStack mFocusedStack;\n\n    /** If this is the same as mFocusedStack then the activity on the top of the focused stack has\n     * been resumed. If stacks are changing position this will hold the old stack until the new\n     * stack becomes resumed after which it will be set to mFocusedStack. */\n    private ActivityStack mLastFocusedStack;\n```\n\nActivityStackSupervisor中就这三个ActivityStack，正如前面说的mHomeStack是存所有与Launcher有关的Activity。mFocusStack是存所有其他的Activity。mLastFocusedStack是一个备份用的，从注释可以看出，是用来备份mFocusStack的。\n\n至于为什么这样做，当然为了用户体验了，用户可以随时回到桌面就是因为这种管理结构。\n\n#### 2. ActivityStack\n\n```java\n/**\n     * The back history of all previous (and possibly still\n     * running) activities.  It contains #TaskRecord objects.\n     */\n    private ArrayList<TaskRecord> mTaskHistory = new ArrayList<TaskRecord>();\n```\n\nActivityStack中存有一个TaskRecord的List，不同的TaskRecord就保存在这个List中。\n\n另外，为了方便调用，AMS中这些类都持有它上一级管理者的引用，比如在ActivityStack代码中你就可以看到这样的引用。\n\n```java\n  /** Run all ActivityStacks through this */\n    final ActivityStackSupervisor mStackSupervisor;\n```\n\n#### 3. TaskRecord\n\n```java\n/** List of all activities in the task arranged in history order */\n    final ArrayList<ActivityRecord> mActivities;\n```\n\nTaskRecord中存的是一个ActivityRecord的List，这个List就是我们传统意义上理解的Activity栈，这个List中Activity的顺序也就是Activity在屏幕上被启动的顺序。\n\n同样的，TaskRecord也持有它的上一级管理器ActivityStack的引用。\n\n```java\n/** Current stack */\n    ActivityStack stack;\n```\n\n#### 4. ActivityRecord\n在AMS这边的Activity，就是ActivityRecord了，它的变量中有真正Activity对应的token。\n\n```java\nfinal IApplicationToken.Stub appToken; // window manager token\n```\n\n同时，他也持有它父管理器的一些引用\n```java\nTaskRecord task;        // the task this is in.\n```\n\n```java\nfinal ActivityManagerService service; // owner\n```\n\n以上就是Server端对Activity的管理结构，接下来我们看Client端的管理结构\n\n#### 5. ActivityThread\nClient这边最大的类是ActivityThread，我们知道，在ActivityThread中就管理着所有的Acitivity。\n\n```java\nfinal ArrayMap<IBinder, ActivityClientRecord> mActivities\n            = new ArrayMap<IBinder, ActivityClientRecord>();\n```\n\nActivityThread中有一个ActivityClientRecord的Map，Map的key就是Activity的token。\n\n#### 6. ActivityClientRecord\n\n在ActivityClientRecord中，存有真正的Activity实例和他对应的token。\n\n```java\nIBinder token;\nActivity activity;\n```\n\n#### 7. 相互调用\n接下来我们用一小段代码来说明一下Server端是怎么查找到Activity的。\n\n```java\n//调用onResume              next.app.thread.scheduleResumeActivity(next.appToken, next.app.repProcState,mService.isNextTransitionForward(), resumeAnimOptions);\n```\n\n这是在ActivityStack中的一段调用Resume的方法，看了前面的Activity启动流程分析，我们知道scheduleResumeActivity最终会被ActivityThread的handleResumeActivity处理。\n\nhandleResumeActivity又交给了performResumeActivity去处理这件事，我们看performResumeActivity的代码。\n\n```java\n public final ActivityClientRecord performResumeActivity(IBinder token,\n            boolean clearHide) {\n        ActivityClientRecord r = mActivities.get(token);\n        ...\n        r.activity.performResume();\n```\n\n看，Client端会首先根据token从mActivities中找到ActivityClientRecord，然后取出AcitivityClientRecord中的Activity，去调用它的onResume方法。\n\n\n\n### 管理结构的创建时间点\n\n好的，已经讲完了Activity的管理结构，我们知道在Activity的启动过程中，这个管理结构的类会被依次创建，那么他们是在什么时间点被创建的呢？\n\n前面分析Activity的时候我没有特别去讲解这个结构的创建，这里就补充一下这个点。我会说每个结构是在哪个方法中被创建的，但是方法是在什么时候调用的， 不清楚的同学可以去查阅Activity启动流程分析。\n\nActivityStackSupervisor因为很重要，所以在ActivityManagerService构造函数的时候就创建了。\n\n```java\n public ActivityManagerService(Context systemContext) {\n        ...\n        mStackSupervisor = new ActivityStackSupervisor(this);\n        ...\n }\n```\n\nActivityRecord是在ActivityStackSupervisor的startActivityLocked中被创建的，如下图\n\n![这里写图片描述](http://img.blog.csdn.net/20161102175329326)\n\n然后ActivityStack和TaskRecord在同个类的startActivityUncheckedlocked方法中被创建，如下图。\n\n![这里写图片描述](http://img.blog.csdn.net/20161102175501924)\n\nadjustStackFocus中会创建ActivityStack，但是正如前面说的，只有当mFocusStack没有被创建的时候才会重新创建，如果mFocusStack已经有啦，那么，就用mFocusStack。\n\n至此，Server端这边的结构都被创建出来了，然后再看Client端的结构。\n\nActivityClientRecord是在ActivityThread的scheduleLaunchActivity，如图\n\n![这里写图片描述](http://img.blog.csdn.net/20161102175850425)\n\n注意，这个时候Activity实例还没有被创建出来。而Activity的创建是在什么点呢。\n\n![这里写图片描述](http://img.blog.csdn.net/20161102180002769)\n\n\n在performLaunchActivity中，并且创建完了之后把自己加入到ActivityClientRecord中，然后把ActivityCLientRecord加入到mActivities中。\n\n至此，所有的管理结构都创建完成，Activity也基本启动完成了。\n\n例行广告，喜欢这篇文章的朋友可以关注我的博客[http://zwgeek.com](http://zwgeek.com)\n\n\n\n\n","slug":"Activity管理结构及源码分析","published":1,"updated":"2024-06-14T09:25:33.675Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clxjsxtvw0008lq6gk73exovt","content":"<p>例行广告，喜欢这篇文章的朋友可以关注我的博客<a href=\"http://zwgeek.com\">http://zwgeek.com</a></p>\n<p>之前几篇文章分析了Activity的启动流程，当时因为要抓启动的主线，所以中间涉及到一些类之间的关系都一笔带过了。后来再重新看前面文章的时候发现没有这部分的讲解，很影响理解，所以今天准备把这些详细拿出来讲一下。</p>\n<p>没看过Activity启动流程分析的同学可以去看一下，因为这篇文章中会直接引用启动流程中已经说过的一些点。以下是传送门。</p>\n<p><a href=\"http://zwgeek.com/2016/10/09/Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/\">Activity启动流程分析</a></p>\n<p><a href=\"http://zwgeek.com/2016/10/25/Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%902/\">Activity启动流程分析(二)</a></p>\n<p><a href=\"http://zwgeek.com/2016/10/26/Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E7%95%AA%E5%A4%96%E7%AF%87/\">Activity启动流程番外篇</a></p>\n<p>这篇文章是带着这样一个问题来讲的，我们知道Android分为Server和Client两部分，那么Activity在这两部分中是怎么被组织被管理的。管理Activity的各部分组件又是什么时候生成的，并且在管理过程中起到了什么作用。</p>\n<h3 id=\"Activity的管理结构\"><a href=\"#Activity的管理结构\" class=\"headerlink\" title=\"Activity的管理结构\"></a>Activity的管理结构</h3><p>先放一张结果图</p>\n<p><img src=\"http://img.blog.csdn.net/20161102165944689\" alt=\"这里写图片描述\"></p>\n<p>这就是整个Android中对Activity的管理结构，左边是Client端也就是APP部分，右边是Server端也就是Android System部分。</p>\n<p>我们先来看Server端，在Server端跟Activity有关系的最大的类就是ActivityManagerService了，但是它更像是一个上帝类，而不是管理结构中的一部分，所以我就没有把它列在图上。</p>\n<p>那么我们依次来看图上的部分<br>ActivityStackSupervisor，这个类像是一个工具类，会封装一些管理Activity的操作，但相信我，真正做事情的肯定不是它。</p>\n<p>下面就是管理结构了，最外层是ActivityStack，直译过来是Activity栈，但却不是我们通常意义上理解的Activity栈，因为这个ActivityStack在Android中只有两个，HomeStack和FocusStack，跟Launcher有关的Activity都在HomeStack中，其他所有Activity都在FocusStack中。</p>\n<p>然后ActivityStack中有TaskRecord，这个TaskRecord才是我们理解的Activity栈，一系列有关的Activity都在一个TaskRecord中，并且只有在一个TaskRecord中的Activity才能调用startActivityForResult，这个是前面提到的。这个TaskRecord跟两个参数息息相关。</p>\n<ul>\n<li>FLAG_ACTIVITY_NEW_TASK</li>\n<li>affinity</li>\n</ul>\n<p>这两个参数熟悉开发的朋友应该都很熟悉吧。</p>\n<p>然后在TaskRecord中有ActivityRecord，这个ActivityRecord在Server端就对应着一个Activity。是的，在Server端并没有真正的Activity实例，而只有Activity的token，而这个token就是存在ActivityRecord中的appToken，ActivityRecord还记录了一些其他的必要信息。</p>\n<p>Token的类型是IApplicationToken.Stub，也是个Binder对象，服务端只存储Activity对应的Token。而真正的Activity实例是存储在Client端的。Server端就是通过token去Client端找到对应的Activity实例的。</p>\n<p>接下来我们看Client端，在Client端也不是直接存储Activity的，因为还有一些Activity的信息要记录，所以Client端存的是Activity的包装类ActivityClientRecord，在ActivityClientRecord中包含有真正的Activity实例。</p>\n<p>整个管理结构就是这样的，其实很简单。但是要从Android那繁杂错乱的源码中梳理出这层关系，还真是花了我好长时间。下面我们从源码中来验证这层管理关系。</p>\n<h4 id=\"1-ActivityStackSupervisor\"><a href=\"#1-ActivityStackSupervisor\" class=\"headerlink\" title=\"1. ActivityStackSupervisor\"></a>1. ActivityStackSupervisor</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/** The stack containing the launcher app. Assumed to always be attached to</span></div><div class=\"line\">     * Display.DEFAULT_DISPLAY. */</div><div class=\"line\">    <span class=\"keyword\">private</span> ActivityStack mHomeStack;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/** The stack currently receiving input or launching the next activity. */</span></div><div class=\"line\">    <span class=\"keyword\">private</span> ActivityStack mFocusedStack;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/** If this is the same as mFocusedStack then the activity on the top of the focused stack has</span></div><div class=\"line\">     * been resumed. If stacks are changing position this will hold the old stack until the new</div><div class=\"line\">     * stack becomes resumed after which it will be set to mFocusedStack. */</div><div class=\"line\">    <span class=\"keyword\">private</span> ActivityStack mLastFocusedStack;</div></pre></td></tr></table></figure>\n<p>ActivityStackSupervisor中就这三个ActivityStack，正如前面说的mHomeStack是存所有与Launcher有关的Activity。mFocusStack是存所有其他的Activity。mLastFocusedStack是一个备份用的，从注释可以看出，是用来备份mFocusStack的。</p>\n<p>至于为什么这样做，当然为了用户体验了，用户可以随时回到桌面就是因为这种管理结构。</p>\n<h4 id=\"2-ActivityStack\"><a href=\"#2-ActivityStack\" class=\"headerlink\" title=\"2. ActivityStack\"></a>2. ActivityStack</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\">     * The back history of all previous (and possibly still</div><div class=\"line\">     * running) activities.  It contains #TaskRecord objects.</div><div class=\"line\">     */</div><div class=\"line\">    <span class=\"keyword\">private</span> ArrayList&lt;TaskRecord&gt; mTaskHistory = <span class=\"keyword\">new</span> ArrayList&lt;TaskRecord&gt;();</div></pre></td></tr></table></figure>\n<p>ActivityStack中存有一个TaskRecord的List，不同的TaskRecord就保存在这个List中。</p>\n<p>另外，为了方便调用，AMS中这些类都持有它上一级管理者的引用，比如在ActivityStack代码中你就可以看到这样的引用。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/** Run all ActivityStacks through this */</span></div><div class=\"line\">  <span class=\"keyword\">final</span> ActivityStackSupervisor mStackSupervisor;</div></pre></td></tr></table></figure>\n<h4 id=\"3-TaskRecord\"><a href=\"#3-TaskRecord\" class=\"headerlink\" title=\"3. TaskRecord\"></a>3. TaskRecord</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/** List of all activities in the task arranged in history order */</span></div><div class=\"line\">    <span class=\"keyword\">final</span> ArrayList&lt;ActivityRecord&gt; mActivities;</div></pre></td></tr></table></figure>\n<p>TaskRecord中存的是一个ActivityRecord的List，这个List就是我们传统意义上理解的Activity栈，这个List中Activity的顺序也就是Activity在屏幕上被启动的顺序。</p>\n<p>同样的，TaskRecord也持有它的上一级管理器ActivityStack的引用。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/** Current stack */</span></div><div class=\"line\">    ActivityStack stack;</div></pre></td></tr></table></figure>\n<h4 id=\"4-ActivityRecord\"><a href=\"#4-ActivityRecord\" class=\"headerlink\" title=\"4. ActivityRecord\"></a>4. ActivityRecord</h4><p>在AMS这边的Activity，就是ActivityRecord了，它的变量中有真正Activity对应的token。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">final</span> IApplicationToken.Stub appToken; <span class=\"comment\">// window manager token</span></div></pre></td></tr></table></figure>\n<p>同时，他也持有它父管理器的一些引用<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">TaskRecord task;        <span class=\"comment\">// the task this is in.</span></div></pre></td></tr></table></figure></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">final</span> ActivityManagerService service; <span class=\"comment\">// owner</span></div></pre></td></tr></table></figure>\n<p>以上就是Server端对Activity的管理结构，接下来我们看Client端的管理结构</p>\n<h4 id=\"5-ActivityThread\"><a href=\"#5-ActivityThread\" class=\"headerlink\" title=\"5. ActivityThread\"></a>5. ActivityThread</h4><p>Client这边最大的类是ActivityThread，我们知道，在ActivityThread中就管理着所有的Acitivity。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">final</span> ArrayMap&lt;IBinder, ActivityClientRecord&gt; mActivities</div><div class=\"line\">            = <span class=\"keyword\">new</span> ArrayMap&lt;IBinder, ActivityClientRecord&gt;();</div></pre></td></tr></table></figure>\n<p>ActivityThread中有一个ActivityClientRecord的Map，Map的key就是Activity的token。</p>\n<h4 id=\"6-ActivityClientRecord\"><a href=\"#6-ActivityClientRecord\" class=\"headerlink\" title=\"6. ActivityClientRecord\"></a>6. ActivityClientRecord</h4><p>在ActivityClientRecord中，存有真正的Activity实例和他对应的token。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">IBinder token;</div><div class=\"line\">Activity activity;</div></pre></td></tr></table></figure>\n<h4 id=\"7-相互调用\"><a href=\"#7-相互调用\" class=\"headerlink\" title=\"7. 相互调用\"></a>7. 相互调用</h4><p>接下来我们用一小段代码来说明一下Server端是怎么查找到Activity的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//调用onResume              next.app.thread.scheduleResumeActivity(next.appToken, next.app.repProcState,mService.isNextTransitionForward(), resumeAnimOptions);</span></div></pre></td></tr></table></figure>\n<p>这是在ActivityStack中的一段调用Resume的方法，看了前面的Activity启动流程分析，我们知道scheduleResumeActivity最终会被ActivityThread的handleResumeActivity处理。</p>\n<p>handleResumeActivity又交给了performResumeActivity去处理这件事，我们看performResumeActivity的代码。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> ActivityClientRecord <span class=\"title\">performResumeActivity</span><span class=\"params\">(IBinder token,</span></span></div><div class=\"line\">           <span class=\"keyword\">boolean</span> clearHide) &#123;</div><div class=\"line\">       ActivityClientRecord r = mActivities.get(token);</div><div class=\"line\">       ...</div><div class=\"line\">       r.activity.performResume();</div></pre></td></tr></table></figure>\n<p>看，Client端会首先根据token从mActivities中找到ActivityClientRecord，然后取出AcitivityClientRecord中的Activity，去调用它的onResume方法。</p>\n<h3 id=\"管理结构的创建时间点\"><a href=\"#管理结构的创建时间点\" class=\"headerlink\" title=\"管理结构的创建时间点\"></a>管理结构的创建时间点</h3><p>好的，已经讲完了Activity的管理结构，我们知道在Activity的启动过程中，这个管理结构的类会被依次创建，那么他们是在什么时间点被创建的呢？</p>\n<p>前面分析Activity的时候我没有特别去讲解这个结构的创建，这里就补充一下这个点。我会说每个结构是在哪个方法中被创建的，但是方法是在什么时候调用的， 不清楚的同学可以去查阅Activity启动流程分析。</p>\n<p>ActivityStackSupervisor因为很重要，所以在ActivityManagerService构造函数的时候就创建了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ActivityManagerService</span><span class=\"params\">(Context systemContext)</span> </span>&#123;</div><div class=\"line\">       ...</div><div class=\"line\">       mStackSupervisor = <span class=\"keyword\">new</span> ActivityStackSupervisor(<span class=\"keyword\">this</span>);</div><div class=\"line\">       ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>ActivityRecord是在ActivityStackSupervisor的startActivityLocked中被创建的，如下图</p>\n<p><img src=\"http://img.blog.csdn.net/20161102175329326\" alt=\"这里写图片描述\"></p>\n<p>然后ActivityStack和TaskRecord在同个类的startActivityUncheckedlocked方法中被创建，如下图。</p>\n<p><img src=\"http://img.blog.csdn.net/20161102175501924\" alt=\"这里写图片描述\"></p>\n<p>adjustStackFocus中会创建ActivityStack，但是正如前面说的，只有当mFocusStack没有被创建的时候才会重新创建，如果mFocusStack已经有啦，那么，就用mFocusStack。</p>\n<p>至此，Server端这边的结构都被创建出来了，然后再看Client端的结构。</p>\n<p>ActivityClientRecord是在ActivityThread的scheduleLaunchActivity，如图</p>\n<p><img src=\"http://img.blog.csdn.net/20161102175850425\" alt=\"这里写图片描述\"></p>\n<p>注意，这个时候Activity实例还没有被创建出来。而Activity的创建是在什么点呢。</p>\n<p><img src=\"http://img.blog.csdn.net/20161102180002769\" alt=\"这里写图片描述\"></p>\n<p>在performLaunchActivity中，并且创建完了之后把自己加入到ActivityClientRecord中，然后把ActivityCLientRecord加入到mActivities中。</p>\n<p>至此，所有的管理结构都创建完成，Activity也基本启动完成了。</p>\n<p>例行广告，喜欢这篇文章的朋友可以关注我的博客<a href=\"http://zwgeek.com\">http://zwgeek.com</a></p>\n","excerpt":"","more":"<p>例行广告，喜欢这篇文章的朋友可以关注我的博客<a href=\"http://zwgeek.com\">http://zwgeek.com</a></p>\n<p>之前几篇文章分析了Activity的启动流程，当时因为要抓启动的主线，所以中间涉及到一些类之间的关系都一笔带过了。后来再重新看前面文章的时候发现没有这部分的讲解，很影响理解，所以今天准备把这些详细拿出来讲一下。</p>\n<p>没看过Activity启动流程分析的同学可以去看一下，因为这篇文章中会直接引用启动流程中已经说过的一些点。以下是传送门。</p>\n<p><a href=\"http://zwgeek.com/2016/10/09/Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/\">Activity启动流程分析</a></p>\n<p><a href=\"http://zwgeek.com/2016/10/25/Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%902/\">Activity启动流程分析(二)</a></p>\n<p><a href=\"http://zwgeek.com/2016/10/26/Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E7%95%AA%E5%A4%96%E7%AF%87/\">Activity启动流程番外篇</a></p>\n<p>这篇文章是带着这样一个问题来讲的，我们知道Android分为Server和Client两部分，那么Activity在这两部分中是怎么被组织被管理的。管理Activity的各部分组件又是什么时候生成的，并且在管理过程中起到了什么作用。</p>\n<h3 id=\"Activity的管理结构\"><a href=\"#Activity的管理结构\" class=\"headerlink\" title=\"Activity的管理结构\"></a>Activity的管理结构</h3><p>先放一张结果图</p>\n<p><img src=\"http://img.blog.csdn.net/20161102165944689\" alt=\"这里写图片描述\"></p>\n<p>这就是整个Android中对Activity的管理结构，左边是Client端也就是APP部分，右边是Server端也就是Android System部分。</p>\n<p>我们先来看Server端，在Server端跟Activity有关系的最大的类就是ActivityManagerService了，但是它更像是一个上帝类，而不是管理结构中的一部分，所以我就没有把它列在图上。</p>\n<p>那么我们依次来看图上的部分<br>ActivityStackSupervisor，这个类像是一个工具类，会封装一些管理Activity的操作，但相信我，真正做事情的肯定不是它。</p>\n<p>下面就是管理结构了，最外层是ActivityStack，直译过来是Activity栈，但却不是我们通常意义上理解的Activity栈，因为这个ActivityStack在Android中只有两个，HomeStack和FocusStack，跟Launcher有关的Activity都在HomeStack中，其他所有Activity都在FocusStack中。</p>\n<p>然后ActivityStack中有TaskRecord，这个TaskRecord才是我们理解的Activity栈，一系列有关的Activity都在一个TaskRecord中，并且只有在一个TaskRecord中的Activity才能调用startActivityForResult，这个是前面提到的。这个TaskRecord跟两个参数息息相关。</p>\n<ul>\n<li>FLAG_ACTIVITY_NEW_TASK</li>\n<li>affinity</li>\n</ul>\n<p>这两个参数熟悉开发的朋友应该都很熟悉吧。</p>\n<p>然后在TaskRecord中有ActivityRecord，这个ActivityRecord在Server端就对应着一个Activity。是的，在Server端并没有真正的Activity实例，而只有Activity的token，而这个token就是存在ActivityRecord中的appToken，ActivityRecord还记录了一些其他的必要信息。</p>\n<p>Token的类型是IApplicationToken.Stub，也是个Binder对象，服务端只存储Activity对应的Token。而真正的Activity实例是存储在Client端的。Server端就是通过token去Client端找到对应的Activity实例的。</p>\n<p>接下来我们看Client端，在Client端也不是直接存储Activity的，因为还有一些Activity的信息要记录，所以Client端存的是Activity的包装类ActivityClientRecord，在ActivityClientRecord中包含有真正的Activity实例。</p>\n<p>整个管理结构就是这样的，其实很简单。但是要从Android那繁杂错乱的源码中梳理出这层关系，还真是花了我好长时间。下面我们从源码中来验证这层管理关系。</p>\n<h4 id=\"1-ActivityStackSupervisor\"><a href=\"#1-ActivityStackSupervisor\" class=\"headerlink\" title=\"1. ActivityStackSupervisor\"></a>1. ActivityStackSupervisor</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/** The stack containing the launcher app. Assumed to always be attached to</div><div class=\"line\">     * Display.DEFAULT_DISPLAY. */</span></div><div class=\"line\">    <span class=\"keyword\">private</span> ActivityStack mHomeStack;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/** The stack currently receiving input or launching the next activity. */</span></div><div class=\"line\">    <span class=\"keyword\">private</span> ActivityStack mFocusedStack;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/** If this is the same as mFocusedStack then the activity on the top of the focused stack has</div><div class=\"line\">     * been resumed. If stacks are changing position this will hold the old stack until the new</div><div class=\"line\">     * stack becomes resumed after which it will be set to mFocusedStack. */</span></div><div class=\"line\">    <span class=\"keyword\">private</span> ActivityStack mLastFocusedStack;</div></pre></td></tr></table></figure>\n<p>ActivityStackSupervisor中就这三个ActivityStack，正如前面说的mHomeStack是存所有与Launcher有关的Activity。mFocusStack是存所有其他的Activity。mLastFocusedStack是一个备份用的，从注释可以看出，是用来备份mFocusStack的。</p>\n<p>至于为什么这样做，当然为了用户体验了，用户可以随时回到桌面就是因为这种管理结构。</p>\n<h4 id=\"2-ActivityStack\"><a href=\"#2-ActivityStack\" class=\"headerlink\" title=\"2. ActivityStack\"></a>2. ActivityStack</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\">     * The back history of all previous (and possibly still</div><div class=\"line\">     * running) activities.  It contains #TaskRecord objects.</div><div class=\"line\">     */</span></div><div class=\"line\">    <span class=\"keyword\">private</span> ArrayList&lt;TaskRecord&gt; mTaskHistory = <span class=\"keyword\">new</span> ArrayList&lt;TaskRecord&gt;();</div></pre></td></tr></table></figure>\n<p>ActivityStack中存有一个TaskRecord的List，不同的TaskRecord就保存在这个List中。</p>\n<p>另外，为了方便调用，AMS中这些类都持有它上一级管理者的引用，比如在ActivityStack代码中你就可以看到这样的引用。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/** Run all ActivityStacks through this */</span></div><div class=\"line\">  <span class=\"keyword\">final</span> ActivityStackSupervisor mStackSupervisor;</div></pre></td></tr></table></figure>\n<h4 id=\"3-TaskRecord\"><a href=\"#3-TaskRecord\" class=\"headerlink\" title=\"3. TaskRecord\"></a>3. TaskRecord</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/** List of all activities in the task arranged in history order */</span></div><div class=\"line\">    <span class=\"keyword\">final</span> ArrayList&lt;ActivityRecord&gt; mActivities;</div></pre></td></tr></table></figure>\n<p>TaskRecord中存的是一个ActivityRecord的List，这个List就是我们传统意义上理解的Activity栈，这个List中Activity的顺序也就是Activity在屏幕上被启动的顺序。</p>\n<p>同样的，TaskRecord也持有它的上一级管理器ActivityStack的引用。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/** Current stack */</span></div><div class=\"line\">    ActivityStack stack;</div></pre></td></tr></table></figure>\n<h4 id=\"4-ActivityRecord\"><a href=\"#4-ActivityRecord\" class=\"headerlink\" title=\"4. ActivityRecord\"></a>4. ActivityRecord</h4><p>在AMS这边的Activity，就是ActivityRecord了，它的变量中有真正Activity对应的token。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">final</span> IApplicationToken.Stub appToken; <span class=\"comment\">// window manager token</span></div></pre></td></tr></table></figure>\n<p>同时，他也持有它父管理器的一些引用<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">TaskRecord task;        <span class=\"comment\">// the task this is in.</span></div></pre></td></tr></table></figure></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">final</span> ActivityManagerService service; <span class=\"comment\">// owner</span></div></pre></td></tr></table></figure>\n<p>以上就是Server端对Activity的管理结构，接下来我们看Client端的管理结构</p>\n<h4 id=\"5-ActivityThread\"><a href=\"#5-ActivityThread\" class=\"headerlink\" title=\"5. ActivityThread\"></a>5. ActivityThread</h4><p>Client这边最大的类是ActivityThread，我们知道，在ActivityThread中就管理着所有的Acitivity。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">final</span> ArrayMap&lt;IBinder, ActivityClientRecord&gt; mActivities</div><div class=\"line\">            = <span class=\"keyword\">new</span> ArrayMap&lt;IBinder, ActivityClientRecord&gt;();</div></pre></td></tr></table></figure>\n<p>ActivityThread中有一个ActivityClientRecord的Map，Map的key就是Activity的token。</p>\n<h4 id=\"6-ActivityClientRecord\"><a href=\"#6-ActivityClientRecord\" class=\"headerlink\" title=\"6. ActivityClientRecord\"></a>6. ActivityClientRecord</h4><p>在ActivityClientRecord中，存有真正的Activity实例和他对应的token。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">IBinder token;</div><div class=\"line\">Activity activity;</div></pre></td></tr></table></figure>\n<h4 id=\"7-相互调用\"><a href=\"#7-相互调用\" class=\"headerlink\" title=\"7. 相互调用\"></a>7. 相互调用</h4><p>接下来我们用一小段代码来说明一下Server端是怎么查找到Activity的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//调用onResume              next.app.thread.scheduleResumeActivity(next.appToken, next.app.repProcState,mService.isNextTransitionForward(), resumeAnimOptions);</span></div></pre></td></tr></table></figure>\n<p>这是在ActivityStack中的一段调用Resume的方法，看了前面的Activity启动流程分析，我们知道scheduleResumeActivity最终会被ActivityThread的handleResumeActivity处理。</p>\n<p>handleResumeActivity又交给了performResumeActivity去处理这件事，我们看performResumeActivity的代码。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> ActivityClientRecord <span class=\"title\">performResumeActivity</span><span class=\"params\">(IBinder token,</div><div class=\"line\">           <span class=\"keyword\">boolean</span> clearHide)</span> </span>&#123;</div><div class=\"line\">       ActivityClientRecord r = mActivities.get(token);</div><div class=\"line\">       ...</div><div class=\"line\">       r.activity.performResume();</div></pre></td></tr></table></figure>\n<p>看，Client端会首先根据token从mActivities中找到ActivityClientRecord，然后取出AcitivityClientRecord中的Activity，去调用它的onResume方法。</p>\n<h3 id=\"管理结构的创建时间点\"><a href=\"#管理结构的创建时间点\" class=\"headerlink\" title=\"管理结构的创建时间点\"></a>管理结构的创建时间点</h3><p>好的，已经讲完了Activity的管理结构，我们知道在Activity的启动过程中，这个管理结构的类会被依次创建，那么他们是在什么时间点被创建的呢？</p>\n<p>前面分析Activity的时候我没有特别去讲解这个结构的创建，这里就补充一下这个点。我会说每个结构是在哪个方法中被创建的，但是方法是在什么时候调用的， 不清楚的同学可以去查阅Activity启动流程分析。</p>\n<p>ActivityStackSupervisor因为很重要，所以在ActivityManagerService构造函数的时候就创建了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ActivityManagerService</span><span class=\"params\">(Context systemContext)</span> </span>&#123;</div><div class=\"line\">       ...</div><div class=\"line\">       mStackSupervisor = <span class=\"keyword\">new</span> ActivityStackSupervisor(<span class=\"keyword\">this</span>);</div><div class=\"line\">       ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>ActivityRecord是在ActivityStackSupervisor的startActivityLocked中被创建的，如下图</p>\n<p><img src=\"http://img.blog.csdn.net/20161102175329326\" alt=\"这里写图片描述\"></p>\n<p>然后ActivityStack和TaskRecord在同个类的startActivityUncheckedlocked方法中被创建，如下图。</p>\n<p><img src=\"http://img.blog.csdn.net/20161102175501924\" alt=\"这里写图片描述\"></p>\n<p>adjustStackFocus中会创建ActivityStack，但是正如前面说的，只有当mFocusStack没有被创建的时候才会重新创建，如果mFocusStack已经有啦，那么，就用mFocusStack。</p>\n<p>至此，Server端这边的结构都被创建出来了，然后再看Client端的结构。</p>\n<p>ActivityClientRecord是在ActivityThread的scheduleLaunchActivity，如图</p>\n<p><img src=\"http://img.blog.csdn.net/20161102175850425\" alt=\"这里写图片描述\"></p>\n<p>注意，这个时候Activity实例还没有被创建出来。而Activity的创建是在什么点呢。</p>\n<p><img src=\"http://img.blog.csdn.net/20161102180002769\" alt=\"这里写图片描述\"></p>\n<p>在performLaunchActivity中，并且创建完了之后把自己加入到ActivityClientRecord中，然后把ActivityCLientRecord加入到mActivities中。</p>\n<p>至此，所有的管理结构都创建完成，Activity也基本启动完成了。</p>\n<p>例行广告，喜欢这篇文章的朋友可以关注我的博客<a href=\"http://zwgeek.com\">http://zwgeek.com</a></p>\n"},{"title":"Proguard指南","date":"2017-05-09T04:01:35.000Z","_content":"\n之前在使用fastjson的时候遇到一些坑，这些坑中有一个和混淆选项有关，后来发现了Proguard其实是有一个官网的，里面介绍了各种情况。而我们平时开发可能就是单纯的从网上拷贝一个最佳实践的Proguard配置文件，而完全不在意各种配置项是什么意思，所以我想利用空闲时间翻译一下这个Proguard指南。以后配置Proguard的时候心里也会有底。\n\nProguard的官网是[Proguard Manual](https://www.guardsquare.com/en/proguard/manual/introduction)\n\n\n## 简介\nProGuard是一个集Java类文件压缩，优化，混淆和预校验的工具。压缩指的是发现并删除无用的类，字段，方法和属性。优化指的是分析并优化字节码数据。混淆指的是把固定的类名，字段名和方法名用更短的没有意义的名字代替。前面这些步骤让代码量更小，运行更快，并且不容易被反编译。预校验步骤能够提前在class里加入Java6+及Java ME需要的预校验信息，来达到加快代码校验速度的目的。\n\n当然，上面所说的这四步都是可选的。例如，开发者可以只用ProGuard来列出程序中的无用代码，或者可以只做预校验来让代码可以在Java6+上运行的更快。\n\n![这里写图片描述](https://www.guardsquare.com/files/media/guardsquare2016/Website/ProGuard/ProGuard_build_process.png)\n\n 上面的图展示了ProGuard压缩，优化，混淆和预校验Java Code的过程。\n\nProGuard首先会读取Jar文件（或者aar，war，ear，zip，apk，目录等）。然后压缩，优化，混淆，预校验这些文件。开发者也可以选择让ProGuard循环优化一个文件，也就是优化一个文件多次。ProGuard会把优化的结果输出到一个或多个Jar文件（或者aar，war，ear，zip，apk，目录等）中，同时开发者可以选择让ProGuard把输入文件中包含的源代码的类名或类内容用混淆名称代替。\n\n需要注意的是，ProGuard只能接收Library文件（也就是jar，aar，war，ear，zip，apk，目录等）作为输入文件，所以开发者需要先编译代码变成Library文件。ProGuard会重新处理Library文件中的类依赖关系，但是Library本身不会变，处理完成后，你还要把这些文件放在你最好的应用程序中替换原来的Library文件\n\n\n### 程序入口\n\n入口，也可以被称作入口函数或入口类，在Proguard中是一个很重要的概念。为了确定哪些代码应该被保护，哪些代码可以被删减或混淆，开发者必须指定一个或多个入口。入口通常是有Main方法的类，Java应用程序的面板，或Android的Acitivity等。\n\n- 压缩时，Proguard会从入口处循环遍历来确认哪些类和成员变量被用过。没有用过的类和成员变量将被删除。\n\n- 优化时，Proguard会优化上一步产生的代码，和其他优化一样，不是入口的类和方法可以被修改成private，static或final的，无用的参数可以被移除，一些方法也可能会被内联化。\n\n- 混淆时，Proguard会重命名哪些非入口的类和类的成员变量。同时，会保证入口函数仍然可以以他们原来的名字被访问到。\n\n- 入口点在预校验步骤不是必要的。\n\n程序入口可以用keep命令来定义，keep命令在用法简介一章会介绍，并且在样例代码一章会给出一些示例。\n\n### 反射\n\n在大多数的代码自动化处理中，反射总是会出一些或多或少的问题。在ProGuard中，如果你的类或者类的成员变量是被动态创建和调用的，也就是说， 根据类名或方法名被调用，那么这些类和成员变量必须被指定为入口。举个例子，Class.forName() 在运行期可构造任意的类，所以以此来推断哪个类应该被保护几乎不可能，而且这些类名还有可能是从配置文件中读出来的。所以开发者应该在ProGuard的配置文件中用简单的keep选项来指明这些类。\n\n但是，现在ProGuard已经能够预测并处理以下这些情况了。\n\n- Class.forName(\"SomeClass\")\n- SomeClass.class\n- SomeClass.class.getField(\"someField\")\n- SomeClass.class.getDeclaredField(\"someField\")\n- SomeClass.class.getMethod(\"someMethod\", new Class[] {})\n- SomeClass.class.getMethod(\"someMethod\", new Class[] { A.class })\n- SomeClass.class.getMethod(\"someMethod\", new Class[] { A.class, B.class })\n- SomeClass.class.getDeclaredMethod(\"someMethod\", new Class[] {})\n- SomeClass.class.getDeclaredMethod(\"someMethod\", new Class[] { A.class })\n- SomeClass.class.getDeclaredMethod(\"someMethod\", new Class[] { A.class, B.class })\n- AtomicIntegerFieldUpdater.newUpdater(SomeClass.class, \"someField\")\n- AtomicLongFieldUpdater.newUpdater(SomeClass.class, \"someField\")\n- AtomicReferenceFieldUpdater.newUpdater(SomeClass.class, SomeType.class, \"someField\")\n\n当然，上面示例中的类和变量名不是固定的，但是构造方法应该和上面样例中展示的一样，以便ProGuard能够识别出他们。这样的话，相关的类和变量就可以在压缩的时候被识别出来，然后被保护。\n\n未来，ProGuard希望提供一些建议如果需要开发者手动keep一些类或成员变量。例如，ProGuard会注意下面这种情况：\n```\n(SomeClass)Class.forName(variable).newInstance()\n```\n在这种情况下，可能代表SomeClass这个类或接口的实现类需要被保护。给出这样的提示后，开发者可以根据情况来编辑配置文件。\n\n为了更好的处理提示结果，开发者需要对自己处理的代码比较熟悉。因为混淆代码可能会产生一大堆的提示让开发者去判断类是否需要被保护。如果开发者对代码的内部实现不熟悉，可能会引发一些异常。\n","source":"_posts/Proguard指南.md","raw":"---\ntitle: Proguard指南\ndate: 2017-05-09 12:01:35\ntags: \n  - Android\n  - Proguard\n  - 混淆\n  - 译文\ncategories: Android\n \n---\n\n之前在使用fastjson的时候遇到一些坑，这些坑中有一个和混淆选项有关，后来发现了Proguard其实是有一个官网的，里面介绍了各种情况。而我们平时开发可能就是单纯的从网上拷贝一个最佳实践的Proguard配置文件，而完全不在意各种配置项是什么意思，所以我想利用空闲时间翻译一下这个Proguard指南。以后配置Proguard的时候心里也会有底。\n\nProguard的官网是[Proguard Manual](https://www.guardsquare.com/en/proguard/manual/introduction)\n\n\n## 简介\nProGuard是一个集Java类文件压缩，优化，混淆和预校验的工具。压缩指的是发现并删除无用的类，字段，方法和属性。优化指的是分析并优化字节码数据。混淆指的是把固定的类名，字段名和方法名用更短的没有意义的名字代替。前面这些步骤让代码量更小，运行更快，并且不容易被反编译。预校验步骤能够提前在class里加入Java6+及Java ME需要的预校验信息，来达到加快代码校验速度的目的。\n\n当然，上面所说的这四步都是可选的。例如，开发者可以只用ProGuard来列出程序中的无用代码，或者可以只做预校验来让代码可以在Java6+上运行的更快。\n\n![这里写图片描述](https://www.guardsquare.com/files/media/guardsquare2016/Website/ProGuard/ProGuard_build_process.png)\n\n 上面的图展示了ProGuard压缩，优化，混淆和预校验Java Code的过程。\n\nProGuard首先会读取Jar文件（或者aar，war，ear，zip，apk，目录等）。然后压缩，优化，混淆，预校验这些文件。开发者也可以选择让ProGuard循环优化一个文件，也就是优化一个文件多次。ProGuard会把优化的结果输出到一个或多个Jar文件（或者aar，war，ear，zip，apk，目录等）中，同时开发者可以选择让ProGuard把输入文件中包含的源代码的类名或类内容用混淆名称代替。\n\n需要注意的是，ProGuard只能接收Library文件（也就是jar，aar，war，ear，zip，apk，目录等）作为输入文件，所以开发者需要先编译代码变成Library文件。ProGuard会重新处理Library文件中的类依赖关系，但是Library本身不会变，处理完成后，你还要把这些文件放在你最好的应用程序中替换原来的Library文件\n\n\n### 程序入口\n\n入口，也可以被称作入口函数或入口类，在Proguard中是一个很重要的概念。为了确定哪些代码应该被保护，哪些代码可以被删减或混淆，开发者必须指定一个或多个入口。入口通常是有Main方法的类，Java应用程序的面板，或Android的Acitivity等。\n\n- 压缩时，Proguard会从入口处循环遍历来确认哪些类和成员变量被用过。没有用过的类和成员变量将被删除。\n\n- 优化时，Proguard会优化上一步产生的代码，和其他优化一样，不是入口的类和方法可以被修改成private，static或final的，无用的参数可以被移除，一些方法也可能会被内联化。\n\n- 混淆时，Proguard会重命名哪些非入口的类和类的成员变量。同时，会保证入口函数仍然可以以他们原来的名字被访问到。\n\n- 入口点在预校验步骤不是必要的。\n\n程序入口可以用keep命令来定义，keep命令在用法简介一章会介绍，并且在样例代码一章会给出一些示例。\n\n### 反射\n\n在大多数的代码自动化处理中，反射总是会出一些或多或少的问题。在ProGuard中，如果你的类或者类的成员变量是被动态创建和调用的，也就是说， 根据类名或方法名被调用，那么这些类和成员变量必须被指定为入口。举个例子，Class.forName() 在运行期可构造任意的类，所以以此来推断哪个类应该被保护几乎不可能，而且这些类名还有可能是从配置文件中读出来的。所以开发者应该在ProGuard的配置文件中用简单的keep选项来指明这些类。\n\n但是，现在ProGuard已经能够预测并处理以下这些情况了。\n\n- Class.forName(\"SomeClass\")\n- SomeClass.class\n- SomeClass.class.getField(\"someField\")\n- SomeClass.class.getDeclaredField(\"someField\")\n- SomeClass.class.getMethod(\"someMethod\", new Class[] {})\n- SomeClass.class.getMethod(\"someMethod\", new Class[] { A.class })\n- SomeClass.class.getMethod(\"someMethod\", new Class[] { A.class, B.class })\n- SomeClass.class.getDeclaredMethod(\"someMethod\", new Class[] {})\n- SomeClass.class.getDeclaredMethod(\"someMethod\", new Class[] { A.class })\n- SomeClass.class.getDeclaredMethod(\"someMethod\", new Class[] { A.class, B.class })\n- AtomicIntegerFieldUpdater.newUpdater(SomeClass.class, \"someField\")\n- AtomicLongFieldUpdater.newUpdater(SomeClass.class, \"someField\")\n- AtomicReferenceFieldUpdater.newUpdater(SomeClass.class, SomeType.class, \"someField\")\n\n当然，上面示例中的类和变量名不是固定的，但是构造方法应该和上面样例中展示的一样，以便ProGuard能够识别出他们。这样的话，相关的类和变量就可以在压缩的时候被识别出来，然后被保护。\n\n未来，ProGuard希望提供一些建议如果需要开发者手动keep一些类或成员变量。例如，ProGuard会注意下面这种情况：\n```\n(SomeClass)Class.forName(variable).newInstance()\n```\n在这种情况下，可能代表SomeClass这个类或接口的实现类需要被保护。给出这样的提示后，开发者可以根据情况来编辑配置文件。\n\n为了更好的处理提示结果，开发者需要对自己处理的代码比较熟悉。因为混淆代码可能会产生一大堆的提示让开发者去判断类是否需要被保护。如果开发者对代码的内部实现不熟悉，可能会引发一些异常。\n","slug":"Proguard指南","published":1,"updated":"2024-06-14T09:25:33.676Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clxjsxtvx0009lq6g2u38v1f2","content":"<p>之前在使用fastjson的时候遇到一些坑，这些坑中有一个和混淆选项有关，后来发现了Proguard其实是有一个官网的，里面介绍了各种情况。而我们平时开发可能就是单纯的从网上拷贝一个最佳实践的Proguard配置文件，而完全不在意各种配置项是什么意思，所以我想利用空闲时间翻译一下这个Proguard指南。以后配置Proguard的时候心里也会有底。</p>\n<p>Proguard的官网是<a href=\"https://www.guardsquare.com/en/proguard/manual/introduction\" target=\"_blank\" rel=\"external\">Proguard Manual</a></p>\n<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>ProGuard是一个集Java类文件压缩，优化，混淆和预校验的工具。压缩指的是发现并删除无用的类，字段，方法和属性。优化指的是分析并优化字节码数据。混淆指的是把固定的类名，字段名和方法名用更短的没有意义的名字代替。前面这些步骤让代码量更小，运行更快，并且不容易被反编译。预校验步骤能够提前在class里加入Java6+及Java ME需要的预校验信息，来达到加快代码校验速度的目的。</p>\n<p>当然，上面所说的这四步都是可选的。例如，开发者可以只用ProGuard来列出程序中的无用代码，或者可以只做预校验来让代码可以在Java6+上运行的更快。</p>\n<p><img src=\"https://www.guardsquare.com/files/media/guardsquare2016/Website/ProGuard/ProGuard_build_process.png\" alt=\"这里写图片描述\"></p>\n<p> 上面的图展示了ProGuard压缩，优化，混淆和预校验Java Code的过程。</p>\n<p>ProGuard首先会读取Jar文件（或者aar，war，ear，zip，apk，目录等）。然后压缩，优化，混淆，预校验这些文件。开发者也可以选择让ProGuard循环优化一个文件，也就是优化一个文件多次。ProGuard会把优化的结果输出到一个或多个Jar文件（或者aar，war，ear，zip，apk，目录等）中，同时开发者可以选择让ProGuard把输入文件中包含的源代码的类名或类内容用混淆名称代替。</p>\n<p>需要注意的是，ProGuard只能接收Library文件（也就是jar，aar，war，ear，zip，apk，目录等）作为输入文件，所以开发者需要先编译代码变成Library文件。ProGuard会重新处理Library文件中的类依赖关系，但是Library本身不会变，处理完成后，你还要把这些文件放在你最好的应用程序中替换原来的Library文件</p>\n<h3 id=\"程序入口\"><a href=\"#程序入口\" class=\"headerlink\" title=\"程序入口\"></a>程序入口</h3><p>入口，也可以被称作入口函数或入口类，在Proguard中是一个很重要的概念。为了确定哪些代码应该被保护，哪些代码可以被删减或混淆，开发者必须指定一个或多个入口。入口通常是有Main方法的类，Java应用程序的面板，或Android的Acitivity等。</p>\n<ul>\n<li><p>压缩时，Proguard会从入口处循环遍历来确认哪些类和成员变量被用过。没有用过的类和成员变量将被删除。</p>\n</li>\n<li><p>优化时，Proguard会优化上一步产生的代码，和其他优化一样，不是入口的类和方法可以被修改成private，static或final的，无用的参数可以被移除，一些方法也可能会被内联化。</p>\n</li>\n<li><p>混淆时，Proguard会重命名哪些非入口的类和类的成员变量。同时，会保证入口函数仍然可以以他们原来的名字被访问到。</p>\n</li>\n<li><p>入口点在预校验步骤不是必要的。</p>\n</li>\n</ul>\n<p>程序入口可以用keep命令来定义，keep命令在用法简介一章会介绍，并且在样例代码一章会给出一些示例。</p>\n<h3 id=\"反射\"><a href=\"#反射\" class=\"headerlink\" title=\"反射\"></a>反射</h3><p>在大多数的代码自动化处理中，反射总是会出一些或多或少的问题。在ProGuard中，如果你的类或者类的成员变量是被动态创建和调用的，也就是说， 根据类名或方法名被调用，那么这些类和成员变量必须被指定为入口。举个例子，Class.forName() 在运行期可构造任意的类，所以以此来推断哪个类应该被保护几乎不可能，而且这些类名还有可能是从配置文件中读出来的。所以开发者应该在ProGuard的配置文件中用简单的keep选项来指明这些类。</p>\n<p>但是，现在ProGuard已经能够预测并处理以下这些情况了。</p>\n<ul>\n<li>Class.forName(“SomeClass”)</li>\n<li>SomeClass.class</li>\n<li>SomeClass.class.getField(“someField”)</li>\n<li>SomeClass.class.getDeclaredField(“someField”)</li>\n<li>SomeClass.class.getMethod(“someMethod”, new Class[] {})</li>\n<li>SomeClass.class.getMethod(“someMethod”, new Class[] { A.class })</li>\n<li>SomeClass.class.getMethod(“someMethod”, new Class[] { A.class, B.class })</li>\n<li>SomeClass.class.getDeclaredMethod(“someMethod”, new Class[] {})</li>\n<li>SomeClass.class.getDeclaredMethod(“someMethod”, new Class[] { A.class })</li>\n<li>SomeClass.class.getDeclaredMethod(“someMethod”, new Class[] { A.class, B.class })</li>\n<li>AtomicIntegerFieldUpdater.newUpdater(SomeClass.class, “someField”)</li>\n<li>AtomicLongFieldUpdater.newUpdater(SomeClass.class, “someField”)</li>\n<li>AtomicReferenceFieldUpdater.newUpdater(SomeClass.class, SomeType.class, “someField”)</li>\n</ul>\n<p>当然，上面示例中的类和变量名不是固定的，但是构造方法应该和上面样例中展示的一样，以便ProGuard能够识别出他们。这样的话，相关的类和变量就可以在压缩的时候被识别出来，然后被保护。</p>\n<p>未来，ProGuard希望提供一些建议如果需要开发者手动keep一些类或成员变量。例如，ProGuard会注意下面这种情况：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">(SomeClass)Class.forName(variable).newInstance()</div></pre></td></tr></table></figure></p>\n<p>在这种情况下，可能代表SomeClass这个类或接口的实现类需要被保护。给出这样的提示后，开发者可以根据情况来编辑配置文件。</p>\n<p>为了更好的处理提示结果，开发者需要对自己处理的代码比较熟悉。因为混淆代码可能会产生一大堆的提示让开发者去判断类是否需要被保护。如果开发者对代码的内部实现不熟悉，可能会引发一些异常。</p>\n","excerpt":"","more":"<p>之前在使用fastjson的时候遇到一些坑，这些坑中有一个和混淆选项有关，后来发现了Proguard其实是有一个官网的，里面介绍了各种情况。而我们平时开发可能就是单纯的从网上拷贝一个最佳实践的Proguard配置文件，而完全不在意各种配置项是什么意思，所以我想利用空闲时间翻译一下这个Proguard指南。以后配置Proguard的时候心里也会有底。</p>\n<p>Proguard的官网是<a href=\"https://www.guardsquare.com/en/proguard/manual/introduction\">Proguard Manual</a></p>\n<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>ProGuard是一个集Java类文件压缩，优化，混淆和预校验的工具。压缩指的是发现并删除无用的类，字段，方法和属性。优化指的是分析并优化字节码数据。混淆指的是把固定的类名，字段名和方法名用更短的没有意义的名字代替。前面这些步骤让代码量更小，运行更快，并且不容易被反编译。预校验步骤能够提前在class里加入Java6+及Java ME需要的预校验信息，来达到加快代码校验速度的目的。</p>\n<p>当然，上面所说的这四步都是可选的。例如，开发者可以只用ProGuard来列出程序中的无用代码，或者可以只做预校验来让代码可以在Java6+上运行的更快。</p>\n<p><img src=\"https://www.guardsquare.com/files/media/guardsquare2016/Website/ProGuard/ProGuard_build_process.png\" alt=\"这里写图片描述\"></p>\n<p> 上面的图展示了ProGuard压缩，优化，混淆和预校验Java Code的过程。</p>\n<p>ProGuard首先会读取Jar文件（或者aar，war，ear，zip，apk，目录等）。然后压缩，优化，混淆，预校验这些文件。开发者也可以选择让ProGuard循环优化一个文件，也就是优化一个文件多次。ProGuard会把优化的结果输出到一个或多个Jar文件（或者aar，war，ear，zip，apk，目录等）中，同时开发者可以选择让ProGuard把输入文件中包含的源代码的类名或类内容用混淆名称代替。</p>\n<p>需要注意的是，ProGuard只能接收Library文件（也就是jar，aar，war，ear，zip，apk，目录等）作为输入文件，所以开发者需要先编译代码变成Library文件。ProGuard会重新处理Library文件中的类依赖关系，但是Library本身不会变，处理完成后，你还要把这些文件放在你最好的应用程序中替换原来的Library文件</p>\n<h3 id=\"程序入口\"><a href=\"#程序入口\" class=\"headerlink\" title=\"程序入口\"></a>程序入口</h3><p>入口，也可以被称作入口函数或入口类，在Proguard中是一个很重要的概念。为了确定哪些代码应该被保护，哪些代码可以被删减或混淆，开发者必须指定一个或多个入口。入口通常是有Main方法的类，Java应用程序的面板，或Android的Acitivity等。</p>\n<ul>\n<li><p>压缩时，Proguard会从入口处循环遍历来确认哪些类和成员变量被用过。没有用过的类和成员变量将被删除。</p>\n</li>\n<li><p>优化时，Proguard会优化上一步产生的代码，和其他优化一样，不是入口的类和方法可以被修改成private，static或final的，无用的参数可以被移除，一些方法也可能会被内联化。</p>\n</li>\n<li><p>混淆时，Proguard会重命名哪些非入口的类和类的成员变量。同时，会保证入口函数仍然可以以他们原来的名字被访问到。</p>\n</li>\n<li><p>入口点在预校验步骤不是必要的。</p>\n</li>\n</ul>\n<p>程序入口可以用keep命令来定义，keep命令在用法简介一章会介绍，并且在样例代码一章会给出一些示例。</p>\n<h3 id=\"反射\"><a href=\"#反射\" class=\"headerlink\" title=\"反射\"></a>反射</h3><p>在大多数的代码自动化处理中，反射总是会出一些或多或少的问题。在ProGuard中，如果你的类或者类的成员变量是被动态创建和调用的，也就是说， 根据类名或方法名被调用，那么这些类和成员变量必须被指定为入口。举个例子，Class.forName() 在运行期可构造任意的类，所以以此来推断哪个类应该被保护几乎不可能，而且这些类名还有可能是从配置文件中读出来的。所以开发者应该在ProGuard的配置文件中用简单的keep选项来指明这些类。</p>\n<p>但是，现在ProGuard已经能够预测并处理以下这些情况了。</p>\n<ul>\n<li>Class.forName(“SomeClass”)</li>\n<li>SomeClass.class</li>\n<li>SomeClass.class.getField(“someField”)</li>\n<li>SomeClass.class.getDeclaredField(“someField”)</li>\n<li>SomeClass.class.getMethod(“someMethod”, new Class[] {})</li>\n<li>SomeClass.class.getMethod(“someMethod”, new Class[] { A.class })</li>\n<li>SomeClass.class.getMethod(“someMethod”, new Class[] { A.class, B.class })</li>\n<li>SomeClass.class.getDeclaredMethod(“someMethod”, new Class[] {})</li>\n<li>SomeClass.class.getDeclaredMethod(“someMethod”, new Class[] { A.class })</li>\n<li>SomeClass.class.getDeclaredMethod(“someMethod”, new Class[] { A.class, B.class })</li>\n<li>AtomicIntegerFieldUpdater.newUpdater(SomeClass.class, “someField”)</li>\n<li>AtomicLongFieldUpdater.newUpdater(SomeClass.class, “someField”)</li>\n<li>AtomicReferenceFieldUpdater.newUpdater(SomeClass.class, SomeType.class, “someField”)</li>\n</ul>\n<p>当然，上面示例中的类和变量名不是固定的，但是构造方法应该和上面样例中展示的一样，以便ProGuard能够识别出他们。这样的话，相关的类和变量就可以在压缩的时候被识别出来，然后被保护。</p>\n<p>未来，ProGuard希望提供一些建议如果需要开发者手动keep一些类或成员变量。例如，ProGuard会注意下面这种情况：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">(SomeClass)Class.forName(variable).newInstance()</div></pre></td></tr></table></figure></p>\n<p>在这种情况下，可能代表SomeClass这个类或接口的实现类需要被保护。给出这样的提示后，开发者可以根据情况来编辑配置文件。</p>\n<p>为了更好的处理提示结果，开发者需要对自己处理的代码比较熟悉。因为混淆代码可能会产生一大堆的提示让开发者去判断类是否需要被保护。如果开发者对代码的内部实现不熟悉，可能会引发一些异常。</p>\n"},{"title":"Android NDK 使用简介","date":"2016-10-11T09:41:51.000Z","_content":"\n今天我们来简单说一下Android NDK的使用方法。众所周知，so文件在Android的开发过程中起到了很重要的作用，无论与底层设备打交道还是在Android安全领域。so文件都格外受人青睐。NDK就是Android发布的用于编译so文件的一套工具，\n\n引用自百度百科的一段解释\n>Android NDK 是在SDK前面又加上了“原生”二字，即Native Development Kit，因此又被Google称为“NDK”。\n\n>众所周知，Android程序运行在Dalvik虚拟机中，NDK允许用户使用类似C / C++之类的原生代码语言执行部分程序。\nNDK包括了：\n\n>- 从C / C++生成原生代码库所需要的工具和build files。\n- 将一致的原生库嵌入可以在Android设备上部署的应用程序包文件（application packages files ，即.apk文件）中。\n- 支持所有未来Android平台的一系列原生系统头文件和库\n\n>为何要用到NDK?\n概括来说主要分为以下几种情况：\n\n>1. 代码的保护，由于apk的java层代码很容易被反编译，而C/C++库反汇难度较大。\n2. 在NDK中调用第三方C/C++库，因为大部分的开源库都是用C/C++代码编写的。\n3. 便于移植，用C/C++写的库可以方便在其他的嵌入式平台上再次使用。\n\n本文从以下三个方面讲解NDK的使用\n\n- 直接在命令行中用NDK进行编译\n- Android Studio2.2以前对NDK的支持\n- Android Studio2.2及以后对NDK的支持\n\n### 直接在命令行使用NDK\nNDK本来就是一套编译工具，自然是在命令行中执行，其实后面两种方法都是对这种方法的自动化处理，万变不离其宗， 要理解后面两种方法，还是应该熟悉一下不借助任何工具时的操作。\n\nSDK默认是不带NDK的，所以NDK需要额外下载，下载后还需要配置环境变量。具体方法可以查看百度，配置环境变量很简单，只需要把NDK根目录，也就是ndk-build所在的目录加入环境变量即可。\n\n用NDK-BUILD构建一个NDK程序，我们知道就是将C文件编译成so文件，其实原理很简单，用gcc进行编译。哦，因为我是mac环境，所以自带GCC编译环境，如果是windows下的话，还需要安装Cygwin环境来模拟linux，不过听说最新的NDK自带Cygwin，所以不再需要额外安装，Windows的同学可以试一下，有问题可以在评论区提问， 有机会我会补充Win下的使用方法。\n\n编译c程序需要makefile，其实简单说就是告诉GCC怎么编译，先编什么在编什么，需要哪些包等等。这个熟悉c的同学应该知道的。一个简单的so项目包含以下四个文件。\n\n![这里写图片描述](http://img.blog.csdn.net/20161011175730810)\n\n除了.h和.c文件，还有两个makefile，Application.mk是项目makefile，它会指定调用哪个子makefile，然后Android.mk是具体执行操作的makefile。Application.mk的名字不能变，因为NDK会默认去找这个文件，后面也会讲到，Android.mk的名字可以变，是配置在Application.mk中的。\n\n然后NDK还有一些规定，看.h文件的名字，c文件中的方法与java中某个方法是一一对应的，出于安全考量，NDK要求C中的方法名应该以对应java文件的包名+类名+方法名来命名。\n\n头文件\n\n```c\n/* DO NOT EDIT THIS FILE - it is machine generated */\n#include <jni.h>\n/* Header for class com_example_zzw_helloworld_JniUtils */\n\n#ifndef _Included_com_example_zzw_helloworld_JniUtils\n#define _Included_com_example_zzw_helloworld_JniUtils\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n/*\n * Class:     com_example_zzw_helloworld_JniUtils\n * Method:    stringFromJNI\n * Signature: ()Ljava/lang/String;\n */\nJNIEXPORT jstring JNICALL Java_com_example_zzw_helloworld_JniUtils_stringFromJNI\n  (JNIEnv *, jobject);\n\n#ifdef __cplusplus\n}\n#endif\n#endif\n```\n\n 这个头文件很简单，就声明了一个方法，这两个参数是固定的，这个方法在java中的表现形式为\n \n \n \tstringFromJNI() \n \n \n返回类型对应的是java中的string。然后创建C文件，实现该方法。\n\n\n```C\n//\n// Created by zzw on 16/10/11.\n//\n#include \"com_example_zzw_helloworld_JniUtils.h\"\n\nJNIEXPORT jstring JNICALL Java_com_example_zzw_helloworld_JniUtils_stringFromJNI\n        (JNIEnv *env, jobject instance) {\n    return (*env)->NewStringUTF(env, \"Hello from JNI !\");\n}\n```\n\n然后我们还需要两个make文件，一个是Application.mk另一个是Android.mk\nApplication.mk内容如下：\n\n```makefile\nAPP_BUILD_SCRIPT := /Users/zzw/Desktop/jni/Android.mk\n```\n\n其实就是声明Android.mk的位置\nAndroid.mk如下：\n\n```makefile\nLOCAL_PATH := $(call my-dir)\n\ninclude $(CLEAR_VARS)\n\nLOCAL_MODULE    := hello-jni\nLOCAL_SRC_FILES := hello-jni.c\n\ninclude $(BUILD_SHARED_LIBRARY)\n```\n然后运行\n\n```shell\n./ndk-build NDK_PROJECT_PATH=/Users/zzw/Desktop\n```\n \n指定PROJECT的位置，然后NDK会自动寻找该路径下的jni文件夹中的Application.mk，然后去编译。\n\n如果编译成功，则会在该文件夹下生成libs文件夹，里面就是各种架构下的so文件\n![这里写图片描述](http://img.blog.csdn.net/20161011181217255)\n\n生成的文件放在Android的libs中，对应的java文件调用方法为\n\n```java\npackage com.example.zzw.helloworld;\n\n/**\n * Created by zzw on 16/10/11.\n */\n\npublic class JniUtils {\n    static {\n        System.loadLibrary(\"hello-jni\");\n    }\n\n    public static native String stringFromJNI();\n\n    public static String stringFromJNINative(){\n        return stringFromJNI();\n    }\n}\n```\n\n先用loadLibrary引入so文件，然后用native声明底层方法，然后我们就可以在程序中调用方法了。\n\n这种方法完全没有借助任何的IDE，不过你也能看出来，有些工作是可以简化的，下面我们就说下在IDE中的做法。\n\n### Android Studio2.2 之前使用NDK\n\n老的Android Studio支持NDK的方式可以根据java类帮我们生成头文件，然后编译过程可以写在gradle中，而不需要先编出so，再编android这样，具体过程如下\n\n先写一个Java类，因为我们可以用jni工具根据java类来生成头文件，java类载入so文件并且声明底层方法，这个和前面一样，如下\n\n```java\npackage com.example.zzw.helloworld;\n\n/**\n * Created by zzw on 16/10/11.\n */\n\npublic class JniUtils {\n    static {\n        System.loadLibrary(\"hello-jni\");\n    }\n\n    public static native String stringFromJNI();\n\n    public static String stringFromJNINative(){\n        return stringFromJNI();\n    }\n}\n```\n\n然后编译程序，注意只编译不运行，因为此时运行会报错，编译后，在build的文件夹下面能看到这个class文件\n\n![这里写图片描述](http://img.blog.csdn.net/20161011181737161)\n\n接下来我们可以用jni工具来根据这个class文件自动生成头文件了。命令行cd到build文件夹一层，然后执行如下命令\n\n```cmd\ncd app/build/intermediates/classes/debug/\njavah -jni com.example.zzw.helloworld.JniUtils\n```\n\n完整路径的类名，如果这一步报错，可以检查一下NDK有没有配到环境变量里。方法可以自行百度。\n\n如果成功的话，你应该能看到在build文件夹下生成了一个.h文件，如下\n\n![这里写图片描述](http://img.blog.csdn.net/20161011181815929)\n\n把这个文件拷贝到main下面jni文件夹下，这个文件夹也不是固定的，可以配置。但是我们一般习惯于放在这个地方。\n\n复制过来之后这就是我们的头文件，然后我们可以创建一个c文件，实现头文件的方法\n\n文件内容如下\n\n```c\n#include \"com_example_zzw_helloworld_JniUtils.h\"\n\nJNIEXPORT jstring JNICALL Java_com_example_zzw_helloworld_JniUtils_stringFromJNI\n        (JNIEnv *env, jobject instance) {\n    return (*env)->NewStringUTF(env, \"Hello from JNI !\");\n}\n```\n\nbuild.gradle中需要配置ndk\n![这里写图片描述](http://img.blog.csdn.net/20161011182053587)\n\n然后点击运行。\n\n遇到的问题，\n报错\n\n```\nError:Execution failed for task ':app:compileDebugNdk'.\n> Error: NDK integration is deprecated in the current plugin.  Consider trying the new experimental plugin.  For details, see http://tools.android.com/tech-docs/new-build-system/gradle-experimental.  Set \"$USE_DEPRECATED_NDK=true\" in gradle.properties to continue using the current NDK integration.\n```\n\n这是因为gradle插件版本太高，已经不支持这个方法了，它提示我们在gradle.properties里面加一句话，但经过我测试，那句话是不对的，应该加如下一句：\n\n```\nandroid.useDeprecatedNdk=true\n```\n\n然后运行，正常。\n\n### Android Studio2.2之后使用NDK\n前面我们看到其实比起第一种方法也没有简化多少，所以在Studio2.2的时候google又尝试简化了做法，Android Studio 2.2开始支持用內建的方法来执行复杂的NDK编译，这意味着开发者只需要写好c文件，其他所有的编译，链接都可以交给系统去做。\n\n*注意：gradle版本需要2.2及以上*\n\n这个特性的实现要依赖于一个build标签，叫externalNativeBuild。标签配置如下\n\n```xml\ndefaultConfig {\n    externalNativeBuild {\n        ndkBuild {\n            arguments \"NDK_LIBS_OUT=$jniLibsDir\", \"-j$numProcs\", \"all\"\n            abiFilters \"armeabi-v7a\"\n        }\n    }\n}\nexternalNativeBuild{\n    ndkBuild{\n        path \"src/main/jni/Android.mk\"\n    }\n}\n```\n arguments指定编译的参数，abiFilters指定编译的平台，这些参数都可以省略以使用默认参数。下面path指定make文件的位置。\n\n之后，NDK执行的task配置如下\n\n```xml\ntask ndkBuild(type: Exec) {\n    commandLine getNdkBuildCmd(),\n            '-C', file('src/main/jni').absolutePath,\n            '-j', Runtime.runtime.availableProcessors(),\n            \"NDK_LIBS_OUT=$jniLibsDir\",\n            'all',\n            'NDK_DEBUG=1'\n\n    dependsOn 'generateLuaBytecodes'\n\n    doFirst {\n        println '== ndkBuild =='\n    }\n}\n```\n\n接下来让我们来看一下，具体的实现步骤是什么样的，不需要像以前一样自己写头文件，然后再编译，现在只需要关注c文件即可。以hello world为例，我们写一个C文件如下：\n\n```c\n#include <string.h>\n#include <jni.h>\n\n\nJNIEXPORT jstring JNICALL\nJava_com_example_zzw_helloworld_MainActivity_stringFromJNI(JNIEnv *env, jobject instance) {\n    return (*env)->NewStringUTF(env, \"Hello from JNI !\");\n}\n```\n注意方法名要以调用它的JAVA文件的包名+类名+方法名命名。\n这样写完之后，我们就可以在相应的JAVA文件中调用了，代码如下：\n\n```java\npackage com.example.zzw.helloworld;\n\nimport android.os.Bundle;\nimport android.support.v7.app.AppCompatActivity;\n\npublic class MainActivity extends AppCompatActivity {\n\n\n\n    static {\n        System.loadLibrary(\"hello-jni\");\n    }\n\n    public native String stringFromJNI();\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        System.out.println(stringFromJNI());\n\n    }\n}\n```\n\n先用loadLibrary引入so文件，然后用native声明底层方法，然后我们就可以在程序中调用方法了。\n当然前面提到了make文件，我们要创建一个Android.mk文件在externalNativeBuild中声明的位置，如下：\n\n```makefile\nLOCAL_PATH := $(call my-dir)\n\ninclude $(CLEAR_VARS)\n\nLOCAL_MODULE    := hello-jni\nLOCAL_SRC_FILES := hello-jni.c\n\ninclude $(BUILD_SHARED_LIBRARY)\n```\n\n之后，make project，运行程序应该就能看的效果了，通过这种方法生成的so文件放在app/.externalNativeBuild/debug/obj/local/下，并以lib+类名命名文件，如下：\n\n![这里写图片描述](http://img.blog.csdn.net/20161011182623870)\n\n 感觉现在应该很简单了，只需要关注方法实现就可以了，其他基本都不要开发者关心了。\n\n","source":"_posts/AndroidNDK使用简介.md","raw":"---\ntitle: Android NDK 使用简介\ndate: 2016-10-11 17:41:51\ntags:\n  - Android\n  - NDK\n  - Android Sudio\ncategories: Android\n---\n\n今天我们来简单说一下Android NDK的使用方法。众所周知，so文件在Android的开发过程中起到了很重要的作用，无论与底层设备打交道还是在Android安全领域。so文件都格外受人青睐。NDK就是Android发布的用于编译so文件的一套工具，\n\n引用自百度百科的一段解释\n>Android NDK 是在SDK前面又加上了“原生”二字，即Native Development Kit，因此又被Google称为“NDK”。\n\n>众所周知，Android程序运行在Dalvik虚拟机中，NDK允许用户使用类似C / C++之类的原生代码语言执行部分程序。\nNDK包括了：\n\n>- 从C / C++生成原生代码库所需要的工具和build files。\n- 将一致的原生库嵌入可以在Android设备上部署的应用程序包文件（application packages files ，即.apk文件）中。\n- 支持所有未来Android平台的一系列原生系统头文件和库\n\n>为何要用到NDK?\n概括来说主要分为以下几种情况：\n\n>1. 代码的保护，由于apk的java层代码很容易被反编译，而C/C++库反汇难度较大。\n2. 在NDK中调用第三方C/C++库，因为大部分的开源库都是用C/C++代码编写的。\n3. 便于移植，用C/C++写的库可以方便在其他的嵌入式平台上再次使用。\n\n本文从以下三个方面讲解NDK的使用\n\n- 直接在命令行中用NDK进行编译\n- Android Studio2.2以前对NDK的支持\n- Android Studio2.2及以后对NDK的支持\n\n### 直接在命令行使用NDK\nNDK本来就是一套编译工具，自然是在命令行中执行，其实后面两种方法都是对这种方法的自动化处理，万变不离其宗， 要理解后面两种方法，还是应该熟悉一下不借助任何工具时的操作。\n\nSDK默认是不带NDK的，所以NDK需要额外下载，下载后还需要配置环境变量。具体方法可以查看百度，配置环境变量很简单，只需要把NDK根目录，也就是ndk-build所在的目录加入环境变量即可。\n\n用NDK-BUILD构建一个NDK程序，我们知道就是将C文件编译成so文件，其实原理很简单，用gcc进行编译。哦，因为我是mac环境，所以自带GCC编译环境，如果是windows下的话，还需要安装Cygwin环境来模拟linux，不过听说最新的NDK自带Cygwin，所以不再需要额外安装，Windows的同学可以试一下，有问题可以在评论区提问， 有机会我会补充Win下的使用方法。\n\n编译c程序需要makefile，其实简单说就是告诉GCC怎么编译，先编什么在编什么，需要哪些包等等。这个熟悉c的同学应该知道的。一个简单的so项目包含以下四个文件。\n\n![这里写图片描述](http://img.blog.csdn.net/20161011175730810)\n\n除了.h和.c文件，还有两个makefile，Application.mk是项目makefile，它会指定调用哪个子makefile，然后Android.mk是具体执行操作的makefile。Application.mk的名字不能变，因为NDK会默认去找这个文件，后面也会讲到，Android.mk的名字可以变，是配置在Application.mk中的。\n\n然后NDK还有一些规定，看.h文件的名字，c文件中的方法与java中某个方法是一一对应的，出于安全考量，NDK要求C中的方法名应该以对应java文件的包名+类名+方法名来命名。\n\n头文件\n\n```c\n/* DO NOT EDIT THIS FILE - it is machine generated */\n#include <jni.h>\n/* Header for class com_example_zzw_helloworld_JniUtils */\n\n#ifndef _Included_com_example_zzw_helloworld_JniUtils\n#define _Included_com_example_zzw_helloworld_JniUtils\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n/*\n * Class:     com_example_zzw_helloworld_JniUtils\n * Method:    stringFromJNI\n * Signature: ()Ljava/lang/String;\n */\nJNIEXPORT jstring JNICALL Java_com_example_zzw_helloworld_JniUtils_stringFromJNI\n  (JNIEnv *, jobject);\n\n#ifdef __cplusplus\n}\n#endif\n#endif\n```\n\n 这个头文件很简单，就声明了一个方法，这两个参数是固定的，这个方法在java中的表现形式为\n \n \n \tstringFromJNI() \n \n \n返回类型对应的是java中的string。然后创建C文件，实现该方法。\n\n\n```C\n//\n// Created by zzw on 16/10/11.\n//\n#include \"com_example_zzw_helloworld_JniUtils.h\"\n\nJNIEXPORT jstring JNICALL Java_com_example_zzw_helloworld_JniUtils_stringFromJNI\n        (JNIEnv *env, jobject instance) {\n    return (*env)->NewStringUTF(env, \"Hello from JNI !\");\n}\n```\n\n然后我们还需要两个make文件，一个是Application.mk另一个是Android.mk\nApplication.mk内容如下：\n\n```makefile\nAPP_BUILD_SCRIPT := /Users/zzw/Desktop/jni/Android.mk\n```\n\n其实就是声明Android.mk的位置\nAndroid.mk如下：\n\n```makefile\nLOCAL_PATH := $(call my-dir)\n\ninclude $(CLEAR_VARS)\n\nLOCAL_MODULE    := hello-jni\nLOCAL_SRC_FILES := hello-jni.c\n\ninclude $(BUILD_SHARED_LIBRARY)\n```\n然后运行\n\n```shell\n./ndk-build NDK_PROJECT_PATH=/Users/zzw/Desktop\n```\n \n指定PROJECT的位置，然后NDK会自动寻找该路径下的jni文件夹中的Application.mk，然后去编译。\n\n如果编译成功，则会在该文件夹下生成libs文件夹，里面就是各种架构下的so文件\n![这里写图片描述](http://img.blog.csdn.net/20161011181217255)\n\n生成的文件放在Android的libs中，对应的java文件调用方法为\n\n```java\npackage com.example.zzw.helloworld;\n\n/**\n * Created by zzw on 16/10/11.\n */\n\npublic class JniUtils {\n    static {\n        System.loadLibrary(\"hello-jni\");\n    }\n\n    public static native String stringFromJNI();\n\n    public static String stringFromJNINative(){\n        return stringFromJNI();\n    }\n}\n```\n\n先用loadLibrary引入so文件，然后用native声明底层方法，然后我们就可以在程序中调用方法了。\n\n这种方法完全没有借助任何的IDE，不过你也能看出来，有些工作是可以简化的，下面我们就说下在IDE中的做法。\n\n### Android Studio2.2 之前使用NDK\n\n老的Android Studio支持NDK的方式可以根据java类帮我们生成头文件，然后编译过程可以写在gradle中，而不需要先编出so，再编android这样，具体过程如下\n\n先写一个Java类，因为我们可以用jni工具根据java类来生成头文件，java类载入so文件并且声明底层方法，这个和前面一样，如下\n\n```java\npackage com.example.zzw.helloworld;\n\n/**\n * Created by zzw on 16/10/11.\n */\n\npublic class JniUtils {\n    static {\n        System.loadLibrary(\"hello-jni\");\n    }\n\n    public static native String stringFromJNI();\n\n    public static String stringFromJNINative(){\n        return stringFromJNI();\n    }\n}\n```\n\n然后编译程序，注意只编译不运行，因为此时运行会报错，编译后，在build的文件夹下面能看到这个class文件\n\n![这里写图片描述](http://img.blog.csdn.net/20161011181737161)\n\n接下来我们可以用jni工具来根据这个class文件自动生成头文件了。命令行cd到build文件夹一层，然后执行如下命令\n\n```cmd\ncd app/build/intermediates/classes/debug/\njavah -jni com.example.zzw.helloworld.JniUtils\n```\n\n完整路径的类名，如果这一步报错，可以检查一下NDK有没有配到环境变量里。方法可以自行百度。\n\n如果成功的话，你应该能看到在build文件夹下生成了一个.h文件，如下\n\n![这里写图片描述](http://img.blog.csdn.net/20161011181815929)\n\n把这个文件拷贝到main下面jni文件夹下，这个文件夹也不是固定的，可以配置。但是我们一般习惯于放在这个地方。\n\n复制过来之后这就是我们的头文件，然后我们可以创建一个c文件，实现头文件的方法\n\n文件内容如下\n\n```c\n#include \"com_example_zzw_helloworld_JniUtils.h\"\n\nJNIEXPORT jstring JNICALL Java_com_example_zzw_helloworld_JniUtils_stringFromJNI\n        (JNIEnv *env, jobject instance) {\n    return (*env)->NewStringUTF(env, \"Hello from JNI !\");\n}\n```\n\nbuild.gradle中需要配置ndk\n![这里写图片描述](http://img.blog.csdn.net/20161011182053587)\n\n然后点击运行。\n\n遇到的问题，\n报错\n\n```\nError:Execution failed for task ':app:compileDebugNdk'.\n> Error: NDK integration is deprecated in the current plugin.  Consider trying the new experimental plugin.  For details, see http://tools.android.com/tech-docs/new-build-system/gradle-experimental.  Set \"$USE_DEPRECATED_NDK=true\" in gradle.properties to continue using the current NDK integration.\n```\n\n这是因为gradle插件版本太高，已经不支持这个方法了，它提示我们在gradle.properties里面加一句话，但经过我测试，那句话是不对的，应该加如下一句：\n\n```\nandroid.useDeprecatedNdk=true\n```\n\n然后运行，正常。\n\n### Android Studio2.2之后使用NDK\n前面我们看到其实比起第一种方法也没有简化多少，所以在Studio2.2的时候google又尝试简化了做法，Android Studio 2.2开始支持用內建的方法来执行复杂的NDK编译，这意味着开发者只需要写好c文件，其他所有的编译，链接都可以交给系统去做。\n\n*注意：gradle版本需要2.2及以上*\n\n这个特性的实现要依赖于一个build标签，叫externalNativeBuild。标签配置如下\n\n```xml\ndefaultConfig {\n    externalNativeBuild {\n        ndkBuild {\n            arguments \"NDK_LIBS_OUT=$jniLibsDir\", \"-j$numProcs\", \"all\"\n            abiFilters \"armeabi-v7a\"\n        }\n    }\n}\nexternalNativeBuild{\n    ndkBuild{\n        path \"src/main/jni/Android.mk\"\n    }\n}\n```\n arguments指定编译的参数，abiFilters指定编译的平台，这些参数都可以省略以使用默认参数。下面path指定make文件的位置。\n\n之后，NDK执行的task配置如下\n\n```xml\ntask ndkBuild(type: Exec) {\n    commandLine getNdkBuildCmd(),\n            '-C', file('src/main/jni').absolutePath,\n            '-j', Runtime.runtime.availableProcessors(),\n            \"NDK_LIBS_OUT=$jniLibsDir\",\n            'all',\n            'NDK_DEBUG=1'\n\n    dependsOn 'generateLuaBytecodes'\n\n    doFirst {\n        println '== ndkBuild =='\n    }\n}\n```\n\n接下来让我们来看一下，具体的实现步骤是什么样的，不需要像以前一样自己写头文件，然后再编译，现在只需要关注c文件即可。以hello world为例，我们写一个C文件如下：\n\n```c\n#include <string.h>\n#include <jni.h>\n\n\nJNIEXPORT jstring JNICALL\nJava_com_example_zzw_helloworld_MainActivity_stringFromJNI(JNIEnv *env, jobject instance) {\n    return (*env)->NewStringUTF(env, \"Hello from JNI !\");\n}\n```\n注意方法名要以调用它的JAVA文件的包名+类名+方法名命名。\n这样写完之后，我们就可以在相应的JAVA文件中调用了，代码如下：\n\n```java\npackage com.example.zzw.helloworld;\n\nimport android.os.Bundle;\nimport android.support.v7.app.AppCompatActivity;\n\npublic class MainActivity extends AppCompatActivity {\n\n\n\n    static {\n        System.loadLibrary(\"hello-jni\");\n    }\n\n    public native String stringFromJNI();\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        System.out.println(stringFromJNI());\n\n    }\n}\n```\n\n先用loadLibrary引入so文件，然后用native声明底层方法，然后我们就可以在程序中调用方法了。\n当然前面提到了make文件，我们要创建一个Android.mk文件在externalNativeBuild中声明的位置，如下：\n\n```makefile\nLOCAL_PATH := $(call my-dir)\n\ninclude $(CLEAR_VARS)\n\nLOCAL_MODULE    := hello-jni\nLOCAL_SRC_FILES := hello-jni.c\n\ninclude $(BUILD_SHARED_LIBRARY)\n```\n\n之后，make project，运行程序应该就能看的效果了，通过这种方法生成的so文件放在app/.externalNativeBuild/debug/obj/local/下，并以lib+类名命名文件，如下：\n\n![这里写图片描述](http://img.blog.csdn.net/20161011182623870)\n\n 感觉现在应该很简单了，只需要关注方法实现就可以了，其他基本都不要开发者关心了。\n\n","slug":"AndroidNDK使用简介","published":1,"updated":"2024-06-14T09:25:33.676Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clxjsxtvy000clq6ghqk6xyh2","content":"<p>今天我们来简单说一下Android NDK的使用方法。众所周知，so文件在Android的开发过程中起到了很重要的作用，无论与底层设备打交道还是在Android安全领域。so文件都格外受人青睐。NDK就是Android发布的用于编译so文件的一套工具，</p>\n<p>引用自百度百科的一段解释</p>\n<blockquote>\n<p>Android NDK 是在SDK前面又加上了“原生”二字，即Native Development Kit，因此又被Google称为“NDK”。</p>\n<p>众所周知，Android程序运行在Dalvik虚拟机中，NDK允许用户使用类似C / C++之类的原生代码语言执行部分程序。<br>NDK包括了：</p>\n<ul>\n<li>从C / C++生成原生代码库所需要的工具和build files。</li>\n<li>将一致的原生库嵌入可以在Android设备上部署的应用程序包文件（application packages files ，即.apk文件）中。</li>\n<li>支持所有未来Android平台的一系列原生系统头文件和库</li>\n</ul>\n<p>为何要用到NDK?<br>概括来说主要分为以下几种情况：</p>\n<ol>\n<li>代码的保护，由于apk的java层代码很容易被反编译，而C/C++库反汇难度较大。</li>\n<li>在NDK中调用第三方C/C++库，因为大部分的开源库都是用C/C++代码编写的。</li>\n<li>便于移植，用C/C++写的库可以方便在其他的嵌入式平台上再次使用。</li>\n</ol>\n</blockquote>\n<p>本文从以下三个方面讲解NDK的使用</p>\n<ul>\n<li>直接在命令行中用NDK进行编译</li>\n<li>Android Studio2.2以前对NDK的支持</li>\n<li>Android Studio2.2及以后对NDK的支持</li>\n</ul>\n<h3 id=\"直接在命令行使用NDK\"><a href=\"#直接在命令行使用NDK\" class=\"headerlink\" title=\"直接在命令行使用NDK\"></a>直接在命令行使用NDK</h3><p>NDK本来就是一套编译工具，自然是在命令行中执行，其实后面两种方法都是对这种方法的自动化处理，万变不离其宗， 要理解后面两种方法，还是应该熟悉一下不借助任何工具时的操作。</p>\n<p>SDK默认是不带NDK的，所以NDK需要额外下载，下载后还需要配置环境变量。具体方法可以查看百度，配置环境变量很简单，只需要把NDK根目录，也就是ndk-build所在的目录加入环境变量即可。</p>\n<p>用NDK-BUILD构建一个NDK程序，我们知道就是将C文件编译成so文件，其实原理很简单，用gcc进行编译。哦，因为我是mac环境，所以自带GCC编译环境，如果是windows下的话，还需要安装Cygwin环境来模拟linux，不过听说最新的NDK自带Cygwin，所以不再需要额外安装，Windows的同学可以试一下，有问题可以在评论区提问， 有机会我会补充Win下的使用方法。</p>\n<p>编译c程序需要makefile，其实简单说就是告诉GCC怎么编译，先编什么在编什么，需要哪些包等等。这个熟悉c的同学应该知道的。一个简单的so项目包含以下四个文件。</p>\n<p><img src=\"http://img.blog.csdn.net/20161011175730810\" alt=\"这里写图片描述\"></p>\n<p>除了.h和.c文件，还有两个makefile，Application.mk是项目makefile，它会指定调用哪个子makefile，然后Android.mk是具体执行操作的makefile。Application.mk的名字不能变，因为NDK会默认去找这个文件，后面也会讲到，Android.mk的名字可以变，是配置在Application.mk中的。</p>\n<p>然后NDK还有一些规定，看.h文件的名字，c文件中的方法与java中某个方法是一一对应的，出于安全考量，NDK要求C中的方法名应该以对应java文件的包名+类名+方法名来命名。</p>\n<p>头文件</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/* DO NOT EDIT THIS FILE - it is machine generated */</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;jni.h&gt;</span></span></div><div class=\"line\"><span class=\"comment\">/* Header for class com_example_zzw_helloworld_JniUtils */</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> _Included_com_example_zzw_helloworld_JniUtils</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> _Included_com_example_zzw_helloworld_JniUtils</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> __cplusplus</span></div><div class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">\"C\"</span> &#123;</div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></div><div class=\"line\"><span class=\"comment\">/*</span></div><div class=\"line\"> * Class:     com_example_zzw_helloworld_JniUtils</div><div class=\"line\"> * Method:    stringFromJNI</div><div class=\"line\"> * Signature: ()Ljava/lang/String;</div><div class=\"line\"> */</div><div class=\"line\"><span class=\"function\">JNIEXPORT jstring JNICALL <span class=\"title\">Java_com_example_zzw_helloworld_JniUtils_stringFromJNI</span></span></div><div class=\"line\">  <span class=\"params\">(JNIEnv *, jobject)</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> __cplusplus</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></div></pre></td></tr></table></figure>\n<p> 这个头文件很简单，就声明了一个方法，这两个参数是固定的，这个方法在java中的表现形式为</p>\n<pre><code>stringFromJNI() \n</code></pre><p>返回类型对应的是java中的string。然后创建C文件，实现该方法。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//</span></div><div class=\"line\"><span class=\"comment\">// Created by zzw on 16/10/11.</span></div><div class=\"line\"><span class=\"comment\">//</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"com_example_zzw_helloworld_JniUtils.h\"</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\">JNIEXPORT jstring JNICALL <span class=\"title\">Java_com_example_zzw_helloworld_JniUtils_stringFromJNI</span></span></div><div class=\"line\">        <span class=\"params\">(JNIEnv *env, jobject instance)</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> (*env)-&gt;NewStringUTF(env, <span class=\"string\">\"Hello from JNI !\"</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>然后我们还需要两个make文件，一个是Application.mk另一个是Android.mk<br>Application.mk内容如下：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">APP_BUILD_SCRIPT := /Users/zzw/Desktop/jni/Android.mk</div></pre></td></tr></table></figure>\n<p>其实就是声明Android.mk的位置<br>Android.mk如下：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">LOCAL_PATH := <span class=\"variable\">$(call my-dir)</span></div><div class=\"line\"></div><div class=\"line\">include $(CLEAR_VARS)</div><div class=\"line\"></div><div class=\"line\">LOCAL_MODULE    := hello-jni</div><div class=\"line\">LOCAL_SRC_FILES := hello-jni.c</div><div class=\"line\"></div><div class=\"line\">include $(BUILD_SHARED_LIBRARY)</div></pre></td></tr></table></figure>\n<p>然后运行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">./ndk-build NDK_PROJECT_PATH=/Users/zzw/Desktop</div></pre></td></tr></table></figure>\n<p>指定PROJECT的位置，然后NDK会自动寻找该路径下的jni文件夹中的Application.mk，然后去编译。</p>\n<p>如果编译成功，则会在该文件夹下生成libs文件夹，里面就是各种架构下的so文件<br><img src=\"http://img.blog.csdn.net/20161011181217255\" alt=\"这里写图片描述\"></p>\n<p>生成的文件放在Android的libs中，对应的java文件调用方法为</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> com.example.zzw.helloworld;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"> * Created by zzw on 16/10/11.</div><div class=\"line\"> */</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JniUtils</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">static</span> &#123;</div><div class=\"line\">        System.loadLibrary(<span class=\"string\">\"hello-jni\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">native</span> String <span class=\"title\">stringFromJNI</span><span class=\"params\">()</span></span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">stringFromJNINative</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> stringFromJNI();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>先用loadLibrary引入so文件，然后用native声明底层方法，然后我们就可以在程序中调用方法了。</p>\n<p>这种方法完全没有借助任何的IDE，不过你也能看出来，有些工作是可以简化的，下面我们就说下在IDE中的做法。</p>\n<h3 id=\"Android-Studio2-2-之前使用NDK\"><a href=\"#Android-Studio2-2-之前使用NDK\" class=\"headerlink\" title=\"Android Studio2.2 之前使用NDK\"></a>Android Studio2.2 之前使用NDK</h3><p>老的Android Studio支持NDK的方式可以根据java类帮我们生成头文件，然后编译过程可以写在gradle中，而不需要先编出so，再编android这样，具体过程如下</p>\n<p>先写一个Java类，因为我们可以用jni工具根据java类来生成头文件，java类载入so文件并且声明底层方法，这个和前面一样，如下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> com.example.zzw.helloworld;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"> * Created by zzw on 16/10/11.</div><div class=\"line\"> */</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JniUtils</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">static</span> &#123;</div><div class=\"line\">        System.loadLibrary(<span class=\"string\">\"hello-jni\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">native</span> String <span class=\"title\">stringFromJNI</span><span class=\"params\">()</span></span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">stringFromJNINative</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> stringFromJNI();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>然后编译程序，注意只编译不运行，因为此时运行会报错，编译后，在build的文件夹下面能看到这个class文件</p>\n<p><img src=\"http://img.blog.csdn.net/20161011181737161\" alt=\"这里写图片描述\"></p>\n<p>接下来我们可以用jni工具来根据这个class文件自动生成头文件了。命令行cd到build文件夹一层，然后执行如下命令</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">cd</span> app/build/intermediates/classes/debug/</div><div class=\"line\">javah -jni com.example.zzw.helloworld.JniUtils</div></pre></td></tr></table></figure>\n<p>完整路径的类名，如果这一步报错，可以检查一下NDK有没有配到环境变量里。方法可以自行百度。</p>\n<p>如果成功的话，你应该能看到在build文件夹下生成了一个.h文件，如下</p>\n<p><img src=\"http://img.blog.csdn.net/20161011181815929\" alt=\"这里写图片描述\"></p>\n<p>把这个文件拷贝到main下面jni文件夹下，这个文件夹也不是固定的，可以配置。但是我们一般习惯于放在这个地方。</p>\n<p>复制过来之后这就是我们的头文件，然后我们可以创建一个c文件，实现头文件的方法</p>\n<p>文件内容如下</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"com_example_zzw_helloworld_JniUtils.h\"</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\">JNIEXPORT jstring JNICALL <span class=\"title\">Java_com_example_zzw_helloworld_JniUtils_stringFromJNI</span></span></div><div class=\"line\">        <span class=\"params\">(JNIEnv *env, jobject instance)</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> (*env)-&gt;NewStringUTF(env, <span class=\"string\">\"Hello from JNI !\"</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>build.gradle中需要配置ndk<br><img src=\"http://img.blog.csdn.net/20161011182053587\" alt=\"这里写图片描述\"></p>\n<p>然后点击运行。</p>\n<p>遇到的问题，<br>报错</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">Error:Execution failed for task &apos;:app:compileDebugNdk&apos;.</div><div class=\"line\">&gt; Error: NDK integration is deprecated in the current plugin.  Consider trying the new experimental plugin.  For details, see http://tools.android.com/tech-docs/new-build-system/gradle-experimental.  Set &quot;$USE_DEPRECATED_NDK=true&quot; in gradle.properties to continue using the current NDK integration.</div></pre></td></tr></table></figure>\n<p>这是因为gradle插件版本太高，已经不支持这个方法了，它提示我们在gradle.properties里面加一句话，但经过我测试，那句话是不对的，应该加如下一句：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">android.useDeprecatedNdk=true</div></pre></td></tr></table></figure>\n<p>然后运行，正常。</p>\n<h3 id=\"Android-Studio2-2之后使用NDK\"><a href=\"#Android-Studio2-2之后使用NDK\" class=\"headerlink\" title=\"Android Studio2.2之后使用NDK\"></a>Android Studio2.2之后使用NDK</h3><p>前面我们看到其实比起第一种方法也没有简化多少，所以在Studio2.2的时候google又尝试简化了做法，Android Studio 2.2开始支持用內建的方法来执行复杂的NDK编译，这意味着开发者只需要写好c文件，其他所有的编译，链接都可以交给系统去做。</p>\n<p><em>注意：gradle版本需要2.2及以上</em></p>\n<p>这个特性的实现要依赖于一个build标签，叫externalNativeBuild。标签配置如下</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">defaultConfig &#123;</div><div class=\"line\">    externalNativeBuild &#123;</div><div class=\"line\">        ndkBuild &#123;</div><div class=\"line\">            arguments \"NDK_LIBS_OUT=$jniLibsDir\", \"-j$numProcs\", \"all\"</div><div class=\"line\">            abiFilters \"armeabi-v7a\"</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">externalNativeBuild&#123;</div><div class=\"line\">    ndkBuild&#123;</div><div class=\"line\">        path \"src/main/jni/Android.mk\"</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p> arguments指定编译的参数，abiFilters指定编译的平台，这些参数都可以省略以使用默认参数。下面path指定make文件的位置。</p>\n<p>之后，NDK执行的task配置如下</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">task ndkBuild(type: Exec) &#123;</div><div class=\"line\">    commandLine getNdkBuildCmd(),</div><div class=\"line\">            '-C', file('src/main/jni').absolutePath,</div><div class=\"line\">            '-j', Runtime.runtime.availableProcessors(),</div><div class=\"line\">            \"NDK_LIBS_OUT=$jniLibsDir\",</div><div class=\"line\">            'all',</div><div class=\"line\">            'NDK_DEBUG=1'</div><div class=\"line\"></div><div class=\"line\">    dependsOn 'generateLuaBytecodes'</div><div class=\"line\"></div><div class=\"line\">    doFirst &#123;</div><div class=\"line\">        println '== ndkBuild =='</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>接下来让我们来看一下，具体的实现步骤是什么样的，不需要像以前一样自己写头文件，然后再编译，现在只需要关注c文件即可。以hello world为例，我们写一个C文件如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string.h&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;jni.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\">JNIEXPORT jstring JNICALL</span></div><div class=\"line\"><span class=\"title\">Java_com_example_zzw_helloworld_MainActivity_stringFromJNI</span><span class=\"params\">(JNIEnv *env, jobject instance)</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> (*env)-&gt;NewStringUTF(env, <span class=\"string\">\"Hello from JNI !\"</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>注意方法名要以调用它的JAVA文件的包名+类名+方法名命名。<br>这样写完之后，我们就可以在相应的JAVA文件中调用了，代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> com.example.zzw.helloworld;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> android.os.Bundle;</div><div class=\"line\"><span class=\"keyword\">import</span> android.support.v7.app.AppCompatActivity;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">AppCompatActivity</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">static</span> &#123;</div><div class=\"line\">        System.loadLibrary(<span class=\"string\">\"hello-jni\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> String <span class=\"title\">stringFromJNI</span><span class=\"params\">()</span></span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</div><div class=\"line\">        setContentView(R.layout.activity_main);</div><div class=\"line\">        System.out.println(stringFromJNI());</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>先用loadLibrary引入so文件，然后用native声明底层方法，然后我们就可以在程序中调用方法了。<br>当然前面提到了make文件，我们要创建一个Android.mk文件在externalNativeBuild中声明的位置，如下：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">LOCAL_PATH := <span class=\"variable\">$(call my-dir)</span></div><div class=\"line\"></div><div class=\"line\">include $(CLEAR_VARS)</div><div class=\"line\"></div><div class=\"line\">LOCAL_MODULE    := hello-jni</div><div class=\"line\">LOCAL_SRC_FILES := hello-jni.c</div><div class=\"line\"></div><div class=\"line\">include $(BUILD_SHARED_LIBRARY)</div></pre></td></tr></table></figure>\n<p>之后，make project，运行程序应该就能看的效果了，通过这种方法生成的so文件放在app/.externalNativeBuild/debug/obj/local/下，并以lib+类名命名文件，如下：</p>\n<p><img src=\"http://img.blog.csdn.net/20161011182623870\" alt=\"这里写图片描述\"></p>\n<p> 感觉现在应该很简单了，只需要关注方法实现就可以了，其他基本都不要开发者关心了。</p>\n","excerpt":"","more":"<p>今天我们来简单说一下Android NDK的使用方法。众所周知，so文件在Android的开发过程中起到了很重要的作用，无论与底层设备打交道还是在Android安全领域。so文件都格外受人青睐。NDK就是Android发布的用于编译so文件的一套工具，</p>\n<p>引用自百度百科的一段解释</p>\n<blockquote>\n<p>Android NDK 是在SDK前面又加上了“原生”二字，即Native Development Kit，因此又被Google称为“NDK”。</p>\n<p>众所周知，Android程序运行在Dalvik虚拟机中，NDK允许用户使用类似C / C++之类的原生代码语言执行部分程序。<br>NDK包括了：</p>\n<ul>\n<li>从C / C++生成原生代码库所需要的工具和build files。</li>\n<li>将一致的原生库嵌入可以在Android设备上部署的应用程序包文件（application packages files ，即.apk文件）中。</li>\n<li>支持所有未来Android平台的一系列原生系统头文件和库</li>\n</ul>\n<p>为何要用到NDK?<br>概括来说主要分为以下几种情况：</p>\n<ol>\n<li>代码的保护，由于apk的java层代码很容易被反编译，而C/C++库反汇难度较大。</li>\n<li>在NDK中调用第三方C/C++库，因为大部分的开源库都是用C/C++代码编写的。</li>\n<li>便于移植，用C/C++写的库可以方便在其他的嵌入式平台上再次使用。</li>\n</ol>\n</blockquote>\n<p>本文从以下三个方面讲解NDK的使用</p>\n<ul>\n<li>直接在命令行中用NDK进行编译</li>\n<li>Android Studio2.2以前对NDK的支持</li>\n<li>Android Studio2.2及以后对NDK的支持</li>\n</ul>\n<h3 id=\"直接在命令行使用NDK\"><a href=\"#直接在命令行使用NDK\" class=\"headerlink\" title=\"直接在命令行使用NDK\"></a>直接在命令行使用NDK</h3><p>NDK本来就是一套编译工具，自然是在命令行中执行，其实后面两种方法都是对这种方法的自动化处理，万变不离其宗， 要理解后面两种方法，还是应该熟悉一下不借助任何工具时的操作。</p>\n<p>SDK默认是不带NDK的，所以NDK需要额外下载，下载后还需要配置环境变量。具体方法可以查看百度，配置环境变量很简单，只需要把NDK根目录，也就是ndk-build所在的目录加入环境变量即可。</p>\n<p>用NDK-BUILD构建一个NDK程序，我们知道就是将C文件编译成so文件，其实原理很简单，用gcc进行编译。哦，因为我是mac环境，所以自带GCC编译环境，如果是windows下的话，还需要安装Cygwin环境来模拟linux，不过听说最新的NDK自带Cygwin，所以不再需要额外安装，Windows的同学可以试一下，有问题可以在评论区提问， 有机会我会补充Win下的使用方法。</p>\n<p>编译c程序需要makefile，其实简单说就是告诉GCC怎么编译，先编什么在编什么，需要哪些包等等。这个熟悉c的同学应该知道的。一个简单的so项目包含以下四个文件。</p>\n<p><img src=\"http://img.blog.csdn.net/20161011175730810\" alt=\"这里写图片描述\"></p>\n<p>除了.h和.c文件，还有两个makefile，Application.mk是项目makefile，它会指定调用哪个子makefile，然后Android.mk是具体执行操作的makefile。Application.mk的名字不能变，因为NDK会默认去找这个文件，后面也会讲到，Android.mk的名字可以变，是配置在Application.mk中的。</p>\n<p>然后NDK还有一些规定，看.h文件的名字，c文件中的方法与java中某个方法是一一对应的，出于安全考量，NDK要求C中的方法名应该以对应java文件的包名+类名+方法名来命名。</p>\n<p>头文件</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/* DO NOT EDIT THIS FILE - it is machine generated */</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;jni.h&gt;</span></span></div><div class=\"line\"><span class=\"comment\">/* Header for class com_example_zzw_helloworld_JniUtils */</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> _Included_com_example_zzw_helloworld_JniUtils</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> _Included_com_example_zzw_helloworld_JniUtils</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> __cplusplus</span></div><div class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">\"C\"</span> &#123;</div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></div><div class=\"line\"><span class=\"comment\">/*</div><div class=\"line\"> * Class:     com_example_zzw_helloworld_JniUtils</div><div class=\"line\"> * Method:    stringFromJNI</div><div class=\"line\"> * Signature: ()Ljava/lang/String;</div><div class=\"line\"> */</span></div><div class=\"line\"><span class=\"function\">JNIEXPORT jstring JNICALL <span class=\"title\">Java_com_example_zzw_helloworld_JniUtils_stringFromJNI</span></div><div class=\"line\">  <span class=\"params\">(JNIEnv *, jobject)</span></span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> __cplusplus</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></div></pre></td></tr></table></figure>\n<p> 这个头文件很简单，就声明了一个方法，这两个参数是固定的，这个方法在java中的表现形式为</p>\n<pre><code>stringFromJNI() \n</code></pre><p>返回类型对应的是java中的string。然后创建C文件，实现该方法。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//</span></div><div class=\"line\"><span class=\"comment\">// Created by zzw on 16/10/11.</span></div><div class=\"line\"><span class=\"comment\">//</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"com_example_zzw_helloworld_JniUtils.h\"</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\">JNIEXPORT jstring JNICALL <span class=\"title\">Java_com_example_zzw_helloworld_JniUtils_stringFromJNI</span></div><div class=\"line\">        <span class=\"params\">(JNIEnv *env, jobject instance)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> (*env)-&gt;NewStringUTF(env, <span class=\"string\">\"Hello from JNI !\"</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>然后我们还需要两个make文件，一个是Application.mk另一个是Android.mk<br>Application.mk内容如下：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">APP_BUILD_SCRIPT := /Users/zzw/Desktop/jni/Android.mk</div></pre></td></tr></table></figure>\n<p>其实就是声明Android.mk的位置<br>Android.mk如下：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">LOCAL_PATH := <span class=\"variable\">$(call my-dir)</span></div><div class=\"line\"></div><div class=\"line\">include $(CLEAR_VARS)</div><div class=\"line\"></div><div class=\"line\">LOCAL_MODULE    := hello-jni</div><div class=\"line\">LOCAL_SRC_FILES := hello-jni.c</div><div class=\"line\"></div><div class=\"line\">include $(BUILD_SHARED_LIBRARY)</div></pre></td></tr></table></figure>\n<p>然后运行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">./ndk-build NDK_PROJECT_PATH=/Users/zzw/Desktop</div></pre></td></tr></table></figure>\n<p>指定PROJECT的位置，然后NDK会自动寻找该路径下的jni文件夹中的Application.mk，然后去编译。</p>\n<p>如果编译成功，则会在该文件夹下生成libs文件夹，里面就是各种架构下的so文件<br><img src=\"http://img.blog.csdn.net/20161011181217255\" alt=\"这里写图片描述\"></p>\n<p>生成的文件放在Android的libs中，对应的java文件调用方法为</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> com.example.zzw.helloworld;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\"> * Created by zzw on 16/10/11.</div><div class=\"line\"> */</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JniUtils</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">static</span> &#123;</div><div class=\"line\">        System.loadLibrary(<span class=\"string\">\"hello-jni\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">native</span> String <span class=\"title\">stringFromJNI</span><span class=\"params\">()</span></span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">stringFromJNINative</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> stringFromJNI();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>先用loadLibrary引入so文件，然后用native声明底层方法，然后我们就可以在程序中调用方法了。</p>\n<p>这种方法完全没有借助任何的IDE，不过你也能看出来，有些工作是可以简化的，下面我们就说下在IDE中的做法。</p>\n<h3 id=\"Android-Studio2-2-之前使用NDK\"><a href=\"#Android-Studio2-2-之前使用NDK\" class=\"headerlink\" title=\"Android Studio2.2 之前使用NDK\"></a>Android Studio2.2 之前使用NDK</h3><p>老的Android Studio支持NDK的方式可以根据java类帮我们生成头文件，然后编译过程可以写在gradle中，而不需要先编出so，再编android这样，具体过程如下</p>\n<p>先写一个Java类，因为我们可以用jni工具根据java类来生成头文件，java类载入so文件并且声明底层方法，这个和前面一样，如下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> com.example.zzw.helloworld;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\"> * Created by zzw on 16/10/11.</div><div class=\"line\"> */</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JniUtils</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">static</span> &#123;</div><div class=\"line\">        System.loadLibrary(<span class=\"string\">\"hello-jni\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">native</span> String <span class=\"title\">stringFromJNI</span><span class=\"params\">()</span></span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">stringFromJNINative</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> stringFromJNI();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>然后编译程序，注意只编译不运行，因为此时运行会报错，编译后，在build的文件夹下面能看到这个class文件</p>\n<p><img src=\"http://img.blog.csdn.net/20161011181737161\" alt=\"这里写图片描述\"></p>\n<p>接下来我们可以用jni工具来根据这个class文件自动生成头文件了。命令行cd到build文件夹一层，然后执行如下命令</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">cd</span> app/build/intermediates/classes/debug/</div><div class=\"line\">javah -jni com.example.zzw.helloworld.JniUtils</div></pre></td></tr></table></figure>\n<p>完整路径的类名，如果这一步报错，可以检查一下NDK有没有配到环境变量里。方法可以自行百度。</p>\n<p>如果成功的话，你应该能看到在build文件夹下生成了一个.h文件，如下</p>\n<p><img src=\"http://img.blog.csdn.net/20161011181815929\" alt=\"这里写图片描述\"></p>\n<p>把这个文件拷贝到main下面jni文件夹下，这个文件夹也不是固定的，可以配置。但是我们一般习惯于放在这个地方。</p>\n<p>复制过来之后这就是我们的头文件，然后我们可以创建一个c文件，实现头文件的方法</p>\n<p>文件内容如下</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"com_example_zzw_helloworld_JniUtils.h\"</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\">JNIEXPORT jstring JNICALL <span class=\"title\">Java_com_example_zzw_helloworld_JniUtils_stringFromJNI</span></div><div class=\"line\">        <span class=\"params\">(JNIEnv *env, jobject instance)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> (*env)-&gt;NewStringUTF(env, <span class=\"string\">\"Hello from JNI !\"</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>build.gradle中需要配置ndk<br><img src=\"http://img.blog.csdn.net/20161011182053587\" alt=\"这里写图片描述\"></p>\n<p>然后点击运行。</p>\n<p>遇到的问题，<br>报错</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">Error:Execution failed for task &apos;:app:compileDebugNdk&apos;.</div><div class=\"line\">&gt; Error: NDK integration is deprecated in the current plugin.  Consider trying the new experimental plugin.  For details, see http://tools.android.com/tech-docs/new-build-system/gradle-experimental.  Set &quot;$USE_DEPRECATED_NDK=true&quot; in gradle.properties to continue using the current NDK integration.</div></pre></td></tr></table></figure>\n<p>这是因为gradle插件版本太高，已经不支持这个方法了，它提示我们在gradle.properties里面加一句话，但经过我测试，那句话是不对的，应该加如下一句：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">android.useDeprecatedNdk=true</div></pre></td></tr></table></figure>\n<p>然后运行，正常。</p>\n<h3 id=\"Android-Studio2-2之后使用NDK\"><a href=\"#Android-Studio2-2之后使用NDK\" class=\"headerlink\" title=\"Android Studio2.2之后使用NDK\"></a>Android Studio2.2之后使用NDK</h3><p>前面我们看到其实比起第一种方法也没有简化多少，所以在Studio2.2的时候google又尝试简化了做法，Android Studio 2.2开始支持用內建的方法来执行复杂的NDK编译，这意味着开发者只需要写好c文件，其他所有的编译，链接都可以交给系统去做。</p>\n<p><em>注意：gradle版本需要2.2及以上</em></p>\n<p>这个特性的实现要依赖于一个build标签，叫externalNativeBuild。标签配置如下</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">defaultConfig &#123;</div><div class=\"line\">    externalNativeBuild &#123;</div><div class=\"line\">        ndkBuild &#123;</div><div class=\"line\">            arguments \"NDK_LIBS_OUT=$jniLibsDir\", \"-j$numProcs\", \"all\"</div><div class=\"line\">            abiFilters \"armeabi-v7a\"</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">externalNativeBuild&#123;</div><div class=\"line\">    ndkBuild&#123;</div><div class=\"line\">        path \"src/main/jni/Android.mk\"</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p> arguments指定编译的参数，abiFilters指定编译的平台，这些参数都可以省略以使用默认参数。下面path指定make文件的位置。</p>\n<p>之后，NDK执行的task配置如下</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">task ndkBuild(type: Exec) &#123;</div><div class=\"line\">    commandLine getNdkBuildCmd(),</div><div class=\"line\">            '-C', file('src/main/jni').absolutePath,</div><div class=\"line\">            '-j', Runtime.runtime.availableProcessors(),</div><div class=\"line\">            \"NDK_LIBS_OUT=$jniLibsDir\",</div><div class=\"line\">            'all',</div><div class=\"line\">            'NDK_DEBUG=1'</div><div class=\"line\"></div><div class=\"line\">    dependsOn 'generateLuaBytecodes'</div><div class=\"line\"></div><div class=\"line\">    doFirst &#123;</div><div class=\"line\">        println '== ndkBuild =='</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>接下来让我们来看一下，具体的实现步骤是什么样的，不需要像以前一样自己写头文件，然后再编译，现在只需要关注c文件即可。以hello world为例，我们写一个C文件如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string.h&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;jni.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\">JNIEXPORT jstring JNICALL</div><div class=\"line\"><span class=\"title\">Java_com_example_zzw_helloworld_MainActivity_stringFromJNI</span><span class=\"params\">(JNIEnv *env, jobject instance)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> (*env)-&gt;NewStringUTF(env, <span class=\"string\">\"Hello from JNI !\"</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>注意方法名要以调用它的JAVA文件的包名+类名+方法名命名。<br>这样写完之后，我们就可以在相应的JAVA文件中调用了，代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> com.example.zzw.helloworld;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> android.os.Bundle;</div><div class=\"line\"><span class=\"keyword\">import</span> android.support.v7.app.AppCompatActivity;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">AppCompatActivity</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">static</span> &#123;</div><div class=\"line\">        System.loadLibrary(<span class=\"string\">\"hello-jni\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> String <span class=\"title\">stringFromJNI</span><span class=\"params\">()</span></span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</div><div class=\"line\">        setContentView(R.layout.activity_main);</div><div class=\"line\">        System.out.println(stringFromJNI());</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>先用loadLibrary引入so文件，然后用native声明底层方法，然后我们就可以在程序中调用方法了。<br>当然前面提到了make文件，我们要创建一个Android.mk文件在externalNativeBuild中声明的位置，如下：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">LOCAL_PATH := <span class=\"variable\">$(call my-dir)</span></div><div class=\"line\"></div><div class=\"line\">include $(CLEAR_VARS)</div><div class=\"line\"></div><div class=\"line\">LOCAL_MODULE    := hello-jni</div><div class=\"line\">LOCAL_SRC_FILES := hello-jni.c</div><div class=\"line\"></div><div class=\"line\">include $(BUILD_SHARED_LIBRARY)</div></pre></td></tr></table></figure>\n<p>之后，make project，运行程序应该就能看的效果了，通过这种方法生成的so文件放在app/.externalNativeBuild/debug/obj/local/下，并以lib+类名命名文件，如下：</p>\n<p><img src=\"http://img.blog.csdn.net/20161011182623870\" alt=\"这里写图片描述\"></p>\n<p> 感觉现在应该很简单了，只需要关注方法实现就可以了，其他基本都不要开发者关心了。</p>\n"},{"title":"SpringMVC对象绑定时自定义名称对应关系","date":"2016-12-28T10:15:57.000Z","_content":"\n例行推广一下我的博客，喜欢这篇文章的朋友可以看我的博客[http://zwgeek.com](http://zwgeek.com)\n\n这个需求来源自一个Post的Controller的请求含有太多的参数，于是想把所有的参数封装到对象中，然后Controller的方法接收一个对象类型的参数，这样后期扩展修改都比较方便，不需要动到方法签名。\n\n有一句俗话说得好，需求是第一生产力，上面的这个需求就催生了这篇文章的一系列调研。\n\n首先，这个需求SpringMVC本身是支持的，你把一个对象放在Controller方法的参数里，SpringMVC本身的支持就能把request中和这个对象属性同名的参数绑定到对象属性上，比如下面这样：\n\n```java\n@RequestMapping(value = \"/test\", method = RequestMethod.GET)\npublic void test(Test test) {\n   LOG.debug(test.toString());\n}\n```\n\nTest中是这样定义的\n```\npublic class Test {\n\n    private String test1;\n\n    private String test2;\n\n    private String test3;\n}\n```\n由于我使用了lombok，所以没有Getter和Setter方法，大家看demo的时候可以注意下。这个时候我们访问/test?test1=1&test2=2&test3=3，SpringMVC会自动把同名的属性和Request中的参数绑定在一起。\n\n![这里写图片描述](http://img.blog.csdn.net/20161228184306167?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemd6Y3p6dw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n到这里貌似可以结题了，开玩笑，哪有这么简单。大家想这样一种情况，在JAVA中我们用的是驼峰命名法（比如：testName），而在前端JS中我们大多用的是蛇形命名法（比如：test_name）。当然，我们可以要求前端在请求接口的时候用驼峰命名法，但是问题不是这样逃避的。另外，如果我前端接口参数的名字和对象里面属性的名字不一样怎么办呢，比如前端接口里参数叫person，但是我对象里的属性叫people，当然这种情况比较少，但是也不排除在各种复杂的需求中会出现这种情况，所以我们这篇文章的目的就是做到自定义的参数名和属性名映射，想让哪个请求参数对应哪个属性都可以，想点哪里点哪里就是这个意思。\n\n这篇文章只讲解决方案，我会在下一篇文中讲一下SpringMVC数据绑定的实现原理。\n\n虽然不细说原理，但是有几个概念还是要提前说一下的，使用SpringMVC时，所有的请求都是最先经过DispatcherServlet的，然后由DispatcherServlet选择合适的HandlerMapping和HandlerAdapter来处理请求，HandlerMapping的作用就是找到请求所对应的方法，而HandlerAdapter则来处理和请求相关的的各种事情。我们这里要讲的请求参数绑定也是HandlerAdapter来做的。大概就知道这些吧，我们需要写一个自定义的请求参数处理器，然后把这个处理器放到HandlerAdapter中，这样我们的处理器就可以被拿来处理请求了。\n\n首先第一步，我们先来做一个参数处理器SnakeToCamelModelAttributeMethodProcessor\n```java\npublic class SnakeToCamelModelAttributeMethodProcessor extends ServletModelAttributeMethodProcessor {\n\n    ApplicationContext applicationContext;\n\n    public SnakeToCamelModelAttributeMethodProcessor(boolean annotationNotRequired, ApplicationContext applicationContext) {\n        super(annotationNotRequired);\n        this.applicationContext = applicationContext;\n    }\n\n    @Override\n    protected void bindRequestParameters(WebDataBinder binder, NativeWebRequest request) {\n        SnakeToCamelRequestDataBinder camelBinder = new SnakeToCamelRequestDataBinder(binder.getTarget(), binder.getObjectName());\n        RequestMappingHandlerAdapter requestMappingHandlerAdapter = applicationContext.getBean(RequestMappingHandlerAdapter.class);\n        requestMappingHandlerAdapter.getWebBindingInitializer().initBinder(camelBinder, request);\n        camelBinder.bind(request.getNativeRequest(ServletRequest.class));\n    }\n}\n```\n\n这个处理器要继承ServletModelAttributeMethodProcessor，来看下继承关系\n![这里写图片描述](http://img.blog.csdn.net/20161228201634838?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemd6Y3p6dw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n看最上面实现的是HandlerMethodArgumentResolver接口，这个接口代表这个类是用来处理请求参数的，有两个方法\n```java\npublic interface HandlerMethodArgumentResolver {\n    boolean supportsParameter(MethodParameter var1);\n\n    Object resolveArgument(MethodParameter var1, ModelAndViewContainer var2, NativeWebRequest var3, WebDataBinderFactory var4) throws Exception;\n}\n\n```\nsupportsParameter返回是否支持这种参数，resolveArgument是具体处理参数的方法。ServletModelAttributeMethodProcessor是处理复杂对象的，也就是除了int，char等等简单对象之外自定义的复杂对象，比如上文中我们提到的Test。\n\n我们自定义的处理器也是处理复杂对象，只是扩展了可以处理名称映射，所以继承这个ServletModelAttributeMethodProcessor即可。好了，处理器写好了，那么接下来怎么做呢，重写父类的bindRequestParameters方法，这个方法就是绑定数据对象的时候调用的方法。\n\n在这个方法中，我们新建了一个自定义的DataBinder-SnakeToCamelRequestDataBinder，然后用HandlerAdapter初始化了这个DataBinder，最后调了DataBinder的bind方法。DataBinder顾名思义就是实际去把请求参数和对象绑定的类，这个自定义的DataBinder怎么写呢，如下：\n\n```java\npublic class SnakeToCamelRequestDataBinder extends ExtendedServletRequestDataBinder {\n\n    public SnakeToCamelRequestDataBinder(Object target, String objectName) {\n        super(target, objectName);\n    }\n\n    protected void addBindValues(MutablePropertyValues mpvs, ServletRequest request) {\n        super.addBindValues(mpvs, request);\n\n        //处理JsonProperty注释的对象\n        Class<?> targetClass = getTarget().getClass();\n        Field[] fields = targetClass.getDeclaredFields();\n        for (Field field : fields) {\n            JsonProperty jsonPropertyAnnotation = field.getAnnotation(JsonProperty.class);\n            if (jsonPropertyAnnotation != null && mpvs.contains(jsonPropertyAnnotation.value())) {\n                if (!mpvs.contains(field.getName())) {\n                    mpvs.add(field.getName(), mpvs.getPropertyValue(jsonPropertyAnnotation.value()).getValue());\n                }\n            }\n        }\n\n        List<PropertyValue> covertValues = new ArrayList<PropertyValue>();\n        for (PropertyValue propertyValue : mpvs.getPropertyValueList()) {\n            if(propertyValue.getName().contains(\"_\")) {\n                String camelName = SnakeToCamelRequestParameterUtil.convertSnakeToCamel(propertyValue.getName());\n                if (!mpvs.contains(camelName)) {\n                    covertValues.add(new PropertyValue(camelName, propertyValue.getValue()));\n                }\n            }\n        }\n        mpvs.getPropertyValueList().addAll(covertValues);\n    }\n}\n```\n这个自定义的DataBinder继承自ExtendedServletRequestDataBinder，可扩展的DataBinder，用来给子类复写的方法是addBindValues，有两个参数，一个是MutablePropertyValues类型的，这里面存的就是请求参数的key-value对，还有一个参数是request对象本身。request对象这里用不到，我们用的就是这个MutablePropertyValues类型的mpvs。\n\n其实处理的原理很简单，SpringMVC在做完这一步参数绑定之后就会去通过反射调用Controller中的方法了，调用Controller方法的时候要给参数赋值，赋值的时候就是从这个mpvs里面把对应参数name的value取出来。举个例子，我们的样例Controller中的对象时Test，Test有个属性是Test1，那么在给Test1赋值的时候就会从这个mpvs中去取key为Test1所对应的value。可是你想想，前端请求的参数是test\\_1这样的，所以这个mpvs中只有一个key为test\\_1的值，那自然就会报错。知道了这种处理方法，就很简单了，我们在这个mpvs中再加一个key为test1，value和test_1的value一样的对象就可以了。\n\n再扩展一点，说到自定义Name，比如test\\_1对应属性为test2这样，我们用一个有value的注释，比如这里用到的JsonProperty，在test2上加上注释@JsonProperty(\"test_1\")，这里处理的时候会先把这个注释的值取出来，从mpvs里面查，如果有这个key，那么就把value取出来再加进去一个key为field name的map就可以了。上面SnakeToCamelRequestDataBinder的处理方法大概就是这样了。\n\n然后这里我们抽出了一个工具类，用来处理蛇形string到驼峰string的转换。\n\n```java\npublic class SnakeToCamelRequestParameterUtil {\n    public static String convertSnakeToCamel(String snake) {\n\n        if (snake == null) {\n            return null;\n        }\n\n        if (snake.indexOf(\"_\") < 0) {\n            return snake;\n        }\n\n        String result = \"\";\n\n        String[] split = StringUtils.split(snake, \"_\");\n        int index = 0;\n        for (String s : split) {\n            if (index == 0) {\n                result += s.toLowerCase();\n            } else {\n                result += capitalize(s);\n            }\n            index++;\n        }\n\n        return result;\n    }\n\n    private static String capitalize(String s) {\n\n        if (s == null) {\n            return null;\n        }\n\n        if (s.length() == 1) {\n            return s.toUpperCase();\n        }\n\n        return s.substring(0, 1).toUpperCase() + s.substring(1);\n    }\n}\n```\n\n做完了上面这些，应该说处理过程就搞定了，还差最后一步，需要把我们自定义的处理器SnakeToCamelModelAttributeMethodProcessor加到系统的HandlerAdapter中去。方法有很多，如果你不知道HandlerAdapter是什么东西，那八成你用的是系统默认的HandlerAdapter。加起来也很简单。如果你用了\n\n```xml\n<mvc:annotation-driven>\n```\n\n元素，可以用下面这个方法。\n\n```xml\n<mvc:annotation-driven>\n    <mvc:argument-resolvers>\n        <bean class=\"package.name.SnakeToCamelModelAttributeMethodProcessor\">\n            <constructor-arg name=\"annotationNotRequired\" value=\"true\"/>\n        </bean>\n    </mvc:argument-resolvers>\n</mvc:annotation-driven> \n```\n\n如果你用的是JAVA代码配置，可以用\n\n```java\n@Configuration\npublic class WebContextConfiguration extends WebMvcConfigurationSupport {\n    @Override\n    protected void addArgumentResolvers(List<HandlerMethodArgumentResolver> argumentResolvers) {\n        argumentResolvers.add(processor());\n    }\n\n    @Bean\n    protected SnakeToCamelModelAttributeMethodProcessor processor() {\n        return new SnakeToCamelModelAttributeMethodProcessor(true);\n    }\n} \n```\n\n像我这边，因为项目需要自定义了HandlerAdapter。\n\n```\n<bean class=\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter\">\n        ...\n    </bean>\n```\n\n所以我写了一个注册器，用来把处理器注册进HandlerAdapter，代码如下。\n\n```java\npublic class SnakeToCamelProcessorRegistry implements ApplicationContextAware, BeanFactoryPostProcessor {\n\n    private ApplicationContext applicationContext;\n\n    @Override\n    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {\n        this.applicationContext = applicationContext;\n    }\n\n    @Override\n    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {\n\n        RequestMappingHandlerAdapter requestMappingHandlerAdapter = applicationContext.getBean(RequestMappingHandlerAdapter.class);\n\n        List<HandlerMethodArgumentResolver> resolvers = requestMappingHandlerAdapter.getArgumentResolvers().getResolvers();\n\n\n        List<HandlerMethodArgumentResolver> newResolvers = new ArrayList<HandlerMethodArgumentResolver>();\n\n        for (HandlerMethodArgumentResolver resolver : resolvers) {\n            newResolvers.add(resolver);\n        }\n        newResolvers.add(0, new SnakeToCamelModelAttributeMethodProcessor(true, applicationContext));\n        requestMappingHandlerAdapter.setArgumentResolvers(Collections.unmodifiableList(newResolvers));\n    }\n}\n```\n看起来可能逻辑比较复杂，为什么要做这一堆事情呢，话要从HandlerAdapter里系统自带的处理器说起。我这边系统默认带了24个处理器，其中有两个ServletModelAttributeMethodProcessor，也就是我们自定义处理器继承的系统处理器。SpringMVC处理请求参数是轮询每一个处理器，看是否支持，也就是supportsParameter方法， 如果返回true，就交给你出来，并不会问下面的处理器。这就导致了如果我们简单的把我们的自定义处理器加到HandlerAdapter的Resolver列中是不行的，需要加到第一个去。\n\n然后ServletModelAttributeMethodProcessor的构造器有一个参数是true，代表什么意思呢，看这句代码\n```\npublic boolean supportsParameter(MethodParameter parameter) {\n        return parameter.hasParameterAnnotation(ModelAttribute.class)?true:(this.annotationNotRequired?!BeanUtils.isSimpleProperty(parameter.getParameterType()):false);\n    }\n```\nServletModelAttributeMethodProcessor是否支持某种类型的参数，是这样判断的。首先，对象是否有ModelAttribute注解，如果有，则处理，如果没有，则判断annotationNotRequired，是否不需要注释，如果true，再判断对象是否简单对象。我们的Test对象是没有注释的，所以我们就需要传参为true，表示不一定需要注解。\n\n以上就是所有的配置过程，通过这一系列配置，我们就可以自定义前端请求参数和对象属性名称的映射关系了，通过JsonProperty注解，如果没有注解，会自动转换蛇形命名到驼峰命名。下面是效果，Demo的Controller依然是这个：\n```\n@RequestMapping(value = \"/test\", method = RequestMethod.GET)\n    @ResponseBody\n    public void test(Test test) {\n        LOG.debug(test.toString());\n    }\n```\nTest对象这样写\n\n```\npublic class Test {\n\n    @JsonProperty(\"test_1\")\n    private String test1;\n\n    private String test2;\n\n    @JsonProperty(\"test_3\")\n    private String test99;\n}\n```\n这样前端请求的参数中的test\\_1和test1都会绑定到test1，test\\_2和test2都会绑定到test2，test\\_3,test99和test\\_99都会绑定到test99上。我们试一下这个请求\n```\n/test?test_1=1&test_2=2&test_3=3\n```\nLog输出如下\n\n![这里写图片描述](http://img.blog.csdn.net/20161229123336052?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemd6Y3p6dw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n下一篇文章准备详细的讲一下SpringMVC处理请求最后映射到一个Controller方法上的过程。\n\n例行推广一下我的博客，喜欢这篇文章的朋友可以看我的博客[http://zwgeek.com](http://zwgeek.com)\n\n\n","source":"_posts/SpringMVC对象绑定自定义名称对应关系.md","raw":"---\ntitle: SpringMVC对象绑定时自定义名称对应关系\ndate: 2016-12-28 18:15:57\ntags:\n  - SpringMVC\n  - 请求对象绑定\ncategories: 服务端开发\n---\n\n例行推广一下我的博客，喜欢这篇文章的朋友可以看我的博客[http://zwgeek.com](http://zwgeek.com)\n\n这个需求来源自一个Post的Controller的请求含有太多的参数，于是想把所有的参数封装到对象中，然后Controller的方法接收一个对象类型的参数，这样后期扩展修改都比较方便，不需要动到方法签名。\n\n有一句俗话说得好，需求是第一生产力，上面的这个需求就催生了这篇文章的一系列调研。\n\n首先，这个需求SpringMVC本身是支持的，你把一个对象放在Controller方法的参数里，SpringMVC本身的支持就能把request中和这个对象属性同名的参数绑定到对象属性上，比如下面这样：\n\n```java\n@RequestMapping(value = \"/test\", method = RequestMethod.GET)\npublic void test(Test test) {\n   LOG.debug(test.toString());\n}\n```\n\nTest中是这样定义的\n```\npublic class Test {\n\n    private String test1;\n\n    private String test2;\n\n    private String test3;\n}\n```\n由于我使用了lombok，所以没有Getter和Setter方法，大家看demo的时候可以注意下。这个时候我们访问/test?test1=1&test2=2&test3=3，SpringMVC会自动把同名的属性和Request中的参数绑定在一起。\n\n![这里写图片描述](http://img.blog.csdn.net/20161228184306167?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemd6Y3p6dw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n到这里貌似可以结题了，开玩笑，哪有这么简单。大家想这样一种情况，在JAVA中我们用的是驼峰命名法（比如：testName），而在前端JS中我们大多用的是蛇形命名法（比如：test_name）。当然，我们可以要求前端在请求接口的时候用驼峰命名法，但是问题不是这样逃避的。另外，如果我前端接口参数的名字和对象里面属性的名字不一样怎么办呢，比如前端接口里参数叫person，但是我对象里的属性叫people，当然这种情况比较少，但是也不排除在各种复杂的需求中会出现这种情况，所以我们这篇文章的目的就是做到自定义的参数名和属性名映射，想让哪个请求参数对应哪个属性都可以，想点哪里点哪里就是这个意思。\n\n这篇文章只讲解决方案，我会在下一篇文中讲一下SpringMVC数据绑定的实现原理。\n\n虽然不细说原理，但是有几个概念还是要提前说一下的，使用SpringMVC时，所有的请求都是最先经过DispatcherServlet的，然后由DispatcherServlet选择合适的HandlerMapping和HandlerAdapter来处理请求，HandlerMapping的作用就是找到请求所对应的方法，而HandlerAdapter则来处理和请求相关的的各种事情。我们这里要讲的请求参数绑定也是HandlerAdapter来做的。大概就知道这些吧，我们需要写一个自定义的请求参数处理器，然后把这个处理器放到HandlerAdapter中，这样我们的处理器就可以被拿来处理请求了。\n\n首先第一步，我们先来做一个参数处理器SnakeToCamelModelAttributeMethodProcessor\n```java\npublic class SnakeToCamelModelAttributeMethodProcessor extends ServletModelAttributeMethodProcessor {\n\n    ApplicationContext applicationContext;\n\n    public SnakeToCamelModelAttributeMethodProcessor(boolean annotationNotRequired, ApplicationContext applicationContext) {\n        super(annotationNotRequired);\n        this.applicationContext = applicationContext;\n    }\n\n    @Override\n    protected void bindRequestParameters(WebDataBinder binder, NativeWebRequest request) {\n        SnakeToCamelRequestDataBinder camelBinder = new SnakeToCamelRequestDataBinder(binder.getTarget(), binder.getObjectName());\n        RequestMappingHandlerAdapter requestMappingHandlerAdapter = applicationContext.getBean(RequestMappingHandlerAdapter.class);\n        requestMappingHandlerAdapter.getWebBindingInitializer().initBinder(camelBinder, request);\n        camelBinder.bind(request.getNativeRequest(ServletRequest.class));\n    }\n}\n```\n\n这个处理器要继承ServletModelAttributeMethodProcessor，来看下继承关系\n![这里写图片描述](http://img.blog.csdn.net/20161228201634838?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemd6Y3p6dw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n看最上面实现的是HandlerMethodArgumentResolver接口，这个接口代表这个类是用来处理请求参数的，有两个方法\n```java\npublic interface HandlerMethodArgumentResolver {\n    boolean supportsParameter(MethodParameter var1);\n\n    Object resolveArgument(MethodParameter var1, ModelAndViewContainer var2, NativeWebRequest var3, WebDataBinderFactory var4) throws Exception;\n}\n\n```\nsupportsParameter返回是否支持这种参数，resolveArgument是具体处理参数的方法。ServletModelAttributeMethodProcessor是处理复杂对象的，也就是除了int，char等等简单对象之外自定义的复杂对象，比如上文中我们提到的Test。\n\n我们自定义的处理器也是处理复杂对象，只是扩展了可以处理名称映射，所以继承这个ServletModelAttributeMethodProcessor即可。好了，处理器写好了，那么接下来怎么做呢，重写父类的bindRequestParameters方法，这个方法就是绑定数据对象的时候调用的方法。\n\n在这个方法中，我们新建了一个自定义的DataBinder-SnakeToCamelRequestDataBinder，然后用HandlerAdapter初始化了这个DataBinder，最后调了DataBinder的bind方法。DataBinder顾名思义就是实际去把请求参数和对象绑定的类，这个自定义的DataBinder怎么写呢，如下：\n\n```java\npublic class SnakeToCamelRequestDataBinder extends ExtendedServletRequestDataBinder {\n\n    public SnakeToCamelRequestDataBinder(Object target, String objectName) {\n        super(target, objectName);\n    }\n\n    protected void addBindValues(MutablePropertyValues mpvs, ServletRequest request) {\n        super.addBindValues(mpvs, request);\n\n        //处理JsonProperty注释的对象\n        Class<?> targetClass = getTarget().getClass();\n        Field[] fields = targetClass.getDeclaredFields();\n        for (Field field : fields) {\n            JsonProperty jsonPropertyAnnotation = field.getAnnotation(JsonProperty.class);\n            if (jsonPropertyAnnotation != null && mpvs.contains(jsonPropertyAnnotation.value())) {\n                if (!mpvs.contains(field.getName())) {\n                    mpvs.add(field.getName(), mpvs.getPropertyValue(jsonPropertyAnnotation.value()).getValue());\n                }\n            }\n        }\n\n        List<PropertyValue> covertValues = new ArrayList<PropertyValue>();\n        for (PropertyValue propertyValue : mpvs.getPropertyValueList()) {\n            if(propertyValue.getName().contains(\"_\")) {\n                String camelName = SnakeToCamelRequestParameterUtil.convertSnakeToCamel(propertyValue.getName());\n                if (!mpvs.contains(camelName)) {\n                    covertValues.add(new PropertyValue(camelName, propertyValue.getValue()));\n                }\n            }\n        }\n        mpvs.getPropertyValueList().addAll(covertValues);\n    }\n}\n```\n这个自定义的DataBinder继承自ExtendedServletRequestDataBinder，可扩展的DataBinder，用来给子类复写的方法是addBindValues，有两个参数，一个是MutablePropertyValues类型的，这里面存的就是请求参数的key-value对，还有一个参数是request对象本身。request对象这里用不到，我们用的就是这个MutablePropertyValues类型的mpvs。\n\n其实处理的原理很简单，SpringMVC在做完这一步参数绑定之后就会去通过反射调用Controller中的方法了，调用Controller方法的时候要给参数赋值，赋值的时候就是从这个mpvs里面把对应参数name的value取出来。举个例子，我们的样例Controller中的对象时Test，Test有个属性是Test1，那么在给Test1赋值的时候就会从这个mpvs中去取key为Test1所对应的value。可是你想想，前端请求的参数是test\\_1这样的，所以这个mpvs中只有一个key为test\\_1的值，那自然就会报错。知道了这种处理方法，就很简单了，我们在这个mpvs中再加一个key为test1，value和test_1的value一样的对象就可以了。\n\n再扩展一点，说到自定义Name，比如test\\_1对应属性为test2这样，我们用一个有value的注释，比如这里用到的JsonProperty，在test2上加上注释@JsonProperty(\"test_1\")，这里处理的时候会先把这个注释的值取出来，从mpvs里面查，如果有这个key，那么就把value取出来再加进去一个key为field name的map就可以了。上面SnakeToCamelRequestDataBinder的处理方法大概就是这样了。\n\n然后这里我们抽出了一个工具类，用来处理蛇形string到驼峰string的转换。\n\n```java\npublic class SnakeToCamelRequestParameterUtil {\n    public static String convertSnakeToCamel(String snake) {\n\n        if (snake == null) {\n            return null;\n        }\n\n        if (snake.indexOf(\"_\") < 0) {\n            return snake;\n        }\n\n        String result = \"\";\n\n        String[] split = StringUtils.split(snake, \"_\");\n        int index = 0;\n        for (String s : split) {\n            if (index == 0) {\n                result += s.toLowerCase();\n            } else {\n                result += capitalize(s);\n            }\n            index++;\n        }\n\n        return result;\n    }\n\n    private static String capitalize(String s) {\n\n        if (s == null) {\n            return null;\n        }\n\n        if (s.length() == 1) {\n            return s.toUpperCase();\n        }\n\n        return s.substring(0, 1).toUpperCase() + s.substring(1);\n    }\n}\n```\n\n做完了上面这些，应该说处理过程就搞定了，还差最后一步，需要把我们自定义的处理器SnakeToCamelModelAttributeMethodProcessor加到系统的HandlerAdapter中去。方法有很多，如果你不知道HandlerAdapter是什么东西，那八成你用的是系统默认的HandlerAdapter。加起来也很简单。如果你用了\n\n```xml\n<mvc:annotation-driven>\n```\n\n元素，可以用下面这个方法。\n\n```xml\n<mvc:annotation-driven>\n    <mvc:argument-resolvers>\n        <bean class=\"package.name.SnakeToCamelModelAttributeMethodProcessor\">\n            <constructor-arg name=\"annotationNotRequired\" value=\"true\"/>\n        </bean>\n    </mvc:argument-resolvers>\n</mvc:annotation-driven> \n```\n\n如果你用的是JAVA代码配置，可以用\n\n```java\n@Configuration\npublic class WebContextConfiguration extends WebMvcConfigurationSupport {\n    @Override\n    protected void addArgumentResolvers(List<HandlerMethodArgumentResolver> argumentResolvers) {\n        argumentResolvers.add(processor());\n    }\n\n    @Bean\n    protected SnakeToCamelModelAttributeMethodProcessor processor() {\n        return new SnakeToCamelModelAttributeMethodProcessor(true);\n    }\n} \n```\n\n像我这边，因为项目需要自定义了HandlerAdapter。\n\n```\n<bean class=\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter\">\n        ...\n    </bean>\n```\n\n所以我写了一个注册器，用来把处理器注册进HandlerAdapter，代码如下。\n\n```java\npublic class SnakeToCamelProcessorRegistry implements ApplicationContextAware, BeanFactoryPostProcessor {\n\n    private ApplicationContext applicationContext;\n\n    @Override\n    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {\n        this.applicationContext = applicationContext;\n    }\n\n    @Override\n    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {\n\n        RequestMappingHandlerAdapter requestMappingHandlerAdapter = applicationContext.getBean(RequestMappingHandlerAdapter.class);\n\n        List<HandlerMethodArgumentResolver> resolvers = requestMappingHandlerAdapter.getArgumentResolvers().getResolvers();\n\n\n        List<HandlerMethodArgumentResolver> newResolvers = new ArrayList<HandlerMethodArgumentResolver>();\n\n        for (HandlerMethodArgumentResolver resolver : resolvers) {\n            newResolvers.add(resolver);\n        }\n        newResolvers.add(0, new SnakeToCamelModelAttributeMethodProcessor(true, applicationContext));\n        requestMappingHandlerAdapter.setArgumentResolvers(Collections.unmodifiableList(newResolvers));\n    }\n}\n```\n看起来可能逻辑比较复杂，为什么要做这一堆事情呢，话要从HandlerAdapter里系统自带的处理器说起。我这边系统默认带了24个处理器，其中有两个ServletModelAttributeMethodProcessor，也就是我们自定义处理器继承的系统处理器。SpringMVC处理请求参数是轮询每一个处理器，看是否支持，也就是supportsParameter方法， 如果返回true，就交给你出来，并不会问下面的处理器。这就导致了如果我们简单的把我们的自定义处理器加到HandlerAdapter的Resolver列中是不行的，需要加到第一个去。\n\n然后ServletModelAttributeMethodProcessor的构造器有一个参数是true，代表什么意思呢，看这句代码\n```\npublic boolean supportsParameter(MethodParameter parameter) {\n        return parameter.hasParameterAnnotation(ModelAttribute.class)?true:(this.annotationNotRequired?!BeanUtils.isSimpleProperty(parameter.getParameterType()):false);\n    }\n```\nServletModelAttributeMethodProcessor是否支持某种类型的参数，是这样判断的。首先，对象是否有ModelAttribute注解，如果有，则处理，如果没有，则判断annotationNotRequired，是否不需要注释，如果true，再判断对象是否简单对象。我们的Test对象是没有注释的，所以我们就需要传参为true，表示不一定需要注解。\n\n以上就是所有的配置过程，通过这一系列配置，我们就可以自定义前端请求参数和对象属性名称的映射关系了，通过JsonProperty注解，如果没有注解，会自动转换蛇形命名到驼峰命名。下面是效果，Demo的Controller依然是这个：\n```\n@RequestMapping(value = \"/test\", method = RequestMethod.GET)\n    @ResponseBody\n    public void test(Test test) {\n        LOG.debug(test.toString());\n    }\n```\nTest对象这样写\n\n```\npublic class Test {\n\n    @JsonProperty(\"test_1\")\n    private String test1;\n\n    private String test2;\n\n    @JsonProperty(\"test_3\")\n    private String test99;\n}\n```\n这样前端请求的参数中的test\\_1和test1都会绑定到test1，test\\_2和test2都会绑定到test2，test\\_3,test99和test\\_99都会绑定到test99上。我们试一下这个请求\n```\n/test?test_1=1&test_2=2&test_3=3\n```\nLog输出如下\n\n![这里写图片描述](http://img.blog.csdn.net/20161229123336052?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemd6Y3p6dw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n下一篇文章准备详细的讲一下SpringMVC处理请求最后映射到一个Controller方法上的过程。\n\n例行推广一下我的博客，喜欢这篇文章的朋友可以看我的博客[http://zwgeek.com](http://zwgeek.com)\n\n\n","slug":"SpringMVC对象绑定自定义名称对应关系","published":1,"updated":"2024-06-14T09:25:33.677Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clxjsxtvz000elq6gml657nch","content":"<p>例行推广一下我的博客，喜欢这篇文章的朋友可以看我的博客<a href=\"http://zwgeek.com\">http://zwgeek.com</a></p>\n<p>这个需求来源自一个Post的Controller的请求含有太多的参数，于是想把所有的参数封装到对象中，然后Controller的方法接收一个对象类型的参数，这样后期扩展修改都比较方便，不需要动到方法签名。</p>\n<p>有一句俗话说得好，需求是第一生产力，上面的这个需求就催生了这篇文章的一系列调研。</p>\n<p>首先，这个需求SpringMVC本身是支持的，你把一个对象放在Controller方法的参数里，SpringMVC本身的支持就能把request中和这个对象属性同名的参数绑定到对象属性上，比如下面这样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@RequestMapping</span>(value = <span class=\"string\">\"/test\"</span>, method = RequestMethod.GET)</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">(Test test)</span> </span>&#123;</div><div class=\"line\">   LOG.debug(test.toString());</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Test中是这样定义的<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class Test &#123;</div><div class=\"line\"></div><div class=\"line\">    private String test1;</div><div class=\"line\"></div><div class=\"line\">    private String test2;</div><div class=\"line\"></div><div class=\"line\">    private String test3;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>由于我使用了lombok，所以没有Getter和Setter方法，大家看demo的时候可以注意下。这个时候我们访问/test?test1=1&amp;test2=2&amp;test3=3，SpringMVC会自动把同名的属性和Request中的参数绑定在一起。</p>\n<p><img src=\"http://img.blog.csdn.net/20161228184306167?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemd6Y3p6dw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<p>到这里貌似可以结题了，开玩笑，哪有这么简单。大家想这样一种情况，在JAVA中我们用的是驼峰命名法（比如：testName），而在前端JS中我们大多用的是蛇形命名法（比如：test_name）。当然，我们可以要求前端在请求接口的时候用驼峰命名法，但是问题不是这样逃避的。另外，如果我前端接口参数的名字和对象里面属性的名字不一样怎么办呢，比如前端接口里参数叫person，但是我对象里的属性叫people，当然这种情况比较少，但是也不排除在各种复杂的需求中会出现这种情况，所以我们这篇文章的目的就是做到自定义的参数名和属性名映射，想让哪个请求参数对应哪个属性都可以，想点哪里点哪里就是这个意思。</p>\n<p>这篇文章只讲解决方案，我会在下一篇文中讲一下SpringMVC数据绑定的实现原理。</p>\n<p>虽然不细说原理，但是有几个概念还是要提前说一下的，使用SpringMVC时，所有的请求都是最先经过DispatcherServlet的，然后由DispatcherServlet选择合适的HandlerMapping和HandlerAdapter来处理请求，HandlerMapping的作用就是找到请求所对应的方法，而HandlerAdapter则来处理和请求相关的的各种事情。我们这里要讲的请求参数绑定也是HandlerAdapter来做的。大概就知道这些吧，我们需要写一个自定义的请求参数处理器，然后把这个处理器放到HandlerAdapter中，这样我们的处理器就可以被拿来处理请求了。</p>\n<p>首先第一步，我们先来做一个参数处理器SnakeToCamelModelAttributeMethodProcessor<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SnakeToCamelModelAttributeMethodProcessor</span> <span class=\"keyword\">extends</span> <span class=\"title\">ServletModelAttributeMethodProcessor</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    ApplicationContext applicationContext;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">SnakeToCamelModelAttributeMethodProcessor</span><span class=\"params\">(<span class=\"keyword\">boolean</span> annotationNotRequired, ApplicationContext applicationContext)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>(annotationNotRequired);</div><div class=\"line\">        <span class=\"keyword\">this</span>.applicationContext = applicationContext;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">bindRequestParameters</span><span class=\"params\">(WebDataBinder binder, NativeWebRequest request)</span> </span>&#123;</div><div class=\"line\">        SnakeToCamelRequestDataBinder camelBinder = <span class=\"keyword\">new</span> SnakeToCamelRequestDataBinder(binder.getTarget(), binder.getObjectName());</div><div class=\"line\">        RequestMappingHandlerAdapter requestMappingHandlerAdapter = applicationContext.getBean(RequestMappingHandlerAdapter.class);</div><div class=\"line\">        requestMappingHandlerAdapter.getWebBindingInitializer().initBinder(camelBinder, request);</div><div class=\"line\">        camelBinder.bind(request.getNativeRequest(ServletRequest.class));</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这个处理器要继承ServletModelAttributeMethodProcessor，来看下继承关系<br><img src=\"http://img.blog.csdn.net/20161228201634838?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemd6Y3p6dw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<p>看最上面实现的是HandlerMethodArgumentResolver接口，这个接口代表这个类是用来处理请求参数的，有两个方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">HandlerMethodArgumentResolver</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">supportsParameter</span><span class=\"params\">(MethodParameter var1)</span></span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\">Object <span class=\"title\">resolveArgument</span><span class=\"params\">(MethodParameter var1, ModelAndViewContainer var2, NativeWebRequest var3, WebDataBinderFactory var4)</span> <span class=\"keyword\">throws</span> Exception</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>supportsParameter返回是否支持这种参数，resolveArgument是具体处理参数的方法。ServletModelAttributeMethodProcessor是处理复杂对象的，也就是除了int，char等等简单对象之外自定义的复杂对象，比如上文中我们提到的Test。</p>\n<p>我们自定义的处理器也是处理复杂对象，只是扩展了可以处理名称映射，所以继承这个ServletModelAttributeMethodProcessor即可。好了，处理器写好了，那么接下来怎么做呢，重写父类的bindRequestParameters方法，这个方法就是绑定数据对象的时候调用的方法。</p>\n<p>在这个方法中，我们新建了一个自定义的DataBinder-SnakeToCamelRequestDataBinder，然后用HandlerAdapter初始化了这个DataBinder，最后调了DataBinder的bind方法。DataBinder顾名思义就是实际去把请求参数和对象绑定的类，这个自定义的DataBinder怎么写呢，如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SnakeToCamelRequestDataBinder</span> <span class=\"keyword\">extends</span> <span class=\"title\">ExtendedServletRequestDataBinder</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">SnakeToCamelRequestDataBinder</span><span class=\"params\">(Object target, String objectName)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>(target, objectName);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">addBindValues</span><span class=\"params\">(MutablePropertyValues mpvs, ServletRequest request)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>.addBindValues(mpvs, request);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">//处理JsonProperty注释的对象</span></div><div class=\"line\">        Class&lt;?&gt; targetClass = getTarget().getClass();</div><div class=\"line\">        Field[] fields = targetClass.getDeclaredFields();</div><div class=\"line\">        <span class=\"keyword\">for</span> (Field field : fields) &#123;</div><div class=\"line\">            JsonProperty jsonPropertyAnnotation = field.getAnnotation(JsonProperty.class);</div><div class=\"line\">            <span class=\"keyword\">if</span> (jsonPropertyAnnotation != <span class=\"keyword\">null</span> &amp;&amp; mpvs.contains(jsonPropertyAnnotation.value())) &#123;</div><div class=\"line\">                <span class=\"keyword\">if</span> (!mpvs.contains(field.getName())) &#123;</div><div class=\"line\">                    mpvs.add(field.getName(), mpvs.getPropertyValue(jsonPropertyAnnotation.value()).getValue());</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        List&lt;PropertyValue&gt; covertValues = <span class=\"keyword\">new</span> ArrayList&lt;PropertyValue&gt;();</div><div class=\"line\">        <span class=\"keyword\">for</span> (PropertyValue propertyValue : mpvs.getPropertyValueList()) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span>(propertyValue.getName().contains(<span class=\"string\">\"_\"</span>)) &#123;</div><div class=\"line\">                String camelName = SnakeToCamelRequestParameterUtil.convertSnakeToCamel(propertyValue.getName());</div><div class=\"line\">                <span class=\"keyword\">if</span> (!mpvs.contains(camelName)) &#123;</div><div class=\"line\">                    covertValues.add(<span class=\"keyword\">new</span> PropertyValue(camelName, propertyValue.getValue()));</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        mpvs.getPropertyValueList().addAll(covertValues);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个自定义的DataBinder继承自ExtendedServletRequestDataBinder，可扩展的DataBinder，用来给子类复写的方法是addBindValues，有两个参数，一个是MutablePropertyValues类型的，这里面存的就是请求参数的key-value对，还有一个参数是request对象本身。request对象这里用不到，我们用的就是这个MutablePropertyValues类型的mpvs。</p>\n<p>其实处理的原理很简单，SpringMVC在做完这一步参数绑定之后就会去通过反射调用Controller中的方法了，调用Controller方法的时候要给参数赋值，赋值的时候就是从这个mpvs里面把对应参数name的value取出来。举个例子，我们的样例Controller中的对象时Test，Test有个属性是Test1，那么在给Test1赋值的时候就会从这个mpvs中去取key为Test1所对应的value。可是你想想，前端请求的参数是test_1这样的，所以这个mpvs中只有一个key为test_1的值，那自然就会报错。知道了这种处理方法，就很简单了，我们在这个mpvs中再加一个key为test1，value和test_1的value一样的对象就可以了。</p>\n<p>再扩展一点，说到自定义Name，比如test_1对应属性为test2这样，我们用一个有value的注释，比如这里用到的JsonProperty，在test2上加上注释@JsonProperty(“test_1”)，这里处理的时候会先把这个注释的值取出来，从mpvs里面查，如果有这个key，那么就把value取出来再加进去一个key为field name的map就可以了。上面SnakeToCamelRequestDataBinder的处理方法大概就是这样了。</p>\n<p>然后这里我们抽出了一个工具类，用来处理蛇形string到驼峰string的转换。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SnakeToCamelRequestParameterUtil</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">convertSnakeToCamel</span><span class=\"params\">(String snake)</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (snake == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (snake.indexOf(<span class=\"string\">\"_\"</span>) &lt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> snake;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        String result = <span class=\"string\">\"\"</span>;</div><div class=\"line\"></div><div class=\"line\">        String[] split = StringUtils.split(snake, <span class=\"string\">\"_\"</span>);</div><div class=\"line\">        <span class=\"keyword\">int</span> index = <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"keyword\">for</span> (String s : split) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (index == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">                result += s.toLowerCase();</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                result += capitalize(s);</div><div class=\"line\">            &#125;</div><div class=\"line\">            index++;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">return</span> result;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> String <span class=\"title\">capitalize</span><span class=\"params\">(String s)</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (s == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (s.length() == <span class=\"number\">1</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> s.toUpperCase();</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">return</span> s.substring(<span class=\"number\">0</span>, <span class=\"number\">1</span>).toUpperCase() + s.substring(<span class=\"number\">1</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>做完了上面这些，应该说处理过程就搞定了，还差最后一步，需要把我们自定义的处理器SnakeToCamelModelAttributeMethodProcessor加到系统的HandlerAdapter中去。方法有很多，如果你不知道HandlerAdapter是什么东西，那八成你用的是系统默认的HandlerAdapter。加起来也很简单。如果你用了</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">mvc:annotation-driven</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>元素，可以用下面这个方法。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">mvc:annotation-driven</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">mvc:argument-resolvers</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">\"package.name.SnakeToCamelModelAttributeMethodProcessor\"</span>&gt;</span></div><div class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">constructor-arg</span> <span class=\"attr\">name</span>=<span class=\"string\">\"annotationNotRequired\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"true\"</span>/&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">mvc:argument-resolvers</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">mvc:annotation-driven</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>如果你用的是JAVA代码配置，可以用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Configuration</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WebContextConfiguration</span> <span class=\"keyword\">extends</span> <span class=\"title\">WebMvcConfigurationSupport</span> </span>&#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">addArgumentResolvers</span><span class=\"params\">(List&lt;HandlerMethodArgumentResolver&gt; argumentResolvers)</span> </span>&#123;</div><div class=\"line\">        argumentResolvers.add(processor());</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Bean</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> SnakeToCamelModelAttributeMethodProcessor <span class=\"title\">processor</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> SnakeToCamelModelAttributeMethodProcessor(<span class=\"keyword\">true</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>像我这边，因为项目需要自定义了HandlerAdapter。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;&gt;</div><div class=\"line\">        ...</div><div class=\"line\">    &lt;/bean&gt;</div></pre></td></tr></table></figure>\n<p>所以我写了一个注册器，用来把处理器注册进HandlerAdapter，代码如下。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SnakeToCamelProcessorRegistry</span> <span class=\"keyword\">implements</span> <span class=\"title\">ApplicationContextAware</span>, <span class=\"title\">BeanFactoryPostProcessor</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">private</span> ApplicationContext applicationContext;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setApplicationContext</span><span class=\"params\">(ApplicationContext applicationContext)</span> <span class=\"keyword\">throws</span> BeansException </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.applicationContext = applicationContext;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">postProcessBeanFactory</span><span class=\"params\">(ConfigurableListableBeanFactory beanFactory)</span> <span class=\"keyword\">throws</span> BeansException </span>&#123;</div><div class=\"line\"></div><div class=\"line\">        RequestMappingHandlerAdapter requestMappingHandlerAdapter = applicationContext.getBean(RequestMappingHandlerAdapter.class);</div><div class=\"line\"></div><div class=\"line\">        List&lt;HandlerMethodArgumentResolver&gt; resolvers = requestMappingHandlerAdapter.getArgumentResolvers().getResolvers();</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">        List&lt;HandlerMethodArgumentResolver&gt; newResolvers = <span class=\"keyword\">new</span> ArrayList&lt;HandlerMethodArgumentResolver&gt;();</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">for</span> (HandlerMethodArgumentResolver resolver : resolvers) &#123;</div><div class=\"line\">            newResolvers.add(resolver);</div><div class=\"line\">        &#125;</div><div class=\"line\">        newResolvers.add(<span class=\"number\">0</span>, <span class=\"keyword\">new</span> SnakeToCamelModelAttributeMethodProcessor(<span class=\"keyword\">true</span>, applicationContext));</div><div class=\"line\">        requestMappingHandlerAdapter.setArgumentResolvers(Collections.unmodifiableList(newResolvers));</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>看起来可能逻辑比较复杂，为什么要做这一堆事情呢，话要从HandlerAdapter里系统自带的处理器说起。我这边系统默认带了24个处理器，其中有两个ServletModelAttributeMethodProcessor，也就是我们自定义处理器继承的系统处理器。SpringMVC处理请求参数是轮询每一个处理器，看是否支持，也就是supportsParameter方法， 如果返回true，就交给你出来，并不会问下面的处理器。这就导致了如果我们简单的把我们的自定义处理器加到HandlerAdapter的Resolver列中是不行的，需要加到第一个去。</p>\n<p>然后ServletModelAttributeMethodProcessor的构造器有一个参数是true，代表什么意思呢，看这句代码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">public boolean supportsParameter(MethodParameter parameter) &#123;</div><div class=\"line\">        return parameter.hasParameterAnnotation(ModelAttribute.class)?true:(this.annotationNotRequired?!BeanUtils.isSimpleProperty(parameter.getParameterType()):false);</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>ServletModelAttributeMethodProcessor是否支持某种类型的参数，是这样判断的。首先，对象是否有ModelAttribute注解，如果有，则处理，如果没有，则判断annotationNotRequired，是否不需要注释，如果true，再判断对象是否简单对象。我们的Test对象是没有注释的，所以我们就需要传参为true，表示不一定需要注解。</p>\n<p>以上就是所有的配置过程，通过这一系列配置，我们就可以自定义前端请求参数和对象属性名称的映射关系了，通过JsonProperty注解，如果没有注解，会自动转换蛇形命名到驼峰命名。下面是效果，Demo的Controller依然是这个：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">@RequestMapping(value = &quot;/test&quot;, method = RequestMethod.GET)</div><div class=\"line\">    @ResponseBody</div><div class=\"line\">    public void test(Test test) &#123;</div><div class=\"line\">        LOG.debug(test.toString());</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>Test对象这样写</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class Test &#123;</div><div class=\"line\"></div><div class=\"line\">    @JsonProperty(&quot;test_1&quot;)</div><div class=\"line\">    private String test1;</div><div class=\"line\"></div><div class=\"line\">    private String test2;</div><div class=\"line\"></div><div class=\"line\">    @JsonProperty(&quot;test_3&quot;)</div><div class=\"line\">    private String test99;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这样前端请求的参数中的test_1和test1都会绑定到test1，test_2和test2都会绑定到test2，test_3,test99和test_99都会绑定到test99上。我们试一下这个请求<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">/test?test_1=1&amp;test_2=2&amp;test_3=3</div></pre></td></tr></table></figure></p>\n<p>Log输出如下</p>\n<p><img src=\"http://img.blog.csdn.net/20161229123336052?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemd6Y3p6dw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<p>下一篇文章准备详细的讲一下SpringMVC处理请求最后映射到一个Controller方法上的过程。</p>\n<p>例行推广一下我的博客，喜欢这篇文章的朋友可以看我的博客<a href=\"http://zwgeek.com\">http://zwgeek.com</a></p>\n","excerpt":"","more":"<p>例行推广一下我的博客，喜欢这篇文章的朋友可以看我的博客<a href=\"http://zwgeek.com\">http://zwgeek.com</a></p>\n<p>这个需求来源自一个Post的Controller的请求含有太多的参数，于是想把所有的参数封装到对象中，然后Controller的方法接收一个对象类型的参数，这样后期扩展修改都比较方便，不需要动到方法签名。</p>\n<p>有一句俗话说得好，需求是第一生产力，上面的这个需求就催生了这篇文章的一系列调研。</p>\n<p>首先，这个需求SpringMVC本身是支持的，你把一个对象放在Controller方法的参数里，SpringMVC本身的支持就能把request中和这个对象属性同名的参数绑定到对象属性上，比如下面这样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@RequestMapping</span>(value = <span class=\"string\">\"/test\"</span>, method = RequestMethod.GET)</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">(Test test)</span> </span>&#123;</div><div class=\"line\">   LOG.debug(test.toString());</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Test中是这样定义的<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class Test &#123;</div><div class=\"line\"></div><div class=\"line\">    private String test1;</div><div class=\"line\"></div><div class=\"line\">    private String test2;</div><div class=\"line\"></div><div class=\"line\">    private String test3;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>由于我使用了lombok，所以没有Getter和Setter方法，大家看demo的时候可以注意下。这个时候我们访问/test?test1=1&amp;test2=2&amp;test3=3，SpringMVC会自动把同名的属性和Request中的参数绑定在一起。</p>\n<p><img src=\"http://img.blog.csdn.net/20161228184306167?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemd6Y3p6dw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<p>到这里貌似可以结题了，开玩笑，哪有这么简单。大家想这样一种情况，在JAVA中我们用的是驼峰命名法（比如：testName），而在前端JS中我们大多用的是蛇形命名法（比如：test_name）。当然，我们可以要求前端在请求接口的时候用驼峰命名法，但是问题不是这样逃避的。另外，如果我前端接口参数的名字和对象里面属性的名字不一样怎么办呢，比如前端接口里参数叫person，但是我对象里的属性叫people，当然这种情况比较少，但是也不排除在各种复杂的需求中会出现这种情况，所以我们这篇文章的目的就是做到自定义的参数名和属性名映射，想让哪个请求参数对应哪个属性都可以，想点哪里点哪里就是这个意思。</p>\n<p>这篇文章只讲解决方案，我会在下一篇文中讲一下SpringMVC数据绑定的实现原理。</p>\n<p>虽然不细说原理，但是有几个概念还是要提前说一下的，使用SpringMVC时，所有的请求都是最先经过DispatcherServlet的，然后由DispatcherServlet选择合适的HandlerMapping和HandlerAdapter来处理请求，HandlerMapping的作用就是找到请求所对应的方法，而HandlerAdapter则来处理和请求相关的的各种事情。我们这里要讲的请求参数绑定也是HandlerAdapter来做的。大概就知道这些吧，我们需要写一个自定义的请求参数处理器，然后把这个处理器放到HandlerAdapter中，这样我们的处理器就可以被拿来处理请求了。</p>\n<p>首先第一步，我们先来做一个参数处理器SnakeToCamelModelAttributeMethodProcessor<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SnakeToCamelModelAttributeMethodProcessor</span> <span class=\"keyword\">extends</span> <span class=\"title\">ServletModelAttributeMethodProcessor</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    ApplicationContext applicationContext;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">SnakeToCamelModelAttributeMethodProcessor</span><span class=\"params\">(<span class=\"keyword\">boolean</span> annotationNotRequired, ApplicationContext applicationContext)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>(annotationNotRequired);</div><div class=\"line\">        <span class=\"keyword\">this</span>.applicationContext = applicationContext;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">bindRequestParameters</span><span class=\"params\">(WebDataBinder binder, NativeWebRequest request)</span> </span>&#123;</div><div class=\"line\">        SnakeToCamelRequestDataBinder camelBinder = <span class=\"keyword\">new</span> SnakeToCamelRequestDataBinder(binder.getTarget(), binder.getObjectName());</div><div class=\"line\">        RequestMappingHandlerAdapter requestMappingHandlerAdapter = applicationContext.getBean(RequestMappingHandlerAdapter.class);</div><div class=\"line\">        requestMappingHandlerAdapter.getWebBindingInitializer().initBinder(camelBinder, request);</div><div class=\"line\">        camelBinder.bind(request.getNativeRequest(ServletRequest.class));</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这个处理器要继承ServletModelAttributeMethodProcessor，来看下继承关系<br><img src=\"http://img.blog.csdn.net/20161228201634838?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemd6Y3p6dw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<p>看最上面实现的是HandlerMethodArgumentResolver接口，这个接口代表这个类是用来处理请求参数的，有两个方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">HandlerMethodArgumentResolver</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">supportsParameter</span><span class=\"params\">(MethodParameter var1)</span></span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\">Object <span class=\"title\">resolveArgument</span><span class=\"params\">(MethodParameter var1, ModelAndViewContainer var2, NativeWebRequest var3, WebDataBinderFactory var4)</span> <span class=\"keyword\">throws</span> Exception</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>supportsParameter返回是否支持这种参数，resolveArgument是具体处理参数的方法。ServletModelAttributeMethodProcessor是处理复杂对象的，也就是除了int，char等等简单对象之外自定义的复杂对象，比如上文中我们提到的Test。</p>\n<p>我们自定义的处理器也是处理复杂对象，只是扩展了可以处理名称映射，所以继承这个ServletModelAttributeMethodProcessor即可。好了，处理器写好了，那么接下来怎么做呢，重写父类的bindRequestParameters方法，这个方法就是绑定数据对象的时候调用的方法。</p>\n<p>在这个方法中，我们新建了一个自定义的DataBinder-SnakeToCamelRequestDataBinder，然后用HandlerAdapter初始化了这个DataBinder，最后调了DataBinder的bind方法。DataBinder顾名思义就是实际去把请求参数和对象绑定的类，这个自定义的DataBinder怎么写呢，如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SnakeToCamelRequestDataBinder</span> <span class=\"keyword\">extends</span> <span class=\"title\">ExtendedServletRequestDataBinder</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">SnakeToCamelRequestDataBinder</span><span class=\"params\">(Object target, String objectName)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>(target, objectName);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">addBindValues</span><span class=\"params\">(MutablePropertyValues mpvs, ServletRequest request)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>.addBindValues(mpvs, request);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">//处理JsonProperty注释的对象</span></div><div class=\"line\">        Class&lt;?&gt; targetClass = getTarget().getClass();</div><div class=\"line\">        Field[] fields = targetClass.getDeclaredFields();</div><div class=\"line\">        <span class=\"keyword\">for</span> (Field field : fields) &#123;</div><div class=\"line\">            JsonProperty jsonPropertyAnnotation = field.getAnnotation(JsonProperty.class);</div><div class=\"line\">            <span class=\"keyword\">if</span> (jsonPropertyAnnotation != <span class=\"keyword\">null</span> &amp;&amp; mpvs.contains(jsonPropertyAnnotation.value())) &#123;</div><div class=\"line\">                <span class=\"keyword\">if</span> (!mpvs.contains(field.getName())) &#123;</div><div class=\"line\">                    mpvs.add(field.getName(), mpvs.getPropertyValue(jsonPropertyAnnotation.value()).getValue());</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        List&lt;PropertyValue&gt; covertValues = <span class=\"keyword\">new</span> ArrayList&lt;PropertyValue&gt;();</div><div class=\"line\">        <span class=\"keyword\">for</span> (PropertyValue propertyValue : mpvs.getPropertyValueList()) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span>(propertyValue.getName().contains(<span class=\"string\">\"_\"</span>)) &#123;</div><div class=\"line\">                String camelName = SnakeToCamelRequestParameterUtil.convertSnakeToCamel(propertyValue.getName());</div><div class=\"line\">                <span class=\"keyword\">if</span> (!mpvs.contains(camelName)) &#123;</div><div class=\"line\">                    covertValues.add(<span class=\"keyword\">new</span> PropertyValue(camelName, propertyValue.getValue()));</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        mpvs.getPropertyValueList().addAll(covertValues);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个自定义的DataBinder继承自ExtendedServletRequestDataBinder，可扩展的DataBinder，用来给子类复写的方法是addBindValues，有两个参数，一个是MutablePropertyValues类型的，这里面存的就是请求参数的key-value对，还有一个参数是request对象本身。request对象这里用不到，我们用的就是这个MutablePropertyValues类型的mpvs。</p>\n<p>其实处理的原理很简单，SpringMVC在做完这一步参数绑定之后就会去通过反射调用Controller中的方法了，调用Controller方法的时候要给参数赋值，赋值的时候就是从这个mpvs里面把对应参数name的value取出来。举个例子，我们的样例Controller中的对象时Test，Test有个属性是Test1，那么在给Test1赋值的时候就会从这个mpvs中去取key为Test1所对应的value。可是你想想，前端请求的参数是test_1这样的，所以这个mpvs中只有一个key为test_1的值，那自然就会报错。知道了这种处理方法，就很简单了，我们在这个mpvs中再加一个key为test1，value和test_1的value一样的对象就可以了。</p>\n<p>再扩展一点，说到自定义Name，比如test_1对应属性为test2这样，我们用一个有value的注释，比如这里用到的JsonProperty，在test2上加上注释@JsonProperty(“test_1”)，这里处理的时候会先把这个注释的值取出来，从mpvs里面查，如果有这个key，那么就把value取出来再加进去一个key为field name的map就可以了。上面SnakeToCamelRequestDataBinder的处理方法大概就是这样了。</p>\n<p>然后这里我们抽出了一个工具类，用来处理蛇形string到驼峰string的转换。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SnakeToCamelRequestParameterUtil</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">convertSnakeToCamel</span><span class=\"params\">(String snake)</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (snake == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (snake.indexOf(<span class=\"string\">\"_\"</span>) &lt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> snake;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        String result = <span class=\"string\">\"\"</span>;</div><div class=\"line\"></div><div class=\"line\">        String[] split = StringUtils.split(snake, <span class=\"string\">\"_\"</span>);</div><div class=\"line\">        <span class=\"keyword\">int</span> index = <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"keyword\">for</span> (String s : split) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (index == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">                result += s.toLowerCase();</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                result += capitalize(s);</div><div class=\"line\">            &#125;</div><div class=\"line\">            index++;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">return</span> result;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> String <span class=\"title\">capitalize</span><span class=\"params\">(String s)</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (s == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (s.length() == <span class=\"number\">1</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> s.toUpperCase();</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">return</span> s.substring(<span class=\"number\">0</span>, <span class=\"number\">1</span>).toUpperCase() + s.substring(<span class=\"number\">1</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>做完了上面这些，应该说处理过程就搞定了，还差最后一步，需要把我们自定义的处理器SnakeToCamelModelAttributeMethodProcessor加到系统的HandlerAdapter中去。方法有很多，如果你不知道HandlerAdapter是什么东西，那八成你用的是系统默认的HandlerAdapter。加起来也很简单。如果你用了</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">mvc:annotation-driven</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>元素，可以用下面这个方法。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">mvc:annotation-driven</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">mvc:argument-resolvers</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">\"package.name.SnakeToCamelModelAttributeMethodProcessor\"</span>&gt;</span></div><div class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">constructor-arg</span> <span class=\"attr\">name</span>=<span class=\"string\">\"annotationNotRequired\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"true\"</span>/&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">mvc:argument-resolvers</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">mvc:annotation-driven</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>如果你用的是JAVA代码配置，可以用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Configuration</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WebContextConfiguration</span> <span class=\"keyword\">extends</span> <span class=\"title\">WebMvcConfigurationSupport</span> </span>&#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">addArgumentResolvers</span><span class=\"params\">(List&lt;HandlerMethodArgumentResolver&gt; argumentResolvers)</span> </span>&#123;</div><div class=\"line\">        argumentResolvers.add(processor());</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Bean</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> SnakeToCamelModelAttributeMethodProcessor <span class=\"title\">processor</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> SnakeToCamelModelAttributeMethodProcessor(<span class=\"keyword\">true</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>像我这边，因为项目需要自定义了HandlerAdapter。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;&gt;</div><div class=\"line\">        ...</div><div class=\"line\">    &lt;/bean&gt;</div></pre></td></tr></table></figure>\n<p>所以我写了一个注册器，用来把处理器注册进HandlerAdapter，代码如下。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SnakeToCamelProcessorRegistry</span> <span class=\"keyword\">implements</span> <span class=\"title\">ApplicationContextAware</span>, <span class=\"title\">BeanFactoryPostProcessor</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">private</span> ApplicationContext applicationContext;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setApplicationContext</span><span class=\"params\">(ApplicationContext applicationContext)</span> <span class=\"keyword\">throws</span> BeansException </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.applicationContext = applicationContext;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">postProcessBeanFactory</span><span class=\"params\">(ConfigurableListableBeanFactory beanFactory)</span> <span class=\"keyword\">throws</span> BeansException </span>&#123;</div><div class=\"line\"></div><div class=\"line\">        RequestMappingHandlerAdapter requestMappingHandlerAdapter = applicationContext.getBean(RequestMappingHandlerAdapter.class);</div><div class=\"line\"></div><div class=\"line\">        List&lt;HandlerMethodArgumentResolver&gt; resolvers = requestMappingHandlerAdapter.getArgumentResolvers().getResolvers();</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">        List&lt;HandlerMethodArgumentResolver&gt; newResolvers = <span class=\"keyword\">new</span> ArrayList&lt;HandlerMethodArgumentResolver&gt;();</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">for</span> (HandlerMethodArgumentResolver resolver : resolvers) &#123;</div><div class=\"line\">            newResolvers.add(resolver);</div><div class=\"line\">        &#125;</div><div class=\"line\">        newResolvers.add(<span class=\"number\">0</span>, <span class=\"keyword\">new</span> SnakeToCamelModelAttributeMethodProcessor(<span class=\"keyword\">true</span>, applicationContext));</div><div class=\"line\">        requestMappingHandlerAdapter.setArgumentResolvers(Collections.unmodifiableList(newResolvers));</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>看起来可能逻辑比较复杂，为什么要做这一堆事情呢，话要从HandlerAdapter里系统自带的处理器说起。我这边系统默认带了24个处理器，其中有两个ServletModelAttributeMethodProcessor，也就是我们自定义处理器继承的系统处理器。SpringMVC处理请求参数是轮询每一个处理器，看是否支持，也就是supportsParameter方法， 如果返回true，就交给你出来，并不会问下面的处理器。这就导致了如果我们简单的把我们的自定义处理器加到HandlerAdapter的Resolver列中是不行的，需要加到第一个去。</p>\n<p>然后ServletModelAttributeMethodProcessor的构造器有一个参数是true，代表什么意思呢，看这句代码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">public boolean supportsParameter(MethodParameter parameter) &#123;</div><div class=\"line\">        return parameter.hasParameterAnnotation(ModelAttribute.class)?true:(this.annotationNotRequired?!BeanUtils.isSimpleProperty(parameter.getParameterType()):false);</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>ServletModelAttributeMethodProcessor是否支持某种类型的参数，是这样判断的。首先，对象是否有ModelAttribute注解，如果有，则处理，如果没有，则判断annotationNotRequired，是否不需要注释，如果true，再判断对象是否简单对象。我们的Test对象是没有注释的，所以我们就需要传参为true，表示不一定需要注解。</p>\n<p>以上就是所有的配置过程，通过这一系列配置，我们就可以自定义前端请求参数和对象属性名称的映射关系了，通过JsonProperty注解，如果没有注解，会自动转换蛇形命名到驼峰命名。下面是效果，Demo的Controller依然是这个：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">@RequestMapping(value = &quot;/test&quot;, method = RequestMethod.GET)</div><div class=\"line\">    @ResponseBody</div><div class=\"line\">    public void test(Test test) &#123;</div><div class=\"line\">        LOG.debug(test.toString());</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>Test对象这样写</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class Test &#123;</div><div class=\"line\"></div><div class=\"line\">    @JsonProperty(&quot;test_1&quot;)</div><div class=\"line\">    private String test1;</div><div class=\"line\"></div><div class=\"line\">    private String test2;</div><div class=\"line\"></div><div class=\"line\">    @JsonProperty(&quot;test_3&quot;)</div><div class=\"line\">    private String test99;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这样前端请求的参数中的test_1和test1都会绑定到test1，test_2和test2都会绑定到test2，test_3,test99和test_99都会绑定到test99上。我们试一下这个请求<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">/test?test_1=1&amp;test_2=2&amp;test_3=3</div></pre></td></tr></table></figure></p>\n<p>Log输出如下</p>\n<p><img src=\"http://img.blog.csdn.net/20161229123336052?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemd6Y3p6dw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<p>下一篇文章准备详细的讲一下SpringMVC处理请求最后映射到一个Controller方法上的过程。</p>\n<p>例行推广一下我的博客，喜欢这篇文章的朋友可以看我的博客<a href=\"http://zwgeek.com\">http://zwgeek.com</a></p>\n"},{"title":"SpringMVC从request到controller过程详解","date":"2016-12-29T05:10:47.000Z","_content":"\n例行推广一下我的博客，喜欢这篇文章的朋友可以关注我的博客http://zwgeek.com\n\n## 1. 背景\n\n之前一篇文章 [SpringMVC对象绑定时自定义名称对应关系](http://zwgeek.com/2016/12/28/SpringMVC%E5%AF%B9%E8%B1%A1%E7%BB%91%E5%AE%9A%E8%87%AA%E5%AE%9A%E4%B9%89%E5%90%8D%E7%A7%B0%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB/) 讲了如何去把request中的请求参数指定到对象的某个属性上。但文中只讲了一下做法，没有讲原理，因为这个原理涉及到SpringMVC时怎么处理Request的复杂过程。这篇文章就来和大家扒一扒这件事，SpringMVC是怎么把一个request的请求最终映射到Controller的方法的。这是正向的，对于Spring来说，其实还负责把Controller的返回结果通过一些处理展现给用户，这是后话，这篇文章我们只说正向的请求，也就是从request到Controller的过程。\n\n首先，来一张SpringMVC处理请求的整个过程，图是来自《Spring实战》5.1.1章，我觉得总结的非常到位，几个大的过程都画出来了。\n\n![这里写图片描述](http://img.blog.csdn.net/20161229134539820?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemd6Y3p6dw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n我们这篇文章要说的其实就是1，2，3这三个阶段的实现原理。后面4，5，6，7可能会再开一篇文章来说，如果我的懒癌治好了的话。过程1是第二部分__请求到DispatcherServlet__，过程2和过程3可以总结为__DispatcherServlet处理请求__，也就是本文的第三部分。\n\n## 2. 请求到DispatcherServlet\n\n那我们按照顺序先来说一下过程1，熟悉SpringMVC的同学肯定都知道DispatcherServlet这个类，这个类是整个SpringMVC的入口。那在这个类之前做工作的其实是J2EE，不是我们重点关注的对象。只简单说一下：\n\n首先一个WEB程序的入口其实是web.xml，一个请求过来，J2EE会先来这个文件中寻找合适的servlet-mapping，找到了就交给对应的Servlet处理。SpringMVC也需要在这里配一个Servlet，并且声明处理一些请求，简单点来说，我们都会让SpringMVC处理所有的请求，所以请求映射的地方就会写‘/*’，比如下面这样。\n\n```xml\n<servlet>\n    <servlet-name>Spring web</servlet-name>\n    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n    <init-param>\n      <param-name>contextConfigLocation</param-name>\n      <param-value>classpath:spring/web-context.xml</param-value>\n    </init-param>\n    <load-on-startup>1</load-on-startup>\n  </servlet>\n\n  <servlet-mapping>\n    <servlet-name>Spring web</servlet-name>\n    <url-pattern>/*</url-pattern>\n  </servlet-mapping>\n```\n这样配置一下，所有的请求就都会交给DispatcherServlet来处理了，也就是交给SpringMVC来处理了。1的过程就这么简单，想看代码实现的话可以翻翻Tomcat的代码。好，那接下来我们这篇文章重点，过程2和过程3的实现原理，也就是DispatcherServlet的处理过程。\n\nDispatcherServlet作为一个标准的Servlet，生命周期也是有三个，初始化，处理请求和销毁，分别对应Servlet接口的三个方法，init(), service()和destroy()。\n\n```java\npublic interface Servlet {\n    void init(ServletConfig var1) throws ServletException;\n\n    ServletConfig getServletConfig();\n\n    void service(ServletRequest var1, ServletResponse var2) throws ServletException, IOException;\n\n    String getServletInfo();\n\n    void destroy();\n}\n\n```\n\n这里我们重点关注init和service的过程，destroy是service之后的过程了，可以暂时忽略不看。\n\n### 2.1 DispatcherServlet初始化\n\n这里先放一张DispatcherServlet的继承关系吧\n\n![这里写图片描述](http://img.blog.csdn.net/20161229133354781?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemd6Y3p6dw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n左边这条线就是Servlet的线，HttpServlet以及之上就是J2EE部分的代码，关注的是对请求的处理，比如doGet，doPost这些。下面HttpServletBean获取环境变量以方便子类使用。然后FrameworkServlet主要维护了自己的上下文对象webApplicationContext。我们知道一般的Servlet是不维护上下文对象的，而DispatcherServlet就是因为继承了FrameworkServlet，所以拥有了自己的上下文。简单来说大概就是这样，后面分析DispatcherServlet的工作过程的时候，还会追踪到它的这几个父类中来，到时候我们再细说。\n\n首先我们先从init方法来分析DispatcherServlet的的初始化过程，这是Servlet接口中init的方法签名。\n\n```\nvoid init(ServletConfig var1) throws ServletException;\n```\n这个带参的init方法出现在GenericServlet中\n\n```\n    public void init(ServletConfig config) throws ServletException {\n        this.config = config;\n        this.init();\n    }\n\n    public void init() throws ServletException {\n    }\n```\n\n接收了一个J2EE环境传过来的配置对象config，然后提供了一个无参的init方法供子类初始化。这个无参的init方法在HttpServletBean中。\n\n```\npublic final void init() throws ServletException {\n        if(this.logger.isDebugEnabled()) {\n            this.logger.debug(\"Initializing servlet \\'\" + this.getServletName() + \"\\'\");\n        }\n\n        try {\n            //获取配置文件，就是web.xml中contextConfigLocation的值\n            HttpServletBean.ServletConfigPropertyValues ex = new HttpServletBean.ServletConfigPropertyValues(this.getServletConfig(), this.requiredProperties);\n            //将Servlet包装成一个bean\n            BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(this);\n            //获取服务器信息\n            ServletContextResourceLoader resourceLoader = new ServletContextResourceLoader(this.getServletContext());\n            bw.registerCustomEditor(Resource.class, new ResourceEditor(resourceLoader, this.getEnvironment()));\n            //初始化Bean\n            this.initBeanWrapper(bw);\n            //设置配置文件到bean\n            bw.setPropertyValues(ex, true);\n            //其实以上部分没用到，因为在DispatcherServlet里initBeanWrapper没有被实现\n        } catch (BeansException var4) {\n            this.logger.error(\"Failed to set bean properties on servlet \\'\" + this.getServletName() + \"\\'\", var4);\n            throw var4;\n        }\n        //供子类初始化\n        this.initServletBean();\n        if(this.logger.isDebugEnabled()) {\n            this.logger.debug(\"Servlet \\'\" + this.getServletName() + \"\\' configured successfully\");\n        }\n\n    }\n```\n\nHttpServletBean中提供了两个供子类重写的初始化方法initBeanWrapper和initServletBean，其中initBeanWrapper没有使用，DispatcherServlet使用了initServletBean来初始化接下来的工作。\n\ninitServletBean在FrameworkServlet中。\n\n```\nprotected final void initServletBean() throws ServletException {\n        this.getServletContext().log(\"Initializing Spring FrameworkServlet \\'\" + this.getServletName() + \"\\'\");\n        if(this.logger.isInfoEnabled()) {\n            this.logger.info(\"FrameworkServlet \\'\" + this.getServletName() + \"\\': initialization started\");\n        }\n\n        long startTime = System.currentTimeMillis();\n\n        try {\n            //初始化上下文对象\n            this.webApplicationContext = this.initWebApplicationContext();\n            //提供给子类初始化\n            this.initFrameworkServlet();\n        } catch (ServletException var5) {\n            this.logger.error(\"Context initialization failed\", var5);\n            throw var5;\n        } catch (RuntimeException var6) {\n            this.logger.error(\"Context initialization failed\", var6);\n            throw var6;\n        }\n\n        if(this.logger.isInfoEnabled()) {\n            long elapsedTime = System.currentTimeMillis() - startTime;\n            this.logger.info(\"FrameworkServlet \\'\" + this.getServletName() + \"\\': initialization completed in \" + elapsedTime + \" ms\");\n        }\n\n    }\n```\ninitFrameworkServlet是提供给子类复写的初始化方法，但是DispatcherServlet也没有用，而是用了initWebApplicationContext中的refresh方法，任性啊。initWebApplicationContext是用来初始化上下文对象的，具体逻辑如下\n\n```\n    protected WebApplicationContext initWebApplicationContext() {\n        //前面检查ApplicationContext是否被初始化过，如果有就直接拿来用\n        WebApplicationContext rootContext = WebApplicationContextUtils.getWebApplicationContext(this.getServletContext());\n        WebApplicationContext wac = null;\n        if(this.webApplicationContext != null) {\n            wac = this.webApplicationContext;\n            if(wac instanceof ConfigurableWebApplicationContext) {\n                ConfigurableWebApplicationContext attrName = (ConfigurableWebApplicationContext)wac;\n                if(!attrName.isActive()) {\n                    if(attrName.getParent() == null) {\n                        attrName.setParent(rootContext);\n                    }\n\n                    this.configureAndRefreshWebApplicationContext(attrName);\n                }\n            }\n        }\n\n        if(wac == null) {\n            wac = this.findWebApplicationContext();\n        }\n\n        if(wac == null) {\n            wac = this.createWebApplicationContext(rootContext);\n        }\n        //Servlet自己的初始化方法\n        if(!this.refreshEventReceived) {\n            this.onRefresh(wac);\n        }\n\n        //将上下文对象保存起来\n        if(this.publishContext) {\n            String attrName1 = this.getServletContextAttributeName();\n            this.getServletContext().setAttribute(attrName1, wac);\n            if(this.logger.isDebugEnabled()) {\n                this.logger.debug(\"Published WebApplicationContext of servlet \\'\" + this.getServletName() + \"\\' as ServletContext attribute with name [\" + attrName1 + \"]\");\n            }\n        }\n\n        return wac;\n    }\n```\n\n这个方法前半部分是检查之前有没有创建过ApplicationContext对象，如果有，就直接拿过来用。如果没有，则初始化一个，onRefresh则是Servlet将自己的配置加到上下文对象中的方法，DispatcherServlet也是用了这个方法来初始化各种Bean。追了一堆，init方法终于到DispatcherServlet内部了。\n\n```\n    protected void onRefresh(ApplicationContext context) {\n        this.initStrategies(context);\n    }\n\n    protected void initStrategies(ApplicationContext context) {\n        this.initMultipartResolver(context);\n        this.initLocaleResolver(context);\n        this.initThemeResolver(context);\n        this.initHandlerMappings(context);\n        this.initHandlerAdapters(context);\n        this.initHandlerExceptionResolvers(context);\n        this.initRequestToViewNameTranslator(context);\n        this.initViewResolvers(context);\n        this.initFlashMapManager(context);\n    }\n```\n\n看，上面就是DispatcherServlet的一堆初始化方法。\n> 来自http://blog.csdn.net/snail_bi/article/details/50578371\n> \n> 1. MultipartResolver: \n> http://exceptioneye.iteye.com/blog/1314958\n> --> CommonsMultipartResolver 文件上传解析器\n> \n> 2. LocalResolver: 支持国际化,区域解析器。每DispatcherServlet只能注册一个区域解析器\n> http://blog.csdn.NET/rj042/article/details/23354225\n>    --> AcceptHeaderLocaleResolver 它通过检验HTTP请求的accept-language头部来解析区域。由用户的web浏览器根据底层操作系统的区域设置进行设定。\n>    --> SessionLocaleResolver 它通过检验用户会话中预置的属性来解析区域。如果该会话属性\n> 不存在，它会根据accept-language HTTP头部确定默认区域。\n> --> CookieLocaleResolver来解析区域。如果Cookie不存在，它会根据accept-language HTTP头部确定默认区域。 \n> --> FixedLocaleResolver 一直使用固定的Local, 不支持Local改变 。\n> 修改用户的区域\n> 除了显式调用LocaleResolver.setLocale()来修改用户的区域之外，还可以将LocaleChangeInterceptor拦截器应用到处理程序映射中，它会发现当前HTTP请求中出现的特殊参数。其中的参数名称可以通过拦截器的paramName属性进行自定义。如果这种参数出现在当前请求中，拦截器就会根据参数值来改变用户的区域。\n> \n> 3. ThemeSource 动态更换样式的支持(主题)\n> http://starscream.iteye.com/blog/1075855\n> --> FixedThemeResolver:固定格式的theme,不能在系统运行时动态更改theme.\n> --> SessionThemeResolver:theme name存放在session中key值为 org.springframework.web.servlet.theme.SessionThemeResolver.THEME 的session attribute中。可在运行中通过更改session中的相应的key值来动态调整theme的值。\n> --> CookieThemeResolver:theme name存放在cookie中key值为 org.springframework.web.servlet.theme.CookieThemeResolver.THEME 中。可在运行中通过更改cookie中的相应的key值来动态调整theme的值。\n> \n> 4. HandlerMapping\n> http://blog.csdn.Net/sunxing007/article/details/4584748\n> http://blog.csdn.net/prince2270/article/details/5894456\n> -->BeanNameUrlHandlerMapping: 查找spring容器中和请求的url同名的bean.\n> -->BeanNameUrlHandlerMapping ：通过对比url和bean的name找到对应的对象 \n> -->SimpleUrlHandlerMapping ：也是直接配置url和对应bean,比BeanNameUrlHandlerMapping功能更多 \n> -->DefaultAnnotationHandlerMapping : 主要是针对注解配置@RequestMapping的，已过时 \n> -->RequestMappingHandlerMapping ：取代了上面一个 \n>   --> 还有很多 ，请看源码\n> \n> 5. HandlerAdapter\n> --> SimpleControllerHandlerAdapter\n> --> SimpleServletHandlerAdapter\n> --> RequestMappingHandlerAdapter\n> --> HttpRequestHandlerAdapter\n> --> AnnotationMethodHandlerAdapter\n> \n> 6. HandlerExceptionResolver\n> \n> 7. RequestToViewNameTranslator  用于直接将请求转换为逻辑视图名。\n> http://sishuok.com/forum/blogPost/list/0/5514.html\n> http://haohaoxuexi.iteye.com/blog/1774603\n> --> DefaultRequestToViewNameTranslator\n> [\n> http://localhost:9080/web上下文/list -------> 逻辑视图名为list\n>   http://localhost:9080/web上下文/list.html -------> 逻辑视图名为list(默认删除扩展名)\n>   http://localhost:9080/web上下文/user/list.html -------> 逻辑视图名为user/list\n> ]\n> \n> 8. ViewResolver 视图解析器：定义了如何通过view 名称来解析对应View实例的行为\n> http://blog.csdn.net/prince2270/article/details/5891085\n> http://www.iteye.com/problems/76107 多视图问题的解决\n> http://my.oschina.net/HeliosFly/blog/221392\n> \n> 9. FlashMapManager  \n> http://www.oschina.net/translate/spring-mvc-flash-attribute-example\n> --> SessionFlashMapManager\n\n以上就是SpringMVC在初始化的时候加入的各种处理器，对于请求到Controller的映射，比较重要的是HandlerMapping和HandlerAdapter，HandlerMapping是用来查找处理请求的对象，HandlerAdapter是用来处理请求参数。这里以HandlerAdapter来举个例子，看一下initHandlerAdapters方法。\n\n```\n·private void initHandlerAdapters(ApplicationContext context) {\n        this.handlerAdapters = null;\n        if(this.detectAllHandlerAdapters) {\n            Map ex = BeanFactoryUtils.beansOfTypeIncludingAncestors(context, HandlerAdapter.class, true, false);\n            if(!ex.isEmpty()) {\n                this.handlerAdapters = new ArrayList(ex.values());\n                OrderComparator.sort(this.handlerAdapters);\n            }\n        } else {\n            try {\n                HandlerAdapter ex1 = (HandlerAdapter)context.getBean(\"handlerAdapter\", HandlerAdapter.class);\n                this.handlerAdapters = Collections.singletonList(ex1);\n            } catch (NoSuchBeanDefinitionException var3) {\n                ;\n            }\n        }\n\n        if(this.handlerAdapters == null) {\n            this.handlerAdapters = this.getDefaultStrategies(context, HandlerAdapter.class);\n            if(this.logger.isDebugEnabled()) {\n                this.logger.debug(\"No HandlerAdapters found in servlet \\'\" + this.getServletName() + \"\\': using default\");\n            }\n        }\n\n    }\n```\n\n上面的逻辑是这样的\n> 1)如果detectAllHandlerAdapters属性为true(默认为true)，根据类型匹配(HandlerAdapter)机制查找上下文及父Spring容器中所有匹配的Bean，将它们作为该类型组件；\n> 2)如果detectAllHandlerAdapters属性为false，查找名为handlerAdapter类型为HandlerAdapter的Bean作为该类型组件；\n> 3)如果通过以上方式都找不到，使用DispatcherServlet.properties配置文件中指定的三个实现类分别创建一个适配器，添加到适配器列表中。\n\nDispatcherServlet.properties和DispatcherServlet在同一个包下，定义了一些默认的类，内容如下。\n\n```\norg.springframework.web.servlet.LocaleResolver=org.springframework.web.servlet.i18n.AcceptHeaderLocaleResolver\n\norg.springframework.web.servlet.ThemeResolver=org.springframework.web.servlet.theme.FixedThemeResolver\n\norg.springframework.web.servlet.HandlerMapping=org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping,\\\n\torg.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping\n\norg.springframework.web.servlet.HandlerAdapter=org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter,\\\n\torg.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter,\\\n\torg.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter\n\norg.springframework.web.servlet.HandlerExceptionResolver=org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerExceptionResolver,\\\n\torg.springframework.web.servlet.mvc.annotation.ResponseStatusExceptionResolver,\\\n\torg.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver\n\norg.springframework.web.servlet.RequestToViewNameTranslator=org.springframework.web.servlet.view.DefaultRequestToViewNameTranslator\n\norg.springframework.web.servlet.ViewResolver=org.springframework.web.servlet.view.InternalResourceViewResolver\n\norg.springframework.web.servlet.FlashMapManager=org.springframework.web.servlet.support.SessionFlashMapManager\n```\n\n我们看到HandlerAdapter是有三个默认类，如果程序从上下文中找不到任何HandlerAdapter，就会把这三个加载进来。\n\nDispatcherServlet结束了onRefresh的一系列方法，初始化过程就结束了。接下来就是一个请求到来的时候的处理工作了。\n\n## 3. Dispatcher处理请求\n### 3.1 预处理请求\n\n请求到来的时候，J2EE会调用相应Servlet的onService方法，对于DispatcherServlet来说，这个onService在FrameworkServlet里，代码如下\n\n```\nprotected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String method = request.getMethod();\n        if(method.equalsIgnoreCase(RequestMethod.PATCH.name())) {\n            this.processRequest(request, response);\n        } else {\n            super.service(request, response);\n        }\n\n    }\n```\n这个方法补充了对PATCH请求类型的处理，其他请求类型如GET，PUT，调用了super的service方法，也就是在HttpServlet的service方法(HttpServletBean中没有复写)。\n\n```\nprotected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        String method = req.getMethod();\n        long errMsg;\n        if(method.equals(\"GET\")) {\n            errMsg = this.getLastModified(req);\n            if(errMsg == -1L) {\n                this.doGet(req, resp);\n            } else {\n                long ifModifiedSince = req.getDateHeader(\"If-Modified-Since\");\n                if(ifModifiedSince < errMsg / 1000L * 1000L) {\n                    this.maybeSetLastModified(resp, errMsg);\n                    this.doGet(req, resp);\n                } else {\n                    resp.setStatus(304);\n                }\n            }\n        } else if(method.equals(\"HEAD\")) {\n            errMsg = this.getLastModified(req);\n            this.maybeSetLastModified(resp, errMsg);\n            this.doHead(req, resp);\n        } else if(method.equals(\"POST\")) {\n            this.doPost(req, resp);\n        } else if(method.equals(\"PUT\")) {\n            this.doPut(req, resp);\n        } else if(method.equals(\"DELETE\")) {\n            this.doDelete(req, resp);\n        } else if(method.equals(\"OPTIONS\")) {\n            this.doOptions(req, resp);\n        } else if(method.equals(\"TRACE\")) {\n            this.doTrace(req, resp);\n        } else {\n            String errMsg1 = lStrings.getString(\"http.method_not_implemented\");\n            Object[] errArgs = new Object[]{method};\n            errMsg1 = MessageFormat.format(errMsg1, errArgs);\n            resp.sendError(501, errMsg1);\n        }\n\n    }\n```\n这个方法也很简单，根据不同的请求类型调用不同的方法，这里我们假设请求是个GET请求，那就会去执行子类的doGet方法，在FrameworkServlet里。\n\n```\nprotected final void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        this.processRequest(request, response);\n    }\n```\n也没做什么，交给了processRequest处理，其实其他请求最后也都转给processRequest这个方法处理了，因为处理参数的逻辑是一样的。\n\n```\n    protected final void processRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        long startTime = System.currentTimeMillis();\n        Object failureCause = null;\n        //获取之前的位置信息，最后finally时恢复之前配置\n        LocaleContext previousLocaleContext = LocaleContextHolder.getLocaleContext();\n        LocaleContext localeContext = this.buildLocaleContext(request);\n        RequestAttributes previousAttributes = RequestContextHolder.getRequestAttributes();\n        ServletRequestAttributes requestAttributes = this.buildRequestAttributes(request, response, previousAttributes);\n        //注册Interceptor，没理解干嘛的\n        WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);\n        asyncManager.registerCallableInterceptor(FrameworkServlet.class.getName(), new FrameworkServlet.RequestBindingInterceptor(null));\n        //将请求中的位置信息记入\n        this.initContextHolders(request, localeContext, requestAttributes);\n\n        try {\n            //做事情\n            this.doService(request, response);\n        } catch (ServletException var18) {\n            failureCause = var18;\n            throw var18;\n        } catch (IOException var19) {\n            failureCause = var19;\n            throw var19;\n        } catch (Throwable var20) {\n            failureCause = var20;\n            throw new NestedServletException(\"Request processing failed\", var20);\n        } finally {\n        //恢复之前配置\n            this.resetContextHolders(request, previousLocaleContext, previousAttributes);\n            if(requestAttributes != null) {\n                requestAttributes.requestCompleted();\n            }\n\n            if(this.logger.isDebugEnabled()) {\n                if(failureCause != null) {\n                    this.logger.debug(\"Could not complete request\", (Throwable)failureCause);\n                } else if(asyncManager.isConcurrentHandlingStarted()) {\n                    this.logger.debug(\"Leaving response open for concurrent processing\");\n                } else {\n                    this.logger.debug(\"Successfully completed request\");\n                }\n            }\n\n           //发布事件 this.publishRequestHandledEvent(request, startTime, (Throwable)failureCause);\n        }\n\n    }\n```\n先说下发布事件，Spring在请求处理结束后会发布一个ServletRequestHandledEvent类型的事件，可以通过ApplicationListener接收。\n\n这个方法前面和后面做的工作是保留现场，请求处理结束后恢复现场。真正处理请求的方法是doService。这个方法在DispatcherServlet中。\n\n话语权终于到DispatcherServlet中了。\n\n```\n    protected void doService(HttpServletRequest request, HttpServletResponse response) throws Exception {\n        if(this.logger.isDebugEnabled()) {\n            String attributesSnapshot = WebAsyncUtils.getAsyncManager(request).hasConcurrentResult()?\" resumed\":\"\";\n            this.logger.debug(\"DispatcherServlet with name \\'\" + this.getServletName() + \"\\'\" + attributesSnapshot + \" processing \" + request.getMethod() + \" request for [\" + getRequestUri(request) + \"]\");\n        }\n\n        HashMap attributesSnapshot1 = null;\n        //处理include类型的request，用不到\n        if(WebUtils.isIncludeRequest(request)) {\n            attributesSnapshot1 = new HashMap();\n            Enumeration inputFlashMap = request.getAttributeNames();\n\n            label113:\n            while(true) {\n                String attrName;\n                do {\n                    if(!inputFlashMap.hasMoreElements()) {\n                        break label113;\n                    }\n\n                    attrName = (String)inputFlashMap.nextElement();\n                } while(!this.cleanupAfterInclude && !attrName.startsWith(\"org.springframework.web.servlet\"));\n\n                attributesSnapshot1.put(attrName, request.getAttribute(attrName));\n            }\n        }\n        //将现在的各种参数加到Request中\n        request.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, this.getWebApplicationContext());\n        request.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, this.localeResolver);\n        request.setAttribute(THEME_RESOLVER_ATTRIBUTE, this.themeResolver);\n        request.setAttribute(THEME_SOURCE_ATTRIBUTE, this.getThemeSource());\n        FlashMap inputFlashMap1 = this.flashMapManager.retrieveAndUpdate(request, response);\n        if(inputFlashMap1 != null) {\n            request.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, Collections.unmodifiableMap(inputFlashMap1));\n        }\n\n        request.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, new FlashMap());\n        request.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, this.flashMapManager);\n\n        try {\n            //做事情\n            this.doDispatch(request, response);\n        } finally {\n            if(WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) {\n                return;\n            }\n\n            if(attributesSnapshot1 != null) {\n                this.restoreAttributesAfterInclude(request, attributesSnapshot1);\n            }\n\n        }\n\n    }\n```\n这个方法主要是把现在有的一些参数比如上下文对象加到Request中，然后转发到doDispatch方法去处理，终于到了最关键的方法了。\n\n```\n    protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {\n        HttpServletRequest processedRequest = request;\n        HandlerExecutionChain mappedHandler = null;\n        boolean multipartRequestParsed = false;\n        WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);\n\n        try {\n            try {\n                ModelAndView err = null;\n                Exception dispatchException = null;\n\n                try {\n                    processedRequest = this.checkMultipart(request);\n                    multipartRequestParsed = processedRequest != request;\n                    //获取Hanlder\n                    mappedHandler = this.getHandler(processedRequest, false);\n                    if(mappedHandler == null || mappedHandler.getHandler() == null) {\n                        this.noHandlerFound(processedRequest, response);\n                        return;\n                    }\n                    //获取Adapter\n                    HandlerAdapter ex = this.getHandlerAdapter(mappedHandler.getHandler());\n                    String method = request.getMethod();\n                    boolean isGet = \"GET\".equals(method);\n                    if(isGet || \"HEAD\".equals(method)) {\n                        long lastModified = ex.getLastModified(request, mappedHandler.getHandler());\n                        if(this.logger.isDebugEnabled()) {\n                            this.logger.debug(\"Last-Modified value for [\" + getRequestUri(request) + \"] is: \" + lastModified);\n                        }\n\n                        if((new ServletWebRequest(request, response)).checkNotModified(lastModified) && isGet) {\n                            return;\n                        }\n                    }\n                    //执行preHandle方法\n                    if(!mappedHandler.applyPreHandle(processedRequest, response)) {\n                        return;\n                    }\n\n                     //执行Handle方法                    \n                    try {\n                        err = ex.handle(processedRequest, response, mappedHandler.getHandler());\n                    } finally {\n                        if(asyncManager.isConcurrentHandlingStarted()) {\n                            return;\n                        }\n\n                    }\n                    //处理默认的ViewName\n                    this.applyDefaultViewName(request, err);\n                    //执行PostHandle\n                    mappedHandler.applyPostHandle(processedRequest, response, err);\n                } catch (Exception var27) {\n                    dispatchException = var27;\n                }\n                //处理返回结果，绘制View\n                this.processDispatchResult(processedRequest, response, mappedHandler, err, dispatchException);\n            } catch (Exception var28) {\n                this.triggerAfterCompletion(processedRequest, response, mappedHandler, var28);\n            } catch (Error var29) {\n                this.triggerAfterCompletionWithError(processedRequest, response, mappedHandler, var29);\n            }\n\n        } finally {\n            if(asyncManager.isConcurrentHandlingStarted()) {\n                mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);\n                return;\n            } else {\n                if(multipartRequestParsed) {\n                    this.cleanupMultipart(processedRequest);\n                }\n\n            }\n        }\n    }\n```\n虽然这个方法可以说是整个SpringMVC中最重要的方法，但是整个流程缺及其简单，可以说这一切都归功于Spring框架高度的抽象。我们来梳理一下这个doDispatch方法的流程。\n\n1. 获取Handler\n2. 获取Adapter\n3. 执行preHandle方法\n4. 执行Handle方法\n5. 执行PostHandle\n6. 处理返回结果\n\n5和6是Controller请求处理结束后的操作，本文中我们只讨论1-2-3-4这四个步骤。1-2-3-4这四个步骤对应了一开始提到的SpringMVC的七大步中的第二步请求到处理器映射和第三步请求到控制器。其中1-2是请求到处理器映射，3-4是请求到控制器。下面我们一步一步的来看。\n\n### 3.2 根据请求获取Handler\n\n首先第一步是根据request，获取合适的Handler。\n\n```\nmappedHandler = this.getHandler(processedRequest, false);\n```\n\n这里返回的结果是HandlerExecutionChain类型的，从名字我们知道这是一个执行链，里面包含了这个Handler所有相关的信息。下面我们来看下getHandler方法。\n\n```\nprotected HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception {\n        Iterator i$ = this.handlerMappings.iterator();\n\n        HandlerExecutionChain handler;\n        do {\n            if(!i$.hasNext()) {\n                return null;\n            }\n\n            HandlerMapping hm = (HandlerMapping)i$.next();\n            if(this.logger.isTraceEnabled()) {\n                this.logger.trace(\"Testing handler map [\" + hm + \"] in DispatcherServlet with name \\'\" + this.getServletName() + \"\\'\");\n            }\n\n            handler = hm.getHandler(request);\n        } while(handler == null);\n\n        return handler;\n    }\n```\n遍历HandlerMappings，然后依次调用每个HandlerMappings的getHandler方法，如果有返回就交给该Handler处理。\n\n这个HandlerMappings是DispatcherServlet初始化的时候加入的，在initHandlerMapping方法里。我们看下系统默认的HandlerMapping都有哪些。\n\n```\norg.springframework.web.servlet.HandlerMapping=org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping,\\\n\torg.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping\n```\n\n我的项目自定义了一个HandlerMappings，也是基于注解的\n\n```\n<!--配置注解式处理器映射器-->\n <bean class=\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping\"/>\n```\n\n我们来看一下他是怎么工作的。getHandler方法。这个方法在RequestMappingHandlerMapping的父类AbstractHandlerMapping中\n\n```\npublic final HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception {\n        Object handler = this.getHandlerInternal(request);\n        if(handler == null) {\n            handler = this.getDefaultHandler();\n        }\n\n        if(handler == null) {\n            return null;\n        } else {\n            if(handler instanceof String) {\n                String handlerName = (String)handler;\n                handler = this.getApplicationContext().getBean(handlerName);\n            }\n\n            return this.getHandlerExecutionChain(handler, request);\n        }\n    }\n```\n\nSpring框架一贯的套路，父类定义流程，开一个方法供子类去实现，比如这里的getHandlerInternal，返回了Handler之后，再用HandlerExecutionChain包装一下。那先来看下getHandlerInternal方法是怎么获取Handler的。这个方法依然在RequestMappingHandlerMapping的父类AbstractHandlerMethodMapping中。\n\n\n```\nprotected HandlerMethod getHandlerInternal(HttpServletRequest request) throws Exception {\n        String lookupPath = this.getUrlPathHelper().getLookupPathForRequest(request);\n        if(this.logger.isDebugEnabled()) {\n            this.logger.debug(\"Looking up handler method for path \" + lookupPath);\n        }\n\n        HandlerMethod handlerMethod = this.lookupHandlerMethod(lookupPath, request);\n        if(this.logger.isDebugEnabled()) {\n            if(handlerMethod != null) {\n                this.logger.debug(\"Returning handler method [\" + handlerMethod + \"]\");\n            } else {\n                this.logger.debug(\"Did not find handler method for [\" + lookupPath + \"]\");\n            }\n        }\n\n        return handlerMethod != null?handlerMethod.createWithResolvedBean():null;\n    }\n```\n\n两个重要的方法，getLookupPathForRequest和lookupHandlerMethod，这里我就不贴代码了，说一下实现原理吧，其实RequestMappingHandlerMapping在初始化的时候已经将系统中所有的@RequestMapping注解解析了，放在一个Map里面。实现过程如下。\n\nRequestMappingHandlerMapping的父类AbstractHandlerMethodMapping实现了InitializingBean接口，在Bean设置完参数后会调用afterPropertiesSet方法，而它在这个方法里面做了初始化的工作。\n\n```\n\tpublic void afterPropertiesSet() {\n        this.initHandlerMethods();\n    }\n\n    protected void initHandlerMethods() {\n        if(this.logger.isDebugEnabled()) {\n            this.logger.debug(\"Looking for request mappings in application context: \" + this.getApplicationContext());\n        }\n\n        String[] beanNames = this.detectHandlerMethodsInAncestorContexts?BeanFactoryUtils.beanNamesForTypeIncludingAncestors(this.getApplicationContext(), Object.class):this.getApplicationContext().getBeanNamesForType(Object.class);\n        String[] arr$ = beanNames;\n        int len$ = beanNames.length;\n\n        for(int i$ = 0; i$ < len$; ++i$) {\n            String beanName = arr$[i$];\n            //判断类中是否含有RequestMapping注释\n            if(this.isHandler(this.getApplicationContext().getType(beanName))) {\n                //解析方法\n                this.detectHandlerMethods(beanName);\n            }\n        }\n\n        this.handlerMethodsInitialized(this.getHandlerMethods());\n    }\n    \n  protected void detectHandlerMethods(Object handler) {\n        Class handlerType = handler instanceof String?this.getApplicationContext().getType((String)handler):handler.getClass();\n        final IdentityHashMap mappings = new IdentityHashMap();\n        final Class userType = ClassUtils.getUserClass(handlerType);\n        Set methods = HandlerMethodSelector.selectMethods(userType, new MethodFilter() {\n            public boolean matches(Method method) {\n                Object mapping = AbstractHandlerMethodMapping.this.getMappingForMethod(method, userType);\n                if(mapping != null) {\n                    mappings.put(method, mapping);\n                    return true;\n                } else {\n                    return false;\n                }\n            }\n        });\n        Iterator i$ = methods.iterator();\n\n        while(i$.hasNext()) {\n            Method method = (Method)i$.next();\n            //注册方法，加到urlMaps里面\n            this.registerHandlerMethod(handler, method, mappings.get(method));\n        }\n\n    }\n```\n\n这样RequestMappingHandlerMapping 里面就有了所有Controller方法的信息。getLookupPathForRequest就是获取请求的地址，比如我请求的是http://localhost:8090/test，那这里getLookupPathForRequest返回的就是/test。现在只要查询一下RequestMappingHandlerMapping里面有没有key为/test的的value即可，value中有处理的类的Controller对应的bean name，然后下面createWithResolvedBean包装一下返回一个HandlerMethod。返回的HandlerMethod再通过getHandlerExecutionChain包装成HandlerExecutionChain，HandlerExecutionChain里面有什么呢，我们来看一下getHandlerExecutionChain方法是怎么写的。\n\n```\n\tprotected HandlerExecutionChain getHandlerExecutionChain(Object handler, HttpServletRequest request) {\n        HandlerExecutionChain chain = handler instanceof HandlerExecutionChain?(HandlerExecutionChain)handler:new HandlerExecutionChain(handler);\n        chain.addInterceptors(this.getAdaptedInterceptors());\n        String lookupPath = this.urlPathHelper.getLookupPathForRequest(request);\n        Iterator i$ = this.mappedInterceptors.iterator();\n\n        while(i$.hasNext()) {\n            MappedInterceptor mappedInterceptor = (MappedInterceptor)i$.next();\n            if(mappedInterceptor.matches(lookupPath, this.pathMatcher)) {\n                chain.addInterceptor(mappedInterceptor.getInterceptor());\n            }\n        }\n\n        return chain;\n    }\n```\n\n其实就是把Interceptor加进去，你可以通过自定义Interceptor来对一个request的前后做相应的处理，下面是HandlerInterceptor接口的方法。\n\n```\npublic interface HandlerInterceptor {\n    boolean preHandle(HttpServletRequest var1, HttpServletResponse var2, Object var3) throws Exception;\n\n    void postHandle(HttpServletRequest var1, HttpServletResponse var2, Object var3, ModelAndView var4) throws Exception;\n\n    void afterCompletion(HttpServletRequest var1, HttpServletResponse var2, Object var3, Exception var4) throws Exception;\n}\n```\n\n这样就获取到了处理这个request对应的Controller，以及方法名了，控制权又交回到doDispatch方法中去了。\n\n### 3.3 根据处理器获取相应的处理器Adapter适配器\n\n接下来是第二步获取Adapter，这个Adapter的作用主要是把请求中的参数和Controller方法中的参数对应起来，所以就会做一些类型转换相应的工作，也就是下一步，这一部分也是我觉得request到Controller的映射过程中最复杂的一步，不过获取Adapter相对简单。\n\n首先看下getHandlerAdapter的代码\n\n```\n\tprotected HandlerAdapter getHandlerAdapter(Object handler) throws ServletException {\n        Iterator i$ = this.handlerAdapters.iterator();\n\n        HandlerAdapter ha;\n        do {\n            if(!i$.hasNext()) {\n                throw new ServletException(\"No adapter for handler [\" + handler + \"]: The DispatcherServlet configuration needs to include a HandlerAdapter that supports this handler\");\n            }\n\n            ha = (HandlerAdapter)i$.next();\n            if(this.logger.isTraceEnabled()) {\n                this.logger.trace(\"Testing handler adapter [\" + ha + \"]\");\n            }\n        } while(!ha.supports(handler));\n\n        return ha;\n    }\n```\n\n 从初始化的handlerAdapters中取出可以处理相应handler的，如果没有自定义，系统会预置几个，这个前面也说到了。这里我们看下supports方法吧，看下handlerAdapter是怎么判断它自己能否处理这个handler的。我目前项目用的是RequestMappingHandlerAdapter这里Adapter处理类。它的supports方法在他的父类AbstractHandlerMethodAdapter上。\n \n ```\n public final boolean supports(Object handler) {\n        return handler instanceof HandlerMethod && this.supportsInternal((HandlerMethod)handler);\n    }\n ```\n \n ```\n protected boolean supportsInternal(HandlerMethod handlerMethod) {\n        return true;\n    }\n ```\n RequestMappingHandlerAdapter的supportsInternal方法是永远返回true的，所以只要handler的类型是HandlerMethod，这个RequestMappingHandlerAdapter都会处理。这个RequestMappingHandlerAdapter其实是个比较通用的Adapter类。\n \n### 3.4 执行preHandle方法和Handle方法\n \n 获取到了Adapter，接下来就要做实际的事情了，执行preHandle方法很简单，就是调用一下，其实是为了用户定制。接下来真正处理事情的是adapter的handle方法。也就是我们上面提到的doDispatch的第四步。\n \n AbstractHandlerMethodAdapter的handle方法按照Spring的国际惯例肯定，自己做了点保存现场啥的工作，然后定义一个方法让子类去做实际的事情了。我瞅了一眼，我觉得我还是高估这个父类了，它啥都没做直接调用了子类的handleInternal方法。RequestMappingHandlerAdapter中handleInternal的实现是这样的。\n \n ```\n protected final ModelAndView handleInternal(HttpServletRequest request, HttpServletResponse response, HandlerMethod handlerMethod) throws Exception {\n        if(this.getSessionAttributesHandler(handlerMethod).hasSessionAttributes()) {\n            this.checkAndPrepare(request, response, this.cacheSecondsForSessionAttributeHandlers, true);\n        } else {\n            this.checkAndPrepare(request, response, true);\n        }\n\n        if(this.synchronizeOnSession) {\n            HttpSession session = request.getSession(false);\n            if(session != null) {\n                Object mutex = WebUtils.getSessionMutex(session);\n                synchronized(mutex) {\n                    return this.invokeHandleMethod(request, response, handlerMethod);\n                }\n            }\n        }\n\n        return this.invokeHandleMethod(request, response, handlerMethod);\n    }\n ```\n \n 又分了两部分，一个是checkAndPrepare，另一个是invokeHandleMethod，从名字也可以看出，一个事准备，一个事调用方法。按步骤一个一个来，先看看checkAndPrepare做了什么。\n \n ```\n protected final void checkAndPrepare(HttpServletRequest request, HttpServletResponse response, int cacheSeconds, boolean lastModified) throws ServletException {\n        String method = request.getMethod();\n        if(this.supportedMethods != null && !this.supportedMethods.contains(method)) {\n            throw new HttpRequestMethodNotSupportedException(method, StringUtils.toStringArray(this.supportedMethods));\n        } else if(this.requireSession && request.getSession(false) == null) {\n            throw new HttpSessionRequiredException(\"Pre-existing session required but none found\");\n        } else {\n            this.applyCacheSeconds(response, cacheSeconds, lastModified);\n        }\n    }\n ```\n 检查了是否支持请求方法，然后调用了applyCacheSeconds来处理缓存时间戳。也没什么重要的是不是，所以处理参数的其实下面这个方法invokeHandleMethod。\n \n \n ```\n private ModelAndView invokeHandleMethod(HttpServletRequest request, HttpServletResponse response, HandlerMethod handlerMethod) throws Exception {\n \t\t //初始化ServletWebRequest\n        ServletWebRequest webRequest = new ServletWebRequest(request, response);\n        //获取类型转换器\n        WebDataBinderFactory binderFactory = this.getDataBinderFactory(handlerMethod);\n        ModelFactory modelFactory = this.getModelFactory(handlerMethod, binderFactory);\n        //创建Method映射\n        ServletInvocableHandlerMethod requestMappingMethod = this.createRequestMappingMethod(handlerMethod, binderFactory);\n        //创建ModelandView包装器\n        ModelAndViewContainer mavContainer = new ModelAndViewContainer();\n        mavContainer.addAllAttributes(RequestContextUtils.getInputFlashMap(request));\n        modelFactory.initModel(webRequest, mavContainer, requestMappingMethod);\n        mavContainer.setIgnoreDefaultModelOnRedirect(this.ignoreDefaultModelOnRedirect);\n        //异步相关\n        AsyncWebRequest asyncWebRequest = WebAsyncUtils.createAsyncWebRequest(request, response);\n        asyncWebRequest.setTimeout(this.asyncRequestTimeout);\n        WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);\n        asyncManager.setTaskExecutor(this.taskExecutor);\n        asyncManager.setAsyncWebRequest(asyncWebRequest);\n        asyncManager.registerCallableInterceptors(this.callableInterceptors);\n        asyncManager.registerDeferredResultInterceptors(this.deferredResultInterceptors);\n        if(asyncManager.hasConcurrentResult()) {\n            Object result = asyncManager.getConcurrentResult();\n            mavContainer = (ModelAndViewContainer)asyncManager.getConcurrentResultContext()[0];\n            asyncManager.clearConcurrentResult();\n            if(this.logger.isDebugEnabled()) {\n                this.logger.debug(\"Found concurrent result value [\" + result + \"]\");\n            }\n\n            requestMappingMethod = requestMappingMethod.wrapConcurrentResult(result);\n        }\n\n        requestMappingMethod.invokeAndHandle(webRequest, mavContainer, new Object[0]);\n        return asyncManager.isConcurrentHandlingStarted()?null:this.getModelAndView(mavContainer, modelFactory, webRequest);\n    }\n ```\n 现在requestMappingMethod中有了方法信息，有了请求信息，就到了invokeAndHandle。invokeAndHandle中又调了invokeForRequest\n \n ```\n public final Object invokeForRequest(NativeWebRequest request, ModelAndViewContainer mavContainer, Object... providedArgs) throws Exception {\n        Object[] args = this.getMethodArgumentValues(request, mavContainer, providedArgs);\n        if(this.logger.isTraceEnabled()) {\n            StringBuilder returnValue = new StringBuilder(\"Invoking [\");\n            returnValue.append(this.getBeanType().getSimpleName()).append(\".\");\n            returnValue.append(this.getMethod().getName()).append(\"] method with arguments \");\n            returnValue.append(Arrays.asList(args));\n            this.logger.trace(returnValue.toString());\n        }\n\n        Object returnValue1 = this.invoke(args);\n        if(this.logger.isTraceEnabled()) {\n            this.logger.trace(\"Method [\" + this.getMethod().getName() + \"] returned [\" + returnValue1 + \"]\");\n        }\n\n        return returnValue1;\n    }\n\n ```\n invokeForRequest方法通过getMethodArgumentValues从request中获取到了方法的参数列表args，然后调用了invoke反射调用了方法。所以可以看出getMethodArgumentValues中做了request参数到方法参数的转换。继续到里面看。\n \n ```\n private Object[] getMethodArgumentValues(NativeWebRequest request, ModelAndViewContainer mavContainer, Object... providedArgs) throws Exception {\n \t\t //获取所有参数\n        MethodParameter[] parameters = this.getMethodParameters();\n        Object[] args = new Object[parameters.length];\n\n\t\t //每个参数进行处理，从request中找到参数值\n        for(int i = 0; i < parameters.length; ++i) {\n            MethodParameter parameter = parameters[i];\n            parameter.initParameterNameDiscovery(this.parameterNameDiscoverer);\n            //处理提供的数据类型转换，这里传值new Object，所以没用到\n            GenericTypeResolver.resolveParameterType(parameter, this.getBean().getClass());\n            args[i] = this.resolveProvidedArgument(parameter, providedArgs);\n            //如果前面提供的数据类型无法转换\n            if(args[i] == null) {\n                //判断自己的类型转换器能否支持该参数类型\n                if(this.argumentResolvers.supportsParameter(parameter)) {\n                    try {\n                    \t//转换参数\n                        args[i] = this.argumentResolvers.resolveArgument(parameter, mavContainer, request, this.dataBinderFactory);\n                    } catch (Exception var9) {\n                        if(this.logger.isTraceEnabled()) {\n                            this.logger.trace(this.getArgumentResolutionErrorMessage(\"Error resolving argument\", i), var9);\n                        }\n\n                        throw var9;\n                    }\n                } else if(args[i] == null) {\n                    String msg = this.getArgumentResolutionErrorMessage(\"No suitable resolver for argument\", i);\n                    throw new IllegalStateException(msg);\n                }\n            }\n        }\n\n        return args;\n    }\n ```\n \n逻辑在注释中写的差不多了，重点的地方是this.argumentResolvers.supportsParameter(parameter)用来判断自己的参数类型转换器是否支持这种参数类型，然后this.argumentResolvers.resolveArgument来处理参数类型转换。\n\n先来看下this.argumentResolvers.supportsParameter(parameter)，argumentResolvers是一个HandlerMethodArgumentResolverComposite类型的变量，HandlerMethodArgumentResolverComposite是一个Resolver的包装器。\n\n```\n\tpublic boolean supportsParameter(MethodParameter parameter) {\n        return this.getArgumentResolver(parameter) != null;\n    }\n    \n    private HandlerMethodArgumentResolver getArgumentResolver(MethodParameter parameter) {\n        HandlerMethodArgumentResolver result = (HandlerMethodArgumentResolver)this.argumentResolverCache.get(parameter);\n        if(result == null) {\n            Iterator i$ = this.argumentResolvers.iterator();\n\n            while(i$.hasNext()) {\n                HandlerMethodArgumentResolver methodArgumentResolver = (HandlerMethodArgumentResolver)i$.next();\n                if(this.logger.isTraceEnabled()) {\n                    this.logger.trace(\"Testing if argument resolver [\" + methodArgumentResolver + \"] supports [\" + parameter.getGenericParameterType() + \"]\");\n                }\n\n                if(methodArgumentResolver.supportsParameter(parameter)) {\n                    result = methodArgumentResolver;\n                    this.argumentResolverCache.put(parameter, methodArgumentResolver);\n                    break;\n                }\n            }\n        }\n\n        return result;\n    }\n```\n\nmethodArgumentResolver.supportsParameter(parameter)这一句调用了每个Resolver的support方法。关于Resolver是什么，可以看我的上一篇博客。\n\n[SpringMVC对象绑定时自定义名称对应关系](http://zwgeek.com/2016/12/28/SpringMVC%E5%AF%B9%E8%B1%A1%E7%BB%91%E5%AE%9A%E8%87%AA%E5%AE%9A%E4%B9%89%E5%90%8D%E7%A7%B0%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB/)\n\n其实简单来说就是一种类型处理器，我的项目在运行的时候回默认置入24个类型处理器，基本能处理各种类型转换，另外也可以自己自定义类型处理器。传送门里的文章有讲，包括类型处理器是怎么处理类型转换的，里面也有说。总之，类型处理器在argumentResolvers.resolveArgument处理完参数后，会把request的参数转成一个Object[]的列表返回，就是Controller中方法的参数列表。\n\n然后invokeForRequest方法会调用invoke去通过反射调用到Controller中对应的方法。\n\n## 4. 总结\n\n恩，到目前为止，一个request已经被SpringMVC处理后调到了Controller中对应的方法。然后Controller里面就是我们自己的逻辑了。接下来还有doDispatch的后几步，处理Controller的返回并处理成视图返回给用户。这个在以后的文章中慢慢说明。\n\n看Spring的源码，有一个很大的感受就是把抽象接口运用到了极致，几乎所有的处理器都会抽象出一个接口，然后下面会有各种各样的实现。这样处理之后整个流程几乎不涉及具体业务，只有流程规范，非常的容易理解。不得不说是一个让强迫症患者神清气爽的框架。\n\n另外还有一个感受就是，这套框架非常灵活。几乎所有的类都可以做的定制化，每一步处理过程都可以定制化，这样有利有弊，好处就是非常灵活，没有解决不了的问题，坏处就是可能一个地方没理解清楚就会出错。所有在定制化的时候还是要小心一点。\n\n接下来应该会有两篇文章，一篇是讲SpringMVC框架处理Controller的返回结果到视图，再一篇讲下Spring框架初始化Bean和BeanFactory的过程，其实也都在上面讲的流程里面，只是我略过去了。\n\n例行推广一下我的博客，喜欢这篇文章的朋友可以关注我的博客http://zwgeek.com\n\n","source":"_posts/SpringMVC从request到controller过程详解.md","raw":"---\ntitle: SpringMVC从request到controller过程详解\ndate: 2016-12-29 13:10:47\ntags:\n  - SpringMVC\n  - request\n  - controller\n  - DispatcherServlet\ncategories: 服务端开发\n---\n\n例行推广一下我的博客，喜欢这篇文章的朋友可以关注我的博客http://zwgeek.com\n\n## 1. 背景\n\n之前一篇文章 [SpringMVC对象绑定时自定义名称对应关系](http://zwgeek.com/2016/12/28/SpringMVC%E5%AF%B9%E8%B1%A1%E7%BB%91%E5%AE%9A%E8%87%AA%E5%AE%9A%E4%B9%89%E5%90%8D%E7%A7%B0%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB/) 讲了如何去把request中的请求参数指定到对象的某个属性上。但文中只讲了一下做法，没有讲原理，因为这个原理涉及到SpringMVC时怎么处理Request的复杂过程。这篇文章就来和大家扒一扒这件事，SpringMVC是怎么把一个request的请求最终映射到Controller的方法的。这是正向的，对于Spring来说，其实还负责把Controller的返回结果通过一些处理展现给用户，这是后话，这篇文章我们只说正向的请求，也就是从request到Controller的过程。\n\n首先，来一张SpringMVC处理请求的整个过程，图是来自《Spring实战》5.1.1章，我觉得总结的非常到位，几个大的过程都画出来了。\n\n![这里写图片描述](http://img.blog.csdn.net/20161229134539820?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemd6Y3p6dw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n我们这篇文章要说的其实就是1，2，3这三个阶段的实现原理。后面4，5，6，7可能会再开一篇文章来说，如果我的懒癌治好了的话。过程1是第二部分__请求到DispatcherServlet__，过程2和过程3可以总结为__DispatcherServlet处理请求__，也就是本文的第三部分。\n\n## 2. 请求到DispatcherServlet\n\n那我们按照顺序先来说一下过程1，熟悉SpringMVC的同学肯定都知道DispatcherServlet这个类，这个类是整个SpringMVC的入口。那在这个类之前做工作的其实是J2EE，不是我们重点关注的对象。只简单说一下：\n\n首先一个WEB程序的入口其实是web.xml，一个请求过来，J2EE会先来这个文件中寻找合适的servlet-mapping，找到了就交给对应的Servlet处理。SpringMVC也需要在这里配一个Servlet，并且声明处理一些请求，简单点来说，我们都会让SpringMVC处理所有的请求，所以请求映射的地方就会写‘/*’，比如下面这样。\n\n```xml\n<servlet>\n    <servlet-name>Spring web</servlet-name>\n    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n    <init-param>\n      <param-name>contextConfigLocation</param-name>\n      <param-value>classpath:spring/web-context.xml</param-value>\n    </init-param>\n    <load-on-startup>1</load-on-startup>\n  </servlet>\n\n  <servlet-mapping>\n    <servlet-name>Spring web</servlet-name>\n    <url-pattern>/*</url-pattern>\n  </servlet-mapping>\n```\n这样配置一下，所有的请求就都会交给DispatcherServlet来处理了，也就是交给SpringMVC来处理了。1的过程就这么简单，想看代码实现的话可以翻翻Tomcat的代码。好，那接下来我们这篇文章重点，过程2和过程3的实现原理，也就是DispatcherServlet的处理过程。\n\nDispatcherServlet作为一个标准的Servlet，生命周期也是有三个，初始化，处理请求和销毁，分别对应Servlet接口的三个方法，init(), service()和destroy()。\n\n```java\npublic interface Servlet {\n    void init(ServletConfig var1) throws ServletException;\n\n    ServletConfig getServletConfig();\n\n    void service(ServletRequest var1, ServletResponse var2) throws ServletException, IOException;\n\n    String getServletInfo();\n\n    void destroy();\n}\n\n```\n\n这里我们重点关注init和service的过程，destroy是service之后的过程了，可以暂时忽略不看。\n\n### 2.1 DispatcherServlet初始化\n\n这里先放一张DispatcherServlet的继承关系吧\n\n![这里写图片描述](http://img.blog.csdn.net/20161229133354781?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemd6Y3p6dw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n左边这条线就是Servlet的线，HttpServlet以及之上就是J2EE部分的代码，关注的是对请求的处理，比如doGet，doPost这些。下面HttpServletBean获取环境变量以方便子类使用。然后FrameworkServlet主要维护了自己的上下文对象webApplicationContext。我们知道一般的Servlet是不维护上下文对象的，而DispatcherServlet就是因为继承了FrameworkServlet，所以拥有了自己的上下文。简单来说大概就是这样，后面分析DispatcherServlet的工作过程的时候，还会追踪到它的这几个父类中来，到时候我们再细说。\n\n首先我们先从init方法来分析DispatcherServlet的的初始化过程，这是Servlet接口中init的方法签名。\n\n```\nvoid init(ServletConfig var1) throws ServletException;\n```\n这个带参的init方法出现在GenericServlet中\n\n```\n    public void init(ServletConfig config) throws ServletException {\n        this.config = config;\n        this.init();\n    }\n\n    public void init() throws ServletException {\n    }\n```\n\n接收了一个J2EE环境传过来的配置对象config，然后提供了一个无参的init方法供子类初始化。这个无参的init方法在HttpServletBean中。\n\n```\npublic final void init() throws ServletException {\n        if(this.logger.isDebugEnabled()) {\n            this.logger.debug(\"Initializing servlet \\'\" + this.getServletName() + \"\\'\");\n        }\n\n        try {\n            //获取配置文件，就是web.xml中contextConfigLocation的值\n            HttpServletBean.ServletConfigPropertyValues ex = new HttpServletBean.ServletConfigPropertyValues(this.getServletConfig(), this.requiredProperties);\n            //将Servlet包装成一个bean\n            BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(this);\n            //获取服务器信息\n            ServletContextResourceLoader resourceLoader = new ServletContextResourceLoader(this.getServletContext());\n            bw.registerCustomEditor(Resource.class, new ResourceEditor(resourceLoader, this.getEnvironment()));\n            //初始化Bean\n            this.initBeanWrapper(bw);\n            //设置配置文件到bean\n            bw.setPropertyValues(ex, true);\n            //其实以上部分没用到，因为在DispatcherServlet里initBeanWrapper没有被实现\n        } catch (BeansException var4) {\n            this.logger.error(\"Failed to set bean properties on servlet \\'\" + this.getServletName() + \"\\'\", var4);\n            throw var4;\n        }\n        //供子类初始化\n        this.initServletBean();\n        if(this.logger.isDebugEnabled()) {\n            this.logger.debug(\"Servlet \\'\" + this.getServletName() + \"\\' configured successfully\");\n        }\n\n    }\n```\n\nHttpServletBean中提供了两个供子类重写的初始化方法initBeanWrapper和initServletBean，其中initBeanWrapper没有使用，DispatcherServlet使用了initServletBean来初始化接下来的工作。\n\ninitServletBean在FrameworkServlet中。\n\n```\nprotected final void initServletBean() throws ServletException {\n        this.getServletContext().log(\"Initializing Spring FrameworkServlet \\'\" + this.getServletName() + \"\\'\");\n        if(this.logger.isInfoEnabled()) {\n            this.logger.info(\"FrameworkServlet \\'\" + this.getServletName() + \"\\': initialization started\");\n        }\n\n        long startTime = System.currentTimeMillis();\n\n        try {\n            //初始化上下文对象\n            this.webApplicationContext = this.initWebApplicationContext();\n            //提供给子类初始化\n            this.initFrameworkServlet();\n        } catch (ServletException var5) {\n            this.logger.error(\"Context initialization failed\", var5);\n            throw var5;\n        } catch (RuntimeException var6) {\n            this.logger.error(\"Context initialization failed\", var6);\n            throw var6;\n        }\n\n        if(this.logger.isInfoEnabled()) {\n            long elapsedTime = System.currentTimeMillis() - startTime;\n            this.logger.info(\"FrameworkServlet \\'\" + this.getServletName() + \"\\': initialization completed in \" + elapsedTime + \" ms\");\n        }\n\n    }\n```\ninitFrameworkServlet是提供给子类复写的初始化方法，但是DispatcherServlet也没有用，而是用了initWebApplicationContext中的refresh方法，任性啊。initWebApplicationContext是用来初始化上下文对象的，具体逻辑如下\n\n```\n    protected WebApplicationContext initWebApplicationContext() {\n        //前面检查ApplicationContext是否被初始化过，如果有就直接拿来用\n        WebApplicationContext rootContext = WebApplicationContextUtils.getWebApplicationContext(this.getServletContext());\n        WebApplicationContext wac = null;\n        if(this.webApplicationContext != null) {\n            wac = this.webApplicationContext;\n            if(wac instanceof ConfigurableWebApplicationContext) {\n                ConfigurableWebApplicationContext attrName = (ConfigurableWebApplicationContext)wac;\n                if(!attrName.isActive()) {\n                    if(attrName.getParent() == null) {\n                        attrName.setParent(rootContext);\n                    }\n\n                    this.configureAndRefreshWebApplicationContext(attrName);\n                }\n            }\n        }\n\n        if(wac == null) {\n            wac = this.findWebApplicationContext();\n        }\n\n        if(wac == null) {\n            wac = this.createWebApplicationContext(rootContext);\n        }\n        //Servlet自己的初始化方法\n        if(!this.refreshEventReceived) {\n            this.onRefresh(wac);\n        }\n\n        //将上下文对象保存起来\n        if(this.publishContext) {\n            String attrName1 = this.getServletContextAttributeName();\n            this.getServletContext().setAttribute(attrName1, wac);\n            if(this.logger.isDebugEnabled()) {\n                this.logger.debug(\"Published WebApplicationContext of servlet \\'\" + this.getServletName() + \"\\' as ServletContext attribute with name [\" + attrName1 + \"]\");\n            }\n        }\n\n        return wac;\n    }\n```\n\n这个方法前半部分是检查之前有没有创建过ApplicationContext对象，如果有，就直接拿过来用。如果没有，则初始化一个，onRefresh则是Servlet将自己的配置加到上下文对象中的方法，DispatcherServlet也是用了这个方法来初始化各种Bean。追了一堆，init方法终于到DispatcherServlet内部了。\n\n```\n    protected void onRefresh(ApplicationContext context) {\n        this.initStrategies(context);\n    }\n\n    protected void initStrategies(ApplicationContext context) {\n        this.initMultipartResolver(context);\n        this.initLocaleResolver(context);\n        this.initThemeResolver(context);\n        this.initHandlerMappings(context);\n        this.initHandlerAdapters(context);\n        this.initHandlerExceptionResolvers(context);\n        this.initRequestToViewNameTranslator(context);\n        this.initViewResolvers(context);\n        this.initFlashMapManager(context);\n    }\n```\n\n看，上面就是DispatcherServlet的一堆初始化方法。\n> 来自http://blog.csdn.net/snail_bi/article/details/50578371\n> \n> 1. MultipartResolver: \n> http://exceptioneye.iteye.com/blog/1314958\n> --> CommonsMultipartResolver 文件上传解析器\n> \n> 2. LocalResolver: 支持国际化,区域解析器。每DispatcherServlet只能注册一个区域解析器\n> http://blog.csdn.NET/rj042/article/details/23354225\n>    --> AcceptHeaderLocaleResolver 它通过检验HTTP请求的accept-language头部来解析区域。由用户的web浏览器根据底层操作系统的区域设置进行设定。\n>    --> SessionLocaleResolver 它通过检验用户会话中预置的属性来解析区域。如果该会话属性\n> 不存在，它会根据accept-language HTTP头部确定默认区域。\n> --> CookieLocaleResolver来解析区域。如果Cookie不存在，它会根据accept-language HTTP头部确定默认区域。 \n> --> FixedLocaleResolver 一直使用固定的Local, 不支持Local改变 。\n> 修改用户的区域\n> 除了显式调用LocaleResolver.setLocale()来修改用户的区域之外，还可以将LocaleChangeInterceptor拦截器应用到处理程序映射中，它会发现当前HTTP请求中出现的特殊参数。其中的参数名称可以通过拦截器的paramName属性进行自定义。如果这种参数出现在当前请求中，拦截器就会根据参数值来改变用户的区域。\n> \n> 3. ThemeSource 动态更换样式的支持(主题)\n> http://starscream.iteye.com/blog/1075855\n> --> FixedThemeResolver:固定格式的theme,不能在系统运行时动态更改theme.\n> --> SessionThemeResolver:theme name存放在session中key值为 org.springframework.web.servlet.theme.SessionThemeResolver.THEME 的session attribute中。可在运行中通过更改session中的相应的key值来动态调整theme的值。\n> --> CookieThemeResolver:theme name存放在cookie中key值为 org.springframework.web.servlet.theme.CookieThemeResolver.THEME 中。可在运行中通过更改cookie中的相应的key值来动态调整theme的值。\n> \n> 4. HandlerMapping\n> http://blog.csdn.Net/sunxing007/article/details/4584748\n> http://blog.csdn.net/prince2270/article/details/5894456\n> -->BeanNameUrlHandlerMapping: 查找spring容器中和请求的url同名的bean.\n> -->BeanNameUrlHandlerMapping ：通过对比url和bean的name找到对应的对象 \n> -->SimpleUrlHandlerMapping ：也是直接配置url和对应bean,比BeanNameUrlHandlerMapping功能更多 \n> -->DefaultAnnotationHandlerMapping : 主要是针对注解配置@RequestMapping的，已过时 \n> -->RequestMappingHandlerMapping ：取代了上面一个 \n>   --> 还有很多 ，请看源码\n> \n> 5. HandlerAdapter\n> --> SimpleControllerHandlerAdapter\n> --> SimpleServletHandlerAdapter\n> --> RequestMappingHandlerAdapter\n> --> HttpRequestHandlerAdapter\n> --> AnnotationMethodHandlerAdapter\n> \n> 6. HandlerExceptionResolver\n> \n> 7. RequestToViewNameTranslator  用于直接将请求转换为逻辑视图名。\n> http://sishuok.com/forum/blogPost/list/0/5514.html\n> http://haohaoxuexi.iteye.com/blog/1774603\n> --> DefaultRequestToViewNameTranslator\n> [\n> http://localhost:9080/web上下文/list -------> 逻辑视图名为list\n>   http://localhost:9080/web上下文/list.html -------> 逻辑视图名为list(默认删除扩展名)\n>   http://localhost:9080/web上下文/user/list.html -------> 逻辑视图名为user/list\n> ]\n> \n> 8. ViewResolver 视图解析器：定义了如何通过view 名称来解析对应View实例的行为\n> http://blog.csdn.net/prince2270/article/details/5891085\n> http://www.iteye.com/problems/76107 多视图问题的解决\n> http://my.oschina.net/HeliosFly/blog/221392\n> \n> 9. FlashMapManager  \n> http://www.oschina.net/translate/spring-mvc-flash-attribute-example\n> --> SessionFlashMapManager\n\n以上就是SpringMVC在初始化的时候加入的各种处理器，对于请求到Controller的映射，比较重要的是HandlerMapping和HandlerAdapter，HandlerMapping是用来查找处理请求的对象，HandlerAdapter是用来处理请求参数。这里以HandlerAdapter来举个例子，看一下initHandlerAdapters方法。\n\n```\n·private void initHandlerAdapters(ApplicationContext context) {\n        this.handlerAdapters = null;\n        if(this.detectAllHandlerAdapters) {\n            Map ex = BeanFactoryUtils.beansOfTypeIncludingAncestors(context, HandlerAdapter.class, true, false);\n            if(!ex.isEmpty()) {\n                this.handlerAdapters = new ArrayList(ex.values());\n                OrderComparator.sort(this.handlerAdapters);\n            }\n        } else {\n            try {\n                HandlerAdapter ex1 = (HandlerAdapter)context.getBean(\"handlerAdapter\", HandlerAdapter.class);\n                this.handlerAdapters = Collections.singletonList(ex1);\n            } catch (NoSuchBeanDefinitionException var3) {\n                ;\n            }\n        }\n\n        if(this.handlerAdapters == null) {\n            this.handlerAdapters = this.getDefaultStrategies(context, HandlerAdapter.class);\n            if(this.logger.isDebugEnabled()) {\n                this.logger.debug(\"No HandlerAdapters found in servlet \\'\" + this.getServletName() + \"\\': using default\");\n            }\n        }\n\n    }\n```\n\n上面的逻辑是这样的\n> 1)如果detectAllHandlerAdapters属性为true(默认为true)，根据类型匹配(HandlerAdapter)机制查找上下文及父Spring容器中所有匹配的Bean，将它们作为该类型组件；\n> 2)如果detectAllHandlerAdapters属性为false，查找名为handlerAdapter类型为HandlerAdapter的Bean作为该类型组件；\n> 3)如果通过以上方式都找不到，使用DispatcherServlet.properties配置文件中指定的三个实现类分别创建一个适配器，添加到适配器列表中。\n\nDispatcherServlet.properties和DispatcherServlet在同一个包下，定义了一些默认的类，内容如下。\n\n```\norg.springframework.web.servlet.LocaleResolver=org.springframework.web.servlet.i18n.AcceptHeaderLocaleResolver\n\norg.springframework.web.servlet.ThemeResolver=org.springframework.web.servlet.theme.FixedThemeResolver\n\norg.springframework.web.servlet.HandlerMapping=org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping,\\\n\torg.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping\n\norg.springframework.web.servlet.HandlerAdapter=org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter,\\\n\torg.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter,\\\n\torg.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter\n\norg.springframework.web.servlet.HandlerExceptionResolver=org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerExceptionResolver,\\\n\torg.springframework.web.servlet.mvc.annotation.ResponseStatusExceptionResolver,\\\n\torg.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver\n\norg.springframework.web.servlet.RequestToViewNameTranslator=org.springframework.web.servlet.view.DefaultRequestToViewNameTranslator\n\norg.springframework.web.servlet.ViewResolver=org.springframework.web.servlet.view.InternalResourceViewResolver\n\norg.springframework.web.servlet.FlashMapManager=org.springframework.web.servlet.support.SessionFlashMapManager\n```\n\n我们看到HandlerAdapter是有三个默认类，如果程序从上下文中找不到任何HandlerAdapter，就会把这三个加载进来。\n\nDispatcherServlet结束了onRefresh的一系列方法，初始化过程就结束了。接下来就是一个请求到来的时候的处理工作了。\n\n## 3. Dispatcher处理请求\n### 3.1 预处理请求\n\n请求到来的时候，J2EE会调用相应Servlet的onService方法，对于DispatcherServlet来说，这个onService在FrameworkServlet里，代码如下\n\n```\nprotected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String method = request.getMethod();\n        if(method.equalsIgnoreCase(RequestMethod.PATCH.name())) {\n            this.processRequest(request, response);\n        } else {\n            super.service(request, response);\n        }\n\n    }\n```\n这个方法补充了对PATCH请求类型的处理，其他请求类型如GET，PUT，调用了super的service方法，也就是在HttpServlet的service方法(HttpServletBean中没有复写)。\n\n```\nprotected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        String method = req.getMethod();\n        long errMsg;\n        if(method.equals(\"GET\")) {\n            errMsg = this.getLastModified(req);\n            if(errMsg == -1L) {\n                this.doGet(req, resp);\n            } else {\n                long ifModifiedSince = req.getDateHeader(\"If-Modified-Since\");\n                if(ifModifiedSince < errMsg / 1000L * 1000L) {\n                    this.maybeSetLastModified(resp, errMsg);\n                    this.doGet(req, resp);\n                } else {\n                    resp.setStatus(304);\n                }\n            }\n        } else if(method.equals(\"HEAD\")) {\n            errMsg = this.getLastModified(req);\n            this.maybeSetLastModified(resp, errMsg);\n            this.doHead(req, resp);\n        } else if(method.equals(\"POST\")) {\n            this.doPost(req, resp);\n        } else if(method.equals(\"PUT\")) {\n            this.doPut(req, resp);\n        } else if(method.equals(\"DELETE\")) {\n            this.doDelete(req, resp);\n        } else if(method.equals(\"OPTIONS\")) {\n            this.doOptions(req, resp);\n        } else if(method.equals(\"TRACE\")) {\n            this.doTrace(req, resp);\n        } else {\n            String errMsg1 = lStrings.getString(\"http.method_not_implemented\");\n            Object[] errArgs = new Object[]{method};\n            errMsg1 = MessageFormat.format(errMsg1, errArgs);\n            resp.sendError(501, errMsg1);\n        }\n\n    }\n```\n这个方法也很简单，根据不同的请求类型调用不同的方法，这里我们假设请求是个GET请求，那就会去执行子类的doGet方法，在FrameworkServlet里。\n\n```\nprotected final void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        this.processRequest(request, response);\n    }\n```\n也没做什么，交给了processRequest处理，其实其他请求最后也都转给processRequest这个方法处理了，因为处理参数的逻辑是一样的。\n\n```\n    protected final void processRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        long startTime = System.currentTimeMillis();\n        Object failureCause = null;\n        //获取之前的位置信息，最后finally时恢复之前配置\n        LocaleContext previousLocaleContext = LocaleContextHolder.getLocaleContext();\n        LocaleContext localeContext = this.buildLocaleContext(request);\n        RequestAttributes previousAttributes = RequestContextHolder.getRequestAttributes();\n        ServletRequestAttributes requestAttributes = this.buildRequestAttributes(request, response, previousAttributes);\n        //注册Interceptor，没理解干嘛的\n        WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);\n        asyncManager.registerCallableInterceptor(FrameworkServlet.class.getName(), new FrameworkServlet.RequestBindingInterceptor(null));\n        //将请求中的位置信息记入\n        this.initContextHolders(request, localeContext, requestAttributes);\n\n        try {\n            //做事情\n            this.doService(request, response);\n        } catch (ServletException var18) {\n            failureCause = var18;\n            throw var18;\n        } catch (IOException var19) {\n            failureCause = var19;\n            throw var19;\n        } catch (Throwable var20) {\n            failureCause = var20;\n            throw new NestedServletException(\"Request processing failed\", var20);\n        } finally {\n        //恢复之前配置\n            this.resetContextHolders(request, previousLocaleContext, previousAttributes);\n            if(requestAttributes != null) {\n                requestAttributes.requestCompleted();\n            }\n\n            if(this.logger.isDebugEnabled()) {\n                if(failureCause != null) {\n                    this.logger.debug(\"Could not complete request\", (Throwable)failureCause);\n                } else if(asyncManager.isConcurrentHandlingStarted()) {\n                    this.logger.debug(\"Leaving response open for concurrent processing\");\n                } else {\n                    this.logger.debug(\"Successfully completed request\");\n                }\n            }\n\n           //发布事件 this.publishRequestHandledEvent(request, startTime, (Throwable)failureCause);\n        }\n\n    }\n```\n先说下发布事件，Spring在请求处理结束后会发布一个ServletRequestHandledEvent类型的事件，可以通过ApplicationListener接收。\n\n这个方法前面和后面做的工作是保留现场，请求处理结束后恢复现场。真正处理请求的方法是doService。这个方法在DispatcherServlet中。\n\n话语权终于到DispatcherServlet中了。\n\n```\n    protected void doService(HttpServletRequest request, HttpServletResponse response) throws Exception {\n        if(this.logger.isDebugEnabled()) {\n            String attributesSnapshot = WebAsyncUtils.getAsyncManager(request).hasConcurrentResult()?\" resumed\":\"\";\n            this.logger.debug(\"DispatcherServlet with name \\'\" + this.getServletName() + \"\\'\" + attributesSnapshot + \" processing \" + request.getMethod() + \" request for [\" + getRequestUri(request) + \"]\");\n        }\n\n        HashMap attributesSnapshot1 = null;\n        //处理include类型的request，用不到\n        if(WebUtils.isIncludeRequest(request)) {\n            attributesSnapshot1 = new HashMap();\n            Enumeration inputFlashMap = request.getAttributeNames();\n\n            label113:\n            while(true) {\n                String attrName;\n                do {\n                    if(!inputFlashMap.hasMoreElements()) {\n                        break label113;\n                    }\n\n                    attrName = (String)inputFlashMap.nextElement();\n                } while(!this.cleanupAfterInclude && !attrName.startsWith(\"org.springframework.web.servlet\"));\n\n                attributesSnapshot1.put(attrName, request.getAttribute(attrName));\n            }\n        }\n        //将现在的各种参数加到Request中\n        request.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, this.getWebApplicationContext());\n        request.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, this.localeResolver);\n        request.setAttribute(THEME_RESOLVER_ATTRIBUTE, this.themeResolver);\n        request.setAttribute(THEME_SOURCE_ATTRIBUTE, this.getThemeSource());\n        FlashMap inputFlashMap1 = this.flashMapManager.retrieveAndUpdate(request, response);\n        if(inputFlashMap1 != null) {\n            request.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, Collections.unmodifiableMap(inputFlashMap1));\n        }\n\n        request.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, new FlashMap());\n        request.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, this.flashMapManager);\n\n        try {\n            //做事情\n            this.doDispatch(request, response);\n        } finally {\n            if(WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) {\n                return;\n            }\n\n            if(attributesSnapshot1 != null) {\n                this.restoreAttributesAfterInclude(request, attributesSnapshot1);\n            }\n\n        }\n\n    }\n```\n这个方法主要是把现在有的一些参数比如上下文对象加到Request中，然后转发到doDispatch方法去处理，终于到了最关键的方法了。\n\n```\n    protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {\n        HttpServletRequest processedRequest = request;\n        HandlerExecutionChain mappedHandler = null;\n        boolean multipartRequestParsed = false;\n        WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);\n\n        try {\n            try {\n                ModelAndView err = null;\n                Exception dispatchException = null;\n\n                try {\n                    processedRequest = this.checkMultipart(request);\n                    multipartRequestParsed = processedRequest != request;\n                    //获取Hanlder\n                    mappedHandler = this.getHandler(processedRequest, false);\n                    if(mappedHandler == null || mappedHandler.getHandler() == null) {\n                        this.noHandlerFound(processedRequest, response);\n                        return;\n                    }\n                    //获取Adapter\n                    HandlerAdapter ex = this.getHandlerAdapter(mappedHandler.getHandler());\n                    String method = request.getMethod();\n                    boolean isGet = \"GET\".equals(method);\n                    if(isGet || \"HEAD\".equals(method)) {\n                        long lastModified = ex.getLastModified(request, mappedHandler.getHandler());\n                        if(this.logger.isDebugEnabled()) {\n                            this.logger.debug(\"Last-Modified value for [\" + getRequestUri(request) + \"] is: \" + lastModified);\n                        }\n\n                        if((new ServletWebRequest(request, response)).checkNotModified(lastModified) && isGet) {\n                            return;\n                        }\n                    }\n                    //执行preHandle方法\n                    if(!mappedHandler.applyPreHandle(processedRequest, response)) {\n                        return;\n                    }\n\n                     //执行Handle方法                    \n                    try {\n                        err = ex.handle(processedRequest, response, mappedHandler.getHandler());\n                    } finally {\n                        if(asyncManager.isConcurrentHandlingStarted()) {\n                            return;\n                        }\n\n                    }\n                    //处理默认的ViewName\n                    this.applyDefaultViewName(request, err);\n                    //执行PostHandle\n                    mappedHandler.applyPostHandle(processedRequest, response, err);\n                } catch (Exception var27) {\n                    dispatchException = var27;\n                }\n                //处理返回结果，绘制View\n                this.processDispatchResult(processedRequest, response, mappedHandler, err, dispatchException);\n            } catch (Exception var28) {\n                this.triggerAfterCompletion(processedRequest, response, mappedHandler, var28);\n            } catch (Error var29) {\n                this.triggerAfterCompletionWithError(processedRequest, response, mappedHandler, var29);\n            }\n\n        } finally {\n            if(asyncManager.isConcurrentHandlingStarted()) {\n                mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);\n                return;\n            } else {\n                if(multipartRequestParsed) {\n                    this.cleanupMultipart(processedRequest);\n                }\n\n            }\n        }\n    }\n```\n虽然这个方法可以说是整个SpringMVC中最重要的方法，但是整个流程缺及其简单，可以说这一切都归功于Spring框架高度的抽象。我们来梳理一下这个doDispatch方法的流程。\n\n1. 获取Handler\n2. 获取Adapter\n3. 执行preHandle方法\n4. 执行Handle方法\n5. 执行PostHandle\n6. 处理返回结果\n\n5和6是Controller请求处理结束后的操作，本文中我们只讨论1-2-3-4这四个步骤。1-2-3-4这四个步骤对应了一开始提到的SpringMVC的七大步中的第二步请求到处理器映射和第三步请求到控制器。其中1-2是请求到处理器映射，3-4是请求到控制器。下面我们一步一步的来看。\n\n### 3.2 根据请求获取Handler\n\n首先第一步是根据request，获取合适的Handler。\n\n```\nmappedHandler = this.getHandler(processedRequest, false);\n```\n\n这里返回的结果是HandlerExecutionChain类型的，从名字我们知道这是一个执行链，里面包含了这个Handler所有相关的信息。下面我们来看下getHandler方法。\n\n```\nprotected HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception {\n        Iterator i$ = this.handlerMappings.iterator();\n\n        HandlerExecutionChain handler;\n        do {\n            if(!i$.hasNext()) {\n                return null;\n            }\n\n            HandlerMapping hm = (HandlerMapping)i$.next();\n            if(this.logger.isTraceEnabled()) {\n                this.logger.trace(\"Testing handler map [\" + hm + \"] in DispatcherServlet with name \\'\" + this.getServletName() + \"\\'\");\n            }\n\n            handler = hm.getHandler(request);\n        } while(handler == null);\n\n        return handler;\n    }\n```\n遍历HandlerMappings，然后依次调用每个HandlerMappings的getHandler方法，如果有返回就交给该Handler处理。\n\n这个HandlerMappings是DispatcherServlet初始化的时候加入的，在initHandlerMapping方法里。我们看下系统默认的HandlerMapping都有哪些。\n\n```\norg.springframework.web.servlet.HandlerMapping=org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping,\\\n\torg.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping\n```\n\n我的项目自定义了一个HandlerMappings，也是基于注解的\n\n```\n<!--配置注解式处理器映射器-->\n <bean class=\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping\"/>\n```\n\n我们来看一下他是怎么工作的。getHandler方法。这个方法在RequestMappingHandlerMapping的父类AbstractHandlerMapping中\n\n```\npublic final HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception {\n        Object handler = this.getHandlerInternal(request);\n        if(handler == null) {\n            handler = this.getDefaultHandler();\n        }\n\n        if(handler == null) {\n            return null;\n        } else {\n            if(handler instanceof String) {\n                String handlerName = (String)handler;\n                handler = this.getApplicationContext().getBean(handlerName);\n            }\n\n            return this.getHandlerExecutionChain(handler, request);\n        }\n    }\n```\n\nSpring框架一贯的套路，父类定义流程，开一个方法供子类去实现，比如这里的getHandlerInternal，返回了Handler之后，再用HandlerExecutionChain包装一下。那先来看下getHandlerInternal方法是怎么获取Handler的。这个方法依然在RequestMappingHandlerMapping的父类AbstractHandlerMethodMapping中。\n\n\n```\nprotected HandlerMethod getHandlerInternal(HttpServletRequest request) throws Exception {\n        String lookupPath = this.getUrlPathHelper().getLookupPathForRequest(request);\n        if(this.logger.isDebugEnabled()) {\n            this.logger.debug(\"Looking up handler method for path \" + lookupPath);\n        }\n\n        HandlerMethod handlerMethod = this.lookupHandlerMethod(lookupPath, request);\n        if(this.logger.isDebugEnabled()) {\n            if(handlerMethod != null) {\n                this.logger.debug(\"Returning handler method [\" + handlerMethod + \"]\");\n            } else {\n                this.logger.debug(\"Did not find handler method for [\" + lookupPath + \"]\");\n            }\n        }\n\n        return handlerMethod != null?handlerMethod.createWithResolvedBean():null;\n    }\n```\n\n两个重要的方法，getLookupPathForRequest和lookupHandlerMethod，这里我就不贴代码了，说一下实现原理吧，其实RequestMappingHandlerMapping在初始化的时候已经将系统中所有的@RequestMapping注解解析了，放在一个Map里面。实现过程如下。\n\nRequestMappingHandlerMapping的父类AbstractHandlerMethodMapping实现了InitializingBean接口，在Bean设置完参数后会调用afterPropertiesSet方法，而它在这个方法里面做了初始化的工作。\n\n```\n\tpublic void afterPropertiesSet() {\n        this.initHandlerMethods();\n    }\n\n    protected void initHandlerMethods() {\n        if(this.logger.isDebugEnabled()) {\n            this.logger.debug(\"Looking for request mappings in application context: \" + this.getApplicationContext());\n        }\n\n        String[] beanNames = this.detectHandlerMethodsInAncestorContexts?BeanFactoryUtils.beanNamesForTypeIncludingAncestors(this.getApplicationContext(), Object.class):this.getApplicationContext().getBeanNamesForType(Object.class);\n        String[] arr$ = beanNames;\n        int len$ = beanNames.length;\n\n        for(int i$ = 0; i$ < len$; ++i$) {\n            String beanName = arr$[i$];\n            //判断类中是否含有RequestMapping注释\n            if(this.isHandler(this.getApplicationContext().getType(beanName))) {\n                //解析方法\n                this.detectHandlerMethods(beanName);\n            }\n        }\n\n        this.handlerMethodsInitialized(this.getHandlerMethods());\n    }\n    \n  protected void detectHandlerMethods(Object handler) {\n        Class handlerType = handler instanceof String?this.getApplicationContext().getType((String)handler):handler.getClass();\n        final IdentityHashMap mappings = new IdentityHashMap();\n        final Class userType = ClassUtils.getUserClass(handlerType);\n        Set methods = HandlerMethodSelector.selectMethods(userType, new MethodFilter() {\n            public boolean matches(Method method) {\n                Object mapping = AbstractHandlerMethodMapping.this.getMappingForMethod(method, userType);\n                if(mapping != null) {\n                    mappings.put(method, mapping);\n                    return true;\n                } else {\n                    return false;\n                }\n            }\n        });\n        Iterator i$ = methods.iterator();\n\n        while(i$.hasNext()) {\n            Method method = (Method)i$.next();\n            //注册方法，加到urlMaps里面\n            this.registerHandlerMethod(handler, method, mappings.get(method));\n        }\n\n    }\n```\n\n这样RequestMappingHandlerMapping 里面就有了所有Controller方法的信息。getLookupPathForRequest就是获取请求的地址，比如我请求的是http://localhost:8090/test，那这里getLookupPathForRequest返回的就是/test。现在只要查询一下RequestMappingHandlerMapping里面有没有key为/test的的value即可，value中有处理的类的Controller对应的bean name，然后下面createWithResolvedBean包装一下返回一个HandlerMethod。返回的HandlerMethod再通过getHandlerExecutionChain包装成HandlerExecutionChain，HandlerExecutionChain里面有什么呢，我们来看一下getHandlerExecutionChain方法是怎么写的。\n\n```\n\tprotected HandlerExecutionChain getHandlerExecutionChain(Object handler, HttpServletRequest request) {\n        HandlerExecutionChain chain = handler instanceof HandlerExecutionChain?(HandlerExecutionChain)handler:new HandlerExecutionChain(handler);\n        chain.addInterceptors(this.getAdaptedInterceptors());\n        String lookupPath = this.urlPathHelper.getLookupPathForRequest(request);\n        Iterator i$ = this.mappedInterceptors.iterator();\n\n        while(i$.hasNext()) {\n            MappedInterceptor mappedInterceptor = (MappedInterceptor)i$.next();\n            if(mappedInterceptor.matches(lookupPath, this.pathMatcher)) {\n                chain.addInterceptor(mappedInterceptor.getInterceptor());\n            }\n        }\n\n        return chain;\n    }\n```\n\n其实就是把Interceptor加进去，你可以通过自定义Interceptor来对一个request的前后做相应的处理，下面是HandlerInterceptor接口的方法。\n\n```\npublic interface HandlerInterceptor {\n    boolean preHandle(HttpServletRequest var1, HttpServletResponse var2, Object var3) throws Exception;\n\n    void postHandle(HttpServletRequest var1, HttpServletResponse var2, Object var3, ModelAndView var4) throws Exception;\n\n    void afterCompletion(HttpServletRequest var1, HttpServletResponse var2, Object var3, Exception var4) throws Exception;\n}\n```\n\n这样就获取到了处理这个request对应的Controller，以及方法名了，控制权又交回到doDispatch方法中去了。\n\n### 3.3 根据处理器获取相应的处理器Adapter适配器\n\n接下来是第二步获取Adapter，这个Adapter的作用主要是把请求中的参数和Controller方法中的参数对应起来，所以就会做一些类型转换相应的工作，也就是下一步，这一部分也是我觉得request到Controller的映射过程中最复杂的一步，不过获取Adapter相对简单。\n\n首先看下getHandlerAdapter的代码\n\n```\n\tprotected HandlerAdapter getHandlerAdapter(Object handler) throws ServletException {\n        Iterator i$ = this.handlerAdapters.iterator();\n\n        HandlerAdapter ha;\n        do {\n            if(!i$.hasNext()) {\n                throw new ServletException(\"No adapter for handler [\" + handler + \"]: The DispatcherServlet configuration needs to include a HandlerAdapter that supports this handler\");\n            }\n\n            ha = (HandlerAdapter)i$.next();\n            if(this.logger.isTraceEnabled()) {\n                this.logger.trace(\"Testing handler adapter [\" + ha + \"]\");\n            }\n        } while(!ha.supports(handler));\n\n        return ha;\n    }\n```\n\n 从初始化的handlerAdapters中取出可以处理相应handler的，如果没有自定义，系统会预置几个，这个前面也说到了。这里我们看下supports方法吧，看下handlerAdapter是怎么判断它自己能否处理这个handler的。我目前项目用的是RequestMappingHandlerAdapter这里Adapter处理类。它的supports方法在他的父类AbstractHandlerMethodAdapter上。\n \n ```\n public final boolean supports(Object handler) {\n        return handler instanceof HandlerMethod && this.supportsInternal((HandlerMethod)handler);\n    }\n ```\n \n ```\n protected boolean supportsInternal(HandlerMethod handlerMethod) {\n        return true;\n    }\n ```\n RequestMappingHandlerAdapter的supportsInternal方法是永远返回true的，所以只要handler的类型是HandlerMethod，这个RequestMappingHandlerAdapter都会处理。这个RequestMappingHandlerAdapter其实是个比较通用的Adapter类。\n \n### 3.4 执行preHandle方法和Handle方法\n \n 获取到了Adapter，接下来就要做实际的事情了，执行preHandle方法很简单，就是调用一下，其实是为了用户定制。接下来真正处理事情的是adapter的handle方法。也就是我们上面提到的doDispatch的第四步。\n \n AbstractHandlerMethodAdapter的handle方法按照Spring的国际惯例肯定，自己做了点保存现场啥的工作，然后定义一个方法让子类去做实际的事情了。我瞅了一眼，我觉得我还是高估这个父类了，它啥都没做直接调用了子类的handleInternal方法。RequestMappingHandlerAdapter中handleInternal的实现是这样的。\n \n ```\n protected final ModelAndView handleInternal(HttpServletRequest request, HttpServletResponse response, HandlerMethod handlerMethod) throws Exception {\n        if(this.getSessionAttributesHandler(handlerMethod).hasSessionAttributes()) {\n            this.checkAndPrepare(request, response, this.cacheSecondsForSessionAttributeHandlers, true);\n        } else {\n            this.checkAndPrepare(request, response, true);\n        }\n\n        if(this.synchronizeOnSession) {\n            HttpSession session = request.getSession(false);\n            if(session != null) {\n                Object mutex = WebUtils.getSessionMutex(session);\n                synchronized(mutex) {\n                    return this.invokeHandleMethod(request, response, handlerMethod);\n                }\n            }\n        }\n\n        return this.invokeHandleMethod(request, response, handlerMethod);\n    }\n ```\n \n 又分了两部分，一个是checkAndPrepare，另一个是invokeHandleMethod，从名字也可以看出，一个事准备，一个事调用方法。按步骤一个一个来，先看看checkAndPrepare做了什么。\n \n ```\n protected final void checkAndPrepare(HttpServletRequest request, HttpServletResponse response, int cacheSeconds, boolean lastModified) throws ServletException {\n        String method = request.getMethod();\n        if(this.supportedMethods != null && !this.supportedMethods.contains(method)) {\n            throw new HttpRequestMethodNotSupportedException(method, StringUtils.toStringArray(this.supportedMethods));\n        } else if(this.requireSession && request.getSession(false) == null) {\n            throw new HttpSessionRequiredException(\"Pre-existing session required but none found\");\n        } else {\n            this.applyCacheSeconds(response, cacheSeconds, lastModified);\n        }\n    }\n ```\n 检查了是否支持请求方法，然后调用了applyCacheSeconds来处理缓存时间戳。也没什么重要的是不是，所以处理参数的其实下面这个方法invokeHandleMethod。\n \n \n ```\n private ModelAndView invokeHandleMethod(HttpServletRequest request, HttpServletResponse response, HandlerMethod handlerMethod) throws Exception {\n \t\t //初始化ServletWebRequest\n        ServletWebRequest webRequest = new ServletWebRequest(request, response);\n        //获取类型转换器\n        WebDataBinderFactory binderFactory = this.getDataBinderFactory(handlerMethod);\n        ModelFactory modelFactory = this.getModelFactory(handlerMethod, binderFactory);\n        //创建Method映射\n        ServletInvocableHandlerMethod requestMappingMethod = this.createRequestMappingMethod(handlerMethod, binderFactory);\n        //创建ModelandView包装器\n        ModelAndViewContainer mavContainer = new ModelAndViewContainer();\n        mavContainer.addAllAttributes(RequestContextUtils.getInputFlashMap(request));\n        modelFactory.initModel(webRequest, mavContainer, requestMappingMethod);\n        mavContainer.setIgnoreDefaultModelOnRedirect(this.ignoreDefaultModelOnRedirect);\n        //异步相关\n        AsyncWebRequest asyncWebRequest = WebAsyncUtils.createAsyncWebRequest(request, response);\n        asyncWebRequest.setTimeout(this.asyncRequestTimeout);\n        WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);\n        asyncManager.setTaskExecutor(this.taskExecutor);\n        asyncManager.setAsyncWebRequest(asyncWebRequest);\n        asyncManager.registerCallableInterceptors(this.callableInterceptors);\n        asyncManager.registerDeferredResultInterceptors(this.deferredResultInterceptors);\n        if(asyncManager.hasConcurrentResult()) {\n            Object result = asyncManager.getConcurrentResult();\n            mavContainer = (ModelAndViewContainer)asyncManager.getConcurrentResultContext()[0];\n            asyncManager.clearConcurrentResult();\n            if(this.logger.isDebugEnabled()) {\n                this.logger.debug(\"Found concurrent result value [\" + result + \"]\");\n            }\n\n            requestMappingMethod = requestMappingMethod.wrapConcurrentResult(result);\n        }\n\n        requestMappingMethod.invokeAndHandle(webRequest, mavContainer, new Object[0]);\n        return asyncManager.isConcurrentHandlingStarted()?null:this.getModelAndView(mavContainer, modelFactory, webRequest);\n    }\n ```\n 现在requestMappingMethod中有了方法信息，有了请求信息，就到了invokeAndHandle。invokeAndHandle中又调了invokeForRequest\n \n ```\n public final Object invokeForRequest(NativeWebRequest request, ModelAndViewContainer mavContainer, Object... providedArgs) throws Exception {\n        Object[] args = this.getMethodArgumentValues(request, mavContainer, providedArgs);\n        if(this.logger.isTraceEnabled()) {\n            StringBuilder returnValue = new StringBuilder(\"Invoking [\");\n            returnValue.append(this.getBeanType().getSimpleName()).append(\".\");\n            returnValue.append(this.getMethod().getName()).append(\"] method with arguments \");\n            returnValue.append(Arrays.asList(args));\n            this.logger.trace(returnValue.toString());\n        }\n\n        Object returnValue1 = this.invoke(args);\n        if(this.logger.isTraceEnabled()) {\n            this.logger.trace(\"Method [\" + this.getMethod().getName() + \"] returned [\" + returnValue1 + \"]\");\n        }\n\n        return returnValue1;\n    }\n\n ```\n invokeForRequest方法通过getMethodArgumentValues从request中获取到了方法的参数列表args，然后调用了invoke反射调用了方法。所以可以看出getMethodArgumentValues中做了request参数到方法参数的转换。继续到里面看。\n \n ```\n private Object[] getMethodArgumentValues(NativeWebRequest request, ModelAndViewContainer mavContainer, Object... providedArgs) throws Exception {\n \t\t //获取所有参数\n        MethodParameter[] parameters = this.getMethodParameters();\n        Object[] args = new Object[parameters.length];\n\n\t\t //每个参数进行处理，从request中找到参数值\n        for(int i = 0; i < parameters.length; ++i) {\n            MethodParameter parameter = parameters[i];\n            parameter.initParameterNameDiscovery(this.parameterNameDiscoverer);\n            //处理提供的数据类型转换，这里传值new Object，所以没用到\n            GenericTypeResolver.resolveParameterType(parameter, this.getBean().getClass());\n            args[i] = this.resolveProvidedArgument(parameter, providedArgs);\n            //如果前面提供的数据类型无法转换\n            if(args[i] == null) {\n                //判断自己的类型转换器能否支持该参数类型\n                if(this.argumentResolvers.supportsParameter(parameter)) {\n                    try {\n                    \t//转换参数\n                        args[i] = this.argumentResolvers.resolveArgument(parameter, mavContainer, request, this.dataBinderFactory);\n                    } catch (Exception var9) {\n                        if(this.logger.isTraceEnabled()) {\n                            this.logger.trace(this.getArgumentResolutionErrorMessage(\"Error resolving argument\", i), var9);\n                        }\n\n                        throw var9;\n                    }\n                } else if(args[i] == null) {\n                    String msg = this.getArgumentResolutionErrorMessage(\"No suitable resolver for argument\", i);\n                    throw new IllegalStateException(msg);\n                }\n            }\n        }\n\n        return args;\n    }\n ```\n \n逻辑在注释中写的差不多了，重点的地方是this.argumentResolvers.supportsParameter(parameter)用来判断自己的参数类型转换器是否支持这种参数类型，然后this.argumentResolvers.resolveArgument来处理参数类型转换。\n\n先来看下this.argumentResolvers.supportsParameter(parameter)，argumentResolvers是一个HandlerMethodArgumentResolverComposite类型的变量，HandlerMethodArgumentResolverComposite是一个Resolver的包装器。\n\n```\n\tpublic boolean supportsParameter(MethodParameter parameter) {\n        return this.getArgumentResolver(parameter) != null;\n    }\n    \n    private HandlerMethodArgumentResolver getArgumentResolver(MethodParameter parameter) {\n        HandlerMethodArgumentResolver result = (HandlerMethodArgumentResolver)this.argumentResolverCache.get(parameter);\n        if(result == null) {\n            Iterator i$ = this.argumentResolvers.iterator();\n\n            while(i$.hasNext()) {\n                HandlerMethodArgumentResolver methodArgumentResolver = (HandlerMethodArgumentResolver)i$.next();\n                if(this.logger.isTraceEnabled()) {\n                    this.logger.trace(\"Testing if argument resolver [\" + methodArgumentResolver + \"] supports [\" + parameter.getGenericParameterType() + \"]\");\n                }\n\n                if(methodArgumentResolver.supportsParameter(parameter)) {\n                    result = methodArgumentResolver;\n                    this.argumentResolverCache.put(parameter, methodArgumentResolver);\n                    break;\n                }\n            }\n        }\n\n        return result;\n    }\n```\n\nmethodArgumentResolver.supportsParameter(parameter)这一句调用了每个Resolver的support方法。关于Resolver是什么，可以看我的上一篇博客。\n\n[SpringMVC对象绑定时自定义名称对应关系](http://zwgeek.com/2016/12/28/SpringMVC%E5%AF%B9%E8%B1%A1%E7%BB%91%E5%AE%9A%E8%87%AA%E5%AE%9A%E4%B9%89%E5%90%8D%E7%A7%B0%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB/)\n\n其实简单来说就是一种类型处理器，我的项目在运行的时候回默认置入24个类型处理器，基本能处理各种类型转换，另外也可以自己自定义类型处理器。传送门里的文章有讲，包括类型处理器是怎么处理类型转换的，里面也有说。总之，类型处理器在argumentResolvers.resolveArgument处理完参数后，会把request的参数转成一个Object[]的列表返回，就是Controller中方法的参数列表。\n\n然后invokeForRequest方法会调用invoke去通过反射调用到Controller中对应的方法。\n\n## 4. 总结\n\n恩，到目前为止，一个request已经被SpringMVC处理后调到了Controller中对应的方法。然后Controller里面就是我们自己的逻辑了。接下来还有doDispatch的后几步，处理Controller的返回并处理成视图返回给用户。这个在以后的文章中慢慢说明。\n\n看Spring的源码，有一个很大的感受就是把抽象接口运用到了极致，几乎所有的处理器都会抽象出一个接口，然后下面会有各种各样的实现。这样处理之后整个流程几乎不涉及具体业务，只有流程规范，非常的容易理解。不得不说是一个让强迫症患者神清气爽的框架。\n\n另外还有一个感受就是，这套框架非常灵活。几乎所有的类都可以做的定制化，每一步处理过程都可以定制化，这样有利有弊，好处就是非常灵活，没有解决不了的问题，坏处就是可能一个地方没理解清楚就会出错。所有在定制化的时候还是要小心一点。\n\n接下来应该会有两篇文章，一篇是讲SpringMVC框架处理Controller的返回结果到视图，再一篇讲下Spring框架初始化Bean和BeanFactory的过程，其实也都在上面讲的流程里面，只是我略过去了。\n\n例行推广一下我的博客，喜欢这篇文章的朋友可以关注我的博客http://zwgeek.com\n\n","slug":"SpringMVC从request到controller过程详解","published":1,"updated":"2024-06-14T09:25:33.676Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clxjsxtw1000ilq6gwxv3djhs","content":"<p>例行推广一下我的博客，喜欢这篇文章的朋友可以关注我的博客<a href=\"http://zwgeek.com\">http://zwgeek.com</a></p>\n<h2 id=\"1-背景\"><a href=\"#1-背景\" class=\"headerlink\" title=\"1. 背景\"></a>1. 背景</h2><p>之前一篇文章 <a href=\"http://zwgeek.com/2016/12/28/SpringMVC%E5%AF%B9%E8%B1%A1%E7%BB%91%E5%AE%9A%E8%87%AA%E5%AE%9A%E4%B9%89%E5%90%8D%E7%A7%B0%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB/\">SpringMVC对象绑定时自定义名称对应关系</a> 讲了如何去把request中的请求参数指定到对象的某个属性上。但文中只讲了一下做法，没有讲原理，因为这个原理涉及到SpringMVC时怎么处理Request的复杂过程。这篇文章就来和大家扒一扒这件事，SpringMVC是怎么把一个request的请求最终映射到Controller的方法的。这是正向的，对于Spring来说，其实还负责把Controller的返回结果通过一些处理展现给用户，这是后话，这篇文章我们只说正向的请求，也就是从request到Controller的过程。</p>\n<p>首先，来一张SpringMVC处理请求的整个过程，图是来自《Spring实战》5.1.1章，我觉得总结的非常到位，几个大的过程都画出来了。</p>\n<p><img src=\"http://img.blog.csdn.net/20161229134539820?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemd6Y3p6dw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<p>我们这篇文章要说的其实就是1，2，3这三个阶段的实现原理。后面4，5，6，7可能会再开一篇文章来说，如果我的懒癌治好了的话。过程1是第二部分<strong>请求到DispatcherServlet</strong>，过程2和过程3可以总结为<strong>DispatcherServlet处理请求</strong>，也就是本文的第三部分。</p>\n<h2 id=\"2-请求到DispatcherServlet\"><a href=\"#2-请求到DispatcherServlet\" class=\"headerlink\" title=\"2. 请求到DispatcherServlet\"></a>2. 请求到DispatcherServlet</h2><p>那我们按照顺序先来说一下过程1，熟悉SpringMVC的同学肯定都知道DispatcherServlet这个类，这个类是整个SpringMVC的入口。那在这个类之前做工作的其实是J2EE，不是我们重点关注的对象。只简单说一下：</p>\n<p>首先一个WEB程序的入口其实是web.xml，一个请求过来，J2EE会先来这个文件中寻找合适的servlet-mapping，找到了就交给对应的Servlet处理。SpringMVC也需要在这里配一个Servlet，并且声明处理一些请求，简单点来说，我们都会让SpringMVC处理所有的请求，所以请求映射的地方就会写‘/*’，比如下面这样。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>Spring web<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-class</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">init-param</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>contextConfigLocation<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span>classpath:spring/web-context.xml<span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">init-param</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">load-on-startup</span>&gt;</span>1<span class=\"tag\">&lt;/<span class=\"name\">load-on-startup</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">servlet</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">servlet-mapping</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>Spring web<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>/*<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">servlet-mapping</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>这样配置一下，所有的请求就都会交给DispatcherServlet来处理了，也就是交给SpringMVC来处理了。1的过程就这么简单，想看代码实现的话可以翻翻Tomcat的代码。好，那接下来我们这篇文章重点，过程2和过程3的实现原理，也就是DispatcherServlet的处理过程。</p>\n<p>DispatcherServlet作为一个标准的Servlet，生命周期也是有三个，初始化，处理请求和销毁，分别对应Servlet接口的三个方法，init(), service()和destroy()。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Servlet</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">(ServletConfig var1)</span> <span class=\"keyword\">throws</span> ServletException</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\">ServletConfig <span class=\"title\">getServletConfig</span><span class=\"params\">()</span></span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">service</span><span class=\"params\">(ServletRequest var1, ServletResponse var2)</span> <span class=\"keyword\">throws</span> ServletException, IOException</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\">String <span class=\"title\">getServletInfo</span><span class=\"params\">()</span></span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">destroy</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里我们重点关注init和service的过程，destroy是service之后的过程了，可以暂时忽略不看。</p>\n<h3 id=\"2-1-DispatcherServlet初始化\"><a href=\"#2-1-DispatcherServlet初始化\" class=\"headerlink\" title=\"2.1 DispatcherServlet初始化\"></a>2.1 DispatcherServlet初始化</h3><p>这里先放一张DispatcherServlet的继承关系吧</p>\n<p><img src=\"http://img.blog.csdn.net/20161229133354781?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemd6Y3p6dw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<p>左边这条线就是Servlet的线，HttpServlet以及之上就是J2EE部分的代码，关注的是对请求的处理，比如doGet，doPost这些。下面HttpServletBean获取环境变量以方便子类使用。然后FrameworkServlet主要维护了自己的上下文对象webApplicationContext。我们知道一般的Servlet是不维护上下文对象的，而DispatcherServlet就是因为继承了FrameworkServlet，所以拥有了自己的上下文。简单来说大概就是这样，后面分析DispatcherServlet的工作过程的时候，还会追踪到它的这几个父类中来，到时候我们再细说。</p>\n<p>首先我们先从init方法来分析DispatcherServlet的的初始化过程，这是Servlet接口中init的方法签名。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">void init(ServletConfig var1) throws ServletException;</div></pre></td></tr></table></figure>\n<p>这个带参的init方法出现在GenericServlet中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void init(ServletConfig config) throws ServletException &#123;</div><div class=\"line\">    this.config = config;</div><div class=\"line\">    this.init();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">public void init() throws ServletException &#123;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>接收了一个J2EE环境传过来的配置对象config，然后提供了一个无参的init方法供子类初始化。这个无参的init方法在HttpServletBean中。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">public final void init() throws ServletException &#123;</div><div class=\"line\">        if(this.logger.isDebugEnabled()) &#123;</div><div class=\"line\">            this.logger.debug(&quot;Initializing servlet \\&apos;&quot; + this.getServletName() + &quot;\\&apos;&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        try &#123;</div><div class=\"line\">            //获取配置文件，就是web.xml中contextConfigLocation的值</div><div class=\"line\">            HttpServletBean.ServletConfigPropertyValues ex = new HttpServletBean.ServletConfigPropertyValues(this.getServletConfig(), this.requiredProperties);</div><div class=\"line\">            //将Servlet包装成一个bean</div><div class=\"line\">            BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(this);</div><div class=\"line\">            //获取服务器信息</div><div class=\"line\">            ServletContextResourceLoader resourceLoader = new ServletContextResourceLoader(this.getServletContext());</div><div class=\"line\">            bw.registerCustomEditor(Resource.class, new ResourceEditor(resourceLoader, this.getEnvironment()));</div><div class=\"line\">            //初始化Bean</div><div class=\"line\">            this.initBeanWrapper(bw);</div><div class=\"line\">            //设置配置文件到bean</div><div class=\"line\">            bw.setPropertyValues(ex, true);</div><div class=\"line\">            //其实以上部分没用到，因为在DispatcherServlet里initBeanWrapper没有被实现</div><div class=\"line\">        &#125; catch (BeansException var4) &#123;</div><div class=\"line\">            this.logger.error(&quot;Failed to set bean properties on servlet \\&apos;&quot; + this.getServletName() + &quot;\\&apos;&quot;, var4);</div><div class=\"line\">            throw var4;</div><div class=\"line\">        &#125;</div><div class=\"line\">        //供子类初始化</div><div class=\"line\">        this.initServletBean();</div><div class=\"line\">        if(this.logger.isDebugEnabled()) &#123;</div><div class=\"line\">            this.logger.debug(&quot;Servlet \\&apos;&quot; + this.getServletName() + &quot;\\&apos; configured successfully&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>HttpServletBean中提供了两个供子类重写的初始化方法initBeanWrapper和initServletBean，其中initBeanWrapper没有使用，DispatcherServlet使用了initServletBean来初始化接下来的工作。</p>\n<p>initServletBean在FrameworkServlet中。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected final void initServletBean() throws ServletException &#123;</div><div class=\"line\">        this.getServletContext().log(&quot;Initializing Spring FrameworkServlet \\&apos;&quot; + this.getServletName() + &quot;\\&apos;&quot;);</div><div class=\"line\">        if(this.logger.isInfoEnabled()) &#123;</div><div class=\"line\">            this.logger.info(&quot;FrameworkServlet \\&apos;&quot; + this.getServletName() + &quot;\\&apos;: initialization started&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        long startTime = System.currentTimeMillis();</div><div class=\"line\"></div><div class=\"line\">        try &#123;</div><div class=\"line\">            //初始化上下文对象</div><div class=\"line\">            this.webApplicationContext = this.initWebApplicationContext();</div><div class=\"line\">            //提供给子类初始化</div><div class=\"line\">            this.initFrameworkServlet();</div><div class=\"line\">        &#125; catch (ServletException var5) &#123;</div><div class=\"line\">            this.logger.error(&quot;Context initialization failed&quot;, var5);</div><div class=\"line\">            throw var5;</div><div class=\"line\">        &#125; catch (RuntimeException var6) &#123;</div><div class=\"line\">            this.logger.error(&quot;Context initialization failed&quot;, var6);</div><div class=\"line\">            throw var6;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        if(this.logger.isInfoEnabled()) &#123;</div><div class=\"line\">            long elapsedTime = System.currentTimeMillis() - startTime;</div><div class=\"line\">            this.logger.info(&quot;FrameworkServlet \\&apos;&quot; + this.getServletName() + &quot;\\&apos;: initialization completed in &quot; + elapsedTime + &quot; ms&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>initFrameworkServlet是提供给子类复写的初始化方法，但是DispatcherServlet也没有用，而是用了initWebApplicationContext中的refresh方法，任性啊。initWebApplicationContext是用来初始化上下文对象的，具体逻辑如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected WebApplicationContext initWebApplicationContext() &#123;</div><div class=\"line\">    //前面检查ApplicationContext是否被初始化过，如果有就直接拿来用</div><div class=\"line\">    WebApplicationContext rootContext = WebApplicationContextUtils.getWebApplicationContext(this.getServletContext());</div><div class=\"line\">    WebApplicationContext wac = null;</div><div class=\"line\">    if(this.webApplicationContext != null) &#123;</div><div class=\"line\">        wac = this.webApplicationContext;</div><div class=\"line\">        if(wac instanceof ConfigurableWebApplicationContext) &#123;</div><div class=\"line\">            ConfigurableWebApplicationContext attrName = (ConfigurableWebApplicationContext)wac;</div><div class=\"line\">            if(!attrName.isActive()) &#123;</div><div class=\"line\">                if(attrName.getParent() == null) &#123;</div><div class=\"line\">                    attrName.setParent(rootContext);</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                this.configureAndRefreshWebApplicationContext(attrName);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if(wac == null) &#123;</div><div class=\"line\">        wac = this.findWebApplicationContext();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if(wac == null) &#123;</div><div class=\"line\">        wac = this.createWebApplicationContext(rootContext);</div><div class=\"line\">    &#125;</div><div class=\"line\">    //Servlet自己的初始化方法</div><div class=\"line\">    if(!this.refreshEventReceived) &#123;</div><div class=\"line\">        this.onRefresh(wac);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    //将上下文对象保存起来</div><div class=\"line\">    if(this.publishContext) &#123;</div><div class=\"line\">        String attrName1 = this.getServletContextAttributeName();</div><div class=\"line\">        this.getServletContext().setAttribute(attrName1, wac);</div><div class=\"line\">        if(this.logger.isDebugEnabled()) &#123;</div><div class=\"line\">            this.logger.debug(&quot;Published WebApplicationContext of servlet \\&apos;&quot; + this.getServletName() + &quot;\\&apos; as ServletContext attribute with name [&quot; + attrName1 + &quot;]&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    return wac;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个方法前半部分是检查之前有没有创建过ApplicationContext对象，如果有，就直接拿过来用。如果没有，则初始化一个，onRefresh则是Servlet将自己的配置加到上下文对象中的方法，DispatcherServlet也是用了这个方法来初始化各种Bean。追了一堆，init方法终于到DispatcherServlet内部了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected void onRefresh(ApplicationContext context) &#123;</div><div class=\"line\">    this.initStrategies(context);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">protected void initStrategies(ApplicationContext context) &#123;</div><div class=\"line\">    this.initMultipartResolver(context);</div><div class=\"line\">    this.initLocaleResolver(context);</div><div class=\"line\">    this.initThemeResolver(context);</div><div class=\"line\">    this.initHandlerMappings(context);</div><div class=\"line\">    this.initHandlerAdapters(context);</div><div class=\"line\">    this.initHandlerExceptionResolvers(context);</div><div class=\"line\">    this.initRequestToViewNameTranslator(context);</div><div class=\"line\">    this.initViewResolvers(context);</div><div class=\"line\">    this.initFlashMapManager(context);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>看，上面就是DispatcherServlet的一堆初始化方法。</p>\n<blockquote>\n<p>来自<a href=\"http://blog.csdn.net/snail_bi/article/details/50578371\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/snail_bi/article/details/50578371</a></p>\n<ol>\n<li><p>MultipartResolver:<br><a href=\"http://exceptioneye.iteye.com/blog/1314958\" target=\"_blank\" rel=\"external\">http://exceptioneye.iteye.com/blog/1314958</a><br>–&gt; CommonsMultipartResolver 文件上传解析器</p>\n</li>\n<li><p>LocalResolver: 支持国际化,区域解析器。每DispatcherServlet只能注册一个区域解析器<br><a href=\"http://blog.csdn.NET/rj042/article/details/23354225\" target=\"_blank\" rel=\"external\">http://blog.csdn.NET/rj042/article/details/23354225</a><br>–&gt; AcceptHeaderLocaleResolver 它通过检验HTTP请求的accept-language头部来解析区域。由用户的web浏览器根据底层操作系统的区域设置进行设定。<br>–&gt; SessionLocaleResolver 它通过检验用户会话中预置的属性来解析区域。如果该会话属性<br>不存在，它会根据accept-language HTTP头部确定默认区域。<br>–&gt; CookieLocaleResolver来解析区域。如果Cookie不存在，它会根据accept-language HTTP头部确定默认区域。<br>–&gt; FixedLocaleResolver 一直使用固定的Local, 不支持Local改变 。<br>修改用户的区域<br>除了显式调用LocaleResolver.setLocale()来修改用户的区域之外，还可以将LocaleChangeInterceptor拦截器应用到处理程序映射中，它会发现当前HTTP请求中出现的特殊参数。其中的参数名称可以通过拦截器的paramName属性进行自定义。如果这种参数出现在当前请求中，拦截器就会根据参数值来改变用户的区域。</p>\n</li>\n<li><p>ThemeSource 动态更换样式的支持(主题)<br><a href=\"http://starscream.iteye.com/blog/1075855\" target=\"_blank\" rel=\"external\">http://starscream.iteye.com/blog/1075855</a><br>–&gt; FixedThemeResolver:固定格式的theme,不能在系统运行时动态更改theme.<br>–&gt; SessionThemeResolver:theme name存放在session中key值为 org.springframework.web.servlet.theme.SessionThemeResolver.THEME 的session attribute中。可在运行中通过更改session中的相应的key值来动态调整theme的值。<br>–&gt; CookieThemeResolver:theme name存放在cookie中key值为 org.springframework.web.servlet.theme.CookieThemeResolver.THEME 中。可在运行中通过更改cookie中的相应的key值来动态调整theme的值。</p>\n</li>\n<li><p>HandlerMapping<br><a href=\"http://blog.csdn.Net/sunxing007/article/details/4584748\" target=\"_blank\" rel=\"external\">http://blog.csdn.Net/sunxing007/article/details/4584748</a><br><a href=\"http://blog.csdn.net/prince2270/article/details/5894456\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/prince2270/article/details/5894456</a><br>–&gt;BeanNameUrlHandlerMapping: 查找spring容器中和请求的url同名的bean.<br>–&gt;BeanNameUrlHandlerMapping ：通过对比url和bean的name找到对应的对象<br>–&gt;SimpleUrlHandlerMapping ：也是直接配置url和对应bean,比BeanNameUrlHandlerMapping功能更多<br>–&gt;DefaultAnnotationHandlerMapping : 主要是针对注解配置@RequestMapping的，已过时<br>–&gt;RequestMappingHandlerMapping ：取代了上面一个<br>–&gt; 还有很多 ，请看源码</p>\n</li>\n<li><p>HandlerAdapter<br>–&gt; SimpleControllerHandlerAdapter<br>–&gt; SimpleServletHandlerAdapter<br>–&gt; RequestMappingHandlerAdapter<br>–&gt; HttpRequestHandlerAdapter<br>–&gt; AnnotationMethodHandlerAdapter</p>\n</li>\n<li><p>HandlerExceptionResolver</p>\n</li>\n<li><p>RequestToViewNameTranslator  用于直接将请求转换为逻辑视图名。<br><a href=\"http://sishuok.com/forum/blogPost/list/0/5514.html\" target=\"_blank\" rel=\"external\">http://sishuok.com/forum/blogPost/list/0/5514.html</a><br><a href=\"http://haohaoxuexi.iteye.com/blog/1774603\" target=\"_blank\" rel=\"external\">http://haohaoxuexi.iteye.com/blog/1774603</a><br>–&gt; DefaultRequestToViewNameTranslator<br>[<br><a href=\"http://localhost:9080/web上下文/list\" target=\"_blank\" rel=\"external\">http://localhost:9080/web上下文/list</a> ——-&gt; 逻辑视图名为list<br><a href=\"http://localhost:9080/web上下文/list.html\" target=\"_blank\" rel=\"external\">http://localhost:9080/web上下文/list.html</a> ——-&gt; 逻辑视图名为list(默认删除扩展名)<br><a href=\"http://localhost:9080/web上下文/user/list.html\" target=\"_blank\" rel=\"external\">http://localhost:9080/web上下文/user/list.html</a> ——-&gt; 逻辑视图名为user/list<br>]</p>\n</li>\n<li><p>ViewResolver 视图解析器：定义了如何通过view 名称来解析对应View实例的行为<br><a href=\"http://blog.csdn.net/prince2270/article/details/5891085\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/prince2270/article/details/5891085</a><br><a href=\"http://www.iteye.com/problems/76107\" target=\"_blank\" rel=\"external\">http://www.iteye.com/problems/76107</a> 多视图问题的解决<br><a href=\"http://my.oschina.net/HeliosFly/blog/221392\" target=\"_blank\" rel=\"external\">http://my.oschina.net/HeliosFly/blog/221392</a></p>\n</li>\n<li><p>FlashMapManager<br><a href=\"http://www.oschina.net/translate/spring-mvc-flash-attribute-example\" target=\"_blank\" rel=\"external\">http://www.oschina.net/translate/spring-mvc-flash-attribute-example</a><br>–&gt; SessionFlashMapManager</p>\n</li>\n</ol>\n</blockquote>\n<p>以上就是SpringMVC在初始化的时候加入的各种处理器，对于请求到Controller的映射，比较重要的是HandlerMapping和HandlerAdapter，HandlerMapping是用来查找处理请求的对象，HandlerAdapter是用来处理请求参数。这里以HandlerAdapter来举个例子，看一下initHandlerAdapters方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">·private void initHandlerAdapters(ApplicationContext context) &#123;</div><div class=\"line\">        this.handlerAdapters = null;</div><div class=\"line\">        if(this.detectAllHandlerAdapters) &#123;</div><div class=\"line\">            Map ex = BeanFactoryUtils.beansOfTypeIncludingAncestors(context, HandlerAdapter.class, true, false);</div><div class=\"line\">            if(!ex.isEmpty()) &#123;</div><div class=\"line\">                this.handlerAdapters = new ArrayList(ex.values());</div><div class=\"line\">                OrderComparator.sort(this.handlerAdapters);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            try &#123;</div><div class=\"line\">                HandlerAdapter ex1 = (HandlerAdapter)context.getBean(&quot;handlerAdapter&quot;, HandlerAdapter.class);</div><div class=\"line\">                this.handlerAdapters = Collections.singletonList(ex1);</div><div class=\"line\">            &#125; catch (NoSuchBeanDefinitionException var3) &#123;</div><div class=\"line\">                ;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        if(this.handlerAdapters == null) &#123;</div><div class=\"line\">            this.handlerAdapters = this.getDefaultStrategies(context, HandlerAdapter.class);</div><div class=\"line\">            if(this.logger.isDebugEnabled()) &#123;</div><div class=\"line\">                this.logger.debug(&quot;No HandlerAdapters found in servlet \\&apos;&quot; + this.getServletName() + &quot;\\&apos;: using default&quot;);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>上面的逻辑是这样的</p>\n<blockquote>\n<p>1)如果detectAllHandlerAdapters属性为true(默认为true)，根据类型匹配(HandlerAdapter)机制查找上下文及父Spring容器中所有匹配的Bean，将它们作为该类型组件；<br>2)如果detectAllHandlerAdapters属性为false，查找名为handlerAdapter类型为HandlerAdapter的Bean作为该类型组件；<br>3)如果通过以上方式都找不到，使用DispatcherServlet.properties配置文件中指定的三个实现类分别创建一个适配器，添加到适配器列表中。</p>\n</blockquote>\n<p>DispatcherServlet.properties和DispatcherServlet在同一个包下，定义了一些默认的类，内容如下。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">org.springframework.web.servlet.LocaleResolver=org.springframework.web.servlet.i18n.AcceptHeaderLocaleResolver</div><div class=\"line\"></div><div class=\"line\">org.springframework.web.servlet.ThemeResolver=org.springframework.web.servlet.theme.FixedThemeResolver</div><div class=\"line\"></div><div class=\"line\">org.springframework.web.servlet.HandlerMapping=org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping,\\</div><div class=\"line\">\torg.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping</div><div class=\"line\"></div><div class=\"line\">org.springframework.web.servlet.HandlerAdapter=org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter,\\</div><div class=\"line\">\torg.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter,\\</div><div class=\"line\">\torg.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter</div><div class=\"line\"></div><div class=\"line\">org.springframework.web.servlet.HandlerExceptionResolver=org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerExceptionResolver,\\</div><div class=\"line\">\torg.springframework.web.servlet.mvc.annotation.ResponseStatusExceptionResolver,\\</div><div class=\"line\">\torg.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver</div><div class=\"line\"></div><div class=\"line\">org.springframework.web.servlet.RequestToViewNameTranslator=org.springframework.web.servlet.view.DefaultRequestToViewNameTranslator</div><div class=\"line\"></div><div class=\"line\">org.springframework.web.servlet.ViewResolver=org.springframework.web.servlet.view.InternalResourceViewResolver</div><div class=\"line\"></div><div class=\"line\">org.springframework.web.servlet.FlashMapManager=org.springframework.web.servlet.support.SessionFlashMapManager</div></pre></td></tr></table></figure>\n<p>我们看到HandlerAdapter是有三个默认类，如果程序从上下文中找不到任何HandlerAdapter，就会把这三个加载进来。</p>\n<p>DispatcherServlet结束了onRefresh的一系列方法，初始化过程就结束了。接下来就是一个请求到来的时候的处理工作了。</p>\n<h2 id=\"3-Dispatcher处理请求\"><a href=\"#3-Dispatcher处理请求\" class=\"headerlink\" title=\"3. Dispatcher处理请求\"></a>3. Dispatcher处理请求</h2><h3 id=\"3-1-预处理请求\"><a href=\"#3-1-预处理请求\" class=\"headerlink\" title=\"3.1 预处理请求\"></a>3.1 预处理请求</h3><p>请求到来的时候，J2EE会调用相应Servlet的onService方法，对于DispatcherServlet来说，这个onService在FrameworkServlet里，代码如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</div><div class=\"line\">        String method = request.getMethod();</div><div class=\"line\">        if(method.equalsIgnoreCase(RequestMethod.PATCH.name())) &#123;</div><div class=\"line\">            this.processRequest(request, response);</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            super.service(request, response);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>这个方法补充了对PATCH请求类型的处理，其他请求类型如GET，PUT，调用了super的service方法，也就是在HttpServlet的service方法(HttpServletBean中没有复写)。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</div><div class=\"line\">        String method = req.getMethod();</div><div class=\"line\">        long errMsg;</div><div class=\"line\">        if(method.equals(&quot;GET&quot;)) &#123;</div><div class=\"line\">            errMsg = this.getLastModified(req);</div><div class=\"line\">            if(errMsg == -1L) &#123;</div><div class=\"line\">                this.doGet(req, resp);</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                long ifModifiedSince = req.getDateHeader(&quot;If-Modified-Since&quot;);</div><div class=\"line\">                if(ifModifiedSince &lt; errMsg / 1000L * 1000L) &#123;</div><div class=\"line\">                    this.maybeSetLastModified(resp, errMsg);</div><div class=\"line\">                    this.doGet(req, resp);</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    resp.setStatus(304);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; else if(method.equals(&quot;HEAD&quot;)) &#123;</div><div class=\"line\">            errMsg = this.getLastModified(req);</div><div class=\"line\">            this.maybeSetLastModified(resp, errMsg);</div><div class=\"line\">            this.doHead(req, resp);</div><div class=\"line\">        &#125; else if(method.equals(&quot;POST&quot;)) &#123;</div><div class=\"line\">            this.doPost(req, resp);</div><div class=\"line\">        &#125; else if(method.equals(&quot;PUT&quot;)) &#123;</div><div class=\"line\">            this.doPut(req, resp);</div><div class=\"line\">        &#125; else if(method.equals(&quot;DELETE&quot;)) &#123;</div><div class=\"line\">            this.doDelete(req, resp);</div><div class=\"line\">        &#125; else if(method.equals(&quot;OPTIONS&quot;)) &#123;</div><div class=\"line\">            this.doOptions(req, resp);</div><div class=\"line\">        &#125; else if(method.equals(&quot;TRACE&quot;)) &#123;</div><div class=\"line\">            this.doTrace(req, resp);</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            String errMsg1 = lStrings.getString(&quot;http.method_not_implemented&quot;);</div><div class=\"line\">            Object[] errArgs = new Object[]&#123;method&#125;;</div><div class=\"line\">            errMsg1 = MessageFormat.format(errMsg1, errArgs);</div><div class=\"line\">            resp.sendError(501, errMsg1);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>这个方法也很简单，根据不同的请求类型调用不同的方法，这里我们假设请求是个GET请求，那就会去执行子类的doGet方法，在FrameworkServlet里。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected final void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</div><div class=\"line\">        this.processRequest(request, response);</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>也没做什么，交给了processRequest处理，其实其他请求最后也都转给processRequest这个方法处理了，因为处理参数的逻辑是一样的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected final void processRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</div><div class=\"line\">    long startTime = System.currentTimeMillis();</div><div class=\"line\">    Object failureCause = null;</div><div class=\"line\">    //获取之前的位置信息，最后finally时恢复之前配置</div><div class=\"line\">    LocaleContext previousLocaleContext = LocaleContextHolder.getLocaleContext();</div><div class=\"line\">    LocaleContext localeContext = this.buildLocaleContext(request);</div><div class=\"line\">    RequestAttributes previousAttributes = RequestContextHolder.getRequestAttributes();</div><div class=\"line\">    ServletRequestAttributes requestAttributes = this.buildRequestAttributes(request, response, previousAttributes);</div><div class=\"line\">    //注册Interceptor，没理解干嘛的</div><div class=\"line\">    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</div><div class=\"line\">    asyncManager.registerCallableInterceptor(FrameworkServlet.class.getName(), new FrameworkServlet.RequestBindingInterceptor(null));</div><div class=\"line\">    //将请求中的位置信息记入</div><div class=\"line\">    this.initContextHolders(request, localeContext, requestAttributes);</div><div class=\"line\"></div><div class=\"line\">    try &#123;</div><div class=\"line\">        //做事情</div><div class=\"line\">        this.doService(request, response);</div><div class=\"line\">    &#125; catch (ServletException var18) &#123;</div><div class=\"line\">        failureCause = var18;</div><div class=\"line\">        throw var18;</div><div class=\"line\">    &#125; catch (IOException var19) &#123;</div><div class=\"line\">        failureCause = var19;</div><div class=\"line\">        throw var19;</div><div class=\"line\">    &#125; catch (Throwable var20) &#123;</div><div class=\"line\">        failureCause = var20;</div><div class=\"line\">        throw new NestedServletException(&quot;Request processing failed&quot;, var20);</div><div class=\"line\">    &#125; finally &#123;</div><div class=\"line\">    //恢复之前配置</div><div class=\"line\">        this.resetContextHolders(request, previousLocaleContext, previousAttributes);</div><div class=\"line\">        if(requestAttributes != null) &#123;</div><div class=\"line\">            requestAttributes.requestCompleted();</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        if(this.logger.isDebugEnabled()) &#123;</div><div class=\"line\">            if(failureCause != null) &#123;</div><div class=\"line\">                this.logger.debug(&quot;Could not complete request&quot;, (Throwable)failureCause);</div><div class=\"line\">            &#125; else if(asyncManager.isConcurrentHandlingStarted()) &#123;</div><div class=\"line\">                this.logger.debug(&quot;Leaving response open for concurrent processing&quot;);</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                this.logger.debug(&quot;Successfully completed request&quot;);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">       //发布事件 this.publishRequestHandledEvent(request, startTime, (Throwable)failureCause);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>先说下发布事件，Spring在请求处理结束后会发布一个ServletRequestHandledEvent类型的事件，可以通过ApplicationListener接收。</p>\n<p>这个方法前面和后面做的工作是保留现场，请求处理结束后恢复现场。真正处理请求的方法是doService。这个方法在DispatcherServlet中。</p>\n<p>话语权终于到DispatcherServlet中了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected void doService(HttpServletRequest request, HttpServletResponse response) throws Exception &#123;</div><div class=\"line\">    if(this.logger.isDebugEnabled()) &#123;</div><div class=\"line\">        String attributesSnapshot = WebAsyncUtils.getAsyncManager(request).hasConcurrentResult()?&quot; resumed&quot;:&quot;&quot;;</div><div class=\"line\">        this.logger.debug(&quot;DispatcherServlet with name \\&apos;&quot; + this.getServletName() + &quot;\\&apos;&quot; + attributesSnapshot + &quot; processing &quot; + request.getMethod() + &quot; request for [&quot; + getRequestUri(request) + &quot;]&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    HashMap attributesSnapshot1 = null;</div><div class=\"line\">    //处理include类型的request，用不到</div><div class=\"line\">    if(WebUtils.isIncludeRequest(request)) &#123;</div><div class=\"line\">        attributesSnapshot1 = new HashMap();</div><div class=\"line\">        Enumeration inputFlashMap = request.getAttributeNames();</div><div class=\"line\"></div><div class=\"line\">        label113:</div><div class=\"line\">        while(true) &#123;</div><div class=\"line\">            String attrName;</div><div class=\"line\">            do &#123;</div><div class=\"line\">                if(!inputFlashMap.hasMoreElements()) &#123;</div><div class=\"line\">                    break label113;</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                attrName = (String)inputFlashMap.nextElement();</div><div class=\"line\">            &#125; while(!this.cleanupAfterInclude &amp;&amp; !attrName.startsWith(&quot;org.springframework.web.servlet&quot;));</div><div class=\"line\"></div><div class=\"line\">            attributesSnapshot1.put(attrName, request.getAttribute(attrName));</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    //将现在的各种参数加到Request中</div><div class=\"line\">    request.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, this.getWebApplicationContext());</div><div class=\"line\">    request.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, this.localeResolver);</div><div class=\"line\">    request.setAttribute(THEME_RESOLVER_ATTRIBUTE, this.themeResolver);</div><div class=\"line\">    request.setAttribute(THEME_SOURCE_ATTRIBUTE, this.getThemeSource());</div><div class=\"line\">    FlashMap inputFlashMap1 = this.flashMapManager.retrieveAndUpdate(request, response);</div><div class=\"line\">    if(inputFlashMap1 != null) &#123;</div><div class=\"line\">        request.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, Collections.unmodifiableMap(inputFlashMap1));</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    request.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, new FlashMap());</div><div class=\"line\">    request.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, this.flashMapManager);</div><div class=\"line\"></div><div class=\"line\">    try &#123;</div><div class=\"line\">        //做事情</div><div class=\"line\">        this.doDispatch(request, response);</div><div class=\"line\">    &#125; finally &#123;</div><div class=\"line\">        if(WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123;</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        if(attributesSnapshot1 != null) &#123;</div><div class=\"line\">            this.restoreAttributesAfterInclude(request, attributesSnapshot1);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个方法主要是把现在有的一些参数比如上下文对象加到Request中，然后转发到doDispatch方法去处理，终于到了最关键的方法了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception &#123;</div><div class=\"line\">    HttpServletRequest processedRequest = request;</div><div class=\"line\">    HandlerExecutionChain mappedHandler = null;</div><div class=\"line\">    boolean multipartRequestParsed = false;</div><div class=\"line\">    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</div><div class=\"line\"></div><div class=\"line\">    try &#123;</div><div class=\"line\">        try &#123;</div><div class=\"line\">            ModelAndView err = null;</div><div class=\"line\">            Exception dispatchException = null;</div><div class=\"line\"></div><div class=\"line\">            try &#123;</div><div class=\"line\">                processedRequest = this.checkMultipart(request);</div><div class=\"line\">                multipartRequestParsed = processedRequest != request;</div><div class=\"line\">                //获取Hanlder</div><div class=\"line\">                mappedHandler = this.getHandler(processedRequest, false);</div><div class=\"line\">                if(mappedHandler == null || mappedHandler.getHandler() == null) &#123;</div><div class=\"line\">                    this.noHandlerFound(processedRequest, response);</div><div class=\"line\">                    return;</div><div class=\"line\">                &#125;</div><div class=\"line\">                //获取Adapter</div><div class=\"line\">                HandlerAdapter ex = this.getHandlerAdapter(mappedHandler.getHandler());</div><div class=\"line\">                String method = request.getMethod();</div><div class=\"line\">                boolean isGet = &quot;GET&quot;.equals(method);</div><div class=\"line\">                if(isGet || &quot;HEAD&quot;.equals(method)) &#123;</div><div class=\"line\">                    long lastModified = ex.getLastModified(request, mappedHandler.getHandler());</div><div class=\"line\">                    if(this.logger.isDebugEnabled()) &#123;</div><div class=\"line\">                        this.logger.debug(&quot;Last-Modified value for [&quot; + getRequestUri(request) + &quot;] is: &quot; + lastModified);</div><div class=\"line\">                    &#125;</div><div class=\"line\"></div><div class=\"line\">                    if((new ServletWebRequest(request, response)).checkNotModified(lastModified) &amp;&amp; isGet) &#123;</div><div class=\"line\">                        return;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">                //执行preHandle方法</div><div class=\"line\">                if(!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</div><div class=\"line\">                    return;</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                 //执行Handle方法                    </div><div class=\"line\">                try &#123;</div><div class=\"line\">                    err = ex.handle(processedRequest, response, mappedHandler.getHandler());</div><div class=\"line\">                &#125; finally &#123;</div><div class=\"line\">                    if(asyncManager.isConcurrentHandlingStarted()) &#123;</div><div class=\"line\">                        return;</div><div class=\"line\">                    &#125;</div><div class=\"line\"></div><div class=\"line\">                &#125;</div><div class=\"line\">                //处理默认的ViewName</div><div class=\"line\">                this.applyDefaultViewName(request, err);</div><div class=\"line\">                //执行PostHandle</div><div class=\"line\">                mappedHandler.applyPostHandle(processedRequest, response, err);</div><div class=\"line\">            &#125; catch (Exception var27) &#123;</div><div class=\"line\">                dispatchException = var27;</div><div class=\"line\">            &#125;</div><div class=\"line\">            //处理返回结果，绘制View</div><div class=\"line\">            this.processDispatchResult(processedRequest, response, mappedHandler, err, dispatchException);</div><div class=\"line\">        &#125; catch (Exception var28) &#123;</div><div class=\"line\">            this.triggerAfterCompletion(processedRequest, response, mappedHandler, var28);</div><div class=\"line\">        &#125; catch (Error var29) &#123;</div><div class=\"line\">            this.triggerAfterCompletionWithError(processedRequest, response, mappedHandler, var29);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">    &#125; finally &#123;</div><div class=\"line\">        if(asyncManager.isConcurrentHandlingStarted()) &#123;</div><div class=\"line\">            mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);</div><div class=\"line\">            return;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            if(multipartRequestParsed) &#123;</div><div class=\"line\">                this.cleanupMultipart(processedRequest);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>虽然这个方法可以说是整个SpringMVC中最重要的方法，但是整个流程缺及其简单，可以说这一切都归功于Spring框架高度的抽象。我们来梳理一下这个doDispatch方法的流程。</p>\n<ol>\n<li>获取Handler</li>\n<li>获取Adapter</li>\n<li>执行preHandle方法</li>\n<li>执行Handle方法</li>\n<li>执行PostHandle</li>\n<li>处理返回结果</li>\n</ol>\n<p>5和6是Controller请求处理结束后的操作，本文中我们只讨论1-2-3-4这四个步骤。1-2-3-4这四个步骤对应了一开始提到的SpringMVC的七大步中的第二步请求到处理器映射和第三步请求到控制器。其中1-2是请求到处理器映射，3-4是请求到控制器。下面我们一步一步的来看。</p>\n<h3 id=\"3-2-根据请求获取Handler\"><a href=\"#3-2-根据请求获取Handler\" class=\"headerlink\" title=\"3.2 根据请求获取Handler\"></a>3.2 根据请求获取Handler</h3><p>首先第一步是根据request，获取合适的Handler。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">mappedHandler = this.getHandler(processedRequest, false);</div></pre></td></tr></table></figure>\n<p>这里返回的结果是HandlerExecutionChain类型的，从名字我们知道这是一个执行链，里面包含了这个Handler所有相关的信息。下面我们来看下getHandler方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception &#123;</div><div class=\"line\">        Iterator i$ = this.handlerMappings.iterator();</div><div class=\"line\"></div><div class=\"line\">        HandlerExecutionChain handler;</div><div class=\"line\">        do &#123;</div><div class=\"line\">            if(!i$.hasNext()) &#123;</div><div class=\"line\">                return null;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            HandlerMapping hm = (HandlerMapping)i$.next();</div><div class=\"line\">            if(this.logger.isTraceEnabled()) &#123;</div><div class=\"line\">                this.logger.trace(&quot;Testing handler map [&quot; + hm + &quot;] in DispatcherServlet with name \\&apos;&quot; + this.getServletName() + &quot;\\&apos;&quot;);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            handler = hm.getHandler(request);</div><div class=\"line\">        &#125; while(handler == null);</div><div class=\"line\"></div><div class=\"line\">        return handler;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>遍历HandlerMappings，然后依次调用每个HandlerMappings的getHandler方法，如果有返回就交给该Handler处理。</p>\n<p>这个HandlerMappings是DispatcherServlet初始化的时候加入的，在initHandlerMapping方法里。我们看下系统默认的HandlerMapping都有哪些。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">org.springframework.web.servlet.HandlerMapping=org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping,\\</div><div class=\"line\">\torg.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping</div></pre></td></tr></table></figure>\n<p>我的项目自定义了一个HandlerMappings，也是基于注解的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;!--配置注解式处理器映射器--&gt;</div><div class=\"line\"> &lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping&quot;/&gt;</div></pre></td></tr></table></figure>\n<p>我们来看一下他是怎么工作的。getHandler方法。这个方法在RequestMappingHandlerMapping的父类AbstractHandlerMapping中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">public final HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception &#123;</div><div class=\"line\">        Object handler = this.getHandlerInternal(request);</div><div class=\"line\">        if(handler == null) &#123;</div><div class=\"line\">            handler = this.getDefaultHandler();</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        if(handler == null) &#123;</div><div class=\"line\">            return null;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            if(handler instanceof String) &#123;</div><div class=\"line\">                String handlerName = (String)handler;</div><div class=\"line\">                handler = this.getApplicationContext().getBean(handlerName);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            return this.getHandlerExecutionChain(handler, request);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>Spring框架一贯的套路，父类定义流程，开一个方法供子类去实现，比如这里的getHandlerInternal，返回了Handler之后，再用HandlerExecutionChain包装一下。那先来看下getHandlerInternal方法是怎么获取Handler的。这个方法依然在RequestMappingHandlerMapping的父类AbstractHandlerMethodMapping中。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected HandlerMethod getHandlerInternal(HttpServletRequest request) throws Exception &#123;</div><div class=\"line\">        String lookupPath = this.getUrlPathHelper().getLookupPathForRequest(request);</div><div class=\"line\">        if(this.logger.isDebugEnabled()) &#123;</div><div class=\"line\">            this.logger.debug(&quot;Looking up handler method for path &quot; + lookupPath);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        HandlerMethod handlerMethod = this.lookupHandlerMethod(lookupPath, request);</div><div class=\"line\">        if(this.logger.isDebugEnabled()) &#123;</div><div class=\"line\">            if(handlerMethod != null) &#123;</div><div class=\"line\">                this.logger.debug(&quot;Returning handler method [&quot; + handlerMethod + &quot;]&quot;);</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                this.logger.debug(&quot;Did not find handler method for [&quot; + lookupPath + &quot;]&quot;);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        return handlerMethod != null?handlerMethod.createWithResolvedBean():null;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>两个重要的方法，getLookupPathForRequest和lookupHandlerMethod，这里我就不贴代码了，说一下实现原理吧，其实RequestMappingHandlerMapping在初始化的时候已经将系统中所有的@RequestMapping注解解析了，放在一个Map里面。实现过程如下。</p>\n<p>RequestMappingHandlerMapping的父类AbstractHandlerMethodMapping实现了InitializingBean接口，在Bean设置完参数后会调用afterPropertiesSet方法，而它在这个方法里面做了初始化的工作。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void afterPropertiesSet() &#123;</div><div class=\"line\">       this.initHandlerMethods();</div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\">   protected void initHandlerMethods() &#123;</div><div class=\"line\">       if(this.logger.isDebugEnabled()) &#123;</div><div class=\"line\">           this.logger.debug(&quot;Looking for request mappings in application context: &quot; + this.getApplicationContext());</div><div class=\"line\">       &#125;</div><div class=\"line\"></div><div class=\"line\">       String[] beanNames = this.detectHandlerMethodsInAncestorContexts?BeanFactoryUtils.beanNamesForTypeIncludingAncestors(this.getApplicationContext(), Object.class):this.getApplicationContext().getBeanNamesForType(Object.class);</div><div class=\"line\">       String[] arr$ = beanNames;</div><div class=\"line\">       int len$ = beanNames.length;</div><div class=\"line\"></div><div class=\"line\">       for(int i$ = 0; i$ &lt; len$; ++i$) &#123;</div><div class=\"line\">           String beanName = arr$[i$];</div><div class=\"line\">           //判断类中是否含有RequestMapping注释</div><div class=\"line\">           if(this.isHandler(this.getApplicationContext().getType(beanName))) &#123;</div><div class=\"line\">               //解析方法</div><div class=\"line\">               this.detectHandlerMethods(beanName);</div><div class=\"line\">           &#125;</div><div class=\"line\">       &#125;</div><div class=\"line\"></div><div class=\"line\">       this.handlerMethodsInitialized(this.getHandlerMethods());</div><div class=\"line\">   &#125;</div><div class=\"line\">   </div><div class=\"line\"> protected void detectHandlerMethods(Object handler) &#123;</div><div class=\"line\">       Class handlerType = handler instanceof String?this.getApplicationContext().getType((String)handler):handler.getClass();</div><div class=\"line\">       final IdentityHashMap mappings = new IdentityHashMap();</div><div class=\"line\">       final Class userType = ClassUtils.getUserClass(handlerType);</div><div class=\"line\">       Set methods = HandlerMethodSelector.selectMethods(userType, new MethodFilter() &#123;</div><div class=\"line\">           public boolean matches(Method method) &#123;</div><div class=\"line\">               Object mapping = AbstractHandlerMethodMapping.this.getMappingForMethod(method, userType);</div><div class=\"line\">               if(mapping != null) &#123;</div><div class=\"line\">                   mappings.put(method, mapping);</div><div class=\"line\">                   return true;</div><div class=\"line\">               &#125; else &#123;</div><div class=\"line\">                   return false;</div><div class=\"line\">               &#125;</div><div class=\"line\">           &#125;</div><div class=\"line\">       &#125;);</div><div class=\"line\">       Iterator i$ = methods.iterator();</div><div class=\"line\"></div><div class=\"line\">       while(i$.hasNext()) &#123;</div><div class=\"line\">           Method method = (Method)i$.next();</div><div class=\"line\">           //注册方法，加到urlMaps里面</div><div class=\"line\">           this.registerHandlerMethod(handler, method, mappings.get(method));</div><div class=\"line\">       &#125;</div><div class=\"line\"></div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<p>这样RequestMappingHandlerMapping 里面就有了所有Controller方法的信息。getLookupPathForRequest就是获取请求的地址，比如我请求的是<a href=\"http://localhost:8090/test，那这里getLookupPathForRequest返回的就是/test。现在只要查询一下RequestMappingHandlerMapping里面有没有key为/test的的value即可，value中有处理的类的Controller对应的bean\" target=\"_blank\" rel=\"external\">http://localhost:8090/test，那这里getLookupPathForRequest返回的就是/test。现在只要查询一下RequestMappingHandlerMapping里面有没有key为/test的的value即可，value中有处理的类的Controller对应的bean</a> name，然后下面createWithResolvedBean包装一下返回一个HandlerMethod。返回的HandlerMethod再通过getHandlerExecutionChain包装成HandlerExecutionChain，HandlerExecutionChain里面有什么呢，我们来看一下getHandlerExecutionChain方法是怎么写的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected HandlerExecutionChain getHandlerExecutionChain(Object handler, HttpServletRequest request) &#123;</div><div class=\"line\">       HandlerExecutionChain chain = handler instanceof HandlerExecutionChain?(HandlerExecutionChain)handler:new HandlerExecutionChain(handler);</div><div class=\"line\">       chain.addInterceptors(this.getAdaptedInterceptors());</div><div class=\"line\">       String lookupPath = this.urlPathHelper.getLookupPathForRequest(request);</div><div class=\"line\">       Iterator i$ = this.mappedInterceptors.iterator();</div><div class=\"line\"></div><div class=\"line\">       while(i$.hasNext()) &#123;</div><div class=\"line\">           MappedInterceptor mappedInterceptor = (MappedInterceptor)i$.next();</div><div class=\"line\">           if(mappedInterceptor.matches(lookupPath, this.pathMatcher)) &#123;</div><div class=\"line\">               chain.addInterceptor(mappedInterceptor.getInterceptor());</div><div class=\"line\">           &#125;</div><div class=\"line\">       &#125;</div><div class=\"line\"></div><div class=\"line\">       return chain;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<p>其实就是把Interceptor加进去，你可以通过自定义Interceptor来对一个request的前后做相应的处理，下面是HandlerInterceptor接口的方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">public interface HandlerInterceptor &#123;</div><div class=\"line\">    boolean preHandle(HttpServletRequest var1, HttpServletResponse var2, Object var3) throws Exception;</div><div class=\"line\"></div><div class=\"line\">    void postHandle(HttpServletRequest var1, HttpServletResponse var2, Object var3, ModelAndView var4) throws Exception;</div><div class=\"line\"></div><div class=\"line\">    void afterCompletion(HttpServletRequest var1, HttpServletResponse var2, Object var3, Exception var4) throws Exception;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这样就获取到了处理这个request对应的Controller，以及方法名了，控制权又交回到doDispatch方法中去了。</p>\n<h3 id=\"3-3-根据处理器获取相应的处理器Adapter适配器\"><a href=\"#3-3-根据处理器获取相应的处理器Adapter适配器\" class=\"headerlink\" title=\"3.3 根据处理器获取相应的处理器Adapter适配器\"></a>3.3 根据处理器获取相应的处理器Adapter适配器</h3><p>接下来是第二步获取Adapter，这个Adapter的作用主要是把请求中的参数和Controller方法中的参数对应起来，所以就会做一些类型转换相应的工作，也就是下一步，这一部分也是我觉得request到Controller的映射过程中最复杂的一步，不过获取Adapter相对简单。</p>\n<p>首先看下getHandlerAdapter的代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected HandlerAdapter getHandlerAdapter(Object handler) throws ServletException &#123;</div><div class=\"line\">       Iterator i$ = this.handlerAdapters.iterator();</div><div class=\"line\"></div><div class=\"line\">       HandlerAdapter ha;</div><div class=\"line\">       do &#123;</div><div class=\"line\">           if(!i$.hasNext()) &#123;</div><div class=\"line\">               throw new ServletException(&quot;No adapter for handler [&quot; + handler + &quot;]: The DispatcherServlet configuration needs to include a HandlerAdapter that supports this handler&quot;);</div><div class=\"line\">           &#125;</div><div class=\"line\"></div><div class=\"line\">           ha = (HandlerAdapter)i$.next();</div><div class=\"line\">           if(this.logger.isTraceEnabled()) &#123;</div><div class=\"line\">               this.logger.trace(&quot;Testing handler adapter [&quot; + ha + &quot;]&quot;);</div><div class=\"line\">           &#125;</div><div class=\"line\">       &#125; while(!ha.supports(handler));</div><div class=\"line\"></div><div class=\"line\">       return ha;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<p> 从初始化的handlerAdapters中取出可以处理相应handler的，如果没有自定义，系统会预置几个，这个前面也说到了。这里我们看下supports方法吧，看下handlerAdapter是怎么判断它自己能否处理这个handler的。我目前项目用的是RequestMappingHandlerAdapter这里Adapter处理类。它的supports方法在他的父类AbstractHandlerMethodAdapter上。</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">public final boolean supports(Object handler) &#123;</div><div class=\"line\">       return handler instanceof HandlerMethod &amp;&amp; this.supportsInternal((HandlerMethod)handler);</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected boolean supportsInternal(HandlerMethod handlerMethod) &#123;</div><div class=\"line\">       return true;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<p> RequestMappingHandlerAdapter的supportsInternal方法是永远返回true的，所以只要handler的类型是HandlerMethod，这个RequestMappingHandlerAdapter都会处理。这个RequestMappingHandlerAdapter其实是个比较通用的Adapter类。</p>\n<h3 id=\"3-4-执行preHandle方法和Handle方法\"><a href=\"#3-4-执行preHandle方法和Handle方法\" class=\"headerlink\" title=\"3.4 执行preHandle方法和Handle方法\"></a>3.4 执行preHandle方法和Handle方法</h3><p> 获取到了Adapter，接下来就要做实际的事情了，执行preHandle方法很简单，就是调用一下，其实是为了用户定制。接下来真正处理事情的是adapter的handle方法。也就是我们上面提到的doDispatch的第四步。</p>\n<p> AbstractHandlerMethodAdapter的handle方法按照Spring的国际惯例肯定，自己做了点保存现场啥的工作，然后定义一个方法让子类去做实际的事情了。我瞅了一眼，我觉得我还是高估这个父类了，它啥都没做直接调用了子类的handleInternal方法。RequestMappingHandlerAdapter中handleInternal的实现是这样的。</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected final ModelAndView handleInternal(HttpServletRequest request, HttpServletResponse response, HandlerMethod handlerMethod) throws Exception &#123;</div><div class=\"line\">       if(this.getSessionAttributesHandler(handlerMethod).hasSessionAttributes()) &#123;</div><div class=\"line\">           this.checkAndPrepare(request, response, this.cacheSecondsForSessionAttributeHandlers, true);</div><div class=\"line\">       &#125; else &#123;</div><div class=\"line\">           this.checkAndPrepare(request, response, true);</div><div class=\"line\">       &#125;</div><div class=\"line\"></div><div class=\"line\">       if(this.synchronizeOnSession) &#123;</div><div class=\"line\">           HttpSession session = request.getSession(false);</div><div class=\"line\">           if(session != null) &#123;</div><div class=\"line\">               Object mutex = WebUtils.getSessionMutex(session);</div><div class=\"line\">               synchronized(mutex) &#123;</div><div class=\"line\">                   return this.invokeHandleMethod(request, response, handlerMethod);</div><div class=\"line\">               &#125;</div><div class=\"line\">           &#125;</div><div class=\"line\">       &#125;</div><div class=\"line\"></div><div class=\"line\">       return this.invokeHandleMethod(request, response, handlerMethod);</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<p> 又分了两部分，一个是checkAndPrepare，另一个是invokeHandleMethod，从名字也可以看出，一个事准备，一个事调用方法。按步骤一个一个来，先看看checkAndPrepare做了什么。</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected final void checkAndPrepare(HttpServletRequest request, HttpServletResponse response, int cacheSeconds, boolean lastModified) throws ServletException &#123;</div><div class=\"line\">       String method = request.getMethod();</div><div class=\"line\">       if(this.supportedMethods != null &amp;&amp; !this.supportedMethods.contains(method)) &#123;</div><div class=\"line\">           throw new HttpRequestMethodNotSupportedException(method, StringUtils.toStringArray(this.supportedMethods));</div><div class=\"line\">       &#125; else if(this.requireSession &amp;&amp; request.getSession(false) == null) &#123;</div><div class=\"line\">           throw new HttpSessionRequiredException(&quot;Pre-existing session required but none found&quot;);</div><div class=\"line\">       &#125; else &#123;</div><div class=\"line\">           this.applyCacheSeconds(response, cacheSeconds, lastModified);</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<p> 检查了是否支持请求方法，然后调用了applyCacheSeconds来处理缓存时间戳。也没什么重要的是不是，所以处理参数的其实下面这个方法invokeHandleMethod。</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\">private ModelAndView invokeHandleMethod(HttpServletRequest request, HttpServletResponse response, HandlerMethod handlerMethod) throws Exception &#123;</div><div class=\"line\">\t\t //初始化ServletWebRequest</div><div class=\"line\">       ServletWebRequest webRequest = new ServletWebRequest(request, response);</div><div class=\"line\">       //获取类型转换器</div><div class=\"line\">       WebDataBinderFactory binderFactory = this.getDataBinderFactory(handlerMethod);</div><div class=\"line\">       ModelFactory modelFactory = this.getModelFactory(handlerMethod, binderFactory);</div><div class=\"line\">       //创建Method映射</div><div class=\"line\">       ServletInvocableHandlerMethod requestMappingMethod = this.createRequestMappingMethod(handlerMethod, binderFactory);</div><div class=\"line\">       //创建ModelandView包装器</div><div class=\"line\">       ModelAndViewContainer mavContainer = new ModelAndViewContainer();</div><div class=\"line\">       mavContainer.addAllAttributes(RequestContextUtils.getInputFlashMap(request));</div><div class=\"line\">       modelFactory.initModel(webRequest, mavContainer, requestMappingMethod);</div><div class=\"line\">       mavContainer.setIgnoreDefaultModelOnRedirect(this.ignoreDefaultModelOnRedirect);</div><div class=\"line\">       //异步相关</div><div class=\"line\">       AsyncWebRequest asyncWebRequest = WebAsyncUtils.createAsyncWebRequest(request, response);</div><div class=\"line\">       asyncWebRequest.setTimeout(this.asyncRequestTimeout);</div><div class=\"line\">       WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</div><div class=\"line\">       asyncManager.setTaskExecutor(this.taskExecutor);</div><div class=\"line\">       asyncManager.setAsyncWebRequest(asyncWebRequest);</div><div class=\"line\">       asyncManager.registerCallableInterceptors(this.callableInterceptors);</div><div class=\"line\">       asyncManager.registerDeferredResultInterceptors(this.deferredResultInterceptors);</div><div class=\"line\">       if(asyncManager.hasConcurrentResult()) &#123;</div><div class=\"line\">           Object result = asyncManager.getConcurrentResult();</div><div class=\"line\">           mavContainer = (ModelAndViewContainer)asyncManager.getConcurrentResultContext()[0];</div><div class=\"line\">           asyncManager.clearConcurrentResult();</div><div class=\"line\">           if(this.logger.isDebugEnabled()) &#123;</div><div class=\"line\">               this.logger.debug(&quot;Found concurrent result value [&quot; + result + &quot;]&quot;);</div><div class=\"line\">           &#125;</div><div class=\"line\"></div><div class=\"line\">           requestMappingMethod = requestMappingMethod.wrapConcurrentResult(result);</div><div class=\"line\">       &#125;</div><div class=\"line\"></div><div class=\"line\">       requestMappingMethod.invokeAndHandle(webRequest, mavContainer, new Object[0]);</div><div class=\"line\">       return asyncManager.isConcurrentHandlingStarted()?null:this.getModelAndView(mavContainer, modelFactory, webRequest);</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<p> 现在requestMappingMethod中有了方法信息，有了请求信息，就到了invokeAndHandle。invokeAndHandle中又调了invokeForRequest</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">public final Object invokeForRequest(NativeWebRequest request, ModelAndViewContainer mavContainer, Object... providedArgs) throws Exception &#123;</div><div class=\"line\">       Object[] args = this.getMethodArgumentValues(request, mavContainer, providedArgs);</div><div class=\"line\">       if(this.logger.isTraceEnabled()) &#123;</div><div class=\"line\">           StringBuilder returnValue = new StringBuilder(&quot;Invoking [&quot;);</div><div class=\"line\">           returnValue.append(this.getBeanType().getSimpleName()).append(&quot;.&quot;);</div><div class=\"line\">           returnValue.append(this.getMethod().getName()).append(&quot;] method with arguments &quot;);</div><div class=\"line\">           returnValue.append(Arrays.asList(args));</div><div class=\"line\">           this.logger.trace(returnValue.toString());</div><div class=\"line\">       &#125;</div><div class=\"line\"></div><div class=\"line\">       Object returnValue1 = this.invoke(args);</div><div class=\"line\">       if(this.logger.isTraceEnabled()) &#123;</div><div class=\"line\">           this.logger.trace(&quot;Method [&quot; + this.getMethod().getName() + &quot;] returned [&quot; + returnValue1 + &quot;]&quot;);</div><div class=\"line\">       &#125;</div><div class=\"line\"></div><div class=\"line\">       return returnValue1;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<p> invokeForRequest方法通过getMethodArgumentValues从request中获取到了方法的参数列表args，然后调用了invoke反射调用了方法。所以可以看出getMethodArgumentValues中做了request参数到方法参数的转换。继续到里面看。</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\">private Object[] getMethodArgumentValues(NativeWebRequest request, ModelAndViewContainer mavContainer, Object... providedArgs) throws Exception &#123;</div><div class=\"line\">\t\t //获取所有参数</div><div class=\"line\">       MethodParameter[] parameters = this.getMethodParameters();</div><div class=\"line\">       Object[] args = new Object[parameters.length];</div><div class=\"line\"></div><div class=\"line\">\t //每个参数进行处理，从request中找到参数值</div><div class=\"line\">       for(int i = 0; i &lt; parameters.length; ++i) &#123;</div><div class=\"line\">           MethodParameter parameter = parameters[i];</div><div class=\"line\">           parameter.initParameterNameDiscovery(this.parameterNameDiscoverer);</div><div class=\"line\">           //处理提供的数据类型转换，这里传值new Object，所以没用到</div><div class=\"line\">           GenericTypeResolver.resolveParameterType(parameter, this.getBean().getClass());</div><div class=\"line\">           args[i] = this.resolveProvidedArgument(parameter, providedArgs);</div><div class=\"line\">           //如果前面提供的数据类型无法转换</div><div class=\"line\">           if(args[i] == null) &#123;</div><div class=\"line\">               //判断自己的类型转换器能否支持该参数类型</div><div class=\"line\">               if(this.argumentResolvers.supportsParameter(parameter)) &#123;</div><div class=\"line\">                   try &#123;</div><div class=\"line\">                   \t//转换参数</div><div class=\"line\">                       args[i] = this.argumentResolvers.resolveArgument(parameter, mavContainer, request, this.dataBinderFactory);</div><div class=\"line\">                   &#125; catch (Exception var9) &#123;</div><div class=\"line\">                       if(this.logger.isTraceEnabled()) &#123;</div><div class=\"line\">                           this.logger.trace(this.getArgumentResolutionErrorMessage(&quot;Error resolving argument&quot;, i), var9);</div><div class=\"line\">                       &#125;</div><div class=\"line\"></div><div class=\"line\">                       throw var9;</div><div class=\"line\">                   &#125;</div><div class=\"line\">               &#125; else if(args[i] == null) &#123;</div><div class=\"line\">                   String msg = this.getArgumentResolutionErrorMessage(&quot;No suitable resolver for argument&quot;, i);</div><div class=\"line\">                   throw new IllegalStateException(msg);</div><div class=\"line\">               &#125;</div><div class=\"line\">           &#125;</div><div class=\"line\">       &#125;</div><div class=\"line\"></div><div class=\"line\">       return args;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<p>逻辑在注释中写的差不多了，重点的地方是this.argumentResolvers.supportsParameter(parameter)用来判断自己的参数类型转换器是否支持这种参数类型，然后this.argumentResolvers.resolveArgument来处理参数类型转换。</p>\n<p>先来看下this.argumentResolvers.supportsParameter(parameter)，argumentResolvers是一个HandlerMethodArgumentResolverComposite类型的变量，HandlerMethodArgumentResolverComposite是一个Resolver的包装器。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">public boolean supportsParameter(MethodParameter parameter) &#123;</div><div class=\"line\">       return this.getArgumentResolver(parameter) != null;</div><div class=\"line\">   &#125;</div><div class=\"line\">   </div><div class=\"line\">   private HandlerMethodArgumentResolver getArgumentResolver(MethodParameter parameter) &#123;</div><div class=\"line\">       HandlerMethodArgumentResolver result = (HandlerMethodArgumentResolver)this.argumentResolverCache.get(parameter);</div><div class=\"line\">       if(result == null) &#123;</div><div class=\"line\">           Iterator i$ = this.argumentResolvers.iterator();</div><div class=\"line\"></div><div class=\"line\">           while(i$.hasNext()) &#123;</div><div class=\"line\">               HandlerMethodArgumentResolver methodArgumentResolver = (HandlerMethodArgumentResolver)i$.next();</div><div class=\"line\">               if(this.logger.isTraceEnabled()) &#123;</div><div class=\"line\">                   this.logger.trace(&quot;Testing if argument resolver [&quot; + methodArgumentResolver + &quot;] supports [&quot; + parameter.getGenericParameterType() + &quot;]&quot;);</div><div class=\"line\">               &#125;</div><div class=\"line\"></div><div class=\"line\">               if(methodArgumentResolver.supportsParameter(parameter)) &#123;</div><div class=\"line\">                   result = methodArgumentResolver;</div><div class=\"line\">                   this.argumentResolverCache.put(parameter, methodArgumentResolver);</div><div class=\"line\">                   break;</div><div class=\"line\">               &#125;</div><div class=\"line\">           &#125;</div><div class=\"line\">       &#125;</div><div class=\"line\"></div><div class=\"line\">       return result;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<p>methodArgumentResolver.supportsParameter(parameter)这一句调用了每个Resolver的support方法。关于Resolver是什么，可以看我的上一篇博客。</p>\n<p><a href=\"http://zwgeek.com/2016/12/28/SpringMVC%E5%AF%B9%E8%B1%A1%E7%BB%91%E5%AE%9A%E8%87%AA%E5%AE%9A%E4%B9%89%E5%90%8D%E7%A7%B0%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB/\">SpringMVC对象绑定时自定义名称对应关系</a></p>\n<p>其实简单来说就是一种类型处理器，我的项目在运行的时候回默认置入24个类型处理器，基本能处理各种类型转换，另外也可以自己自定义类型处理器。传送门里的文章有讲，包括类型处理器是怎么处理类型转换的，里面也有说。总之，类型处理器在argumentResolvers.resolveArgument处理完参数后，会把request的参数转成一个Object[]的列表返回，就是Controller中方法的参数列表。</p>\n<p>然后invokeForRequest方法会调用invoke去通过反射调用到Controller中对应的方法。</p>\n<h2 id=\"4-总结\"><a href=\"#4-总结\" class=\"headerlink\" title=\"4. 总结\"></a>4. 总结</h2><p>恩，到目前为止，一个request已经被SpringMVC处理后调到了Controller中对应的方法。然后Controller里面就是我们自己的逻辑了。接下来还有doDispatch的后几步，处理Controller的返回并处理成视图返回给用户。这个在以后的文章中慢慢说明。</p>\n<p>看Spring的源码，有一个很大的感受就是把抽象接口运用到了极致，几乎所有的处理器都会抽象出一个接口，然后下面会有各种各样的实现。这样处理之后整个流程几乎不涉及具体业务，只有流程规范，非常的容易理解。不得不说是一个让强迫症患者神清气爽的框架。</p>\n<p>另外还有一个感受就是，这套框架非常灵活。几乎所有的类都可以做的定制化，每一步处理过程都可以定制化，这样有利有弊，好处就是非常灵活，没有解决不了的问题，坏处就是可能一个地方没理解清楚就会出错。所有在定制化的时候还是要小心一点。</p>\n<p>接下来应该会有两篇文章，一篇是讲SpringMVC框架处理Controller的返回结果到视图，再一篇讲下Spring框架初始化Bean和BeanFactory的过程，其实也都在上面讲的流程里面，只是我略过去了。</p>\n<p>例行推广一下我的博客，喜欢这篇文章的朋友可以关注我的博客<a href=\"http://zwgeek.com\">http://zwgeek.com</a></p>\n","excerpt":"","more":"<p>例行推广一下我的博客，喜欢这篇文章的朋友可以关注我的博客<a href=\"http://zwgeek.com\">http://zwgeek.com</a></p>\n<h2 id=\"1-背景\"><a href=\"#1-背景\" class=\"headerlink\" title=\"1. 背景\"></a>1. 背景</h2><p>之前一篇文章 <a href=\"http://zwgeek.com/2016/12/28/SpringMVC%E5%AF%B9%E8%B1%A1%E7%BB%91%E5%AE%9A%E8%87%AA%E5%AE%9A%E4%B9%89%E5%90%8D%E7%A7%B0%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB/\">SpringMVC对象绑定时自定义名称对应关系</a> 讲了如何去把request中的请求参数指定到对象的某个属性上。但文中只讲了一下做法，没有讲原理，因为这个原理涉及到SpringMVC时怎么处理Request的复杂过程。这篇文章就来和大家扒一扒这件事，SpringMVC是怎么把一个request的请求最终映射到Controller的方法的。这是正向的，对于Spring来说，其实还负责把Controller的返回结果通过一些处理展现给用户，这是后话，这篇文章我们只说正向的请求，也就是从request到Controller的过程。</p>\n<p>首先，来一张SpringMVC处理请求的整个过程，图是来自《Spring实战》5.1.1章，我觉得总结的非常到位，几个大的过程都画出来了。</p>\n<p><img src=\"http://img.blog.csdn.net/20161229134539820?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemd6Y3p6dw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<p>我们这篇文章要说的其实就是1，2，3这三个阶段的实现原理。后面4，5，6，7可能会再开一篇文章来说，如果我的懒癌治好了的话。过程1是第二部分<strong>请求到DispatcherServlet</strong>，过程2和过程3可以总结为<strong>DispatcherServlet处理请求</strong>，也就是本文的第三部分。</p>\n<h2 id=\"2-请求到DispatcherServlet\"><a href=\"#2-请求到DispatcherServlet\" class=\"headerlink\" title=\"2. 请求到DispatcherServlet\"></a>2. 请求到DispatcherServlet</h2><p>那我们按照顺序先来说一下过程1，熟悉SpringMVC的同学肯定都知道DispatcherServlet这个类，这个类是整个SpringMVC的入口。那在这个类之前做工作的其实是J2EE，不是我们重点关注的对象。只简单说一下：</p>\n<p>首先一个WEB程序的入口其实是web.xml，一个请求过来，J2EE会先来这个文件中寻找合适的servlet-mapping，找到了就交给对应的Servlet处理。SpringMVC也需要在这里配一个Servlet，并且声明处理一些请求，简单点来说，我们都会让SpringMVC处理所有的请求，所以请求映射的地方就会写‘/*’，比如下面这样。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>Spring web<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-class</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">init-param</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>contextConfigLocation<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span>classpath:spring/web-context.xml<span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">init-param</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">load-on-startup</span>&gt;</span>1<span class=\"tag\">&lt;/<span class=\"name\">load-on-startup</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">servlet</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">servlet-mapping</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>Spring web<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>/*<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">servlet-mapping</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>这样配置一下，所有的请求就都会交给DispatcherServlet来处理了，也就是交给SpringMVC来处理了。1的过程就这么简单，想看代码实现的话可以翻翻Tomcat的代码。好，那接下来我们这篇文章重点，过程2和过程3的实现原理，也就是DispatcherServlet的处理过程。</p>\n<p>DispatcherServlet作为一个标准的Servlet，生命周期也是有三个，初始化，处理请求和销毁，分别对应Servlet接口的三个方法，init(), service()和destroy()。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Servlet</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">(ServletConfig var1)</span> <span class=\"keyword\">throws</span> ServletException</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\">ServletConfig <span class=\"title\">getServletConfig</span><span class=\"params\">()</span></span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">service</span><span class=\"params\">(ServletRequest var1, ServletResponse var2)</span> <span class=\"keyword\">throws</span> ServletException, IOException</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\">String <span class=\"title\">getServletInfo</span><span class=\"params\">()</span></span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">destroy</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里我们重点关注init和service的过程，destroy是service之后的过程了，可以暂时忽略不看。</p>\n<h3 id=\"2-1-DispatcherServlet初始化\"><a href=\"#2-1-DispatcherServlet初始化\" class=\"headerlink\" title=\"2.1 DispatcherServlet初始化\"></a>2.1 DispatcherServlet初始化</h3><p>这里先放一张DispatcherServlet的继承关系吧</p>\n<p><img src=\"http://img.blog.csdn.net/20161229133354781?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemd6Y3p6dw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<p>左边这条线就是Servlet的线，HttpServlet以及之上就是J2EE部分的代码，关注的是对请求的处理，比如doGet，doPost这些。下面HttpServletBean获取环境变量以方便子类使用。然后FrameworkServlet主要维护了自己的上下文对象webApplicationContext。我们知道一般的Servlet是不维护上下文对象的，而DispatcherServlet就是因为继承了FrameworkServlet，所以拥有了自己的上下文。简单来说大概就是这样，后面分析DispatcherServlet的工作过程的时候，还会追踪到它的这几个父类中来，到时候我们再细说。</p>\n<p>首先我们先从init方法来分析DispatcherServlet的的初始化过程，这是Servlet接口中init的方法签名。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">void init(ServletConfig var1) throws ServletException;</div></pre></td></tr></table></figure>\n<p>这个带参的init方法出现在GenericServlet中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void init(ServletConfig config) throws ServletException &#123;</div><div class=\"line\">    this.config = config;</div><div class=\"line\">    this.init();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">public void init() throws ServletException &#123;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>接收了一个J2EE环境传过来的配置对象config，然后提供了一个无参的init方法供子类初始化。这个无参的init方法在HttpServletBean中。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">public final void init() throws ServletException &#123;</div><div class=\"line\">        if(this.logger.isDebugEnabled()) &#123;</div><div class=\"line\">            this.logger.debug(&quot;Initializing servlet \\&apos;&quot; + this.getServletName() + &quot;\\&apos;&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        try &#123;</div><div class=\"line\">            //获取配置文件，就是web.xml中contextConfigLocation的值</div><div class=\"line\">            HttpServletBean.ServletConfigPropertyValues ex = new HttpServletBean.ServletConfigPropertyValues(this.getServletConfig(), this.requiredProperties);</div><div class=\"line\">            //将Servlet包装成一个bean</div><div class=\"line\">            BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(this);</div><div class=\"line\">            //获取服务器信息</div><div class=\"line\">            ServletContextResourceLoader resourceLoader = new ServletContextResourceLoader(this.getServletContext());</div><div class=\"line\">            bw.registerCustomEditor(Resource.class, new ResourceEditor(resourceLoader, this.getEnvironment()));</div><div class=\"line\">            //初始化Bean</div><div class=\"line\">            this.initBeanWrapper(bw);</div><div class=\"line\">            //设置配置文件到bean</div><div class=\"line\">            bw.setPropertyValues(ex, true);</div><div class=\"line\">            //其实以上部分没用到，因为在DispatcherServlet里initBeanWrapper没有被实现</div><div class=\"line\">        &#125; catch (BeansException var4) &#123;</div><div class=\"line\">            this.logger.error(&quot;Failed to set bean properties on servlet \\&apos;&quot; + this.getServletName() + &quot;\\&apos;&quot;, var4);</div><div class=\"line\">            throw var4;</div><div class=\"line\">        &#125;</div><div class=\"line\">        //供子类初始化</div><div class=\"line\">        this.initServletBean();</div><div class=\"line\">        if(this.logger.isDebugEnabled()) &#123;</div><div class=\"line\">            this.logger.debug(&quot;Servlet \\&apos;&quot; + this.getServletName() + &quot;\\&apos; configured successfully&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>HttpServletBean中提供了两个供子类重写的初始化方法initBeanWrapper和initServletBean，其中initBeanWrapper没有使用，DispatcherServlet使用了initServletBean来初始化接下来的工作。</p>\n<p>initServletBean在FrameworkServlet中。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected final void initServletBean() throws ServletException &#123;</div><div class=\"line\">        this.getServletContext().log(&quot;Initializing Spring FrameworkServlet \\&apos;&quot; + this.getServletName() + &quot;\\&apos;&quot;);</div><div class=\"line\">        if(this.logger.isInfoEnabled()) &#123;</div><div class=\"line\">            this.logger.info(&quot;FrameworkServlet \\&apos;&quot; + this.getServletName() + &quot;\\&apos;: initialization started&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        long startTime = System.currentTimeMillis();</div><div class=\"line\"></div><div class=\"line\">        try &#123;</div><div class=\"line\">            //初始化上下文对象</div><div class=\"line\">            this.webApplicationContext = this.initWebApplicationContext();</div><div class=\"line\">            //提供给子类初始化</div><div class=\"line\">            this.initFrameworkServlet();</div><div class=\"line\">        &#125; catch (ServletException var5) &#123;</div><div class=\"line\">            this.logger.error(&quot;Context initialization failed&quot;, var5);</div><div class=\"line\">            throw var5;</div><div class=\"line\">        &#125; catch (RuntimeException var6) &#123;</div><div class=\"line\">            this.logger.error(&quot;Context initialization failed&quot;, var6);</div><div class=\"line\">            throw var6;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        if(this.logger.isInfoEnabled()) &#123;</div><div class=\"line\">            long elapsedTime = System.currentTimeMillis() - startTime;</div><div class=\"line\">            this.logger.info(&quot;FrameworkServlet \\&apos;&quot; + this.getServletName() + &quot;\\&apos;: initialization completed in &quot; + elapsedTime + &quot; ms&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>initFrameworkServlet是提供给子类复写的初始化方法，但是DispatcherServlet也没有用，而是用了initWebApplicationContext中的refresh方法，任性啊。initWebApplicationContext是用来初始化上下文对象的，具体逻辑如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected WebApplicationContext initWebApplicationContext() &#123;</div><div class=\"line\">    //前面检查ApplicationContext是否被初始化过，如果有就直接拿来用</div><div class=\"line\">    WebApplicationContext rootContext = WebApplicationContextUtils.getWebApplicationContext(this.getServletContext());</div><div class=\"line\">    WebApplicationContext wac = null;</div><div class=\"line\">    if(this.webApplicationContext != null) &#123;</div><div class=\"line\">        wac = this.webApplicationContext;</div><div class=\"line\">        if(wac instanceof ConfigurableWebApplicationContext) &#123;</div><div class=\"line\">            ConfigurableWebApplicationContext attrName = (ConfigurableWebApplicationContext)wac;</div><div class=\"line\">            if(!attrName.isActive()) &#123;</div><div class=\"line\">                if(attrName.getParent() == null) &#123;</div><div class=\"line\">                    attrName.setParent(rootContext);</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                this.configureAndRefreshWebApplicationContext(attrName);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if(wac == null) &#123;</div><div class=\"line\">        wac = this.findWebApplicationContext();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if(wac == null) &#123;</div><div class=\"line\">        wac = this.createWebApplicationContext(rootContext);</div><div class=\"line\">    &#125;</div><div class=\"line\">    //Servlet自己的初始化方法</div><div class=\"line\">    if(!this.refreshEventReceived) &#123;</div><div class=\"line\">        this.onRefresh(wac);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    //将上下文对象保存起来</div><div class=\"line\">    if(this.publishContext) &#123;</div><div class=\"line\">        String attrName1 = this.getServletContextAttributeName();</div><div class=\"line\">        this.getServletContext().setAttribute(attrName1, wac);</div><div class=\"line\">        if(this.logger.isDebugEnabled()) &#123;</div><div class=\"line\">            this.logger.debug(&quot;Published WebApplicationContext of servlet \\&apos;&quot; + this.getServletName() + &quot;\\&apos; as ServletContext attribute with name [&quot; + attrName1 + &quot;]&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    return wac;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个方法前半部分是检查之前有没有创建过ApplicationContext对象，如果有，就直接拿过来用。如果没有，则初始化一个，onRefresh则是Servlet将自己的配置加到上下文对象中的方法，DispatcherServlet也是用了这个方法来初始化各种Bean。追了一堆，init方法终于到DispatcherServlet内部了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected void onRefresh(ApplicationContext context) &#123;</div><div class=\"line\">    this.initStrategies(context);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">protected void initStrategies(ApplicationContext context) &#123;</div><div class=\"line\">    this.initMultipartResolver(context);</div><div class=\"line\">    this.initLocaleResolver(context);</div><div class=\"line\">    this.initThemeResolver(context);</div><div class=\"line\">    this.initHandlerMappings(context);</div><div class=\"line\">    this.initHandlerAdapters(context);</div><div class=\"line\">    this.initHandlerExceptionResolvers(context);</div><div class=\"line\">    this.initRequestToViewNameTranslator(context);</div><div class=\"line\">    this.initViewResolvers(context);</div><div class=\"line\">    this.initFlashMapManager(context);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>看，上面就是DispatcherServlet的一堆初始化方法。</p>\n<blockquote>\n<p>来自<a href=\"http://blog.csdn.net/snail_bi/article/details/50578371\">http://blog.csdn.net/snail_bi/article/details/50578371</a></p>\n<ol>\n<li><p>MultipartResolver:<br><a href=\"http://exceptioneye.iteye.com/blog/1314958\">http://exceptioneye.iteye.com/blog/1314958</a><br>–&gt; CommonsMultipartResolver 文件上传解析器</p>\n</li>\n<li><p>LocalResolver: 支持国际化,区域解析器。每DispatcherServlet只能注册一个区域解析器<br><a href=\"http://blog.csdn.NET/rj042/article/details/23354225\">http://blog.csdn.NET/rj042/article/details/23354225</a><br>–&gt; AcceptHeaderLocaleResolver 它通过检验HTTP请求的accept-language头部来解析区域。由用户的web浏览器根据底层操作系统的区域设置进行设定。<br>–&gt; SessionLocaleResolver 它通过检验用户会话中预置的属性来解析区域。如果该会话属性<br>不存在，它会根据accept-language HTTP头部确定默认区域。<br>–&gt; CookieLocaleResolver来解析区域。如果Cookie不存在，它会根据accept-language HTTP头部确定默认区域。<br>–&gt; FixedLocaleResolver 一直使用固定的Local, 不支持Local改变 。<br>修改用户的区域<br>除了显式调用LocaleResolver.setLocale()来修改用户的区域之外，还可以将LocaleChangeInterceptor拦截器应用到处理程序映射中，它会发现当前HTTP请求中出现的特殊参数。其中的参数名称可以通过拦截器的paramName属性进行自定义。如果这种参数出现在当前请求中，拦截器就会根据参数值来改变用户的区域。</p>\n</li>\n<li><p>ThemeSource 动态更换样式的支持(主题)<br><a href=\"http://starscream.iteye.com/blog/1075855\">http://starscream.iteye.com/blog/1075855</a><br>–&gt; FixedThemeResolver:固定格式的theme,不能在系统运行时动态更改theme.<br>–&gt; SessionThemeResolver:theme name存放在session中key值为 org.springframework.web.servlet.theme.SessionThemeResolver.THEME 的session attribute中。可在运行中通过更改session中的相应的key值来动态调整theme的值。<br>–&gt; CookieThemeResolver:theme name存放在cookie中key值为 org.springframework.web.servlet.theme.CookieThemeResolver.THEME 中。可在运行中通过更改cookie中的相应的key值来动态调整theme的值。</p>\n</li>\n<li><p>HandlerMapping<br><a href=\"http://blog.csdn.Net/sunxing007/article/details/4584748\">http://blog.csdn.Net/sunxing007/article/details/4584748</a><br><a href=\"http://blog.csdn.net/prince2270/article/details/5894456\">http://blog.csdn.net/prince2270/article/details/5894456</a><br>–&gt;BeanNameUrlHandlerMapping: 查找spring容器中和请求的url同名的bean.<br>–&gt;BeanNameUrlHandlerMapping ：通过对比url和bean的name找到对应的对象<br>–&gt;SimpleUrlHandlerMapping ：也是直接配置url和对应bean,比BeanNameUrlHandlerMapping功能更多<br>–&gt;DefaultAnnotationHandlerMapping : 主要是针对注解配置@RequestMapping的，已过时<br>–&gt;RequestMappingHandlerMapping ：取代了上面一个<br>–&gt; 还有很多 ，请看源码</p>\n</li>\n<li><p>HandlerAdapter<br>–&gt; SimpleControllerHandlerAdapter<br>–&gt; SimpleServletHandlerAdapter<br>–&gt; RequestMappingHandlerAdapter<br>–&gt; HttpRequestHandlerAdapter<br>–&gt; AnnotationMethodHandlerAdapter</p>\n</li>\n<li><p>HandlerExceptionResolver</p>\n</li>\n<li><p>RequestToViewNameTranslator  用于直接将请求转换为逻辑视图名。<br><a href=\"http://sishuok.com/forum/blogPost/list/0/5514.html\">http://sishuok.com/forum/blogPost/list/0/5514.html</a><br><a href=\"http://haohaoxuexi.iteye.com/blog/1774603\">http://haohaoxuexi.iteye.com/blog/1774603</a><br>–&gt; DefaultRequestToViewNameTranslator<br>[<br><a href=\"http://localhost:9080/web上下文/list\">http://localhost:9080/web上下文/list</a> ——-&gt; 逻辑视图名为list<br><a href=\"http://localhost:9080/web上下文/list.html\">http://localhost:9080/web上下文/list.html</a> ——-&gt; 逻辑视图名为list(默认删除扩展名)<br><a href=\"http://localhost:9080/web上下文/user/list.html\">http://localhost:9080/web上下文/user/list.html</a> ——-&gt; 逻辑视图名为user/list<br>]</p>\n</li>\n<li><p>ViewResolver 视图解析器：定义了如何通过view 名称来解析对应View实例的行为<br><a href=\"http://blog.csdn.net/prince2270/article/details/5891085\">http://blog.csdn.net/prince2270/article/details/5891085</a><br><a href=\"http://www.iteye.com/problems/76107\">http://www.iteye.com/problems/76107</a> 多视图问题的解决<br><a href=\"http://my.oschina.net/HeliosFly/blog/221392\">http://my.oschina.net/HeliosFly/blog/221392</a></p>\n</li>\n<li><p>FlashMapManager<br><a href=\"http://www.oschina.net/translate/spring-mvc-flash-attribute-example\">http://www.oschina.net/translate/spring-mvc-flash-attribute-example</a><br>–&gt; SessionFlashMapManager</p>\n</li>\n</ol>\n</blockquote>\n<p>以上就是SpringMVC在初始化的时候加入的各种处理器，对于请求到Controller的映射，比较重要的是HandlerMapping和HandlerAdapter，HandlerMapping是用来查找处理请求的对象，HandlerAdapter是用来处理请求参数。这里以HandlerAdapter来举个例子，看一下initHandlerAdapters方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">·private void initHandlerAdapters(ApplicationContext context) &#123;</div><div class=\"line\">        this.handlerAdapters = null;</div><div class=\"line\">        if(this.detectAllHandlerAdapters) &#123;</div><div class=\"line\">            Map ex = BeanFactoryUtils.beansOfTypeIncludingAncestors(context, HandlerAdapter.class, true, false);</div><div class=\"line\">            if(!ex.isEmpty()) &#123;</div><div class=\"line\">                this.handlerAdapters = new ArrayList(ex.values());</div><div class=\"line\">                OrderComparator.sort(this.handlerAdapters);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            try &#123;</div><div class=\"line\">                HandlerAdapter ex1 = (HandlerAdapter)context.getBean(&quot;handlerAdapter&quot;, HandlerAdapter.class);</div><div class=\"line\">                this.handlerAdapters = Collections.singletonList(ex1);</div><div class=\"line\">            &#125; catch (NoSuchBeanDefinitionException var3) &#123;</div><div class=\"line\">                ;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        if(this.handlerAdapters == null) &#123;</div><div class=\"line\">            this.handlerAdapters = this.getDefaultStrategies(context, HandlerAdapter.class);</div><div class=\"line\">            if(this.logger.isDebugEnabled()) &#123;</div><div class=\"line\">                this.logger.debug(&quot;No HandlerAdapters found in servlet \\&apos;&quot; + this.getServletName() + &quot;\\&apos;: using default&quot;);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>上面的逻辑是这样的</p>\n<blockquote>\n<p>1)如果detectAllHandlerAdapters属性为true(默认为true)，根据类型匹配(HandlerAdapter)机制查找上下文及父Spring容器中所有匹配的Bean，将它们作为该类型组件；<br>2)如果detectAllHandlerAdapters属性为false，查找名为handlerAdapter类型为HandlerAdapter的Bean作为该类型组件；<br>3)如果通过以上方式都找不到，使用DispatcherServlet.properties配置文件中指定的三个实现类分别创建一个适配器，添加到适配器列表中。</p>\n</blockquote>\n<p>DispatcherServlet.properties和DispatcherServlet在同一个包下，定义了一些默认的类，内容如下。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">org.springframework.web.servlet.LocaleResolver=org.springframework.web.servlet.i18n.AcceptHeaderLocaleResolver</div><div class=\"line\"></div><div class=\"line\">org.springframework.web.servlet.ThemeResolver=org.springframework.web.servlet.theme.FixedThemeResolver</div><div class=\"line\"></div><div class=\"line\">org.springframework.web.servlet.HandlerMapping=org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping,\\</div><div class=\"line\">\torg.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping</div><div class=\"line\"></div><div class=\"line\">org.springframework.web.servlet.HandlerAdapter=org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter,\\</div><div class=\"line\">\torg.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter,\\</div><div class=\"line\">\torg.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter</div><div class=\"line\"></div><div class=\"line\">org.springframework.web.servlet.HandlerExceptionResolver=org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerExceptionResolver,\\</div><div class=\"line\">\torg.springframework.web.servlet.mvc.annotation.ResponseStatusExceptionResolver,\\</div><div class=\"line\">\torg.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver</div><div class=\"line\"></div><div class=\"line\">org.springframework.web.servlet.RequestToViewNameTranslator=org.springframework.web.servlet.view.DefaultRequestToViewNameTranslator</div><div class=\"line\"></div><div class=\"line\">org.springframework.web.servlet.ViewResolver=org.springframework.web.servlet.view.InternalResourceViewResolver</div><div class=\"line\"></div><div class=\"line\">org.springframework.web.servlet.FlashMapManager=org.springframework.web.servlet.support.SessionFlashMapManager</div></pre></td></tr></table></figure>\n<p>我们看到HandlerAdapter是有三个默认类，如果程序从上下文中找不到任何HandlerAdapter，就会把这三个加载进来。</p>\n<p>DispatcherServlet结束了onRefresh的一系列方法，初始化过程就结束了。接下来就是一个请求到来的时候的处理工作了。</p>\n<h2 id=\"3-Dispatcher处理请求\"><a href=\"#3-Dispatcher处理请求\" class=\"headerlink\" title=\"3. Dispatcher处理请求\"></a>3. Dispatcher处理请求</h2><h3 id=\"3-1-预处理请求\"><a href=\"#3-1-预处理请求\" class=\"headerlink\" title=\"3.1 预处理请求\"></a>3.1 预处理请求</h3><p>请求到来的时候，J2EE会调用相应Servlet的onService方法，对于DispatcherServlet来说，这个onService在FrameworkServlet里，代码如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</div><div class=\"line\">        String method = request.getMethod();</div><div class=\"line\">        if(method.equalsIgnoreCase(RequestMethod.PATCH.name())) &#123;</div><div class=\"line\">            this.processRequest(request, response);</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            super.service(request, response);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>这个方法补充了对PATCH请求类型的处理，其他请求类型如GET，PUT，调用了super的service方法，也就是在HttpServlet的service方法(HttpServletBean中没有复写)。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</div><div class=\"line\">        String method = req.getMethod();</div><div class=\"line\">        long errMsg;</div><div class=\"line\">        if(method.equals(&quot;GET&quot;)) &#123;</div><div class=\"line\">            errMsg = this.getLastModified(req);</div><div class=\"line\">            if(errMsg == -1L) &#123;</div><div class=\"line\">                this.doGet(req, resp);</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                long ifModifiedSince = req.getDateHeader(&quot;If-Modified-Since&quot;);</div><div class=\"line\">                if(ifModifiedSince &lt; errMsg / 1000L * 1000L) &#123;</div><div class=\"line\">                    this.maybeSetLastModified(resp, errMsg);</div><div class=\"line\">                    this.doGet(req, resp);</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    resp.setStatus(304);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; else if(method.equals(&quot;HEAD&quot;)) &#123;</div><div class=\"line\">            errMsg = this.getLastModified(req);</div><div class=\"line\">            this.maybeSetLastModified(resp, errMsg);</div><div class=\"line\">            this.doHead(req, resp);</div><div class=\"line\">        &#125; else if(method.equals(&quot;POST&quot;)) &#123;</div><div class=\"line\">            this.doPost(req, resp);</div><div class=\"line\">        &#125; else if(method.equals(&quot;PUT&quot;)) &#123;</div><div class=\"line\">            this.doPut(req, resp);</div><div class=\"line\">        &#125; else if(method.equals(&quot;DELETE&quot;)) &#123;</div><div class=\"line\">            this.doDelete(req, resp);</div><div class=\"line\">        &#125; else if(method.equals(&quot;OPTIONS&quot;)) &#123;</div><div class=\"line\">            this.doOptions(req, resp);</div><div class=\"line\">        &#125; else if(method.equals(&quot;TRACE&quot;)) &#123;</div><div class=\"line\">            this.doTrace(req, resp);</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            String errMsg1 = lStrings.getString(&quot;http.method_not_implemented&quot;);</div><div class=\"line\">            Object[] errArgs = new Object[]&#123;method&#125;;</div><div class=\"line\">            errMsg1 = MessageFormat.format(errMsg1, errArgs);</div><div class=\"line\">            resp.sendError(501, errMsg1);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>这个方法也很简单，根据不同的请求类型调用不同的方法，这里我们假设请求是个GET请求，那就会去执行子类的doGet方法，在FrameworkServlet里。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected final void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</div><div class=\"line\">        this.processRequest(request, response);</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>也没做什么，交给了processRequest处理，其实其他请求最后也都转给processRequest这个方法处理了，因为处理参数的逻辑是一样的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected final void processRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</div><div class=\"line\">    long startTime = System.currentTimeMillis();</div><div class=\"line\">    Object failureCause = null;</div><div class=\"line\">    //获取之前的位置信息，最后finally时恢复之前配置</div><div class=\"line\">    LocaleContext previousLocaleContext = LocaleContextHolder.getLocaleContext();</div><div class=\"line\">    LocaleContext localeContext = this.buildLocaleContext(request);</div><div class=\"line\">    RequestAttributes previousAttributes = RequestContextHolder.getRequestAttributes();</div><div class=\"line\">    ServletRequestAttributes requestAttributes = this.buildRequestAttributes(request, response, previousAttributes);</div><div class=\"line\">    //注册Interceptor，没理解干嘛的</div><div class=\"line\">    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</div><div class=\"line\">    asyncManager.registerCallableInterceptor(FrameworkServlet.class.getName(), new FrameworkServlet.RequestBindingInterceptor(null));</div><div class=\"line\">    //将请求中的位置信息记入</div><div class=\"line\">    this.initContextHolders(request, localeContext, requestAttributes);</div><div class=\"line\"></div><div class=\"line\">    try &#123;</div><div class=\"line\">        //做事情</div><div class=\"line\">        this.doService(request, response);</div><div class=\"line\">    &#125; catch (ServletException var18) &#123;</div><div class=\"line\">        failureCause = var18;</div><div class=\"line\">        throw var18;</div><div class=\"line\">    &#125; catch (IOException var19) &#123;</div><div class=\"line\">        failureCause = var19;</div><div class=\"line\">        throw var19;</div><div class=\"line\">    &#125; catch (Throwable var20) &#123;</div><div class=\"line\">        failureCause = var20;</div><div class=\"line\">        throw new NestedServletException(&quot;Request processing failed&quot;, var20);</div><div class=\"line\">    &#125; finally &#123;</div><div class=\"line\">    //恢复之前配置</div><div class=\"line\">        this.resetContextHolders(request, previousLocaleContext, previousAttributes);</div><div class=\"line\">        if(requestAttributes != null) &#123;</div><div class=\"line\">            requestAttributes.requestCompleted();</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        if(this.logger.isDebugEnabled()) &#123;</div><div class=\"line\">            if(failureCause != null) &#123;</div><div class=\"line\">                this.logger.debug(&quot;Could not complete request&quot;, (Throwable)failureCause);</div><div class=\"line\">            &#125; else if(asyncManager.isConcurrentHandlingStarted()) &#123;</div><div class=\"line\">                this.logger.debug(&quot;Leaving response open for concurrent processing&quot;);</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                this.logger.debug(&quot;Successfully completed request&quot;);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">       //发布事件 this.publishRequestHandledEvent(request, startTime, (Throwable)failureCause);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>先说下发布事件，Spring在请求处理结束后会发布一个ServletRequestHandledEvent类型的事件，可以通过ApplicationListener接收。</p>\n<p>这个方法前面和后面做的工作是保留现场，请求处理结束后恢复现场。真正处理请求的方法是doService。这个方法在DispatcherServlet中。</p>\n<p>话语权终于到DispatcherServlet中了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected void doService(HttpServletRequest request, HttpServletResponse response) throws Exception &#123;</div><div class=\"line\">    if(this.logger.isDebugEnabled()) &#123;</div><div class=\"line\">        String attributesSnapshot = WebAsyncUtils.getAsyncManager(request).hasConcurrentResult()?&quot; resumed&quot;:&quot;&quot;;</div><div class=\"line\">        this.logger.debug(&quot;DispatcherServlet with name \\&apos;&quot; + this.getServletName() + &quot;\\&apos;&quot; + attributesSnapshot + &quot; processing &quot; + request.getMethod() + &quot; request for [&quot; + getRequestUri(request) + &quot;]&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    HashMap attributesSnapshot1 = null;</div><div class=\"line\">    //处理include类型的request，用不到</div><div class=\"line\">    if(WebUtils.isIncludeRequest(request)) &#123;</div><div class=\"line\">        attributesSnapshot1 = new HashMap();</div><div class=\"line\">        Enumeration inputFlashMap = request.getAttributeNames();</div><div class=\"line\"></div><div class=\"line\">        label113:</div><div class=\"line\">        while(true) &#123;</div><div class=\"line\">            String attrName;</div><div class=\"line\">            do &#123;</div><div class=\"line\">                if(!inputFlashMap.hasMoreElements()) &#123;</div><div class=\"line\">                    break label113;</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                attrName = (String)inputFlashMap.nextElement();</div><div class=\"line\">            &#125; while(!this.cleanupAfterInclude &amp;&amp; !attrName.startsWith(&quot;org.springframework.web.servlet&quot;));</div><div class=\"line\"></div><div class=\"line\">            attributesSnapshot1.put(attrName, request.getAttribute(attrName));</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    //将现在的各种参数加到Request中</div><div class=\"line\">    request.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, this.getWebApplicationContext());</div><div class=\"line\">    request.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, this.localeResolver);</div><div class=\"line\">    request.setAttribute(THEME_RESOLVER_ATTRIBUTE, this.themeResolver);</div><div class=\"line\">    request.setAttribute(THEME_SOURCE_ATTRIBUTE, this.getThemeSource());</div><div class=\"line\">    FlashMap inputFlashMap1 = this.flashMapManager.retrieveAndUpdate(request, response);</div><div class=\"line\">    if(inputFlashMap1 != null) &#123;</div><div class=\"line\">        request.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, Collections.unmodifiableMap(inputFlashMap1));</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    request.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, new FlashMap());</div><div class=\"line\">    request.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, this.flashMapManager);</div><div class=\"line\"></div><div class=\"line\">    try &#123;</div><div class=\"line\">        //做事情</div><div class=\"line\">        this.doDispatch(request, response);</div><div class=\"line\">    &#125; finally &#123;</div><div class=\"line\">        if(WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123;</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        if(attributesSnapshot1 != null) &#123;</div><div class=\"line\">            this.restoreAttributesAfterInclude(request, attributesSnapshot1);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个方法主要是把现在有的一些参数比如上下文对象加到Request中，然后转发到doDispatch方法去处理，终于到了最关键的方法了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception &#123;</div><div class=\"line\">    HttpServletRequest processedRequest = request;</div><div class=\"line\">    HandlerExecutionChain mappedHandler = null;</div><div class=\"line\">    boolean multipartRequestParsed = false;</div><div class=\"line\">    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</div><div class=\"line\"></div><div class=\"line\">    try &#123;</div><div class=\"line\">        try &#123;</div><div class=\"line\">            ModelAndView err = null;</div><div class=\"line\">            Exception dispatchException = null;</div><div class=\"line\"></div><div class=\"line\">            try &#123;</div><div class=\"line\">                processedRequest = this.checkMultipart(request);</div><div class=\"line\">                multipartRequestParsed = processedRequest != request;</div><div class=\"line\">                //获取Hanlder</div><div class=\"line\">                mappedHandler = this.getHandler(processedRequest, false);</div><div class=\"line\">                if(mappedHandler == null || mappedHandler.getHandler() == null) &#123;</div><div class=\"line\">                    this.noHandlerFound(processedRequest, response);</div><div class=\"line\">                    return;</div><div class=\"line\">                &#125;</div><div class=\"line\">                //获取Adapter</div><div class=\"line\">                HandlerAdapter ex = this.getHandlerAdapter(mappedHandler.getHandler());</div><div class=\"line\">                String method = request.getMethod();</div><div class=\"line\">                boolean isGet = &quot;GET&quot;.equals(method);</div><div class=\"line\">                if(isGet || &quot;HEAD&quot;.equals(method)) &#123;</div><div class=\"line\">                    long lastModified = ex.getLastModified(request, mappedHandler.getHandler());</div><div class=\"line\">                    if(this.logger.isDebugEnabled()) &#123;</div><div class=\"line\">                        this.logger.debug(&quot;Last-Modified value for [&quot; + getRequestUri(request) + &quot;] is: &quot; + lastModified);</div><div class=\"line\">                    &#125;</div><div class=\"line\"></div><div class=\"line\">                    if((new ServletWebRequest(request, response)).checkNotModified(lastModified) &amp;&amp; isGet) &#123;</div><div class=\"line\">                        return;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">                //执行preHandle方法</div><div class=\"line\">                if(!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</div><div class=\"line\">                    return;</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                 //执行Handle方法                    </div><div class=\"line\">                try &#123;</div><div class=\"line\">                    err = ex.handle(processedRequest, response, mappedHandler.getHandler());</div><div class=\"line\">                &#125; finally &#123;</div><div class=\"line\">                    if(asyncManager.isConcurrentHandlingStarted()) &#123;</div><div class=\"line\">                        return;</div><div class=\"line\">                    &#125;</div><div class=\"line\"></div><div class=\"line\">                &#125;</div><div class=\"line\">                //处理默认的ViewName</div><div class=\"line\">                this.applyDefaultViewName(request, err);</div><div class=\"line\">                //执行PostHandle</div><div class=\"line\">                mappedHandler.applyPostHandle(processedRequest, response, err);</div><div class=\"line\">            &#125; catch (Exception var27) &#123;</div><div class=\"line\">                dispatchException = var27;</div><div class=\"line\">            &#125;</div><div class=\"line\">            //处理返回结果，绘制View</div><div class=\"line\">            this.processDispatchResult(processedRequest, response, mappedHandler, err, dispatchException);</div><div class=\"line\">        &#125; catch (Exception var28) &#123;</div><div class=\"line\">            this.triggerAfterCompletion(processedRequest, response, mappedHandler, var28);</div><div class=\"line\">        &#125; catch (Error var29) &#123;</div><div class=\"line\">            this.triggerAfterCompletionWithError(processedRequest, response, mappedHandler, var29);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">    &#125; finally &#123;</div><div class=\"line\">        if(asyncManager.isConcurrentHandlingStarted()) &#123;</div><div class=\"line\">            mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);</div><div class=\"line\">            return;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            if(multipartRequestParsed) &#123;</div><div class=\"line\">                this.cleanupMultipart(processedRequest);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>虽然这个方法可以说是整个SpringMVC中最重要的方法，但是整个流程缺及其简单，可以说这一切都归功于Spring框架高度的抽象。我们来梳理一下这个doDispatch方法的流程。</p>\n<ol>\n<li>获取Handler</li>\n<li>获取Adapter</li>\n<li>执行preHandle方法</li>\n<li>执行Handle方法</li>\n<li>执行PostHandle</li>\n<li>处理返回结果</li>\n</ol>\n<p>5和6是Controller请求处理结束后的操作，本文中我们只讨论1-2-3-4这四个步骤。1-2-3-4这四个步骤对应了一开始提到的SpringMVC的七大步中的第二步请求到处理器映射和第三步请求到控制器。其中1-2是请求到处理器映射，3-4是请求到控制器。下面我们一步一步的来看。</p>\n<h3 id=\"3-2-根据请求获取Handler\"><a href=\"#3-2-根据请求获取Handler\" class=\"headerlink\" title=\"3.2 根据请求获取Handler\"></a>3.2 根据请求获取Handler</h3><p>首先第一步是根据request，获取合适的Handler。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">mappedHandler = this.getHandler(processedRequest, false);</div></pre></td></tr></table></figure>\n<p>这里返回的结果是HandlerExecutionChain类型的，从名字我们知道这是一个执行链，里面包含了这个Handler所有相关的信息。下面我们来看下getHandler方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception &#123;</div><div class=\"line\">        Iterator i$ = this.handlerMappings.iterator();</div><div class=\"line\"></div><div class=\"line\">        HandlerExecutionChain handler;</div><div class=\"line\">        do &#123;</div><div class=\"line\">            if(!i$.hasNext()) &#123;</div><div class=\"line\">                return null;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            HandlerMapping hm = (HandlerMapping)i$.next();</div><div class=\"line\">            if(this.logger.isTraceEnabled()) &#123;</div><div class=\"line\">                this.logger.trace(&quot;Testing handler map [&quot; + hm + &quot;] in DispatcherServlet with name \\&apos;&quot; + this.getServletName() + &quot;\\&apos;&quot;);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            handler = hm.getHandler(request);</div><div class=\"line\">        &#125; while(handler == null);</div><div class=\"line\"></div><div class=\"line\">        return handler;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>遍历HandlerMappings，然后依次调用每个HandlerMappings的getHandler方法，如果有返回就交给该Handler处理。</p>\n<p>这个HandlerMappings是DispatcherServlet初始化的时候加入的，在initHandlerMapping方法里。我们看下系统默认的HandlerMapping都有哪些。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">org.springframework.web.servlet.HandlerMapping=org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping,\\</div><div class=\"line\">\torg.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping</div></pre></td></tr></table></figure>\n<p>我的项目自定义了一个HandlerMappings，也是基于注解的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;!--配置注解式处理器映射器--&gt;</div><div class=\"line\"> &lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping&quot;/&gt;</div></pre></td></tr></table></figure>\n<p>我们来看一下他是怎么工作的。getHandler方法。这个方法在RequestMappingHandlerMapping的父类AbstractHandlerMapping中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">public final HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception &#123;</div><div class=\"line\">        Object handler = this.getHandlerInternal(request);</div><div class=\"line\">        if(handler == null) &#123;</div><div class=\"line\">            handler = this.getDefaultHandler();</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        if(handler == null) &#123;</div><div class=\"line\">            return null;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            if(handler instanceof String) &#123;</div><div class=\"line\">                String handlerName = (String)handler;</div><div class=\"line\">                handler = this.getApplicationContext().getBean(handlerName);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            return this.getHandlerExecutionChain(handler, request);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>Spring框架一贯的套路，父类定义流程，开一个方法供子类去实现，比如这里的getHandlerInternal，返回了Handler之后，再用HandlerExecutionChain包装一下。那先来看下getHandlerInternal方法是怎么获取Handler的。这个方法依然在RequestMappingHandlerMapping的父类AbstractHandlerMethodMapping中。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected HandlerMethod getHandlerInternal(HttpServletRequest request) throws Exception &#123;</div><div class=\"line\">        String lookupPath = this.getUrlPathHelper().getLookupPathForRequest(request);</div><div class=\"line\">        if(this.logger.isDebugEnabled()) &#123;</div><div class=\"line\">            this.logger.debug(&quot;Looking up handler method for path &quot; + lookupPath);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        HandlerMethod handlerMethod = this.lookupHandlerMethod(lookupPath, request);</div><div class=\"line\">        if(this.logger.isDebugEnabled()) &#123;</div><div class=\"line\">            if(handlerMethod != null) &#123;</div><div class=\"line\">                this.logger.debug(&quot;Returning handler method [&quot; + handlerMethod + &quot;]&quot;);</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                this.logger.debug(&quot;Did not find handler method for [&quot; + lookupPath + &quot;]&quot;);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        return handlerMethod != null?handlerMethod.createWithResolvedBean():null;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>两个重要的方法，getLookupPathForRequest和lookupHandlerMethod，这里我就不贴代码了，说一下实现原理吧，其实RequestMappingHandlerMapping在初始化的时候已经将系统中所有的@RequestMapping注解解析了，放在一个Map里面。实现过程如下。</p>\n<p>RequestMappingHandlerMapping的父类AbstractHandlerMethodMapping实现了InitializingBean接口，在Bean设置完参数后会调用afterPropertiesSet方法，而它在这个方法里面做了初始化的工作。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void afterPropertiesSet() &#123;</div><div class=\"line\">       this.initHandlerMethods();</div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\">   protected void initHandlerMethods() &#123;</div><div class=\"line\">       if(this.logger.isDebugEnabled()) &#123;</div><div class=\"line\">           this.logger.debug(&quot;Looking for request mappings in application context: &quot; + this.getApplicationContext());</div><div class=\"line\">       &#125;</div><div class=\"line\"></div><div class=\"line\">       String[] beanNames = this.detectHandlerMethodsInAncestorContexts?BeanFactoryUtils.beanNamesForTypeIncludingAncestors(this.getApplicationContext(), Object.class):this.getApplicationContext().getBeanNamesForType(Object.class);</div><div class=\"line\">       String[] arr$ = beanNames;</div><div class=\"line\">       int len$ = beanNames.length;</div><div class=\"line\"></div><div class=\"line\">       for(int i$ = 0; i$ &lt; len$; ++i$) &#123;</div><div class=\"line\">           String beanName = arr$[i$];</div><div class=\"line\">           //判断类中是否含有RequestMapping注释</div><div class=\"line\">           if(this.isHandler(this.getApplicationContext().getType(beanName))) &#123;</div><div class=\"line\">               //解析方法</div><div class=\"line\">               this.detectHandlerMethods(beanName);</div><div class=\"line\">           &#125;</div><div class=\"line\">       &#125;</div><div class=\"line\"></div><div class=\"line\">       this.handlerMethodsInitialized(this.getHandlerMethods());</div><div class=\"line\">   &#125;</div><div class=\"line\">   </div><div class=\"line\"> protected void detectHandlerMethods(Object handler) &#123;</div><div class=\"line\">       Class handlerType = handler instanceof String?this.getApplicationContext().getType((String)handler):handler.getClass();</div><div class=\"line\">       final IdentityHashMap mappings = new IdentityHashMap();</div><div class=\"line\">       final Class userType = ClassUtils.getUserClass(handlerType);</div><div class=\"line\">       Set methods = HandlerMethodSelector.selectMethods(userType, new MethodFilter() &#123;</div><div class=\"line\">           public boolean matches(Method method) &#123;</div><div class=\"line\">               Object mapping = AbstractHandlerMethodMapping.this.getMappingForMethod(method, userType);</div><div class=\"line\">               if(mapping != null) &#123;</div><div class=\"line\">                   mappings.put(method, mapping);</div><div class=\"line\">                   return true;</div><div class=\"line\">               &#125; else &#123;</div><div class=\"line\">                   return false;</div><div class=\"line\">               &#125;</div><div class=\"line\">           &#125;</div><div class=\"line\">       &#125;);</div><div class=\"line\">       Iterator i$ = methods.iterator();</div><div class=\"line\"></div><div class=\"line\">       while(i$.hasNext()) &#123;</div><div class=\"line\">           Method method = (Method)i$.next();</div><div class=\"line\">           //注册方法，加到urlMaps里面</div><div class=\"line\">           this.registerHandlerMethod(handler, method, mappings.get(method));</div><div class=\"line\">       &#125;</div><div class=\"line\"></div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<p>这样RequestMappingHandlerMapping 里面就有了所有Controller方法的信息。getLookupPathForRequest就是获取请求的地址，比如我请求的是<a href=\"http://localhost:8090/test，那这里getLookupPathForRequest返回的就是/test。现在只要查询一下RequestMappingHandlerMapping里面有没有key为/test的的value即可，value中有处理的类的Controller对应的bean\">http://localhost:8090/test，那这里getLookupPathForRequest返回的就是/test。现在只要查询一下RequestMappingHandlerMapping里面有没有key为/test的的value即可，value中有处理的类的Controller对应的bean</a> name，然后下面createWithResolvedBean包装一下返回一个HandlerMethod。返回的HandlerMethod再通过getHandlerExecutionChain包装成HandlerExecutionChain，HandlerExecutionChain里面有什么呢，我们来看一下getHandlerExecutionChain方法是怎么写的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected HandlerExecutionChain getHandlerExecutionChain(Object handler, HttpServletRequest request) &#123;</div><div class=\"line\">       HandlerExecutionChain chain = handler instanceof HandlerExecutionChain?(HandlerExecutionChain)handler:new HandlerExecutionChain(handler);</div><div class=\"line\">       chain.addInterceptors(this.getAdaptedInterceptors());</div><div class=\"line\">       String lookupPath = this.urlPathHelper.getLookupPathForRequest(request);</div><div class=\"line\">       Iterator i$ = this.mappedInterceptors.iterator();</div><div class=\"line\"></div><div class=\"line\">       while(i$.hasNext()) &#123;</div><div class=\"line\">           MappedInterceptor mappedInterceptor = (MappedInterceptor)i$.next();</div><div class=\"line\">           if(mappedInterceptor.matches(lookupPath, this.pathMatcher)) &#123;</div><div class=\"line\">               chain.addInterceptor(mappedInterceptor.getInterceptor());</div><div class=\"line\">           &#125;</div><div class=\"line\">       &#125;</div><div class=\"line\"></div><div class=\"line\">       return chain;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<p>其实就是把Interceptor加进去，你可以通过自定义Interceptor来对一个request的前后做相应的处理，下面是HandlerInterceptor接口的方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">public interface HandlerInterceptor &#123;</div><div class=\"line\">    boolean preHandle(HttpServletRequest var1, HttpServletResponse var2, Object var3) throws Exception;</div><div class=\"line\"></div><div class=\"line\">    void postHandle(HttpServletRequest var1, HttpServletResponse var2, Object var3, ModelAndView var4) throws Exception;</div><div class=\"line\"></div><div class=\"line\">    void afterCompletion(HttpServletRequest var1, HttpServletResponse var2, Object var3, Exception var4) throws Exception;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这样就获取到了处理这个request对应的Controller，以及方法名了，控制权又交回到doDispatch方法中去了。</p>\n<h3 id=\"3-3-根据处理器获取相应的处理器Adapter适配器\"><a href=\"#3-3-根据处理器获取相应的处理器Adapter适配器\" class=\"headerlink\" title=\"3.3 根据处理器获取相应的处理器Adapter适配器\"></a>3.3 根据处理器获取相应的处理器Adapter适配器</h3><p>接下来是第二步获取Adapter，这个Adapter的作用主要是把请求中的参数和Controller方法中的参数对应起来，所以就会做一些类型转换相应的工作，也就是下一步，这一部分也是我觉得request到Controller的映射过程中最复杂的一步，不过获取Adapter相对简单。</p>\n<p>首先看下getHandlerAdapter的代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected HandlerAdapter getHandlerAdapter(Object handler) throws ServletException &#123;</div><div class=\"line\">       Iterator i$ = this.handlerAdapters.iterator();</div><div class=\"line\"></div><div class=\"line\">       HandlerAdapter ha;</div><div class=\"line\">       do &#123;</div><div class=\"line\">           if(!i$.hasNext()) &#123;</div><div class=\"line\">               throw new ServletException(&quot;No adapter for handler [&quot; + handler + &quot;]: The DispatcherServlet configuration needs to include a HandlerAdapter that supports this handler&quot;);</div><div class=\"line\">           &#125;</div><div class=\"line\"></div><div class=\"line\">           ha = (HandlerAdapter)i$.next();</div><div class=\"line\">           if(this.logger.isTraceEnabled()) &#123;</div><div class=\"line\">               this.logger.trace(&quot;Testing handler adapter [&quot; + ha + &quot;]&quot;);</div><div class=\"line\">           &#125;</div><div class=\"line\">       &#125; while(!ha.supports(handler));</div><div class=\"line\"></div><div class=\"line\">       return ha;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<p> 从初始化的handlerAdapters中取出可以处理相应handler的，如果没有自定义，系统会预置几个，这个前面也说到了。这里我们看下supports方法吧，看下handlerAdapter是怎么判断它自己能否处理这个handler的。我目前项目用的是RequestMappingHandlerAdapter这里Adapter处理类。它的supports方法在他的父类AbstractHandlerMethodAdapter上。</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">public final boolean supports(Object handler) &#123;</div><div class=\"line\">       return handler instanceof HandlerMethod &amp;&amp; this.supportsInternal((HandlerMethod)handler);</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected boolean supportsInternal(HandlerMethod handlerMethod) &#123;</div><div class=\"line\">       return true;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<p> RequestMappingHandlerAdapter的supportsInternal方法是永远返回true的，所以只要handler的类型是HandlerMethod，这个RequestMappingHandlerAdapter都会处理。这个RequestMappingHandlerAdapter其实是个比较通用的Adapter类。</p>\n<h3 id=\"3-4-执行preHandle方法和Handle方法\"><a href=\"#3-4-执行preHandle方法和Handle方法\" class=\"headerlink\" title=\"3.4 执行preHandle方法和Handle方法\"></a>3.4 执行preHandle方法和Handle方法</h3><p> 获取到了Adapter，接下来就要做实际的事情了，执行preHandle方法很简单，就是调用一下，其实是为了用户定制。接下来真正处理事情的是adapter的handle方法。也就是我们上面提到的doDispatch的第四步。</p>\n<p> AbstractHandlerMethodAdapter的handle方法按照Spring的国际惯例肯定，自己做了点保存现场啥的工作，然后定义一个方法让子类去做实际的事情了。我瞅了一眼，我觉得我还是高估这个父类了，它啥都没做直接调用了子类的handleInternal方法。RequestMappingHandlerAdapter中handleInternal的实现是这样的。</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected final ModelAndView handleInternal(HttpServletRequest request, HttpServletResponse response, HandlerMethod handlerMethod) throws Exception &#123;</div><div class=\"line\">       if(this.getSessionAttributesHandler(handlerMethod).hasSessionAttributes()) &#123;</div><div class=\"line\">           this.checkAndPrepare(request, response, this.cacheSecondsForSessionAttributeHandlers, true);</div><div class=\"line\">       &#125; else &#123;</div><div class=\"line\">           this.checkAndPrepare(request, response, true);</div><div class=\"line\">       &#125;</div><div class=\"line\"></div><div class=\"line\">       if(this.synchronizeOnSession) &#123;</div><div class=\"line\">           HttpSession session = request.getSession(false);</div><div class=\"line\">           if(session != null) &#123;</div><div class=\"line\">               Object mutex = WebUtils.getSessionMutex(session);</div><div class=\"line\">               synchronized(mutex) &#123;</div><div class=\"line\">                   return this.invokeHandleMethod(request, response, handlerMethod);</div><div class=\"line\">               &#125;</div><div class=\"line\">           &#125;</div><div class=\"line\">       &#125;</div><div class=\"line\"></div><div class=\"line\">       return this.invokeHandleMethod(request, response, handlerMethod);</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<p> 又分了两部分，一个是checkAndPrepare，另一个是invokeHandleMethod，从名字也可以看出，一个事准备，一个事调用方法。按步骤一个一个来，先看看checkAndPrepare做了什么。</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected final void checkAndPrepare(HttpServletRequest request, HttpServletResponse response, int cacheSeconds, boolean lastModified) throws ServletException &#123;</div><div class=\"line\">       String method = request.getMethod();</div><div class=\"line\">       if(this.supportedMethods != null &amp;&amp; !this.supportedMethods.contains(method)) &#123;</div><div class=\"line\">           throw new HttpRequestMethodNotSupportedException(method, StringUtils.toStringArray(this.supportedMethods));</div><div class=\"line\">       &#125; else if(this.requireSession &amp;&amp; request.getSession(false) == null) &#123;</div><div class=\"line\">           throw new HttpSessionRequiredException(&quot;Pre-existing session required but none found&quot;);</div><div class=\"line\">       &#125; else &#123;</div><div class=\"line\">           this.applyCacheSeconds(response, cacheSeconds, lastModified);</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<p> 检查了是否支持请求方法，然后调用了applyCacheSeconds来处理缓存时间戳。也没什么重要的是不是，所以处理参数的其实下面这个方法invokeHandleMethod。</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\">private ModelAndView invokeHandleMethod(HttpServletRequest request, HttpServletResponse response, HandlerMethod handlerMethod) throws Exception &#123;</div><div class=\"line\">\t\t //初始化ServletWebRequest</div><div class=\"line\">       ServletWebRequest webRequest = new ServletWebRequest(request, response);</div><div class=\"line\">       //获取类型转换器</div><div class=\"line\">       WebDataBinderFactory binderFactory = this.getDataBinderFactory(handlerMethod);</div><div class=\"line\">       ModelFactory modelFactory = this.getModelFactory(handlerMethod, binderFactory);</div><div class=\"line\">       //创建Method映射</div><div class=\"line\">       ServletInvocableHandlerMethod requestMappingMethod = this.createRequestMappingMethod(handlerMethod, binderFactory);</div><div class=\"line\">       //创建ModelandView包装器</div><div class=\"line\">       ModelAndViewContainer mavContainer = new ModelAndViewContainer();</div><div class=\"line\">       mavContainer.addAllAttributes(RequestContextUtils.getInputFlashMap(request));</div><div class=\"line\">       modelFactory.initModel(webRequest, mavContainer, requestMappingMethod);</div><div class=\"line\">       mavContainer.setIgnoreDefaultModelOnRedirect(this.ignoreDefaultModelOnRedirect);</div><div class=\"line\">       //异步相关</div><div class=\"line\">       AsyncWebRequest asyncWebRequest = WebAsyncUtils.createAsyncWebRequest(request, response);</div><div class=\"line\">       asyncWebRequest.setTimeout(this.asyncRequestTimeout);</div><div class=\"line\">       WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</div><div class=\"line\">       asyncManager.setTaskExecutor(this.taskExecutor);</div><div class=\"line\">       asyncManager.setAsyncWebRequest(asyncWebRequest);</div><div class=\"line\">       asyncManager.registerCallableInterceptors(this.callableInterceptors);</div><div class=\"line\">       asyncManager.registerDeferredResultInterceptors(this.deferredResultInterceptors);</div><div class=\"line\">       if(asyncManager.hasConcurrentResult()) &#123;</div><div class=\"line\">           Object result = asyncManager.getConcurrentResult();</div><div class=\"line\">           mavContainer = (ModelAndViewContainer)asyncManager.getConcurrentResultContext()[0];</div><div class=\"line\">           asyncManager.clearConcurrentResult();</div><div class=\"line\">           if(this.logger.isDebugEnabled()) &#123;</div><div class=\"line\">               this.logger.debug(&quot;Found concurrent result value [&quot; + result + &quot;]&quot;);</div><div class=\"line\">           &#125;</div><div class=\"line\"></div><div class=\"line\">           requestMappingMethod = requestMappingMethod.wrapConcurrentResult(result);</div><div class=\"line\">       &#125;</div><div class=\"line\"></div><div class=\"line\">       requestMappingMethod.invokeAndHandle(webRequest, mavContainer, new Object[0]);</div><div class=\"line\">       return asyncManager.isConcurrentHandlingStarted()?null:this.getModelAndView(mavContainer, modelFactory, webRequest);</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<p> 现在requestMappingMethod中有了方法信息，有了请求信息，就到了invokeAndHandle。invokeAndHandle中又调了invokeForRequest</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">public final Object invokeForRequest(NativeWebRequest request, ModelAndViewContainer mavContainer, Object... providedArgs) throws Exception &#123;</div><div class=\"line\">       Object[] args = this.getMethodArgumentValues(request, mavContainer, providedArgs);</div><div class=\"line\">       if(this.logger.isTraceEnabled()) &#123;</div><div class=\"line\">           StringBuilder returnValue = new StringBuilder(&quot;Invoking [&quot;);</div><div class=\"line\">           returnValue.append(this.getBeanType().getSimpleName()).append(&quot;.&quot;);</div><div class=\"line\">           returnValue.append(this.getMethod().getName()).append(&quot;] method with arguments &quot;);</div><div class=\"line\">           returnValue.append(Arrays.asList(args));</div><div class=\"line\">           this.logger.trace(returnValue.toString());</div><div class=\"line\">       &#125;</div><div class=\"line\"></div><div class=\"line\">       Object returnValue1 = this.invoke(args);</div><div class=\"line\">       if(this.logger.isTraceEnabled()) &#123;</div><div class=\"line\">           this.logger.trace(&quot;Method [&quot; + this.getMethod().getName() + &quot;] returned [&quot; + returnValue1 + &quot;]&quot;);</div><div class=\"line\">       &#125;</div><div class=\"line\"></div><div class=\"line\">       return returnValue1;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<p> invokeForRequest方法通过getMethodArgumentValues从request中获取到了方法的参数列表args，然后调用了invoke反射调用了方法。所以可以看出getMethodArgumentValues中做了request参数到方法参数的转换。继续到里面看。</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\">private Object[] getMethodArgumentValues(NativeWebRequest request, ModelAndViewContainer mavContainer, Object... providedArgs) throws Exception &#123;</div><div class=\"line\">\t\t //获取所有参数</div><div class=\"line\">       MethodParameter[] parameters = this.getMethodParameters();</div><div class=\"line\">       Object[] args = new Object[parameters.length];</div><div class=\"line\"></div><div class=\"line\">\t //每个参数进行处理，从request中找到参数值</div><div class=\"line\">       for(int i = 0; i &lt; parameters.length; ++i) &#123;</div><div class=\"line\">           MethodParameter parameter = parameters[i];</div><div class=\"line\">           parameter.initParameterNameDiscovery(this.parameterNameDiscoverer);</div><div class=\"line\">           //处理提供的数据类型转换，这里传值new Object，所以没用到</div><div class=\"line\">           GenericTypeResolver.resolveParameterType(parameter, this.getBean().getClass());</div><div class=\"line\">           args[i] = this.resolveProvidedArgument(parameter, providedArgs);</div><div class=\"line\">           //如果前面提供的数据类型无法转换</div><div class=\"line\">           if(args[i] == null) &#123;</div><div class=\"line\">               //判断自己的类型转换器能否支持该参数类型</div><div class=\"line\">               if(this.argumentResolvers.supportsParameter(parameter)) &#123;</div><div class=\"line\">                   try &#123;</div><div class=\"line\">                   \t//转换参数</div><div class=\"line\">                       args[i] = this.argumentResolvers.resolveArgument(parameter, mavContainer, request, this.dataBinderFactory);</div><div class=\"line\">                   &#125; catch (Exception var9) &#123;</div><div class=\"line\">                       if(this.logger.isTraceEnabled()) &#123;</div><div class=\"line\">                           this.logger.trace(this.getArgumentResolutionErrorMessage(&quot;Error resolving argument&quot;, i), var9);</div><div class=\"line\">                       &#125;</div><div class=\"line\"></div><div class=\"line\">                       throw var9;</div><div class=\"line\">                   &#125;</div><div class=\"line\">               &#125; else if(args[i] == null) &#123;</div><div class=\"line\">                   String msg = this.getArgumentResolutionErrorMessage(&quot;No suitable resolver for argument&quot;, i);</div><div class=\"line\">                   throw new IllegalStateException(msg);</div><div class=\"line\">               &#125;</div><div class=\"line\">           &#125;</div><div class=\"line\">       &#125;</div><div class=\"line\"></div><div class=\"line\">       return args;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<p>逻辑在注释中写的差不多了，重点的地方是this.argumentResolvers.supportsParameter(parameter)用来判断自己的参数类型转换器是否支持这种参数类型，然后this.argumentResolvers.resolveArgument来处理参数类型转换。</p>\n<p>先来看下this.argumentResolvers.supportsParameter(parameter)，argumentResolvers是一个HandlerMethodArgumentResolverComposite类型的变量，HandlerMethodArgumentResolverComposite是一个Resolver的包装器。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">public boolean supportsParameter(MethodParameter parameter) &#123;</div><div class=\"line\">       return this.getArgumentResolver(parameter) != null;</div><div class=\"line\">   &#125;</div><div class=\"line\">   </div><div class=\"line\">   private HandlerMethodArgumentResolver getArgumentResolver(MethodParameter parameter) &#123;</div><div class=\"line\">       HandlerMethodArgumentResolver result = (HandlerMethodArgumentResolver)this.argumentResolverCache.get(parameter);</div><div class=\"line\">       if(result == null) &#123;</div><div class=\"line\">           Iterator i$ = this.argumentResolvers.iterator();</div><div class=\"line\"></div><div class=\"line\">           while(i$.hasNext()) &#123;</div><div class=\"line\">               HandlerMethodArgumentResolver methodArgumentResolver = (HandlerMethodArgumentResolver)i$.next();</div><div class=\"line\">               if(this.logger.isTraceEnabled()) &#123;</div><div class=\"line\">                   this.logger.trace(&quot;Testing if argument resolver [&quot; + methodArgumentResolver + &quot;] supports [&quot; + parameter.getGenericParameterType() + &quot;]&quot;);</div><div class=\"line\">               &#125;</div><div class=\"line\"></div><div class=\"line\">               if(methodArgumentResolver.supportsParameter(parameter)) &#123;</div><div class=\"line\">                   result = methodArgumentResolver;</div><div class=\"line\">                   this.argumentResolverCache.put(parameter, methodArgumentResolver);</div><div class=\"line\">                   break;</div><div class=\"line\">               &#125;</div><div class=\"line\">           &#125;</div><div class=\"line\">       &#125;</div><div class=\"line\"></div><div class=\"line\">       return result;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<p>methodArgumentResolver.supportsParameter(parameter)这一句调用了每个Resolver的support方法。关于Resolver是什么，可以看我的上一篇博客。</p>\n<p><a href=\"http://zwgeek.com/2016/12/28/SpringMVC%E5%AF%B9%E8%B1%A1%E7%BB%91%E5%AE%9A%E8%87%AA%E5%AE%9A%E4%B9%89%E5%90%8D%E7%A7%B0%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB/\">SpringMVC对象绑定时自定义名称对应关系</a></p>\n<p>其实简单来说就是一种类型处理器，我的项目在运行的时候回默认置入24个类型处理器，基本能处理各种类型转换，另外也可以自己自定义类型处理器。传送门里的文章有讲，包括类型处理器是怎么处理类型转换的，里面也有说。总之，类型处理器在argumentResolvers.resolveArgument处理完参数后，会把request的参数转成一个Object[]的列表返回，就是Controller中方法的参数列表。</p>\n<p>然后invokeForRequest方法会调用invoke去通过反射调用到Controller中对应的方法。</p>\n<h2 id=\"4-总结\"><a href=\"#4-总结\" class=\"headerlink\" title=\"4. 总结\"></a>4. 总结</h2><p>恩，到目前为止，一个request已经被SpringMVC处理后调到了Controller中对应的方法。然后Controller里面就是我们自己的逻辑了。接下来还有doDispatch的后几步，处理Controller的返回并处理成视图返回给用户。这个在以后的文章中慢慢说明。</p>\n<p>看Spring的源码，有一个很大的感受就是把抽象接口运用到了极致，几乎所有的处理器都会抽象出一个接口，然后下面会有各种各样的实现。这样处理之后整个流程几乎不涉及具体业务，只有流程规范，非常的容易理解。不得不说是一个让强迫症患者神清气爽的框架。</p>\n<p>另外还有一个感受就是，这套框架非常灵活。几乎所有的类都可以做的定制化，每一步处理过程都可以定制化，这样有利有弊，好处就是非常灵活，没有解决不了的问题，坏处就是可能一个地方没理解清楚就会出错。所有在定制化的时候还是要小心一点。</p>\n<p>接下来应该会有两篇文章，一篇是讲SpringMVC框架处理Controller的返回结果到视图，再一篇讲下Spring框架初始化Bean和BeanFactory的过程，其实也都在上面讲的流程里面，只是我略过去了。</p>\n<p>例行推广一下我的博客，喜欢这篇文章的朋友可以关注我的博客<a href=\"http://zwgeek.com\">http://zwgeek.com</a></p>\n"},{"title":"TensorFlow入门1-CNN网络及MNIST例子讲解","date":"2018-04-08T11:17:06.000Z","_content":"\n## 1. 前言\n人工智能自从阿尔法狗大败李世石后就异常火爆，最近工作中需要探索 AI 在移动端的应用，趁着这个计划入门下深度学习吧。\n\n深度学习的入门曲线还是很陡峭的，看了很多资料，询问了从事相关工作的朋友后终于有点感觉了，这篇文章就讲一下我在这个过程中的所见所得吧，肯定是不专业的，如果所说有什么错误，也希望大家帮忙指出，共同进步。\n\n这个入门的文章准备分以下几个部分来说：\n\n- CNN 的原理\n- TensorFlow 使用 CNN 网络解决 MNIST 问题的例子讲解\n- Demo 改造解决我自己的股票图片识别问题\n- 训练出的模型部署到 iOS 端的 TensorFlow Mobile 框架中\n- 训练出的模型部署到 iOS 端的 TensorFlow Lite 框架中\n\n首先我做的第一件事是分清楚一些概念，之前完全不懂得时候只觉得人工智能很厉害，能解决人力解决不了的问题，但人工智能到底是什么，完全不知道。既然要学习，首先就得分清楚人工智能，机器学习，深度学习都是些什么东西，需要从哪里入手等等这些问题。这个问了从事相关工作的同学后再查阅了一些资料后，很容易的就理解了。知乎上的这个回答比较靠谱，[传送门](https://www.zhihu.com/question/57770020)，总结一下就是这两句话。\n\n>机器学习：一种实现人工智能的方法\n>\n>深度学习：一种实现机器学习的技术\n\n而三者的关系就是\n\n![这里写图片描述](https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/Tensorflow%E5%85%A5%E9%97%A8/1.png)\n\n可以看的出来，人工智能是一个很大的概念，想用机器来解决问题的一种思想都可以认为是人工智能，而这个概念早在 19 世纪 50 年代就提出了。机器学习就是实现人工智能的一种方法，一切使用数据分析帮助决策的场景都可以叫做机器学习，这个概念从 19 世纪 80 年代到现在也已经发展了快 40 年了，机器学习其实一点都不神秘，在现代生产中的应用随处可见，比如各种网站的推荐算法，垃圾邮件的过滤算法等等。而最近火热的概念其实人工智能中很小的一部分，叫做深度学习。简单来说，使用深度神经网络去解决问题的学习方法叫做深度学习。如果说广义的机器学习是人类定义好规则，让计算机去做，那么深度学习就是人类定义好规则后，让计算机去学。深度学习依赖于现在计算能力的提升飞速发展，在图像识别、语音识别等领域发挥了巨大的作用。看完这篇文章后，你应该对深度学习会有一个简单的理解。\n\n考虑到机器学习的算法实在是太多，学习需要很多时间（按照我粗浅的理解，机器学习就是一整部统计学在计算机界的应用，很大）。而深度学习就相对单纯一些，据我所知，目前比较流行的深度学习算法就只有 CNN（卷积神经网络），RNN（循环神经网络）和 DNN（深度神经网络）。DNN 是整个深度学习的基础，后面的 CNN 和 RNN 其实都是基于DNN来做的，CNN（卷积神经网络）比较擅长于提取图片特征，处理图像问题。RNN 是把前一次网络的输出作为下一次网络的输入，让整个网络有了前因后果的概念，比较擅长处理有前后时间序列关系的问题，比如语音识别，语义分析等。\n\n根据之前列的大纲，这篇文章会先讲一下 CNN 网络的概念，然后讲一下 TensorFlow 中一个很有用的例子，用 CNN 网络去解决 MNIST 问题。大纲中剩下的部分会在接下来的文章中讲解。\n\n\n## 2. CNN神经网络\nCNN 神经网络，全称是卷积神经网络，是目前深度学习中最常见、应用最广泛的一种网络，适合于解决图像识别，图片分类，图像预测的问题。\n\n这里有一篇讲 CNN 比较好的文章，我看到很多大V讲到 CNN 的时候也会引用这篇文章的内容。有兴趣可以先看一下这篇文章。\n\n[An Intuitive Explanation of Convolutional Neural Networks](https://ujjwalkarn.me/2016/08/11/intuitive-explanation-convnets/)\n\n[译文：什么是卷积神经网络？为什么它们很重要？](http://www.hackcv.com/index.php/archives/104/?hmsr=toutiao.io&utm_medium=toutiao.io&utm_source=toutiao.io)\n\n如果不考虑 CNN，可以先思考下一个自己去实现一个分类图片的程序会怎么做。我之前做了一个判断一张图片是否是自选股截图的程序，自选股截图指的是下面这种图片。\n\n![这里写图片描述](https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/Tensorflow%E5%85%A5%E9%97%A8/2.png)\n\n首先我会去看这种图片有什么特征，很明显，自选股截图上面有规则的红绿方块，而其他图片是没有的。那么在程序中，我首先提取出图片的各个像素值，然后去查找这张图片中是否有这种红绿色块，查找红绿色块的算法，可以这样做，看红色的像素值的坐标是否是一个方块，或者绿色的像素值的坐标是否是一个方块。\n\n由上所知，一个典型的图片分类算法就是提取特征，比较特征。CNN 网络简单来说就是将这个过程自动化，开发人员不需要告诉网络图片的特征是什么，CNN 网络可以自动的从图片中寻找特征，并记录。这个过程是怎么做到的呢，下面来讲。\n\n输入一张图片，网络通过一系列的运算，提取出图片的特征。如下图所示：\n\n![这里写图片描述](https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/Tensorflow%E5%85%A5%E9%97%A8/3.png)\n\n当然，这中间的一系列计算是有算法和参数的。训练的时候我们会给每张图片打上一个对应的标签，CNN 通过上面一系列计算出特征后，每个特征就对应着一个标签。比如\n\n```\n特征1 -> 标签A \n特征2 -> 标签B \n特征3 -> 标签A \n```\n\n当下一张图进入训练时，CNN 网络仍然以上次训练计算出来的参数去提取特征，假如提取出的是特征 2，如果图片的标签是 B，那么证明参数正确，无需调整。如果提取出的是特征 2，但是图片的标签是 A，那么证明参数不准确，需要调整下参数。调整完参数后继续下次训练，以此类推，直到参数大概率准确的时候。\n\n很简单的去解释了 CNN 卷积神经网络是怎么工作的，当然实际的过程比这要复杂的多，提取特征需要一些算法，比如卷积、池化、激活，算法的参数也不是 1 个这么简单，而是几百万个。下面的文章中基于 TensorFlow 中一个很简单的例子 MNIST 问题的代码来讲一下 CNN 网络是怎样工作的。\n\n## 3. MNIST问题\n\nMNIST 问题就相当于图像处理的 Hello World 程序，在 TensorFlow 的官方教程里已经有一个完整的 Demo。\n\n[MNIST问题处理](http://www.tensorfly.cn/tfdoc/tutorials/mnist_beginners.html)\n\nMNIST 问题是很常见的图片分类问题，训练集是已经编码过的手写图片，图片中是手写的 0~9 的数字，模型经过训练后，输入一张图片，可以输出 0~9 的数字。\n\n### 3.1 输入集\n首先我们来看一下 MNIST 问题的输入集，数据集的介绍[传送门](http://yann.lecun.com/exdb/mnist/)。\n\n整个数据集由以下四个文件构成，\n\n```\n//训练集-图片数据\ntrain-images-idx3-ubyte.gz:  training set images (9912422 bytes) \n//训练集-label数据\ntrain-labels-idx1-ubyte.gz:  training set labels (28881 bytes) \n//测试集-图片数据\nt10k-images-idx3-ubyte.gz:   test set images (1648877 bytes) \n//测试集-label数据\nt10k-labels-idx1-ubyte.gz:   test set labels (4542 bytes)\n```\n\n训练集-图片数据的格式如下\n\n```\n[offset] [type]          [value]          [description] \n0000     32 bit integer  0x00000803(2051) magic number \n0004     32 bit integer  60000            number of images \n0008     32 bit integer  28               number of rows \n0012     32 bit integer  28               number of columns \n0016     unsigned byte   ??               pixel \n0017     unsigned byte   ??               pixel \n........ \nxxxx     unsigned byte   ??               pixel\n```\n\n训练集-label 数据的格式如下\n\n```\n[offset] [type]          [value]          [description] \n0000     32 bit integer  0x00000801(2049) magic number (MSB first) \n0004     32 bit integer  60000            number of items \n0008     unsigned byte   ??               label \n0009     unsigned byte   ??               label \n........ \nxxxx     unsigned byte   ??               label\nThe labels values are 0 to 9.\n```\n\n测试集的数据格式和训练集是一样的。\n\n首先我们写个程序试着解析一下这些数据：\n\n```\n#coding=utf-8\nimport os\nimport struct\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\ndef load_mnist(path, kind='train'):\n    # 读取文件\n    labels_path = os.path.join(path,\n                               '%s-labels-idx1-ubyte'\n                               % kind)\n    images_path = os.path.join(path,\n                               '%s-images-idx3-ubyte'\n                               % kind)\n    with open(labels_path, 'rb') as lbpath:\n        # 读取magic numer，labels数量\n        magic, n = struct.unpack('>II',\n                                 lbpath.read(8))\n        print 'label magic : ',\n        print magic\n        # 载入label数据\n        labels = np.fromfile(lbpath,\n                             dtype=np.uint8).reshape(n, 1)\n\n    with open(images_path, 'rb') as imgpath:\n        # 读取magic numer，图片数量，图片宽，高\n        magic, num, rows, cols = struct.unpack('>IIII',\n                                               imgpath.read(16))\n        print 'image magic : ',\n        print magic\n        # 载入图片数据\n        images = np.fromfile(imgpath,\n                             dtype=np.uint8).reshape(num, rows * cols)\n\n    return images, labels, rows, cols\n\n\ndef show_image():\n    images, labels, rows, cols = load_mnist('/tmp/TensorFlow/mnist/input_data/')\n    fig, ax = plt.subplots(\n        nrows=2,\n        ncols=5,\n        sharex=True,\n        sharey=True, )\n\n    ax = ax.flatten()\n    for i in range(10):\n        img = images[i].reshape(rows, cols)\n        print labels[i]\n        ax[i].imshow(img, cmap='Greys', interpolation='nearest')\n\n    ax[0].set_xticks([])\n    ax[0].set_yticks([])\n    plt.tight_layout()\n    plt.show()\n\n\nif __name__ == '__main__':\n  show_image()\n\n\n```\n\n运行程序后，会显示输入集的前 10 张图片，如下图所示：\n\n![](https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/Tensorflow%E5%85%A5%E9%97%A8/Snip20180503_1.png)\n\n在控制台会输出 labels\n\n```\nlabel magic :  2049\nimage magic :  2051\n[5] [0] [4] [1] [9] [2] [1] [3] [1] [4]\n```\n\n这是一个 CNN 模型需要的典型的输入，有一些数据，每个数据都有一个 label。后面我们做自己项目的时候，也是这种数据格式。\n\n因为 MNIST 问题是个比较典型的问题，所以 TensorFlow 甚至封装了解析的方法。\n\n### 3.2 MNIST问题代码解析\n完整的代码在 TensorFlow 的 /TensorFlow/git/TensorFlow/TensorFlow/examples/tutorials/mnist/mnist_deep.py 里面。\n\n我们根据程序的运行顺序来看一下。\n\n#### 3.2.1 读取数据\n\n```\nif __name__ == '__main__':\n  # 解析命令行参数，默认没有\n  parser = argparse.ArgumentParser()\n  # 添加MNIST数据集的下载地址\n  parser.add_argument('--data_dir', type=str,\n                      default='/tmp/TensorFlow/mnist/input_data',\n                      help='Directory for storing input data')\n  FLAGS, unparsed = parser.parse_known_args()\n  # 运行main方法\n  tf.app.run(main=main, argv=[sys.argv[0]] + unparsed)\n```\n\n```\n  # Import data\n  mnist = input_data.read_data_sets(FLAGS.data_dir)\n```\n代码将 MNIST 的下载和解析过程封装了一次，看下 read\\_data\\_sets 方法\n\n```\ndef read_data_sets(train_dir,\n                   fake_data=False,\n                   one_hot=False,\n                   dtype=dtypes.float32,\n                   reshape=True,\n                   validation_size=5000,\n                   seed=None,\n                   source_url=DEFAULT_SOURCE_URL):\n                   ...\n                   return base.Datasets(train=train, validation=validation, test=test)\n```\n\n这个方法最后返回的是一个 Datasets 格式，里面 train，validation 和 test 都是已经解析好的数据，解析方法就类似于上一节讲到的。\n\n读到这里，你可能有个疑问，MNIST 数据里面只有 train 和 test，那验证数据集 validation 是哪里来的。这里 validation 使用的就是 train 数据集。CNN 网络在每次训练完之后运行 validation 数据集，可以让开发者了解目前的准确度，在所有训练结束之后运行 test 数据集，可以知道训练出的这个模型的准确度。所以运行 validation 数据只是给开发者参考用的，这里对数据的要求不是很严苛，可以直接用 train 的数据集，而最后测试模型的准确度时使用的 test 数据集一定不能是 train 里面的数据，因为如果两个数据集有重合，可能无法准确的测试模型的准确度。\n\n#### 3.2.2 定义输入输出\n\n```\n  # Create the model\n  x = tf.placeholder(tf.float32, [None, 784], name=\"x\")\n\n  # Define loss and optimizer\n  y_ = tf.placeholder(tf.int64, [None])\n  \n```\n\ntf.placeholder 可以理解为定义占位符，这些占位符虽然定义的时候没有值，但在实际运行中会给定输入值。这里定义了两个占位符，一个是输入值 x，类型是浮点数，维度是 [None, 784]，None 代表不确定数量，784 代表 28*28，也就是一张 MNIST 输入集的图片，这里的意思是说输入层x可以是不确定数量的图片，代表着我们这个网络可以同时输入多张图片的数据。这种变量就是 TensorFlow 的张量 tensor，而每个 tensor 都可以指定名称，但是我们一般只指定具有代表性的几个 tensor 的名称，比如这个输入节点的名称是 x。\n\n而 y_ 声明的存储 label 的变量，类型是 int 类型，因为 label 是 1-10，也是不确定数量的，因为前面x输入多少图片，这里的 label 就应该有多少数量。\n\n声明一个变量为什么要如此复杂，为什么不能像我们写程序一样直接声明 float x = 5 这样。这里需要给读者讲解一下 TensorFlow 计算图和静态图的概念。训练一个深度学习网络的时候，是需要大量计算的，而深度学习框架为了加快计算速度，会直接把计算的过程扔给 CPU 或 GPU 去运行，CPU 和 GPU 运行结束后返回框架结果。举个简单的例子，如果我们要计算 3\\*5+2，普通的程序是先计算 3\\*5，得到结果之后再 +2，得到结果。如果 TensorFlow 也这样做的话，相当于让 CPU 算 3\\*5， CPU 算完后返回结果，然后把返回的结果和 2 再扔给 CPU 去算，最后得到结果。但是需要知道的是，每一次和CPU的交互其实都是特别浪费时间的，所以如果像普通的程序一样，那训练神经网络会特别耗时。所以有一些深度学习框架像 TensorFlow 提出了静态图的概念，首先定义好整个计算图，放在前面的例子里，就是定义好“先乘后加”，然后将需要计算的数字和这个计算图扔给 CPU，最后 CPU 会计算出一个最终的结果返回给框架，这样整个过程中框架和CPU只有一次交互。这样做可以提升计算的速度，但是有一个致命的缺点是不能调试，你不能在 3*5 之后打个断点看看结果对不对，你只能知道最后的结果是不是正确。\n\n所以 tf.placeholder 只是定义了整个计算图中的一个节点 tensor，所以必须用TensorFlow 定义 tensor 的语法。\n\n#### 3.2.3 定义计算图\n\n```\n# Build the graph for the deep net\n  y_conv = deepnn(x)\n```\n\ndeepnn 这个方法是整个程序的核心，在这个方法中定义了一整个计算图。我们一层一层的看。这个 CNN 的网络用的是LeNet网络。构成是这样的。\n\n![这里写图片描述](https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/Tensorflow%E5%85%A5%E9%97%A8/4.png)\n\n其中有两层卷积层，两层池化层，最后输出层是两层全连接层。代码如下：\n\n```\ndef deepnn(x):\n  \"\"\"deepnn builds the graph for a deep net for classifying digits.\n\n  Args:\n    x: an input tensor with the dimensions (N_examples, 784), where 784 is the\n    number of pixels in a standard MNIST image.\n\n  Returns:\n    A tuple (y, keep_prob). y is a tensor of shape (N_examples, 10), with values\n    equal to the logits of classifying the digit into one of 10 classes (the\n    digits 0-9). keep_prob is a scalar placeholder for the probability of\n    dropout.\n  \"\"\"\n  # Reshape to use within a convolutional neural net.\n  # Last dimension is for \"features\" - there is only one here, since images are\n  # grayscale -- it would be 3 for an RGB image, 4 for RGBA, etc.\n  with tf.name_scope('reshape'):\n    x_image = tf.reshape(x, [-1, 28, 28, 1])\n\n  # First convolutional layer - maps one grayscale image to 32 feature maps.\n  with tf.name_scope('conv1'):\n    W_conv1 = weight_variable([5, 5, 1, 32])\n    b_conv1 = bias_variable([32])\n    h_conv1 = tf.nn.relu(conv2d(x_image, W_conv1) + b_conv1)\n\n  # Pooling layer - downsamples by 2X.\n  with tf.name_scope('pool1'):\n    h_pool1 = max_pool_2x2(h_conv1)\n\n  # Second convolutional layer -- maps 32 feature maps to 64.\n  with tf.name_scope('conv2'):\n    W_conv2 = weight_variable([5, 5, 32, 64])\n    b_conv2 = bias_variable([64])\n    h_conv2 = tf.nn.relu(conv2d(h_pool1, W_conv2) + b_conv2)\n\n  # Second pooling layer.\n  with tf.name_scope('pool2'):\n    h_pool2 = max_pool_2x2(h_conv2)\n\n  # Fully connected layer 1 -- after 2 round of downsampling, our 28x28 image\n  # is down to 7x7x64 feature maps -- maps this to 1024 features.\n  with tf.name_scope('fc1'):\n    W_fc1 = weight_variable([7 * 7 * 64, 1024])\n    b_fc1 = bias_variable([1024])\n\n    h_pool2_flat = tf.reshape(h_pool2, [-1, 7 * 7 * 64])\n    h_fc1 = tf.nn.relu(tf.matmul(h_pool2_flat, W_fc1) + b_fc1)\n\n  # Map the 1024 features to 10 classes, one for each digit\n  with tf.name_scope('fc2'):\n    W_fc2 = weight_variable([1024, 10])\n    b_fc2 = bias_variable([10])\n\n    y_conv = tf.add(tf.matmul(h_fc1, W_fc2), b_fc2, name=\"output\")\n  return y_conv\n```\n\n下面一层一层的看这个网络是怎么工作的。\n\n##### 卷积层\nCNN 叫卷积神经网络，可以看出卷积是这个网络的核心。卷积层是用于提取图片特征，卷积的操作是用一个卷积矩阵（也叫卷积核）在输入矩阵上依次扫描，做矩阵相乘，得到的结果输入矩阵的某一个特征。这样讲是不太好理解，下面用图片说一下这个过程。\n\n假设输入矩阵是这样的\n![这里写图片描述](https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/Tensorflow%E5%85%A5%E9%97%A8/5.png)\n\n选取如下一个卷积核\n![这里写图片描述](https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/Tensorflow%E5%85%A5%E9%97%A8/6.png)\n\n用卷积核在输入矩阵上依次扫过，做矩阵相乘的操作，就可以得到输入矩阵由这个卷积核提取的特征。\n\n![这里写图片描述](https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/Tensorflow%E5%85%A5%E9%97%A8/7.gif)\n\n>在 CNN 的术语中，3x3 的矩阵叫做“滤波器（filter）”或者“核（kernel）”或者“特征检测器（feature detector）”，通过在图像上滑动滤波器并计算点乘得到矩阵叫做“卷积特征（Convolved Feature）”或者“激活图（Activation Map）”或者“特征图（Feature Map）”。记住滤波器在原始输入图像上的作用是特征检测器。\n\n是不是在怀疑，这种操作真的能够提取特征吗，看下对实际图片进行卷积操作的例子。\n\n输入图像如下：\n![这里写图片描述](https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/Tensorflow%E5%85%A5%E9%97%A8/8.png)\n\n用不同的卷积核进行卷积操作的结果如下：\n\n![这里写图片描述](https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/Tensorflow%E5%85%A5%E9%97%A8/10.jpeg)\n\n可以看到，不同的卷积核对原图像进行处理后可以得到不同的特征图像，有的卷积核能提取边缘信息，有的卷积核能提取色彩信息，有的卷积核能提取明暗特征，等等等等。有没有觉得这一步特别像 PS 中的滤镜，其实卷积的操作和滤镜的操作是很类似的。不同的卷积就像不同的滤镜对不同的特征敏感度不同。而代码中的卷积层如下：\n\n```\n# First convolutional layer - maps one grayscale image to 32 feature maps.\n  with tf.name_scope('conv1'):\n    W_conv1 = weight_variable([5, 5, 1, 32])\n    b_conv1 = bias_variable([32])\n    h_conv1 = tf.nn.relu(conv2d(x_image, W_conv1) + b_conv1)\n```\n\n首先定义一个卷积核 W\\_conv1 变量，由于后面会多次定义变量，所以将定义变量的部分提取了方法，如下：\n\n```\ndef weight_variable(shape):\n  \"\"\"weight_variable generates a weight variable of a given shape.\"\"\"\n  initial = tf.truncated_normal(shape, stddev=0.1)\n  return tf.Variable(initial)\n```\n\ntf.Variable 生成一个变量 tensor，参数 initial 是初始化值。initial 由truncated\\_normal 方法生成，shape 指定了生成变量的维度，这里是[5,5,1,32]四维的变量，初始化值是由 truncated\\_normal 产生的正态分布的值，这就是 truncated\\_normal 方法的作用，详细的说明可以看文档。\n\n相对于卷积核的声明，偏量 b\\_conv1 的生成要简单一点。\n\n```\ndef bias_variable(shape):\n  \"\"\"bias_variable generates a bias variable of a given shape.\"\"\"\n  initial = tf.constant(0.1, shape=shape)\n  return tf.Variable(initial)\n```\n\n初始化值是固定的 0.1。\n这两个变量的初始化值不能是 0，而要加入一些脏值，是为了打破对称性以及避免 0 梯度，提升模型训练的效率。\n\n后面的代码就是执行卷积操作，我们来看，\n\n``conv2d(x_image, W_conv1)``\n\n```\ndef conv2d(x, W):\n  \"\"\"conv2d returns a 2d convolution layer with full stride.\"\"\"\n  return tf.nn.conv2d(x, W, strides=[1, 1, 1, 1], padding='SAME')\n```\n\n这个函数就是 TensorFlow 中用于做卷积的函数，2d 代表生成的是一个二维特征图，这个是什么意思呢，后面会提到。除了 conv2d，还有 conv1d 和 conv3d 函数。\n\n看下 conv2d 的函数签名。\n\n```\ntf.nn.conv2d(input, filter, strides, padding, use_cudnn_on_gpu=None, name=None)\n```\n\n除去 name 参数用以指定该操作的 name，与方法有关的一共五个参数：\n\n第一个参数 input：指需要做卷积的输入图像，它要求是一个 tensor，具有 [batch, in_height, in_width, in_channels] 这样的 shape，具体含义是[训练时一个 batch 的图片数量, 图片高度, 图片宽度, 图像通道数]，注意这是一个 4 维的 tensor，要求类型为 float32 和 float64 其中之一\n\n第二个参数 filter：相当于 CNN 中的卷积核，它要求是一个 tensor，具有 [filter_height, filter_width, in_channels, out_channels] 这样的shape，具体含义是[卷积核的高度，卷积核的宽度，图像通道数，卷积核个数]，要求类型与参数 input 相同，有一个地方需要注意，第三维 in_channels，就是参数 input 的第四维\n\n第三个参数 strides：卷积时在图像每一维每一次移动的步长，这是一个一维的向量，长度跟前面卷积核的维度相同，这里是4。\n\n第四个参数 padding：string 类型的量，只能是 \"SAME\", \"VALID\" 其中之一，这个值决定了不同的卷积方式\n\n第五个参数：use\\_cudnn\\_on\\_gpu: bool 类型，是否使用 cudnn 加速，默认为 true，cudnn 是英伟达的GPU处理单元，这里也就是用 GPU 进行加速计算。\n\n###### 二维特征向量\nconv2d 生成的是二维特征向量，conv2d 有两个参数是必要的，input 和 filter。我们的输入参数是一张图片，三维的数据[宽，高，颜色空间]，为了最后向量相乘的结果是二维的，filer 的第三个维度应该和 input 的第四个维度相等，也就是 in\\_channels 相等，这样永远都只能输出一个二维的特征向量，也就是这个函数叫 conv2d 的原因，这里比较难理解，可以仔细考虑一下。\n\n###### padding参数\npadding 参数的可选值是 SAME 和 VALID，这个参数影响了了卷积核对输入矩阵边缘的处理，决定了输出的特征向量大小。\n\n卷积核和按照步数一步步的扫描输入矩阵，做乘法操作。但是在输入矩阵的边缘，如果输入矩阵剩余的维度小于定义的卷积核的维度，那么卷积核就无法做乘法操作了，剩余这部分边界怎么处理呢。\n\n如果 padding 是 SAME，则会在输入矩阵的两端补齐 0，使补齐后的输入矩阵维度刚好可以被卷积核处理，最后得到的特征矩阵和原来的输入矩阵维度相同。\n\n![这里写图片描述](https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/Tensorflow%E5%85%A5%E9%97%A8/11.png)\n\n如果 padding 是 VALID，则会抛弃边界的节点，最后输出的特征矩阵维度和输入矩阵不相同\n\n![这里写图片描述](https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/Tensorflow%E5%85%A5%E9%97%A8/12.png)\n\n再回来看代码\n\n```\n  W_conv1 = weight_variable([5, 5, 3, 32])\n  conv2d(x_image, W_conv1)\n```\n\n卷积核是 5\\*5\\*3 的，一共 32 个卷积核，对图像处理后，可以得到32个特征向量，因为我们没有指定步长和 padding，所以步长默认是1，padding 是 SAME，这样的话，输出的特征矩阵就是28 * 28 * 1。\n\n```\n# 第一个卷积层，从图像中提取32的特征\nwith tf.name_scope('conv1'):\n    W_conv1 = weight_variable([5, 5, 3, 32])  # y =wX+b\n    b_conv1 = bias_variable([32])\n    h_conv1 = tf.nn.relu(conv2d(x_image, W_conv1) + b_conv1)\n```\n\n做完了卷积后，进行了一个relu处理\n\n>ReLU 是一个元素级别的操作（应用到各个像素），并将特征图中的所有小于 0 的像素值设置为零。ReLU 的目的是在 ConvNet 中引入非线性，因为在大部分的我们希望 ConvNet 学习的实际数据是非线性的（卷积是一个线性操作——元素级别的矩阵相乘和相加，所以我们需要通过使用非线性函数 ReLU 来引入非线性。\n\n引入非线性可以让神经网络更好的工作，这个更好的工作指的是在做反向传播的时候避免出现梯度消失的问题，原因涉及到比较深的理论，这篇文章就不多说了。\n\n这样第一个卷积操作就结束了。\n\n##### 池化\n卷积操作之后是一个池化层。\n\n```\n# Pooling layer - downsamples by 2X.\n  with tf.name_scope('pool1'):\n    h_pool1 = max_pool_2x2(h_conv1)\n```\n\n池化的作用类似于压缩，这种压缩是在缩小输入值的维度的同时还要保持输入值的特征。比如在 2*2 的 4 个像素点中取最大值，最小值或者平均值。不过经过研究，最大池化能够比较好的保持原来的特征值。\n\n![这里写图片描述](https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/Tensorflow%E5%85%A5%E9%97%A8/13.png)\n\n\n```\n# 2*2的最大化池化层\n    with tf.name_scope('pool1'):\n        h_pool1 = max_pool_2x2(h_conv1)\n```\n\n```\ndef max_pool_2x2(x):\n  \"\"\"max_pool_2x2 downsamples a feature map by 2X.\"\"\"\n  return tf.nn.max_pool(x, ksize=[1, 2, 2, 1],\n                        strides=[1, 2, 2, 1], padding='SAME')\n```\n\n池化操作也是调用的 TensorFlow 的函数，参数 strides 和 padding 跟前面提到的 conv2d 函数的参数一致。ksize 是定义的在每个维度上池化的大小，上一步卷积之后，输出的特征向量是 1\\*28\\*28\\*1，所以在中间两个维度进行处理。\n\n\n```\n# Second convolutional layer -- maps 32 feature maps to 64.\n  with tf.name_scope('conv2'):\n    W_conv2 = weight_variable([5, 5, 32, 64])\n    b_conv2 = bias_variable([64])\n    h_conv2 = tf.nn.relu(conv2d(h_pool1, W_conv2) + b_conv2)\n\n  # Second pooling layer.\n  with tf.name_scope('pool2'):\n    h_pool2 = max_pool_2x2(h_conv2)\n```\n\n后面又做了一个卷积操作和一个池化操作，这个跟前面的操作是一样的。卷积操作的输出不影响输入值的维度，但是影响输入值的深度。池化操作不影响输入值的深度但是影响输入值的维度，经过两层的卷积和 2*2 的池化后，输入值的维度变成了原来的 1/4。深度变成 64。也就是 7\\*7\\*64。\n\n上面的几层又叫隐藏层，表示使用者看不到的处理层。\n\n##### 全连接\n\n接下来是输出层，输出层是两个全连接层。\n\n```\n  # Fully connected layer 1 -- after 2 round of downsampling, our 28x28 image\n  # is down to 7x7x64 feature maps -- maps this to 1024 features.\n  with tf.name_scope('fc1'):\n    W_fc1 = weight_variable([7 * 7 * 64, 1024])\n    b_fc1 = bias_variable([1024])\n\n    h_pool2_flat = tf.reshape(h_pool2, [-1, 7 * 7 * 64])\n    h_fc1 = tf.nn.relu(tf.matmul(h_pool2_flat, W_fc1) + b_fc1)\n\n  # Map the 1024 features to 10 classes, one for each digit\n  with tf.name_scope('fc2'):\n    W_fc2 = weight_variable([1024, 10])\n    b_fc2 = bias_variable([10])\n\n    y_conv = tf.add(tf.matmul(h_fc1, W_fc2), b_fc2, name=\"output\")\n```\n\n全连接层，顾名思义，指的是这一层的每个节点都跟上一层的全部节点有连接。\n\n![全连接节点](https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/Tensorflow%E5%85%A5%E9%97%A8/Snip20180423_2.png)\n\n比如图中全连接层的节点 a1 与上一层的所有节点 x1,x2,x3 有联系，a2 也与上一层的所有节点有联系，就这样，少一个也不行。因此解释全连接层的时候，图就是这样一个网状结构。\n\n上文中提到了联系，这里的“联系”具体指的是什么呢。如图所示，假设 x1，x2，x3 是全连接层的输入值，那么在全连接层的a1可以表示为以下的形式。\n\n![](https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/Tensorflow%E5%85%A5%E9%97%A8/Snip20180423_3.png)\n\n从这个公式可以看出，a1 与 x1，x2，x3 都有联系，只是输入节点的权重值不同。同理，a2 和 a3 也可以表示为以下的形式。\n\n![](https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/Tensorflow%E5%85%A5%E9%97%A8/Snip20180423_4.png)\n\n由此就可以从数学层面去理解什么叫全连接层，但是这个全连接层在实际应用中表示得意义是什么呢，简单来说，它可以作为一个分类网络，还是上面那个图，输入层是 3 个值，全连接层是 3 个节点，就代表这个全连接层可以把上一层的特征值分类为三种特征。当然，输入层和全连接层的节点数并不一定相同，比如下面这个结构。\n\n![](https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/Tensorflow%E5%85%A5%E9%97%A8/Snip20180423_5.png)\n\n最后的全连接层是 10 个节点，全连接层的上一层是 15 个特征值，这样就把 15 个特征值归类为 10 种特征。举例来说，比如输出的 15 个特征标记位 t1-15，而 t1，t3，t5 三种特征可以认为都属于某一种输出 o1。而 t2，t6 两种特征可以认为属于输出 o2，以此类推，就可以把15个特征分类为 10 个输出。\n\n前面提到的MNIST问题中，全连接层有两层，第一层是 1024 个节点，第二层是 10 个节点。一般情况下，最靠近用户的输出层就是用户所期待的结果类别数，MNIST 问题中，用户期待的输出是 0-9 一共 10 个数字也就是 10 种类别，所以第二层全连接层是 10 个节点。再往前看，卷积层在每一个像素点上提取 64 个特征值，所以整个图片可以有高\\*宽\\*64个特征值，也就是 7\\*7\\*64 个特征，第一个全连接层是 1024 个节点，表示希望这个网络将这 7\\*7\\*64 个特征归类为 1024 个分类。至于为什么第一个连接层是 1024 个节点，是一个经验值的问题，这个节点的个数是可以调整的，后面会讲到全连接层对模型体积的影响，也会再说到这个经验值的问题。那么全连接层是如何分类的。一起来看一下。\n\n回顾一下全连接层的表示公式。\n\n![](https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/Tensorflow%E5%85%A5%E9%97%A8/Snip20180423_3.png)\n\n这里的输入值 x1,x2,x3...，输出值 a1 和权重 W，偏移量 b 到底指的是什么呢。\n\n在MNIST的基础上，可以考虑这样一种情况。看下面这个图，对于0这个数字来说，我们经过训练之后，认为如果一张图片在中间红色部分出现了像素值，那这张图有一定概率不是 0，并且出现在红色部分的像素值越多，不是 0 的概率越大。如果在周围一圈的蓝色部分出现了像素值，那么这张图有一定概率是 0，并且出现在蓝色部分的像素值越多，是 0 的概率越大。\n\n![](https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/Tensorflow%E5%85%A5%E9%97%A8/Snip20180423_6.png)\n\n这个过程用数学公式怎么表示呢，蓝色部分拥有正值的权重，红色部分拥有负值的权重，将输入图片的每个像素点与权重值进行相乘后求和，这样如果红色部分出现的像素值越多，则最后的和越小，如果蓝色部分出现的像素值越多，则最后的和越大。最后得出的结果我们称为是输入图片x是这种分类（比如分类0）的证据 evidence。这样对于一张输入的图片，最后落在每个节点上的 evidence 就可以用如下的公式表示。\n\n![](https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/Tensorflow%E5%85%A5%E9%97%A8/Snip20180427_1.png)\n\n看这个公式，是不是就是全连接层的公式。所以全连接层这个过程比较绕，但是是深度学习网络的基本原理，可以仔细理解一下。\n\n反过来看代码。\n\n```\n  # Fully connected layer 1 -- after 2 round of downsampling, our 28x28 image\n  # is down to 7x7x64 feature maps -- maps this to 1024 features.\n  with tf.name_scope('fc1'):\n    W_fc1 = weight_variable([7 * 7 * 64, 1024])\n    b_fc1 = bias_variable([1024])\n\n    h_pool2_flat = tf.reshape(h_pool2, [-1, 7 * 7 * 64])\n    h_fc1 = tf.nn.relu(tf.matmul(h_pool2_flat, W_fc1) + b_fc1)\n```\n\n首先生成全连接层的权重 W\\_fc1 和偏量 b\\_fc1，这里复用了前面卷积操作生成卷积核和偏量的两个方法，虽然概念不同，但计算是相通的，所以可以复用。tf.reshape(h_pool2, [-1, 7 * 7 * 64]) 将之前层的四维 [1,7,7,64] 的输出变成一个一维的向量，因为全连接层只能处理一维的问题。后面用 tf.matmul 向量乘法实现了全连接层的操作。tf.nn.relu 和前面一样，是个激活函数。\n\n##### droupout\n\n在第一层全连接层之后，加了一个 dropout 的操作\n\n```\n  # Dropout - controls the complexity of the model, prevents co-adaptation of\n  # features.\n  with tf.name_scope('dropout'):\n    keep_prob = tf.placeholder(tf.float32)\n    h_fc1_drop = tf.nn.dropout(h_fc1, keep_prob)\n```\n\ndroupout 的操作如下图所示：\n![](https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/Tensorflow%E5%85%A5%E9%97%A8/Snip20180504_2.png)\n\n在计算的过程中，随机的“丢弃”一些节点，简单来说，h\\_fc1有 1024 个节点，在 droupout 之后，如果 keep\\_prob 是50%，那么经过 droupout 之后，可以认为参与计算的是 512 个节点。droupout 有两个优势。\n\n- 解决过拟合的问题\n- 在训练中加入概率性\n\ndroupout 操作之后又是一层全连接。\n\n```\n  # Map the 1024 features to 10 classes, one for each digit\n  with tf.name_scope('fc2'):\n    W_fc2 = weight_variable([1024, 10])\n    b_fc2 = bias_variable([10])\n\n    y_conv = tf.add(tf.matmul(h_fc1, W_fc2), b_fc2, name=\"output\")\n```\n\n第二层全连接将上一层产生的 1024 个节点归类到 10 个节点上，，得到最后的输出。即使经过 droupout 之后，实体依然是 1024 个节点，只是其中一部分不再参与计算。这个网络结构最后的输出是10个节点的 evidence 的值。\n\n#### 3.2.4 Softmax回归处理\n\n至此，整个计算图就定义完了，接下来定义一些训练中的必要单元来告知框架如何训练。\n\n```\n  with tf.name_scope('loss'):\n    cross_entropy = tf.losses.sparse_softmax_cross_entropy(\n        labels=y_, logits=y_conv)\n  cross_entropy = tf.reduce_mean(cross_entropy)\n```\n\n定义损失函数使用 softmax 交叉熵的，关于 softmax 和交叉熵，这里引用[传送门](https://blog.csdn.net/chaipp0607/article/details/73392175)一段描述。\n\n神经网络的原始输出不是一个概率值，实质上只是输入的数值做了复杂的加权和与非线性处理之后的一个值而已，那么如何将这个输出变为概率分布？ \n\n这就是 softmax 层的作用，假设神经网络的原始输出为 y1,y2,….,yn，那么经过 softmax 回归处理之后的输出为： \n\n![](https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/Tensorflow%E5%85%A5%E9%97%A8/Snip20180504_3.png)\n\n经过 softmax 的公式后，所有节点的和变成了 1，之前神经网络输出的每个节点的权重值变成了每个节点的概率值。\n\n单个节点的输出变成的一个概率值，经过 softmax 处理后结果作为神经网络最后的输出。label\n\n\n#### 3.2.5 交叉熵的原理\n\n交叉熵刻画的是实际输出（概率）与期望输出（概率）的距离，也就是交叉熵的值越小，两个概率分布就越接近。假设概率分布 p 为期望输出，概率分布 q 为实际输出，H(p,q) 为交叉熵，则：\n\n![](https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/Tensorflow%E5%85%A5%E9%97%A8/Snip20180504_4.png)\n\n这个公式如何表征距离呢，举个例子： \n假设 N=3，期望输出为 p = (1,0,0)，实际输出 q1 = (0.5,0.2,0.3)，q2 = (0.8,0.1,0.1)，那么：\n\n![](https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/Tensorflow%E5%85%A5%E9%97%A8/Snip20180504_5.png)\n\n很显然，q2 与 p 更为接近，它的交叉熵也更小。 \n除此之外，交叉熵还有另一种表达形式，还是使用上面的假设条件：\n\n![](https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/Tensorflow%E5%85%A5%E9%97%A8/Snip20180504_6.png)\n\n其结果为：\n\n![](https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/Tensorflow%E5%85%A5%E9%97%A8/Snip20180504_7.png)\n\n以上的所有说明针对的都是单个样例的情况，而在实际的使用训练过程中，数据往往是组合成为一个 batch 来使用，所以对用的神经网络的输出应该是一个 m*n 的二维矩阵，其中 m 为 batch 的个数，n为分类数目，而对应的 label 也是一个二维矩阵，还是拿上面的数据，组合成一个 batch=2 的矩阵：\n\n![](https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/Tensorflow%E5%85%A5%E9%97%A8/Snip20180504_8.png)\n\n所以交叉熵的结果应该是一个列向量（根据第一种方法）： \n\n![](https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/Tensorflow%E5%85%A5%E9%97%A8/Snip20180504_9.png)\n\n而对于一个 batch，最后取平均为 0.2。\n\ntf.losses.sparse\\_softmax\\_cross\\_entropy 是 TensorFlow 将以上两个过程封装后的产物，最后的结果是一个 batch 的概率值，reduce\\_mean 用来取得概率的平均值。综上作为整个网络的损失函数。\n\n#### 3.2.6 训练方法-梯度下降\n\n然后定义梯度下降的方法\n\n```\n  with tf.name_scope('adam_optimizer'):\n    train_step = tf.train.AdamOptimizer(1e-4).minimize(cross_entropy)\n```\n\n以下降步速，即学习率为1e-4的速度最小化损失函数 cross\\_entropy。这样就能定义训练的目的是为了让损失函数越来越来，每次参数的变化值为1e-4。\n\n#### 3.2.7 准确度\n\n定义准确度的计算方法\n\n```\n  with tf.name_scope('accuracy'):\n    correct_prediction = tf.equal(tf.argmax(y_conv, 1), y_)\n    correct_prediction = tf.cast(correct_prediction, tf.float32)\n  accuracy = tf.reduce_mean(correct_prediction)\n```\n\ny\\_conv 是网络输出的原始结果，也就是图片在最后 10 个节点上的权重值，比如 [314, -423, 342...] ，最后权重值最大的节点是我们的期望节点，比如这里第三个节点的权重值最大，那这幅图片可能就是数字 2，tf.argmax 是取出权重值最大的下标。y\\_ 是我们给的 label 值，把这两个值相比较得出准确度。最后依然用 tf.reduce_mean 算出 batch 的平均准确度。\n\n#### 3.2.8 计算图可视化\n\n```\n  graph_location = tempfile.mkdtemp()\n  print('Saving graph to: %s' % graph_location)\n  train_writer = tf.summary.FileWriter(graph_location)\n  train_writer.add_graph(tf.get_default_graph())\n```\n\n这是 TensorFlow 提供的计算图可视化的方法，这里暂时没起到作用。\n\n#### 3.2.9 启动计算图\n\n```\n  with tf.Session() as sess:\n    sess.run(tf.global_variables_initializer())\n    for i in range(20000):\n      batch = mnist.train.next_batch(50)\n      if i % 100 == 0:\n        train_accuracy = accuracy.eval(feed_dict={\n            x: batch[0], y_: batch[1], keep_prob: 1.0})\n        print('step %d, training accuracy %g' % (i, train_accuracy))\n      train_step.run(feed_dict={x: batch[0], y_: batch[1], keep_prob: 0.5})\n\n    print('test accuracy %g' % accuracy.eval(feed_dict={\n        x: mnist.test.images, y_: mnist.test.labels, keep_prob: 1.0}))\n```\n\n这里就是前面提到的将计算图和计算数据给 CPU 计算，TensorFlow 将和 CPU 的一个交互过程定义为 session，启动 session 后，开始运行。\n\n```\nsess.run(tf.global_variables_initializer())\n```\n\n首先将前面定义的所有变量初始化，注意前面在定义图的时候只是定义了变量初始化的方法，而没有真正去做初始化，真正运行是在这个地方。\n\n然后循环 20000 次，每次从训练集中取出50个图片数据作为一个 batch。\n\n```\ntrain_step.run(feed_dict={x: batch[0], y_: batch[1], keep_prob: 0.5})\n```\n\n开始训练，train_step 是前面定义的梯度下降的方法，以这种方法开始训练。参数是图片数据，正确的 labels，和 droupout 的参数。\n\n```\nif i % 100 == 0:\n        train_accuracy = accuracy.eval(feed_dict={\n            x: batch[0], y_: batch[1], keep_prob: 1.0})\n        print('step %d, training accuracy %g' % (i, train_accuracy))\n```\n\n每训练 100 次，输出一下当前的准确率，是为了开发者感知的。测试准确率的时候，是不需要 droupout 操作的，所以 keep\\_prob 是1。\n\n```\nprint('test accuracy %g' % accuracy.eval(feed_dict={\n        x: mnist.test.images, y_: mnist.test.labels, keep_prob: 1.0}))\n```\n\n20000 次训练之后，输出最终的准确率。\n\n输出结果类似这样的\n\n```\nstep 0, training accuracy 0.16\nstep 100, training accuracy 0.9\nstep 200, training accuracy 0.94\nstep 300, training accuracy 0.9\nstep 400, training accuracy 0.96\n...\ntest accuracy 0.9446\n```\n\n## 总结\n\n至此，整个模型的训练过程就完全结束了。通过这个例子，我们知道了一个 CNN 网络是怎么工作的，并且如何用 TensorFlow 来实现一个 CNN 网络。下一篇文章，我将写一下如果改造这个例子，来解决我的一个实际问题。\n","source":"_posts/Tensorflow入门.md","raw":"---\ntitle: TensorFlow入门1-CNN网络及MNIST例子讲解\ndate: 2018-04-08 19:17:06\ntags:\n  - TensorFlow\n  - CNN\ncategories: AI\n---\n\n## 1. 前言\n人工智能自从阿尔法狗大败李世石后就异常火爆，最近工作中需要探索 AI 在移动端的应用，趁着这个计划入门下深度学习吧。\n\n深度学习的入门曲线还是很陡峭的，看了很多资料，询问了从事相关工作的朋友后终于有点感觉了，这篇文章就讲一下我在这个过程中的所见所得吧，肯定是不专业的，如果所说有什么错误，也希望大家帮忙指出，共同进步。\n\n这个入门的文章准备分以下几个部分来说：\n\n- CNN 的原理\n- TensorFlow 使用 CNN 网络解决 MNIST 问题的例子讲解\n- Demo 改造解决我自己的股票图片识别问题\n- 训练出的模型部署到 iOS 端的 TensorFlow Mobile 框架中\n- 训练出的模型部署到 iOS 端的 TensorFlow Lite 框架中\n\n首先我做的第一件事是分清楚一些概念，之前完全不懂得时候只觉得人工智能很厉害，能解决人力解决不了的问题，但人工智能到底是什么，完全不知道。既然要学习，首先就得分清楚人工智能，机器学习，深度学习都是些什么东西，需要从哪里入手等等这些问题。这个问了从事相关工作的同学后再查阅了一些资料后，很容易的就理解了。知乎上的这个回答比较靠谱，[传送门](https://www.zhihu.com/question/57770020)，总结一下就是这两句话。\n\n>机器学习：一种实现人工智能的方法\n>\n>深度学习：一种实现机器学习的技术\n\n而三者的关系就是\n\n![这里写图片描述](https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/Tensorflow%E5%85%A5%E9%97%A8/1.png)\n\n可以看的出来，人工智能是一个很大的概念，想用机器来解决问题的一种思想都可以认为是人工智能，而这个概念早在 19 世纪 50 年代就提出了。机器学习就是实现人工智能的一种方法，一切使用数据分析帮助决策的场景都可以叫做机器学习，这个概念从 19 世纪 80 年代到现在也已经发展了快 40 年了，机器学习其实一点都不神秘，在现代生产中的应用随处可见，比如各种网站的推荐算法，垃圾邮件的过滤算法等等。而最近火热的概念其实人工智能中很小的一部分，叫做深度学习。简单来说，使用深度神经网络去解决问题的学习方法叫做深度学习。如果说广义的机器学习是人类定义好规则，让计算机去做，那么深度学习就是人类定义好规则后，让计算机去学。深度学习依赖于现在计算能力的提升飞速发展，在图像识别、语音识别等领域发挥了巨大的作用。看完这篇文章后，你应该对深度学习会有一个简单的理解。\n\n考虑到机器学习的算法实在是太多，学习需要很多时间（按照我粗浅的理解，机器学习就是一整部统计学在计算机界的应用，很大）。而深度学习就相对单纯一些，据我所知，目前比较流行的深度学习算法就只有 CNN（卷积神经网络），RNN（循环神经网络）和 DNN（深度神经网络）。DNN 是整个深度学习的基础，后面的 CNN 和 RNN 其实都是基于DNN来做的，CNN（卷积神经网络）比较擅长于提取图片特征，处理图像问题。RNN 是把前一次网络的输出作为下一次网络的输入，让整个网络有了前因后果的概念，比较擅长处理有前后时间序列关系的问题，比如语音识别，语义分析等。\n\n根据之前列的大纲，这篇文章会先讲一下 CNN 网络的概念，然后讲一下 TensorFlow 中一个很有用的例子，用 CNN 网络去解决 MNIST 问题。大纲中剩下的部分会在接下来的文章中讲解。\n\n\n## 2. CNN神经网络\nCNN 神经网络，全称是卷积神经网络，是目前深度学习中最常见、应用最广泛的一种网络，适合于解决图像识别，图片分类，图像预测的问题。\n\n这里有一篇讲 CNN 比较好的文章，我看到很多大V讲到 CNN 的时候也会引用这篇文章的内容。有兴趣可以先看一下这篇文章。\n\n[An Intuitive Explanation of Convolutional Neural Networks](https://ujjwalkarn.me/2016/08/11/intuitive-explanation-convnets/)\n\n[译文：什么是卷积神经网络？为什么它们很重要？](http://www.hackcv.com/index.php/archives/104/?hmsr=toutiao.io&utm_medium=toutiao.io&utm_source=toutiao.io)\n\n如果不考虑 CNN，可以先思考下一个自己去实现一个分类图片的程序会怎么做。我之前做了一个判断一张图片是否是自选股截图的程序，自选股截图指的是下面这种图片。\n\n![这里写图片描述](https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/Tensorflow%E5%85%A5%E9%97%A8/2.png)\n\n首先我会去看这种图片有什么特征，很明显，自选股截图上面有规则的红绿方块，而其他图片是没有的。那么在程序中，我首先提取出图片的各个像素值，然后去查找这张图片中是否有这种红绿色块，查找红绿色块的算法，可以这样做，看红色的像素值的坐标是否是一个方块，或者绿色的像素值的坐标是否是一个方块。\n\n由上所知，一个典型的图片分类算法就是提取特征，比较特征。CNN 网络简单来说就是将这个过程自动化，开发人员不需要告诉网络图片的特征是什么，CNN 网络可以自动的从图片中寻找特征，并记录。这个过程是怎么做到的呢，下面来讲。\n\n输入一张图片，网络通过一系列的运算，提取出图片的特征。如下图所示：\n\n![这里写图片描述](https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/Tensorflow%E5%85%A5%E9%97%A8/3.png)\n\n当然，这中间的一系列计算是有算法和参数的。训练的时候我们会给每张图片打上一个对应的标签，CNN 通过上面一系列计算出特征后，每个特征就对应着一个标签。比如\n\n```\n特征1 -> 标签A \n特征2 -> 标签B \n特征3 -> 标签A \n```\n\n当下一张图进入训练时，CNN 网络仍然以上次训练计算出来的参数去提取特征，假如提取出的是特征 2，如果图片的标签是 B，那么证明参数正确，无需调整。如果提取出的是特征 2，但是图片的标签是 A，那么证明参数不准确，需要调整下参数。调整完参数后继续下次训练，以此类推，直到参数大概率准确的时候。\n\n很简单的去解释了 CNN 卷积神经网络是怎么工作的，当然实际的过程比这要复杂的多，提取特征需要一些算法，比如卷积、池化、激活，算法的参数也不是 1 个这么简单，而是几百万个。下面的文章中基于 TensorFlow 中一个很简单的例子 MNIST 问题的代码来讲一下 CNN 网络是怎样工作的。\n\n## 3. MNIST问题\n\nMNIST 问题就相当于图像处理的 Hello World 程序，在 TensorFlow 的官方教程里已经有一个完整的 Demo。\n\n[MNIST问题处理](http://www.tensorfly.cn/tfdoc/tutorials/mnist_beginners.html)\n\nMNIST 问题是很常见的图片分类问题，训练集是已经编码过的手写图片，图片中是手写的 0~9 的数字，模型经过训练后，输入一张图片，可以输出 0~9 的数字。\n\n### 3.1 输入集\n首先我们来看一下 MNIST 问题的输入集，数据集的介绍[传送门](http://yann.lecun.com/exdb/mnist/)。\n\n整个数据集由以下四个文件构成，\n\n```\n//训练集-图片数据\ntrain-images-idx3-ubyte.gz:  training set images (9912422 bytes) \n//训练集-label数据\ntrain-labels-idx1-ubyte.gz:  training set labels (28881 bytes) \n//测试集-图片数据\nt10k-images-idx3-ubyte.gz:   test set images (1648877 bytes) \n//测试集-label数据\nt10k-labels-idx1-ubyte.gz:   test set labels (4542 bytes)\n```\n\n训练集-图片数据的格式如下\n\n```\n[offset] [type]          [value]          [description] \n0000     32 bit integer  0x00000803(2051) magic number \n0004     32 bit integer  60000            number of images \n0008     32 bit integer  28               number of rows \n0012     32 bit integer  28               number of columns \n0016     unsigned byte   ??               pixel \n0017     unsigned byte   ??               pixel \n........ \nxxxx     unsigned byte   ??               pixel\n```\n\n训练集-label 数据的格式如下\n\n```\n[offset] [type]          [value]          [description] \n0000     32 bit integer  0x00000801(2049) magic number (MSB first) \n0004     32 bit integer  60000            number of items \n0008     unsigned byte   ??               label \n0009     unsigned byte   ??               label \n........ \nxxxx     unsigned byte   ??               label\nThe labels values are 0 to 9.\n```\n\n测试集的数据格式和训练集是一样的。\n\n首先我们写个程序试着解析一下这些数据：\n\n```\n#coding=utf-8\nimport os\nimport struct\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\ndef load_mnist(path, kind='train'):\n    # 读取文件\n    labels_path = os.path.join(path,\n                               '%s-labels-idx1-ubyte'\n                               % kind)\n    images_path = os.path.join(path,\n                               '%s-images-idx3-ubyte'\n                               % kind)\n    with open(labels_path, 'rb') as lbpath:\n        # 读取magic numer，labels数量\n        magic, n = struct.unpack('>II',\n                                 lbpath.read(8))\n        print 'label magic : ',\n        print magic\n        # 载入label数据\n        labels = np.fromfile(lbpath,\n                             dtype=np.uint8).reshape(n, 1)\n\n    with open(images_path, 'rb') as imgpath:\n        # 读取magic numer，图片数量，图片宽，高\n        magic, num, rows, cols = struct.unpack('>IIII',\n                                               imgpath.read(16))\n        print 'image magic : ',\n        print magic\n        # 载入图片数据\n        images = np.fromfile(imgpath,\n                             dtype=np.uint8).reshape(num, rows * cols)\n\n    return images, labels, rows, cols\n\n\ndef show_image():\n    images, labels, rows, cols = load_mnist('/tmp/TensorFlow/mnist/input_data/')\n    fig, ax = plt.subplots(\n        nrows=2,\n        ncols=5,\n        sharex=True,\n        sharey=True, )\n\n    ax = ax.flatten()\n    for i in range(10):\n        img = images[i].reshape(rows, cols)\n        print labels[i]\n        ax[i].imshow(img, cmap='Greys', interpolation='nearest')\n\n    ax[0].set_xticks([])\n    ax[0].set_yticks([])\n    plt.tight_layout()\n    plt.show()\n\n\nif __name__ == '__main__':\n  show_image()\n\n\n```\n\n运行程序后，会显示输入集的前 10 张图片，如下图所示：\n\n![](https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/Tensorflow%E5%85%A5%E9%97%A8/Snip20180503_1.png)\n\n在控制台会输出 labels\n\n```\nlabel magic :  2049\nimage magic :  2051\n[5] [0] [4] [1] [9] [2] [1] [3] [1] [4]\n```\n\n这是一个 CNN 模型需要的典型的输入，有一些数据，每个数据都有一个 label。后面我们做自己项目的时候，也是这种数据格式。\n\n因为 MNIST 问题是个比较典型的问题，所以 TensorFlow 甚至封装了解析的方法。\n\n### 3.2 MNIST问题代码解析\n完整的代码在 TensorFlow 的 /TensorFlow/git/TensorFlow/TensorFlow/examples/tutorials/mnist/mnist_deep.py 里面。\n\n我们根据程序的运行顺序来看一下。\n\n#### 3.2.1 读取数据\n\n```\nif __name__ == '__main__':\n  # 解析命令行参数，默认没有\n  parser = argparse.ArgumentParser()\n  # 添加MNIST数据集的下载地址\n  parser.add_argument('--data_dir', type=str,\n                      default='/tmp/TensorFlow/mnist/input_data',\n                      help='Directory for storing input data')\n  FLAGS, unparsed = parser.parse_known_args()\n  # 运行main方法\n  tf.app.run(main=main, argv=[sys.argv[0]] + unparsed)\n```\n\n```\n  # Import data\n  mnist = input_data.read_data_sets(FLAGS.data_dir)\n```\n代码将 MNIST 的下载和解析过程封装了一次，看下 read\\_data\\_sets 方法\n\n```\ndef read_data_sets(train_dir,\n                   fake_data=False,\n                   one_hot=False,\n                   dtype=dtypes.float32,\n                   reshape=True,\n                   validation_size=5000,\n                   seed=None,\n                   source_url=DEFAULT_SOURCE_URL):\n                   ...\n                   return base.Datasets(train=train, validation=validation, test=test)\n```\n\n这个方法最后返回的是一个 Datasets 格式，里面 train，validation 和 test 都是已经解析好的数据，解析方法就类似于上一节讲到的。\n\n读到这里，你可能有个疑问，MNIST 数据里面只有 train 和 test，那验证数据集 validation 是哪里来的。这里 validation 使用的就是 train 数据集。CNN 网络在每次训练完之后运行 validation 数据集，可以让开发者了解目前的准确度，在所有训练结束之后运行 test 数据集，可以知道训练出的这个模型的准确度。所以运行 validation 数据只是给开发者参考用的，这里对数据的要求不是很严苛，可以直接用 train 的数据集，而最后测试模型的准确度时使用的 test 数据集一定不能是 train 里面的数据，因为如果两个数据集有重合，可能无法准确的测试模型的准确度。\n\n#### 3.2.2 定义输入输出\n\n```\n  # Create the model\n  x = tf.placeholder(tf.float32, [None, 784], name=\"x\")\n\n  # Define loss and optimizer\n  y_ = tf.placeholder(tf.int64, [None])\n  \n```\n\ntf.placeholder 可以理解为定义占位符，这些占位符虽然定义的时候没有值，但在实际运行中会给定输入值。这里定义了两个占位符，一个是输入值 x，类型是浮点数，维度是 [None, 784]，None 代表不确定数量，784 代表 28*28，也就是一张 MNIST 输入集的图片，这里的意思是说输入层x可以是不确定数量的图片，代表着我们这个网络可以同时输入多张图片的数据。这种变量就是 TensorFlow 的张量 tensor，而每个 tensor 都可以指定名称，但是我们一般只指定具有代表性的几个 tensor 的名称，比如这个输入节点的名称是 x。\n\n而 y_ 声明的存储 label 的变量，类型是 int 类型，因为 label 是 1-10，也是不确定数量的，因为前面x输入多少图片，这里的 label 就应该有多少数量。\n\n声明一个变量为什么要如此复杂，为什么不能像我们写程序一样直接声明 float x = 5 这样。这里需要给读者讲解一下 TensorFlow 计算图和静态图的概念。训练一个深度学习网络的时候，是需要大量计算的，而深度学习框架为了加快计算速度，会直接把计算的过程扔给 CPU 或 GPU 去运行，CPU 和 GPU 运行结束后返回框架结果。举个简单的例子，如果我们要计算 3\\*5+2，普通的程序是先计算 3\\*5，得到结果之后再 +2，得到结果。如果 TensorFlow 也这样做的话，相当于让 CPU 算 3\\*5， CPU 算完后返回结果，然后把返回的结果和 2 再扔给 CPU 去算，最后得到结果。但是需要知道的是，每一次和CPU的交互其实都是特别浪费时间的，所以如果像普通的程序一样，那训练神经网络会特别耗时。所以有一些深度学习框架像 TensorFlow 提出了静态图的概念，首先定义好整个计算图，放在前面的例子里，就是定义好“先乘后加”，然后将需要计算的数字和这个计算图扔给 CPU，最后 CPU 会计算出一个最终的结果返回给框架，这样整个过程中框架和CPU只有一次交互。这样做可以提升计算的速度，但是有一个致命的缺点是不能调试，你不能在 3*5 之后打个断点看看结果对不对，你只能知道最后的结果是不是正确。\n\n所以 tf.placeholder 只是定义了整个计算图中的一个节点 tensor，所以必须用TensorFlow 定义 tensor 的语法。\n\n#### 3.2.3 定义计算图\n\n```\n# Build the graph for the deep net\n  y_conv = deepnn(x)\n```\n\ndeepnn 这个方法是整个程序的核心，在这个方法中定义了一整个计算图。我们一层一层的看。这个 CNN 的网络用的是LeNet网络。构成是这样的。\n\n![这里写图片描述](https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/Tensorflow%E5%85%A5%E9%97%A8/4.png)\n\n其中有两层卷积层，两层池化层，最后输出层是两层全连接层。代码如下：\n\n```\ndef deepnn(x):\n  \"\"\"deepnn builds the graph for a deep net for classifying digits.\n\n  Args:\n    x: an input tensor with the dimensions (N_examples, 784), where 784 is the\n    number of pixels in a standard MNIST image.\n\n  Returns:\n    A tuple (y, keep_prob). y is a tensor of shape (N_examples, 10), with values\n    equal to the logits of classifying the digit into one of 10 classes (the\n    digits 0-9). keep_prob is a scalar placeholder for the probability of\n    dropout.\n  \"\"\"\n  # Reshape to use within a convolutional neural net.\n  # Last dimension is for \"features\" - there is only one here, since images are\n  # grayscale -- it would be 3 for an RGB image, 4 for RGBA, etc.\n  with tf.name_scope('reshape'):\n    x_image = tf.reshape(x, [-1, 28, 28, 1])\n\n  # First convolutional layer - maps one grayscale image to 32 feature maps.\n  with tf.name_scope('conv1'):\n    W_conv1 = weight_variable([5, 5, 1, 32])\n    b_conv1 = bias_variable([32])\n    h_conv1 = tf.nn.relu(conv2d(x_image, W_conv1) + b_conv1)\n\n  # Pooling layer - downsamples by 2X.\n  with tf.name_scope('pool1'):\n    h_pool1 = max_pool_2x2(h_conv1)\n\n  # Second convolutional layer -- maps 32 feature maps to 64.\n  with tf.name_scope('conv2'):\n    W_conv2 = weight_variable([5, 5, 32, 64])\n    b_conv2 = bias_variable([64])\n    h_conv2 = tf.nn.relu(conv2d(h_pool1, W_conv2) + b_conv2)\n\n  # Second pooling layer.\n  with tf.name_scope('pool2'):\n    h_pool2 = max_pool_2x2(h_conv2)\n\n  # Fully connected layer 1 -- after 2 round of downsampling, our 28x28 image\n  # is down to 7x7x64 feature maps -- maps this to 1024 features.\n  with tf.name_scope('fc1'):\n    W_fc1 = weight_variable([7 * 7 * 64, 1024])\n    b_fc1 = bias_variable([1024])\n\n    h_pool2_flat = tf.reshape(h_pool2, [-1, 7 * 7 * 64])\n    h_fc1 = tf.nn.relu(tf.matmul(h_pool2_flat, W_fc1) + b_fc1)\n\n  # Map the 1024 features to 10 classes, one for each digit\n  with tf.name_scope('fc2'):\n    W_fc2 = weight_variable([1024, 10])\n    b_fc2 = bias_variable([10])\n\n    y_conv = tf.add(tf.matmul(h_fc1, W_fc2), b_fc2, name=\"output\")\n  return y_conv\n```\n\n下面一层一层的看这个网络是怎么工作的。\n\n##### 卷积层\nCNN 叫卷积神经网络，可以看出卷积是这个网络的核心。卷积层是用于提取图片特征，卷积的操作是用一个卷积矩阵（也叫卷积核）在输入矩阵上依次扫描，做矩阵相乘，得到的结果输入矩阵的某一个特征。这样讲是不太好理解，下面用图片说一下这个过程。\n\n假设输入矩阵是这样的\n![这里写图片描述](https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/Tensorflow%E5%85%A5%E9%97%A8/5.png)\n\n选取如下一个卷积核\n![这里写图片描述](https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/Tensorflow%E5%85%A5%E9%97%A8/6.png)\n\n用卷积核在输入矩阵上依次扫过，做矩阵相乘的操作，就可以得到输入矩阵由这个卷积核提取的特征。\n\n![这里写图片描述](https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/Tensorflow%E5%85%A5%E9%97%A8/7.gif)\n\n>在 CNN 的术语中，3x3 的矩阵叫做“滤波器（filter）”或者“核（kernel）”或者“特征检测器（feature detector）”，通过在图像上滑动滤波器并计算点乘得到矩阵叫做“卷积特征（Convolved Feature）”或者“激活图（Activation Map）”或者“特征图（Feature Map）”。记住滤波器在原始输入图像上的作用是特征检测器。\n\n是不是在怀疑，这种操作真的能够提取特征吗，看下对实际图片进行卷积操作的例子。\n\n输入图像如下：\n![这里写图片描述](https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/Tensorflow%E5%85%A5%E9%97%A8/8.png)\n\n用不同的卷积核进行卷积操作的结果如下：\n\n![这里写图片描述](https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/Tensorflow%E5%85%A5%E9%97%A8/10.jpeg)\n\n可以看到，不同的卷积核对原图像进行处理后可以得到不同的特征图像，有的卷积核能提取边缘信息，有的卷积核能提取色彩信息，有的卷积核能提取明暗特征，等等等等。有没有觉得这一步特别像 PS 中的滤镜，其实卷积的操作和滤镜的操作是很类似的。不同的卷积就像不同的滤镜对不同的特征敏感度不同。而代码中的卷积层如下：\n\n```\n# First convolutional layer - maps one grayscale image to 32 feature maps.\n  with tf.name_scope('conv1'):\n    W_conv1 = weight_variable([5, 5, 1, 32])\n    b_conv1 = bias_variable([32])\n    h_conv1 = tf.nn.relu(conv2d(x_image, W_conv1) + b_conv1)\n```\n\n首先定义一个卷积核 W\\_conv1 变量，由于后面会多次定义变量，所以将定义变量的部分提取了方法，如下：\n\n```\ndef weight_variable(shape):\n  \"\"\"weight_variable generates a weight variable of a given shape.\"\"\"\n  initial = tf.truncated_normal(shape, stddev=0.1)\n  return tf.Variable(initial)\n```\n\ntf.Variable 生成一个变量 tensor，参数 initial 是初始化值。initial 由truncated\\_normal 方法生成，shape 指定了生成变量的维度，这里是[5,5,1,32]四维的变量，初始化值是由 truncated\\_normal 产生的正态分布的值，这就是 truncated\\_normal 方法的作用，详细的说明可以看文档。\n\n相对于卷积核的声明，偏量 b\\_conv1 的生成要简单一点。\n\n```\ndef bias_variable(shape):\n  \"\"\"bias_variable generates a bias variable of a given shape.\"\"\"\n  initial = tf.constant(0.1, shape=shape)\n  return tf.Variable(initial)\n```\n\n初始化值是固定的 0.1。\n这两个变量的初始化值不能是 0，而要加入一些脏值，是为了打破对称性以及避免 0 梯度，提升模型训练的效率。\n\n后面的代码就是执行卷积操作，我们来看，\n\n``conv2d(x_image, W_conv1)``\n\n```\ndef conv2d(x, W):\n  \"\"\"conv2d returns a 2d convolution layer with full stride.\"\"\"\n  return tf.nn.conv2d(x, W, strides=[1, 1, 1, 1], padding='SAME')\n```\n\n这个函数就是 TensorFlow 中用于做卷积的函数，2d 代表生成的是一个二维特征图，这个是什么意思呢，后面会提到。除了 conv2d，还有 conv1d 和 conv3d 函数。\n\n看下 conv2d 的函数签名。\n\n```\ntf.nn.conv2d(input, filter, strides, padding, use_cudnn_on_gpu=None, name=None)\n```\n\n除去 name 参数用以指定该操作的 name，与方法有关的一共五个参数：\n\n第一个参数 input：指需要做卷积的输入图像，它要求是一个 tensor，具有 [batch, in_height, in_width, in_channels] 这样的 shape，具体含义是[训练时一个 batch 的图片数量, 图片高度, 图片宽度, 图像通道数]，注意这是一个 4 维的 tensor，要求类型为 float32 和 float64 其中之一\n\n第二个参数 filter：相当于 CNN 中的卷积核，它要求是一个 tensor，具有 [filter_height, filter_width, in_channels, out_channels] 这样的shape，具体含义是[卷积核的高度，卷积核的宽度，图像通道数，卷积核个数]，要求类型与参数 input 相同，有一个地方需要注意，第三维 in_channels，就是参数 input 的第四维\n\n第三个参数 strides：卷积时在图像每一维每一次移动的步长，这是一个一维的向量，长度跟前面卷积核的维度相同，这里是4。\n\n第四个参数 padding：string 类型的量，只能是 \"SAME\", \"VALID\" 其中之一，这个值决定了不同的卷积方式\n\n第五个参数：use\\_cudnn\\_on\\_gpu: bool 类型，是否使用 cudnn 加速，默认为 true，cudnn 是英伟达的GPU处理单元，这里也就是用 GPU 进行加速计算。\n\n###### 二维特征向量\nconv2d 生成的是二维特征向量，conv2d 有两个参数是必要的，input 和 filter。我们的输入参数是一张图片，三维的数据[宽，高，颜色空间]，为了最后向量相乘的结果是二维的，filer 的第三个维度应该和 input 的第四个维度相等，也就是 in\\_channels 相等，这样永远都只能输出一个二维的特征向量，也就是这个函数叫 conv2d 的原因，这里比较难理解，可以仔细考虑一下。\n\n###### padding参数\npadding 参数的可选值是 SAME 和 VALID，这个参数影响了了卷积核对输入矩阵边缘的处理，决定了输出的特征向量大小。\n\n卷积核和按照步数一步步的扫描输入矩阵，做乘法操作。但是在输入矩阵的边缘，如果输入矩阵剩余的维度小于定义的卷积核的维度，那么卷积核就无法做乘法操作了，剩余这部分边界怎么处理呢。\n\n如果 padding 是 SAME，则会在输入矩阵的两端补齐 0，使补齐后的输入矩阵维度刚好可以被卷积核处理，最后得到的特征矩阵和原来的输入矩阵维度相同。\n\n![这里写图片描述](https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/Tensorflow%E5%85%A5%E9%97%A8/11.png)\n\n如果 padding 是 VALID，则会抛弃边界的节点，最后输出的特征矩阵维度和输入矩阵不相同\n\n![这里写图片描述](https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/Tensorflow%E5%85%A5%E9%97%A8/12.png)\n\n再回来看代码\n\n```\n  W_conv1 = weight_variable([5, 5, 3, 32])\n  conv2d(x_image, W_conv1)\n```\n\n卷积核是 5\\*5\\*3 的，一共 32 个卷积核，对图像处理后，可以得到32个特征向量，因为我们没有指定步长和 padding，所以步长默认是1，padding 是 SAME，这样的话，输出的特征矩阵就是28 * 28 * 1。\n\n```\n# 第一个卷积层，从图像中提取32的特征\nwith tf.name_scope('conv1'):\n    W_conv1 = weight_variable([5, 5, 3, 32])  # y =wX+b\n    b_conv1 = bias_variable([32])\n    h_conv1 = tf.nn.relu(conv2d(x_image, W_conv1) + b_conv1)\n```\n\n做完了卷积后，进行了一个relu处理\n\n>ReLU 是一个元素级别的操作（应用到各个像素），并将特征图中的所有小于 0 的像素值设置为零。ReLU 的目的是在 ConvNet 中引入非线性，因为在大部分的我们希望 ConvNet 学习的实际数据是非线性的（卷积是一个线性操作——元素级别的矩阵相乘和相加，所以我们需要通过使用非线性函数 ReLU 来引入非线性。\n\n引入非线性可以让神经网络更好的工作，这个更好的工作指的是在做反向传播的时候避免出现梯度消失的问题，原因涉及到比较深的理论，这篇文章就不多说了。\n\n这样第一个卷积操作就结束了。\n\n##### 池化\n卷积操作之后是一个池化层。\n\n```\n# Pooling layer - downsamples by 2X.\n  with tf.name_scope('pool1'):\n    h_pool1 = max_pool_2x2(h_conv1)\n```\n\n池化的作用类似于压缩，这种压缩是在缩小输入值的维度的同时还要保持输入值的特征。比如在 2*2 的 4 个像素点中取最大值，最小值或者平均值。不过经过研究，最大池化能够比较好的保持原来的特征值。\n\n![这里写图片描述](https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/Tensorflow%E5%85%A5%E9%97%A8/13.png)\n\n\n```\n# 2*2的最大化池化层\n    with tf.name_scope('pool1'):\n        h_pool1 = max_pool_2x2(h_conv1)\n```\n\n```\ndef max_pool_2x2(x):\n  \"\"\"max_pool_2x2 downsamples a feature map by 2X.\"\"\"\n  return tf.nn.max_pool(x, ksize=[1, 2, 2, 1],\n                        strides=[1, 2, 2, 1], padding='SAME')\n```\n\n池化操作也是调用的 TensorFlow 的函数，参数 strides 和 padding 跟前面提到的 conv2d 函数的参数一致。ksize 是定义的在每个维度上池化的大小，上一步卷积之后，输出的特征向量是 1\\*28\\*28\\*1，所以在中间两个维度进行处理。\n\n\n```\n# Second convolutional layer -- maps 32 feature maps to 64.\n  with tf.name_scope('conv2'):\n    W_conv2 = weight_variable([5, 5, 32, 64])\n    b_conv2 = bias_variable([64])\n    h_conv2 = tf.nn.relu(conv2d(h_pool1, W_conv2) + b_conv2)\n\n  # Second pooling layer.\n  with tf.name_scope('pool2'):\n    h_pool2 = max_pool_2x2(h_conv2)\n```\n\n后面又做了一个卷积操作和一个池化操作，这个跟前面的操作是一样的。卷积操作的输出不影响输入值的维度，但是影响输入值的深度。池化操作不影响输入值的深度但是影响输入值的维度，经过两层的卷积和 2*2 的池化后，输入值的维度变成了原来的 1/4。深度变成 64。也就是 7\\*7\\*64。\n\n上面的几层又叫隐藏层，表示使用者看不到的处理层。\n\n##### 全连接\n\n接下来是输出层，输出层是两个全连接层。\n\n```\n  # Fully connected layer 1 -- after 2 round of downsampling, our 28x28 image\n  # is down to 7x7x64 feature maps -- maps this to 1024 features.\n  with tf.name_scope('fc1'):\n    W_fc1 = weight_variable([7 * 7 * 64, 1024])\n    b_fc1 = bias_variable([1024])\n\n    h_pool2_flat = tf.reshape(h_pool2, [-1, 7 * 7 * 64])\n    h_fc1 = tf.nn.relu(tf.matmul(h_pool2_flat, W_fc1) + b_fc1)\n\n  # Map the 1024 features to 10 classes, one for each digit\n  with tf.name_scope('fc2'):\n    W_fc2 = weight_variable([1024, 10])\n    b_fc2 = bias_variable([10])\n\n    y_conv = tf.add(tf.matmul(h_fc1, W_fc2), b_fc2, name=\"output\")\n```\n\n全连接层，顾名思义，指的是这一层的每个节点都跟上一层的全部节点有连接。\n\n![全连接节点](https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/Tensorflow%E5%85%A5%E9%97%A8/Snip20180423_2.png)\n\n比如图中全连接层的节点 a1 与上一层的所有节点 x1,x2,x3 有联系，a2 也与上一层的所有节点有联系，就这样，少一个也不行。因此解释全连接层的时候，图就是这样一个网状结构。\n\n上文中提到了联系，这里的“联系”具体指的是什么呢。如图所示，假设 x1，x2，x3 是全连接层的输入值，那么在全连接层的a1可以表示为以下的形式。\n\n![](https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/Tensorflow%E5%85%A5%E9%97%A8/Snip20180423_3.png)\n\n从这个公式可以看出，a1 与 x1，x2，x3 都有联系，只是输入节点的权重值不同。同理，a2 和 a3 也可以表示为以下的形式。\n\n![](https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/Tensorflow%E5%85%A5%E9%97%A8/Snip20180423_4.png)\n\n由此就可以从数学层面去理解什么叫全连接层，但是这个全连接层在实际应用中表示得意义是什么呢，简单来说，它可以作为一个分类网络，还是上面那个图，输入层是 3 个值，全连接层是 3 个节点，就代表这个全连接层可以把上一层的特征值分类为三种特征。当然，输入层和全连接层的节点数并不一定相同，比如下面这个结构。\n\n![](https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/Tensorflow%E5%85%A5%E9%97%A8/Snip20180423_5.png)\n\n最后的全连接层是 10 个节点，全连接层的上一层是 15 个特征值，这样就把 15 个特征值归类为 10 种特征。举例来说，比如输出的 15 个特征标记位 t1-15，而 t1，t3，t5 三种特征可以认为都属于某一种输出 o1。而 t2，t6 两种特征可以认为属于输出 o2，以此类推，就可以把15个特征分类为 10 个输出。\n\n前面提到的MNIST问题中，全连接层有两层，第一层是 1024 个节点，第二层是 10 个节点。一般情况下，最靠近用户的输出层就是用户所期待的结果类别数，MNIST 问题中，用户期待的输出是 0-9 一共 10 个数字也就是 10 种类别，所以第二层全连接层是 10 个节点。再往前看，卷积层在每一个像素点上提取 64 个特征值，所以整个图片可以有高\\*宽\\*64个特征值，也就是 7\\*7\\*64 个特征，第一个全连接层是 1024 个节点，表示希望这个网络将这 7\\*7\\*64 个特征归类为 1024 个分类。至于为什么第一个连接层是 1024 个节点，是一个经验值的问题，这个节点的个数是可以调整的，后面会讲到全连接层对模型体积的影响，也会再说到这个经验值的问题。那么全连接层是如何分类的。一起来看一下。\n\n回顾一下全连接层的表示公式。\n\n![](https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/Tensorflow%E5%85%A5%E9%97%A8/Snip20180423_3.png)\n\n这里的输入值 x1,x2,x3...，输出值 a1 和权重 W，偏移量 b 到底指的是什么呢。\n\n在MNIST的基础上，可以考虑这样一种情况。看下面这个图，对于0这个数字来说，我们经过训练之后，认为如果一张图片在中间红色部分出现了像素值，那这张图有一定概率不是 0，并且出现在红色部分的像素值越多，不是 0 的概率越大。如果在周围一圈的蓝色部分出现了像素值，那么这张图有一定概率是 0，并且出现在蓝色部分的像素值越多，是 0 的概率越大。\n\n![](https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/Tensorflow%E5%85%A5%E9%97%A8/Snip20180423_6.png)\n\n这个过程用数学公式怎么表示呢，蓝色部分拥有正值的权重，红色部分拥有负值的权重，将输入图片的每个像素点与权重值进行相乘后求和，这样如果红色部分出现的像素值越多，则最后的和越小，如果蓝色部分出现的像素值越多，则最后的和越大。最后得出的结果我们称为是输入图片x是这种分类（比如分类0）的证据 evidence。这样对于一张输入的图片，最后落在每个节点上的 evidence 就可以用如下的公式表示。\n\n![](https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/Tensorflow%E5%85%A5%E9%97%A8/Snip20180427_1.png)\n\n看这个公式，是不是就是全连接层的公式。所以全连接层这个过程比较绕，但是是深度学习网络的基本原理，可以仔细理解一下。\n\n反过来看代码。\n\n```\n  # Fully connected layer 1 -- after 2 round of downsampling, our 28x28 image\n  # is down to 7x7x64 feature maps -- maps this to 1024 features.\n  with tf.name_scope('fc1'):\n    W_fc1 = weight_variable([7 * 7 * 64, 1024])\n    b_fc1 = bias_variable([1024])\n\n    h_pool2_flat = tf.reshape(h_pool2, [-1, 7 * 7 * 64])\n    h_fc1 = tf.nn.relu(tf.matmul(h_pool2_flat, W_fc1) + b_fc1)\n```\n\n首先生成全连接层的权重 W\\_fc1 和偏量 b\\_fc1，这里复用了前面卷积操作生成卷积核和偏量的两个方法，虽然概念不同，但计算是相通的，所以可以复用。tf.reshape(h_pool2, [-1, 7 * 7 * 64]) 将之前层的四维 [1,7,7,64] 的输出变成一个一维的向量，因为全连接层只能处理一维的问题。后面用 tf.matmul 向量乘法实现了全连接层的操作。tf.nn.relu 和前面一样，是个激活函数。\n\n##### droupout\n\n在第一层全连接层之后，加了一个 dropout 的操作\n\n```\n  # Dropout - controls the complexity of the model, prevents co-adaptation of\n  # features.\n  with tf.name_scope('dropout'):\n    keep_prob = tf.placeholder(tf.float32)\n    h_fc1_drop = tf.nn.dropout(h_fc1, keep_prob)\n```\n\ndroupout 的操作如下图所示：\n![](https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/Tensorflow%E5%85%A5%E9%97%A8/Snip20180504_2.png)\n\n在计算的过程中，随机的“丢弃”一些节点，简单来说，h\\_fc1有 1024 个节点，在 droupout 之后，如果 keep\\_prob 是50%，那么经过 droupout 之后，可以认为参与计算的是 512 个节点。droupout 有两个优势。\n\n- 解决过拟合的问题\n- 在训练中加入概率性\n\ndroupout 操作之后又是一层全连接。\n\n```\n  # Map the 1024 features to 10 classes, one for each digit\n  with tf.name_scope('fc2'):\n    W_fc2 = weight_variable([1024, 10])\n    b_fc2 = bias_variable([10])\n\n    y_conv = tf.add(tf.matmul(h_fc1, W_fc2), b_fc2, name=\"output\")\n```\n\n第二层全连接将上一层产生的 1024 个节点归类到 10 个节点上，，得到最后的输出。即使经过 droupout 之后，实体依然是 1024 个节点，只是其中一部分不再参与计算。这个网络结构最后的输出是10个节点的 evidence 的值。\n\n#### 3.2.4 Softmax回归处理\n\n至此，整个计算图就定义完了，接下来定义一些训练中的必要单元来告知框架如何训练。\n\n```\n  with tf.name_scope('loss'):\n    cross_entropy = tf.losses.sparse_softmax_cross_entropy(\n        labels=y_, logits=y_conv)\n  cross_entropy = tf.reduce_mean(cross_entropy)\n```\n\n定义损失函数使用 softmax 交叉熵的，关于 softmax 和交叉熵，这里引用[传送门](https://blog.csdn.net/chaipp0607/article/details/73392175)一段描述。\n\n神经网络的原始输出不是一个概率值，实质上只是输入的数值做了复杂的加权和与非线性处理之后的一个值而已，那么如何将这个输出变为概率分布？ \n\n这就是 softmax 层的作用，假设神经网络的原始输出为 y1,y2,….,yn，那么经过 softmax 回归处理之后的输出为： \n\n![](https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/Tensorflow%E5%85%A5%E9%97%A8/Snip20180504_3.png)\n\n经过 softmax 的公式后，所有节点的和变成了 1，之前神经网络输出的每个节点的权重值变成了每个节点的概率值。\n\n单个节点的输出变成的一个概率值，经过 softmax 处理后结果作为神经网络最后的输出。label\n\n\n#### 3.2.5 交叉熵的原理\n\n交叉熵刻画的是实际输出（概率）与期望输出（概率）的距离，也就是交叉熵的值越小，两个概率分布就越接近。假设概率分布 p 为期望输出，概率分布 q 为实际输出，H(p,q) 为交叉熵，则：\n\n![](https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/Tensorflow%E5%85%A5%E9%97%A8/Snip20180504_4.png)\n\n这个公式如何表征距离呢，举个例子： \n假设 N=3，期望输出为 p = (1,0,0)，实际输出 q1 = (0.5,0.2,0.3)，q2 = (0.8,0.1,0.1)，那么：\n\n![](https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/Tensorflow%E5%85%A5%E9%97%A8/Snip20180504_5.png)\n\n很显然，q2 与 p 更为接近，它的交叉熵也更小。 \n除此之外，交叉熵还有另一种表达形式，还是使用上面的假设条件：\n\n![](https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/Tensorflow%E5%85%A5%E9%97%A8/Snip20180504_6.png)\n\n其结果为：\n\n![](https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/Tensorflow%E5%85%A5%E9%97%A8/Snip20180504_7.png)\n\n以上的所有说明针对的都是单个样例的情况，而在实际的使用训练过程中，数据往往是组合成为一个 batch 来使用，所以对用的神经网络的输出应该是一个 m*n 的二维矩阵，其中 m 为 batch 的个数，n为分类数目，而对应的 label 也是一个二维矩阵，还是拿上面的数据，组合成一个 batch=2 的矩阵：\n\n![](https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/Tensorflow%E5%85%A5%E9%97%A8/Snip20180504_8.png)\n\n所以交叉熵的结果应该是一个列向量（根据第一种方法）： \n\n![](https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/Tensorflow%E5%85%A5%E9%97%A8/Snip20180504_9.png)\n\n而对于一个 batch，最后取平均为 0.2。\n\ntf.losses.sparse\\_softmax\\_cross\\_entropy 是 TensorFlow 将以上两个过程封装后的产物，最后的结果是一个 batch 的概率值，reduce\\_mean 用来取得概率的平均值。综上作为整个网络的损失函数。\n\n#### 3.2.6 训练方法-梯度下降\n\n然后定义梯度下降的方法\n\n```\n  with tf.name_scope('adam_optimizer'):\n    train_step = tf.train.AdamOptimizer(1e-4).minimize(cross_entropy)\n```\n\n以下降步速，即学习率为1e-4的速度最小化损失函数 cross\\_entropy。这样就能定义训练的目的是为了让损失函数越来越来，每次参数的变化值为1e-4。\n\n#### 3.2.7 准确度\n\n定义准确度的计算方法\n\n```\n  with tf.name_scope('accuracy'):\n    correct_prediction = tf.equal(tf.argmax(y_conv, 1), y_)\n    correct_prediction = tf.cast(correct_prediction, tf.float32)\n  accuracy = tf.reduce_mean(correct_prediction)\n```\n\ny\\_conv 是网络输出的原始结果，也就是图片在最后 10 个节点上的权重值，比如 [314, -423, 342...] ，最后权重值最大的节点是我们的期望节点，比如这里第三个节点的权重值最大，那这幅图片可能就是数字 2，tf.argmax 是取出权重值最大的下标。y\\_ 是我们给的 label 值，把这两个值相比较得出准确度。最后依然用 tf.reduce_mean 算出 batch 的平均准确度。\n\n#### 3.2.8 计算图可视化\n\n```\n  graph_location = tempfile.mkdtemp()\n  print('Saving graph to: %s' % graph_location)\n  train_writer = tf.summary.FileWriter(graph_location)\n  train_writer.add_graph(tf.get_default_graph())\n```\n\n这是 TensorFlow 提供的计算图可视化的方法，这里暂时没起到作用。\n\n#### 3.2.9 启动计算图\n\n```\n  with tf.Session() as sess:\n    sess.run(tf.global_variables_initializer())\n    for i in range(20000):\n      batch = mnist.train.next_batch(50)\n      if i % 100 == 0:\n        train_accuracy = accuracy.eval(feed_dict={\n            x: batch[0], y_: batch[1], keep_prob: 1.0})\n        print('step %d, training accuracy %g' % (i, train_accuracy))\n      train_step.run(feed_dict={x: batch[0], y_: batch[1], keep_prob: 0.5})\n\n    print('test accuracy %g' % accuracy.eval(feed_dict={\n        x: mnist.test.images, y_: mnist.test.labels, keep_prob: 1.0}))\n```\n\n这里就是前面提到的将计算图和计算数据给 CPU 计算，TensorFlow 将和 CPU 的一个交互过程定义为 session，启动 session 后，开始运行。\n\n```\nsess.run(tf.global_variables_initializer())\n```\n\n首先将前面定义的所有变量初始化，注意前面在定义图的时候只是定义了变量初始化的方法，而没有真正去做初始化，真正运行是在这个地方。\n\n然后循环 20000 次，每次从训练集中取出50个图片数据作为一个 batch。\n\n```\ntrain_step.run(feed_dict={x: batch[0], y_: batch[1], keep_prob: 0.5})\n```\n\n开始训练，train_step 是前面定义的梯度下降的方法，以这种方法开始训练。参数是图片数据，正确的 labels，和 droupout 的参数。\n\n```\nif i % 100 == 0:\n        train_accuracy = accuracy.eval(feed_dict={\n            x: batch[0], y_: batch[1], keep_prob: 1.0})\n        print('step %d, training accuracy %g' % (i, train_accuracy))\n```\n\n每训练 100 次，输出一下当前的准确率，是为了开发者感知的。测试准确率的时候，是不需要 droupout 操作的，所以 keep\\_prob 是1。\n\n```\nprint('test accuracy %g' % accuracy.eval(feed_dict={\n        x: mnist.test.images, y_: mnist.test.labels, keep_prob: 1.0}))\n```\n\n20000 次训练之后，输出最终的准确率。\n\n输出结果类似这样的\n\n```\nstep 0, training accuracy 0.16\nstep 100, training accuracy 0.9\nstep 200, training accuracy 0.94\nstep 300, training accuracy 0.9\nstep 400, training accuracy 0.96\n...\ntest accuracy 0.9446\n```\n\n## 总结\n\n至此，整个模型的训练过程就完全结束了。通过这个例子，我们知道了一个 CNN 网络是怎么工作的，并且如何用 TensorFlow 来实现一个 CNN 网络。下一篇文章，我将写一下如果改造这个例子，来解决我的一个实际问题。\n","slug":"Tensorflow入门","published":1,"updated":"2024-06-14T09:25:33.677Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clxjsxtw2000klq6gic4px3vs","content":"<h2 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1. 前言\"></a>1. 前言</h2><p>人工智能自从阿尔法狗大败李世石后就异常火爆，最近工作中需要探索 AI 在移动端的应用，趁着这个计划入门下深度学习吧。</p>\n<p>深度学习的入门曲线还是很陡峭的，看了很多资料，询问了从事相关工作的朋友后终于有点感觉了，这篇文章就讲一下我在这个过程中的所见所得吧，肯定是不专业的，如果所说有什么错误，也希望大家帮忙指出，共同进步。</p>\n<p>这个入门的文章准备分以下几个部分来说：</p>\n<ul>\n<li>CNN 的原理</li>\n<li>TensorFlow 使用 CNN 网络解决 MNIST 问题的例子讲解</li>\n<li>Demo 改造解决我自己的股票图片识别问题</li>\n<li>训练出的模型部署到 iOS 端的 TensorFlow Mobile 框架中</li>\n<li>训练出的模型部署到 iOS 端的 TensorFlow Lite 框架中</li>\n</ul>\n<p>首先我做的第一件事是分清楚一些概念，之前完全不懂得时候只觉得人工智能很厉害，能解决人力解决不了的问题，但人工智能到底是什么，完全不知道。既然要学习，首先就得分清楚人工智能，机器学习，深度学习都是些什么东西，需要从哪里入手等等这些问题。这个问了从事相关工作的同学后再查阅了一些资料后，很容易的就理解了。知乎上的这个回答比较靠谱，<a href=\"https://www.zhihu.com/question/57770020\" target=\"_blank\" rel=\"external\">传送门</a>，总结一下就是这两句话。</p>\n<blockquote>\n<p>机器学习：一种实现人工智能的方法</p>\n<p>深度学习：一种实现机器学习的技术</p>\n</blockquote>\n<p>而三者的关系就是</p>\n<p><img src=\"https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/Tensorflow%E5%85%A5%E9%97%A8/1.png\" alt=\"这里写图片描述\"></p>\n<p>可以看的出来，人工智能是一个很大的概念，想用机器来解决问题的一种思想都可以认为是人工智能，而这个概念早在 19 世纪 50 年代就提出了。机器学习就是实现人工智能的一种方法，一切使用数据分析帮助决策的场景都可以叫做机器学习，这个概念从 19 世纪 80 年代到现在也已经发展了快 40 年了，机器学习其实一点都不神秘，在现代生产中的应用随处可见，比如各种网站的推荐算法，垃圾邮件的过滤算法等等。而最近火热的概念其实人工智能中很小的一部分，叫做深度学习。简单来说，使用深度神经网络去解决问题的学习方法叫做深度学习。如果说广义的机器学习是人类定义好规则，让计算机去做，那么深度学习就是人类定义好规则后，让计算机去学。深度学习依赖于现在计算能力的提升飞速发展，在图像识别、语音识别等领域发挥了巨大的作用。看完这篇文章后，你应该对深度学习会有一个简单的理解。</p>\n<p>考虑到机器学习的算法实在是太多，学习需要很多时间（按照我粗浅的理解，机器学习就是一整部统计学在计算机界的应用，很大）。而深度学习就相对单纯一些，据我所知，目前比较流行的深度学习算法就只有 CNN（卷积神经网络），RNN（循环神经网络）和 DNN（深度神经网络）。DNN 是整个深度学习的基础，后面的 CNN 和 RNN 其实都是基于DNN来做的，CNN（卷积神经网络）比较擅长于提取图片特征，处理图像问题。RNN 是把前一次网络的输出作为下一次网络的输入，让整个网络有了前因后果的概念，比较擅长处理有前后时间序列关系的问题，比如语音识别，语义分析等。</p>\n<p>根据之前列的大纲，这篇文章会先讲一下 CNN 网络的概念，然后讲一下 TensorFlow 中一个很有用的例子，用 CNN 网络去解决 MNIST 问题。大纲中剩下的部分会在接下来的文章中讲解。</p>\n<h2 id=\"2-CNN神经网络\"><a href=\"#2-CNN神经网络\" class=\"headerlink\" title=\"2. CNN神经网络\"></a>2. CNN神经网络</h2><p>CNN 神经网络，全称是卷积神经网络，是目前深度学习中最常见、应用最广泛的一种网络，适合于解决图像识别，图片分类，图像预测的问题。</p>\n<p>这里有一篇讲 CNN 比较好的文章，我看到很多大V讲到 CNN 的时候也会引用这篇文章的内容。有兴趣可以先看一下这篇文章。</p>\n<p><a href=\"https://ujjwalkarn.me/2016/08/11/intuitive-explanation-convnets/\" target=\"_blank\" rel=\"external\">An Intuitive Explanation of Convolutional Neural Networks</a></p>\n<p><a href=\"http://www.hackcv.com/index.php/archives/104/?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io\" target=\"_blank\" rel=\"external\">译文：什么是卷积神经网络？为什么它们很重要？</a></p>\n<p>如果不考虑 CNN，可以先思考下一个自己去实现一个分类图片的程序会怎么做。我之前做了一个判断一张图片是否是自选股截图的程序，自选股截图指的是下面这种图片。</p>\n<p><img src=\"https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/Tensorflow%E5%85%A5%E9%97%A8/2.png\" alt=\"这里写图片描述\"></p>\n<p>首先我会去看这种图片有什么特征，很明显，自选股截图上面有规则的红绿方块，而其他图片是没有的。那么在程序中，我首先提取出图片的各个像素值，然后去查找这张图片中是否有这种红绿色块，查找红绿色块的算法，可以这样做，看红色的像素值的坐标是否是一个方块，或者绿色的像素值的坐标是否是一个方块。</p>\n<p>由上所知，一个典型的图片分类算法就是提取特征，比较特征。CNN 网络简单来说就是将这个过程自动化，开发人员不需要告诉网络图片的特征是什么，CNN 网络可以自动的从图片中寻找特征，并记录。这个过程是怎么做到的呢，下面来讲。</p>\n<p>输入一张图片，网络通过一系列的运算，提取出图片的特征。如下图所示：</p>\n<p><img src=\"https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/Tensorflow%E5%85%A5%E9%97%A8/3.png\" alt=\"这里写图片描述\"></p>\n<p>当然，这中间的一系列计算是有算法和参数的。训练的时候我们会给每张图片打上一个对应的标签，CNN 通过上面一系列计算出特征后，每个特征就对应着一个标签。比如</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">特征1 -&gt; 标签A </div><div class=\"line\">特征2 -&gt; 标签B </div><div class=\"line\">特征3 -&gt; 标签A</div></pre></td></tr></table></figure>\n<p>当下一张图进入训练时，CNN 网络仍然以上次训练计算出来的参数去提取特征，假如提取出的是特征 2，如果图片的标签是 B，那么证明参数正确，无需调整。如果提取出的是特征 2，但是图片的标签是 A，那么证明参数不准确，需要调整下参数。调整完参数后继续下次训练，以此类推，直到参数大概率准确的时候。</p>\n<p>很简单的去解释了 CNN 卷积神经网络是怎么工作的，当然实际的过程比这要复杂的多，提取特征需要一些算法，比如卷积、池化、激活，算法的参数也不是 1 个这么简单，而是几百万个。下面的文章中基于 TensorFlow 中一个很简单的例子 MNIST 问题的代码来讲一下 CNN 网络是怎样工作的。</p>\n<h2 id=\"3-MNIST问题\"><a href=\"#3-MNIST问题\" class=\"headerlink\" title=\"3. MNIST问题\"></a>3. MNIST问题</h2><p>MNIST 问题就相当于图像处理的 Hello World 程序，在 TensorFlow 的官方教程里已经有一个完整的 Demo。</p>\n<p><a href=\"http://www.tensorfly.cn/tfdoc/tutorials/mnist_beginners.html\" target=\"_blank\" rel=\"external\">MNIST问题处理</a></p>\n<p>MNIST 问题是很常见的图片分类问题，训练集是已经编码过的手写图片，图片中是手写的 0~9 的数字，模型经过训练后，输入一张图片，可以输出 0~9 的数字。</p>\n<h3 id=\"3-1-输入集\"><a href=\"#3-1-输入集\" class=\"headerlink\" title=\"3.1 输入集\"></a>3.1 输入集</h3><p>首先我们来看一下 MNIST 问题的输入集，数据集的介绍<a href=\"http://yann.lecun.com/exdb/mnist/\" target=\"_blank\" rel=\"external\">传送门</a>。</p>\n<p>整个数据集由以下四个文件构成，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">//训练集-图片数据</div><div class=\"line\">train-images-idx3-ubyte.gz:  training set images (9912422 bytes) </div><div class=\"line\">//训练集-label数据</div><div class=\"line\">train-labels-idx1-ubyte.gz:  training set labels (28881 bytes) </div><div class=\"line\">//测试集-图片数据</div><div class=\"line\">t10k-images-idx3-ubyte.gz:   test set images (1648877 bytes) </div><div class=\"line\">//测试集-label数据</div><div class=\"line\">t10k-labels-idx1-ubyte.gz:   test set labels (4542 bytes)</div></pre></td></tr></table></figure>\n<p>训练集-图片数据的格式如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">[offset] [type]          [value]          [description] </div><div class=\"line\">0000     32 bit integer  0x00000803(2051) magic number </div><div class=\"line\">0004     32 bit integer  60000            number of images </div><div class=\"line\">0008     32 bit integer  28               number of rows </div><div class=\"line\">0012     32 bit integer  28               number of columns </div><div class=\"line\">0016     unsigned byte   ??               pixel </div><div class=\"line\">0017     unsigned byte   ??               pixel </div><div class=\"line\">........ </div><div class=\"line\">xxxx     unsigned byte   ??               pixel</div></pre></td></tr></table></figure>\n<p>训练集-label 数据的格式如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">[offset] [type]          [value]          [description] </div><div class=\"line\">0000     32 bit integer  0x00000801(2049) magic number (MSB first) </div><div class=\"line\">0004     32 bit integer  60000            number of items </div><div class=\"line\">0008     unsigned byte   ??               label </div><div class=\"line\">0009     unsigned byte   ??               label </div><div class=\"line\">........ </div><div class=\"line\">xxxx     unsigned byte   ??               label</div><div class=\"line\">The labels values are 0 to 9.</div></pre></td></tr></table></figure>\n<p>测试集的数据格式和训练集是一样的。</p>\n<p>首先我们写个程序试着解析一下这些数据：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div></pre></td><td class=\"code\"><pre><div class=\"line\">#coding=utf-8</div><div class=\"line\">import os</div><div class=\"line\">import struct</div><div class=\"line\">import numpy as np</div><div class=\"line\">import matplotlib.pyplot as plt</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def load_mnist(path, kind=&apos;train&apos;):</div><div class=\"line\">    # 读取文件</div><div class=\"line\">    labels_path = os.path.join(path,</div><div class=\"line\">                               &apos;%s-labels-idx1-ubyte&apos;</div><div class=\"line\">                               % kind)</div><div class=\"line\">    images_path = os.path.join(path,</div><div class=\"line\">                               &apos;%s-images-idx3-ubyte&apos;</div><div class=\"line\">                               % kind)</div><div class=\"line\">    with open(labels_path, &apos;rb&apos;) as lbpath:</div><div class=\"line\">        # 读取magic numer，labels数量</div><div class=\"line\">        magic, n = struct.unpack(&apos;&gt;II&apos;,</div><div class=\"line\">                                 lbpath.read(8))</div><div class=\"line\">        print &apos;label magic : &apos;,</div><div class=\"line\">        print magic</div><div class=\"line\">        # 载入label数据</div><div class=\"line\">        labels = np.fromfile(lbpath,</div><div class=\"line\">                             dtype=np.uint8).reshape(n, 1)</div><div class=\"line\"></div><div class=\"line\">    with open(images_path, &apos;rb&apos;) as imgpath:</div><div class=\"line\">        # 读取magic numer，图片数量，图片宽，高</div><div class=\"line\">        magic, num, rows, cols = struct.unpack(&apos;&gt;IIII&apos;,</div><div class=\"line\">                                               imgpath.read(16))</div><div class=\"line\">        print &apos;image magic : &apos;,</div><div class=\"line\">        print magic</div><div class=\"line\">        # 载入图片数据</div><div class=\"line\">        images = np.fromfile(imgpath,</div><div class=\"line\">                             dtype=np.uint8).reshape(num, rows * cols)</div><div class=\"line\"></div><div class=\"line\">    return images, labels, rows, cols</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def show_image():</div><div class=\"line\">    images, labels, rows, cols = load_mnist(&apos;/tmp/TensorFlow/mnist/input_data/&apos;)</div><div class=\"line\">    fig, ax = plt.subplots(</div><div class=\"line\">        nrows=2,</div><div class=\"line\">        ncols=5,</div><div class=\"line\">        sharex=True,</div><div class=\"line\">        sharey=True, )</div><div class=\"line\"></div><div class=\"line\">    ax = ax.flatten()</div><div class=\"line\">    for i in range(10):</div><div class=\"line\">        img = images[i].reshape(rows, cols)</div><div class=\"line\">        print labels[i]</div><div class=\"line\">        ax[i].imshow(img, cmap=&apos;Greys&apos;, interpolation=&apos;nearest&apos;)</div><div class=\"line\"></div><div class=\"line\">    ax[0].set_xticks([])</div><div class=\"line\">    ax[0].set_yticks([])</div><div class=\"line\">    plt.tight_layout()</div><div class=\"line\">    plt.show()</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">if __name__ == &apos;__main__&apos;:</div><div class=\"line\">  show_image()</div></pre></td></tr></table></figure>\n<p>运行程序后，会显示输入集的前 10 张图片，如下图所示：</p>\n<p><img src=\"https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/Tensorflow%E5%85%A5%E9%97%A8/Snip20180503_1.png\" alt=\"\"></p>\n<p>在控制台会输出 labels</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">label magic :  2049</div><div class=\"line\">image magic :  2051</div><div class=\"line\">[5] [0] [4] [1] [9] [2] [1] [3] [1] [4]</div></pre></td></tr></table></figure>\n<p>这是一个 CNN 模型需要的典型的输入，有一些数据，每个数据都有一个 label。后面我们做自己项目的时候，也是这种数据格式。</p>\n<p>因为 MNIST 问题是个比较典型的问题，所以 TensorFlow 甚至封装了解析的方法。</p>\n<h3 id=\"3-2-MNIST问题代码解析\"><a href=\"#3-2-MNIST问题代码解析\" class=\"headerlink\" title=\"3.2 MNIST问题代码解析\"></a>3.2 MNIST问题代码解析</h3><p>完整的代码在 TensorFlow 的 /TensorFlow/git/TensorFlow/TensorFlow/examples/tutorials/mnist/mnist_deep.py 里面。</p>\n<p>我们根据程序的运行顺序来看一下。</p>\n<h4 id=\"3-2-1-读取数据\"><a href=\"#3-2-1-读取数据\" class=\"headerlink\" title=\"3.2.1 读取数据\"></a>3.2.1 读取数据</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">if __name__ == &apos;__main__&apos;:</div><div class=\"line\">  # 解析命令行参数，默认没有</div><div class=\"line\">  parser = argparse.ArgumentParser()</div><div class=\"line\">  # 添加MNIST数据集的下载地址</div><div class=\"line\">  parser.add_argument(&apos;--data_dir&apos;, type=str,</div><div class=\"line\">                      default=&apos;/tmp/TensorFlow/mnist/input_data&apos;,</div><div class=\"line\">                      help=&apos;Directory for storing input data&apos;)</div><div class=\"line\">  FLAGS, unparsed = parser.parse_known_args()</div><div class=\"line\">  # 运行main方法</div><div class=\"line\">  tf.app.run(main=main, argv=[sys.argv[0]] + unparsed)</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"># Import data</div><div class=\"line\">mnist = input_data.read_data_sets(FLAGS.data_dir)</div></pre></td></tr></table></figure>\n<p>代码将 MNIST 的下载和解析过程封装了一次，看下 read_data_sets 方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">def read_data_sets(train_dir,</div><div class=\"line\">                   fake_data=False,</div><div class=\"line\">                   one_hot=False,</div><div class=\"line\">                   dtype=dtypes.float32,</div><div class=\"line\">                   reshape=True,</div><div class=\"line\">                   validation_size=5000,</div><div class=\"line\">                   seed=None,</div><div class=\"line\">                   source_url=DEFAULT_SOURCE_URL):</div><div class=\"line\">                   ...</div><div class=\"line\">                   return base.Datasets(train=train, validation=validation, test=test)</div></pre></td></tr></table></figure>\n<p>这个方法最后返回的是一个 Datasets 格式，里面 train，validation 和 test 都是已经解析好的数据，解析方法就类似于上一节讲到的。</p>\n<p>读到这里，你可能有个疑问，MNIST 数据里面只有 train 和 test，那验证数据集 validation 是哪里来的。这里 validation 使用的就是 train 数据集。CNN 网络在每次训练完之后运行 validation 数据集，可以让开发者了解目前的准确度，在所有训练结束之后运行 test 数据集，可以知道训练出的这个模型的准确度。所以运行 validation 数据只是给开发者参考用的，这里对数据的要求不是很严苛，可以直接用 train 的数据集，而最后测试模型的准确度时使用的 test 数据集一定不能是 train 里面的数据，因为如果两个数据集有重合，可能无法准确的测试模型的准确度。</p>\n<h4 id=\"3-2-2-定义输入输出\"><a href=\"#3-2-2-定义输入输出\" class=\"headerlink\" title=\"3.2.2 定义输入输出\"></a>3.2.2 定义输入输出</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"># Create the model</div><div class=\"line\">x = tf.placeholder(tf.float32, [None, 784], name=&quot;x&quot;)</div><div class=\"line\"></div><div class=\"line\"># Define loss and optimizer</div><div class=\"line\">y_ = tf.placeholder(tf.int64, [None])</div></pre></td></tr></table></figure>\n<p>tf.placeholder 可以理解为定义占位符，这些占位符虽然定义的时候没有值，但在实际运行中会给定输入值。这里定义了两个占位符，一个是输入值 x，类型是浮点数，维度是 [None, 784]，None 代表不确定数量，784 代表 28*28，也就是一张 MNIST 输入集的图片，这里的意思是说输入层x可以是不确定数量的图片，代表着我们这个网络可以同时输入多张图片的数据。这种变量就是 TensorFlow 的张量 tensor，而每个 tensor 都可以指定名称，但是我们一般只指定具有代表性的几个 tensor 的名称，比如这个输入节点的名称是 x。</p>\n<p>而 y_ 声明的存储 label 的变量，类型是 int 类型，因为 label 是 1-10，也是不确定数量的，因为前面x输入多少图片，这里的 label 就应该有多少数量。</p>\n<p>声明一个变量为什么要如此复杂，为什么不能像我们写程序一样直接声明 float x = 5 这样。这里需要给读者讲解一下 TensorFlow 计算图和静态图的概念。训练一个深度学习网络的时候，是需要大量计算的，而深度学习框架为了加快计算速度，会直接把计算的过程扔给 CPU 或 GPU 去运行，CPU 和 GPU 运行结束后返回框架结果。举个简单的例子，如果我们要计算 3*5+2，普通的程序是先计算 3*5，得到结果之后再 +2，得到结果。如果 TensorFlow 也这样做的话，相当于让 CPU 算 3*5， CPU 算完后返回结果，然后把返回的结果和 2 再扔给 CPU 去算，最后得到结果。但是需要知道的是，每一次和CPU的交互其实都是特别浪费时间的，所以如果像普通的程序一样，那训练神经网络会特别耗时。所以有一些深度学习框架像 TensorFlow 提出了静态图的概念，首先定义好整个计算图，放在前面的例子里，就是定义好“先乘后加”，然后将需要计算的数字和这个计算图扔给 CPU，最后 CPU 会计算出一个最终的结果返回给框架，这样整个过程中框架和CPU只有一次交互。这样做可以提升计算的速度，但是有一个致命的缺点是不能调试，你不能在 3*5 之后打个断点看看结果对不对，你只能知道最后的结果是不是正确。</p>\n<p>所以 tf.placeholder 只是定义了整个计算图中的一个节点 tensor，所以必须用TensorFlow 定义 tensor 的语法。</p>\n<h4 id=\"3-2-3-定义计算图\"><a href=\"#3-2-3-定义计算图\" class=\"headerlink\" title=\"3.2.3 定义计算图\"></a>3.2.3 定义计算图</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"># Build the graph for the deep net</div><div class=\"line\">  y_conv = deepnn(x)</div></pre></td></tr></table></figure>\n<p>deepnn 这个方法是整个程序的核心，在这个方法中定义了一整个计算图。我们一层一层的看。这个 CNN 的网络用的是LeNet网络。构成是这样的。</p>\n<p><img src=\"https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/Tensorflow%E5%85%A5%E9%97%A8/4.png\" alt=\"这里写图片描述\"></p>\n<p>其中有两层卷积层，两层池化层，最后输出层是两层全连接层。代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div></pre></td><td class=\"code\"><pre><div class=\"line\">def deepnn(x):</div><div class=\"line\">  &quot;&quot;&quot;deepnn builds the graph for a deep net for classifying digits.</div><div class=\"line\"></div><div class=\"line\">  Args:</div><div class=\"line\">    x: an input tensor with the dimensions (N_examples, 784), where 784 is the</div><div class=\"line\">    number of pixels in a standard MNIST image.</div><div class=\"line\"></div><div class=\"line\">  Returns:</div><div class=\"line\">    A tuple (y, keep_prob). y is a tensor of shape (N_examples, 10), with values</div><div class=\"line\">    equal to the logits of classifying the digit into one of 10 classes (the</div><div class=\"line\">    digits 0-9). keep_prob is a scalar placeholder for the probability of</div><div class=\"line\">    dropout.</div><div class=\"line\">  &quot;&quot;&quot;</div><div class=\"line\">  # Reshape to use within a convolutional neural net.</div><div class=\"line\">  # Last dimension is for &quot;features&quot; - there is only one here, since images are</div><div class=\"line\">  # grayscale -- it would be 3 for an RGB image, 4 for RGBA, etc.</div><div class=\"line\">  with tf.name_scope(&apos;reshape&apos;):</div><div class=\"line\">    x_image = tf.reshape(x, [-1, 28, 28, 1])</div><div class=\"line\"></div><div class=\"line\">  # First convolutional layer - maps one grayscale image to 32 feature maps.</div><div class=\"line\">  with tf.name_scope(&apos;conv1&apos;):</div><div class=\"line\">    W_conv1 = weight_variable([5, 5, 1, 32])</div><div class=\"line\">    b_conv1 = bias_variable([32])</div><div class=\"line\">    h_conv1 = tf.nn.relu(conv2d(x_image, W_conv1) + b_conv1)</div><div class=\"line\"></div><div class=\"line\">  # Pooling layer - downsamples by 2X.</div><div class=\"line\">  with tf.name_scope(&apos;pool1&apos;):</div><div class=\"line\">    h_pool1 = max_pool_2x2(h_conv1)</div><div class=\"line\"></div><div class=\"line\">  # Second convolutional layer -- maps 32 feature maps to 64.</div><div class=\"line\">  with tf.name_scope(&apos;conv2&apos;):</div><div class=\"line\">    W_conv2 = weight_variable([5, 5, 32, 64])</div><div class=\"line\">    b_conv2 = bias_variable([64])</div><div class=\"line\">    h_conv2 = tf.nn.relu(conv2d(h_pool1, W_conv2) + b_conv2)</div><div class=\"line\"></div><div class=\"line\">  # Second pooling layer.</div><div class=\"line\">  with tf.name_scope(&apos;pool2&apos;):</div><div class=\"line\">    h_pool2 = max_pool_2x2(h_conv2)</div><div class=\"line\"></div><div class=\"line\">  # Fully connected layer 1 -- after 2 round of downsampling, our 28x28 image</div><div class=\"line\">  # is down to 7x7x64 feature maps -- maps this to 1024 features.</div><div class=\"line\">  with tf.name_scope(&apos;fc1&apos;):</div><div class=\"line\">    W_fc1 = weight_variable([7 * 7 * 64, 1024])</div><div class=\"line\">    b_fc1 = bias_variable([1024])</div><div class=\"line\"></div><div class=\"line\">    h_pool2_flat = tf.reshape(h_pool2, [-1, 7 * 7 * 64])</div><div class=\"line\">    h_fc1 = tf.nn.relu(tf.matmul(h_pool2_flat, W_fc1) + b_fc1)</div><div class=\"line\"></div><div class=\"line\">  # Map the 1024 features to 10 classes, one for each digit</div><div class=\"line\">  with tf.name_scope(&apos;fc2&apos;):</div><div class=\"line\">    W_fc2 = weight_variable([1024, 10])</div><div class=\"line\">    b_fc2 = bias_variable([10])</div><div class=\"line\"></div><div class=\"line\">    y_conv = tf.add(tf.matmul(h_fc1, W_fc2), b_fc2, name=&quot;output&quot;)</div><div class=\"line\">  return y_conv</div></pre></td></tr></table></figure>\n<p>下面一层一层的看这个网络是怎么工作的。</p>\n<h5 id=\"卷积层\"><a href=\"#卷积层\" class=\"headerlink\" title=\"卷积层\"></a>卷积层</h5><p>CNN 叫卷积神经网络，可以看出卷积是这个网络的核心。卷积层是用于提取图片特征，卷积的操作是用一个卷积矩阵（也叫卷积核）在输入矩阵上依次扫描，做矩阵相乘，得到的结果输入矩阵的某一个特征。这样讲是不太好理解，下面用图片说一下这个过程。</p>\n<p>假设输入矩阵是这样的<br><img src=\"https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/Tensorflow%E5%85%A5%E9%97%A8/5.png\" alt=\"这里写图片描述\"></p>\n<p>选取如下一个卷积核<br><img src=\"https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/Tensorflow%E5%85%A5%E9%97%A8/6.png\" alt=\"这里写图片描述\"></p>\n<p>用卷积核在输入矩阵上依次扫过，做矩阵相乘的操作，就可以得到输入矩阵由这个卷积核提取的特征。</p>\n<p><img src=\"https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/Tensorflow%E5%85%A5%E9%97%A8/7.gif\" alt=\"这里写图片描述\"></p>\n<blockquote>\n<p>在 CNN 的术语中，3x3 的矩阵叫做“滤波器（filter）”或者“核（kernel）”或者“特征检测器（feature detector）”，通过在图像上滑动滤波器并计算点乘得到矩阵叫做“卷积特征（Convolved Feature）”或者“激活图（Activation Map）”或者“特征图（Feature Map）”。记住滤波器在原始输入图像上的作用是特征检测器。</p>\n</blockquote>\n<p>是不是在怀疑，这种操作真的能够提取特征吗，看下对实际图片进行卷积操作的例子。</p>\n<p>输入图像如下：<br><img src=\"https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/Tensorflow%E5%85%A5%E9%97%A8/8.png\" alt=\"这里写图片描述\"></p>\n<p>用不同的卷积核进行卷积操作的结果如下：</p>\n<p><img src=\"https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/Tensorflow%E5%85%A5%E9%97%A8/10.jpeg\" alt=\"这里写图片描述\"></p>\n<p>可以看到，不同的卷积核对原图像进行处理后可以得到不同的特征图像，有的卷积核能提取边缘信息，有的卷积核能提取色彩信息，有的卷积核能提取明暗特征，等等等等。有没有觉得这一步特别像 PS 中的滤镜，其实卷积的操作和滤镜的操作是很类似的。不同的卷积就像不同的滤镜对不同的特征敏感度不同。而代码中的卷积层如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"># First convolutional layer - maps one grayscale image to 32 feature maps.</div><div class=\"line\">  with tf.name_scope(&apos;conv1&apos;):</div><div class=\"line\">    W_conv1 = weight_variable([5, 5, 1, 32])</div><div class=\"line\">    b_conv1 = bias_variable([32])</div><div class=\"line\">    h_conv1 = tf.nn.relu(conv2d(x_image, W_conv1) + b_conv1)</div></pre></td></tr></table></figure>\n<p>首先定义一个卷积核 W_conv1 变量，由于后面会多次定义变量，所以将定义变量的部分提取了方法，如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">def weight_variable(shape):</div><div class=\"line\">  &quot;&quot;&quot;weight_variable generates a weight variable of a given shape.&quot;&quot;&quot;</div><div class=\"line\">  initial = tf.truncated_normal(shape, stddev=0.1)</div><div class=\"line\">  return tf.Variable(initial)</div></pre></td></tr></table></figure>\n<p>tf.Variable 生成一个变量 tensor，参数 initial 是初始化值。initial 由truncated_normal 方法生成，shape 指定了生成变量的维度，这里是[5,5,1,32]四维的变量，初始化值是由 truncated_normal 产生的正态分布的值，这就是 truncated_normal 方法的作用，详细的说明可以看文档。</p>\n<p>相对于卷积核的声明，偏量 b_conv1 的生成要简单一点。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">def bias_variable(shape):</div><div class=\"line\">  &quot;&quot;&quot;bias_variable generates a bias variable of a given shape.&quot;&quot;&quot;</div><div class=\"line\">  initial = tf.constant(0.1, shape=shape)</div><div class=\"line\">  return tf.Variable(initial)</div></pre></td></tr></table></figure>\n<p>初始化值是固定的 0.1。<br>这两个变量的初始化值不能是 0，而要加入一些脏值，是为了打破对称性以及避免 0 梯度，提升模型训练的效率。</p>\n<p>后面的代码就是执行卷积操作，我们来看，</p>\n<p><code>conv2d(x_image, W_conv1)</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">def conv2d(x, W):</div><div class=\"line\">  &quot;&quot;&quot;conv2d returns a 2d convolution layer with full stride.&quot;&quot;&quot;</div><div class=\"line\">  return tf.nn.conv2d(x, W, strides=[1, 1, 1, 1], padding=&apos;SAME&apos;)</div></pre></td></tr></table></figure>\n<p>这个函数就是 TensorFlow 中用于做卷积的函数，2d 代表生成的是一个二维特征图，这个是什么意思呢，后面会提到。除了 conv2d，还有 conv1d 和 conv3d 函数。</p>\n<p>看下 conv2d 的函数签名。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">tf.nn.conv2d(input, filter, strides, padding, use_cudnn_on_gpu=None, name=None)</div></pre></td></tr></table></figure>\n<p>除去 name 参数用以指定该操作的 name，与方法有关的一共五个参数：</p>\n<p>第一个参数 input：指需要做卷积的输入图像，它要求是一个 tensor，具有 [batch, in_height, in_width, in_channels] 这样的 shape，具体含义是[训练时一个 batch 的图片数量, 图片高度, 图片宽度, 图像通道数]，注意这是一个 4 维的 tensor，要求类型为 float32 和 float64 其中之一</p>\n<p>第二个参数 filter：相当于 CNN 中的卷积核，它要求是一个 tensor，具有 [filter_height, filter_width, in_channels, out_channels] 这样的shape，具体含义是[卷积核的高度，卷积核的宽度，图像通道数，卷积核个数]，要求类型与参数 input 相同，有一个地方需要注意，第三维 in_channels，就是参数 input 的第四维</p>\n<p>第三个参数 strides：卷积时在图像每一维每一次移动的步长，这是一个一维的向量，长度跟前面卷积核的维度相同，这里是4。</p>\n<p>第四个参数 padding：string 类型的量，只能是 “SAME”, “VALID” 其中之一，这个值决定了不同的卷积方式</p>\n<p>第五个参数：use_cudnn_on_gpu: bool 类型，是否使用 cudnn 加速，默认为 true，cudnn 是英伟达的GPU处理单元，这里也就是用 GPU 进行加速计算。</p>\n<h6 id=\"二维特征向量\"><a href=\"#二维特征向量\" class=\"headerlink\" title=\"二维特征向量\"></a>二维特征向量</h6><p>conv2d 生成的是二维特征向量，conv2d 有两个参数是必要的，input 和 filter。我们的输入参数是一张图片，三维的数据[宽，高，颜色空间]，为了最后向量相乘的结果是二维的，filer 的第三个维度应该和 input 的第四个维度相等，也就是 in_channels 相等，这样永远都只能输出一个二维的特征向量，也就是这个函数叫 conv2d 的原因，这里比较难理解，可以仔细考虑一下。</p>\n<h6 id=\"padding参数\"><a href=\"#padding参数\" class=\"headerlink\" title=\"padding参数\"></a>padding参数</h6><p>padding 参数的可选值是 SAME 和 VALID，这个参数影响了了卷积核对输入矩阵边缘的处理，决定了输出的特征向量大小。</p>\n<p>卷积核和按照步数一步步的扫描输入矩阵，做乘法操作。但是在输入矩阵的边缘，如果输入矩阵剩余的维度小于定义的卷积核的维度，那么卷积核就无法做乘法操作了，剩余这部分边界怎么处理呢。</p>\n<p>如果 padding 是 SAME，则会在输入矩阵的两端补齐 0，使补齐后的输入矩阵维度刚好可以被卷积核处理，最后得到的特征矩阵和原来的输入矩阵维度相同。</p>\n<p><img src=\"https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/Tensorflow%E5%85%A5%E9%97%A8/11.png\" alt=\"这里写图片描述\"></p>\n<p>如果 padding 是 VALID，则会抛弃边界的节点，最后输出的特征矩阵维度和输入矩阵不相同</p>\n<p><img src=\"https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/Tensorflow%E5%85%A5%E9%97%A8/12.png\" alt=\"这里写图片描述\"></p>\n<p>再回来看代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">W_conv1 = weight_variable([5, 5, 3, 32])</div><div class=\"line\">conv2d(x_image, W_conv1)</div></pre></td></tr></table></figure>\n<p>卷积核是 5*5*3 的，一共 32 个卷积核，对图像处理后，可以得到32个特征向量，因为我们没有指定步长和 padding，所以步长默认是1，padding 是 SAME，这样的话，输出的特征矩阵就是28 <em> 28 </em> 1。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"># 第一个卷积层，从图像中提取32的特征</div><div class=\"line\">with tf.name_scope(&apos;conv1&apos;):</div><div class=\"line\">    W_conv1 = weight_variable([5, 5, 3, 32])  # y =wX+b</div><div class=\"line\">    b_conv1 = bias_variable([32])</div><div class=\"line\">    h_conv1 = tf.nn.relu(conv2d(x_image, W_conv1) + b_conv1)</div></pre></td></tr></table></figure>\n<p>做完了卷积后，进行了一个relu处理</p>\n<blockquote>\n<p>ReLU 是一个元素级别的操作（应用到各个像素），并将特征图中的所有小于 0 的像素值设置为零。ReLU 的目的是在 ConvNet 中引入非线性，因为在大部分的我们希望 ConvNet 学习的实际数据是非线性的（卷积是一个线性操作——元素级别的矩阵相乘和相加，所以我们需要通过使用非线性函数 ReLU 来引入非线性。</p>\n</blockquote>\n<p>引入非线性可以让神经网络更好的工作，这个更好的工作指的是在做反向传播的时候避免出现梯度消失的问题，原因涉及到比较深的理论，这篇文章就不多说了。</p>\n<p>这样第一个卷积操作就结束了。</p>\n<h5 id=\"池化\"><a href=\"#池化\" class=\"headerlink\" title=\"池化\"></a>池化</h5><p>卷积操作之后是一个池化层。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"># Pooling layer - downsamples by 2X.</div><div class=\"line\">  with tf.name_scope(&apos;pool1&apos;):</div><div class=\"line\">    h_pool1 = max_pool_2x2(h_conv1)</div></pre></td></tr></table></figure>\n<p>池化的作用类似于压缩，这种压缩是在缩小输入值的维度的同时还要保持输入值的特征。比如在 2*2 的 4 个像素点中取最大值，最小值或者平均值。不过经过研究，最大池化能够比较好的保持原来的特征值。</p>\n<p><img src=\"https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/Tensorflow%E5%85%A5%E9%97%A8/13.png\" alt=\"这里写图片描述\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"># 2*2的最大化池化层</div><div class=\"line\">    with tf.name_scope(&apos;pool1&apos;):</div><div class=\"line\">        h_pool1 = max_pool_2x2(h_conv1)</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">def max_pool_2x2(x):</div><div class=\"line\">  &quot;&quot;&quot;max_pool_2x2 downsamples a feature map by 2X.&quot;&quot;&quot;</div><div class=\"line\">  return tf.nn.max_pool(x, ksize=[1, 2, 2, 1],</div><div class=\"line\">                        strides=[1, 2, 2, 1], padding=&apos;SAME&apos;)</div></pre></td></tr></table></figure>\n<p>池化操作也是调用的 TensorFlow 的函数，参数 strides 和 padding 跟前面提到的 conv2d 函数的参数一致。ksize 是定义的在每个维度上池化的大小，上一步卷积之后，输出的特征向量是 1*28*28*1，所以在中间两个维度进行处理。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"># Second convolutional layer -- maps 32 feature maps to 64.</div><div class=\"line\">  with tf.name_scope(&apos;conv2&apos;):</div><div class=\"line\">    W_conv2 = weight_variable([5, 5, 32, 64])</div><div class=\"line\">    b_conv2 = bias_variable([64])</div><div class=\"line\">    h_conv2 = tf.nn.relu(conv2d(h_pool1, W_conv2) + b_conv2)</div><div class=\"line\"></div><div class=\"line\">  # Second pooling layer.</div><div class=\"line\">  with tf.name_scope(&apos;pool2&apos;):</div><div class=\"line\">    h_pool2 = max_pool_2x2(h_conv2)</div></pre></td></tr></table></figure>\n<p>后面又做了一个卷积操作和一个池化操作，这个跟前面的操作是一样的。卷积操作的输出不影响输入值的维度，但是影响输入值的深度。池化操作不影响输入值的深度但是影响输入值的维度，经过两层的卷积和 2<em>2 的池化后，输入值的维度变成了原来的 1/4。深度变成 64。也就是 7\\</em>7*64。</p>\n<p>上面的几层又叫隐藏层，表示使用者看不到的处理层。</p>\n<h5 id=\"全连接\"><a href=\"#全连接\" class=\"headerlink\" title=\"全连接\"></a>全连接</h5><p>接下来是输出层，输出层是两个全连接层。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"># Fully connected layer 1 -- after 2 round of downsampling, our 28x28 image</div><div class=\"line\"># is down to 7x7x64 feature maps -- maps this to 1024 features.</div><div class=\"line\">with tf.name_scope(&apos;fc1&apos;):</div><div class=\"line\">  W_fc1 = weight_variable([7 * 7 * 64, 1024])</div><div class=\"line\">  b_fc1 = bias_variable([1024])</div><div class=\"line\"></div><div class=\"line\">  h_pool2_flat = tf.reshape(h_pool2, [-1, 7 * 7 * 64])</div><div class=\"line\">  h_fc1 = tf.nn.relu(tf.matmul(h_pool2_flat, W_fc1) + b_fc1)</div><div class=\"line\"></div><div class=\"line\"># Map the 1024 features to 10 classes, one for each digit</div><div class=\"line\">with tf.name_scope(&apos;fc2&apos;):</div><div class=\"line\">  W_fc2 = weight_variable([1024, 10])</div><div class=\"line\">  b_fc2 = bias_variable([10])</div><div class=\"line\"></div><div class=\"line\">  y_conv = tf.add(tf.matmul(h_fc1, W_fc2), b_fc2, name=&quot;output&quot;)</div></pre></td></tr></table></figure>\n<p>全连接层，顾名思义，指的是这一层的每个节点都跟上一层的全部节点有连接。</p>\n<p><img src=\"https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/Tensorflow%E5%85%A5%E9%97%A8/Snip20180423_2.png\" alt=\"全连接节点\"></p>\n<p>比如图中全连接层的节点 a1 与上一层的所有节点 x1,x2,x3 有联系，a2 也与上一层的所有节点有联系，就这样，少一个也不行。因此解释全连接层的时候，图就是这样一个网状结构。</p>\n<p>上文中提到了联系，这里的“联系”具体指的是什么呢。如图所示，假设 x1，x2，x3 是全连接层的输入值，那么在全连接层的a1可以表示为以下的形式。</p>\n<p><img src=\"https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/Tensorflow%E5%85%A5%E9%97%A8/Snip20180423_3.png\" alt=\"\"></p>\n<p>从这个公式可以看出，a1 与 x1，x2，x3 都有联系，只是输入节点的权重值不同。同理，a2 和 a3 也可以表示为以下的形式。</p>\n<p><img src=\"https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/Tensorflow%E5%85%A5%E9%97%A8/Snip20180423_4.png\" alt=\"\"></p>\n<p>由此就可以从数学层面去理解什么叫全连接层，但是这个全连接层在实际应用中表示得意义是什么呢，简单来说，它可以作为一个分类网络，还是上面那个图，输入层是 3 个值，全连接层是 3 个节点，就代表这个全连接层可以把上一层的特征值分类为三种特征。当然，输入层和全连接层的节点数并不一定相同，比如下面这个结构。</p>\n<p><img src=\"https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/Tensorflow%E5%85%A5%E9%97%A8/Snip20180423_5.png\" alt=\"\"></p>\n<p>最后的全连接层是 10 个节点，全连接层的上一层是 15 个特征值，这样就把 15 个特征值归类为 10 种特征。举例来说，比如输出的 15 个特征标记位 t1-15，而 t1，t3，t5 三种特征可以认为都属于某一种输出 o1。而 t2，t6 两种特征可以认为属于输出 o2，以此类推，就可以把15个特征分类为 10 个输出。</p>\n<p>前面提到的MNIST问题中，全连接层有两层，第一层是 1024 个节点，第二层是 10 个节点。一般情况下，最靠近用户的输出层就是用户所期待的结果类别数，MNIST 问题中，用户期待的输出是 0-9 一共 10 个数字也就是 10 种类别，所以第二层全连接层是 10 个节点。再往前看，卷积层在每一个像素点上提取 64 个特征值，所以整个图片可以有高*宽*64个特征值，也就是 7*7*64 个特征，第一个全连接层是 1024 个节点，表示希望这个网络将这 7*7*64 个特征归类为 1024 个分类。至于为什么第一个连接层是 1024 个节点，是一个经验值的问题，这个节点的个数是可以调整的，后面会讲到全连接层对模型体积的影响，也会再说到这个经验值的问题。那么全连接层是如何分类的。一起来看一下。</p>\n<p>回顾一下全连接层的表示公式。</p>\n<p><img src=\"https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/Tensorflow%E5%85%A5%E9%97%A8/Snip20180423_3.png\" alt=\"\"></p>\n<p>这里的输入值 x1,x2,x3…，输出值 a1 和权重 W，偏移量 b 到底指的是什么呢。</p>\n<p>在MNIST的基础上，可以考虑这样一种情况。看下面这个图，对于0这个数字来说，我们经过训练之后，认为如果一张图片在中间红色部分出现了像素值，那这张图有一定概率不是 0，并且出现在红色部分的像素值越多，不是 0 的概率越大。如果在周围一圈的蓝色部分出现了像素值，那么这张图有一定概率是 0，并且出现在蓝色部分的像素值越多，是 0 的概率越大。</p>\n<p><img src=\"https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/Tensorflow%E5%85%A5%E9%97%A8/Snip20180423_6.png\" alt=\"\"></p>\n<p>这个过程用数学公式怎么表示呢，蓝色部分拥有正值的权重，红色部分拥有负值的权重，将输入图片的每个像素点与权重值进行相乘后求和，这样如果红色部分出现的像素值越多，则最后的和越小，如果蓝色部分出现的像素值越多，则最后的和越大。最后得出的结果我们称为是输入图片x是这种分类（比如分类0）的证据 evidence。这样对于一张输入的图片，最后落在每个节点上的 evidence 就可以用如下的公式表示。</p>\n<p><img src=\"https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/Tensorflow%E5%85%A5%E9%97%A8/Snip20180427_1.png\" alt=\"\"></p>\n<p>看这个公式，是不是就是全连接层的公式。所以全连接层这个过程比较绕，但是是深度学习网络的基本原理，可以仔细理解一下。</p>\n<p>反过来看代码。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"># Fully connected layer 1 -- after 2 round of downsampling, our 28x28 image</div><div class=\"line\"># is down to 7x7x64 feature maps -- maps this to 1024 features.</div><div class=\"line\">with tf.name_scope(&apos;fc1&apos;):</div><div class=\"line\">  W_fc1 = weight_variable([7 * 7 * 64, 1024])</div><div class=\"line\">  b_fc1 = bias_variable([1024])</div><div class=\"line\"></div><div class=\"line\">  h_pool2_flat = tf.reshape(h_pool2, [-1, 7 * 7 * 64])</div><div class=\"line\">  h_fc1 = tf.nn.relu(tf.matmul(h_pool2_flat, W_fc1) + b_fc1)</div></pre></td></tr></table></figure>\n<p>首先生成全连接层的权重 W_fc1 和偏量 b_fc1，这里复用了前面卷积操作生成卷积核和偏量的两个方法，虽然概念不同，但计算是相通的，所以可以复用。tf.reshape(h_pool2, [-1, 7 <em> 7 </em> 64]) 将之前层的四维 [1,7,7,64] 的输出变成一个一维的向量，因为全连接层只能处理一维的问题。后面用 tf.matmul 向量乘法实现了全连接层的操作。tf.nn.relu 和前面一样，是个激活函数。</p>\n<h5 id=\"droupout\"><a href=\"#droupout\" class=\"headerlink\" title=\"droupout\"></a>droupout</h5><p>在第一层全连接层之后，加了一个 dropout 的操作</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"># Dropout - controls the complexity of the model, prevents co-adaptation of</div><div class=\"line\"># features.</div><div class=\"line\">with tf.name_scope(&apos;dropout&apos;):</div><div class=\"line\">  keep_prob = tf.placeholder(tf.float32)</div><div class=\"line\">  h_fc1_drop = tf.nn.dropout(h_fc1, keep_prob)</div></pre></td></tr></table></figure>\n<p>droupout 的操作如下图所示：<br><img src=\"https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/Tensorflow%E5%85%A5%E9%97%A8/Snip20180504_2.png\" alt=\"\"></p>\n<p>在计算的过程中，随机的“丢弃”一些节点，简单来说，h_fc1有 1024 个节点，在 droupout 之后，如果 keep_prob 是50%，那么经过 droupout 之后，可以认为参与计算的是 512 个节点。droupout 有两个优势。</p>\n<ul>\n<li>解决过拟合的问题</li>\n<li>在训练中加入概率性</li>\n</ul>\n<p>droupout 操作之后又是一层全连接。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"># Map the 1024 features to 10 classes, one for each digit</div><div class=\"line\">with tf.name_scope(&apos;fc2&apos;):</div><div class=\"line\">  W_fc2 = weight_variable([1024, 10])</div><div class=\"line\">  b_fc2 = bias_variable([10])</div><div class=\"line\"></div><div class=\"line\">  y_conv = tf.add(tf.matmul(h_fc1, W_fc2), b_fc2, name=&quot;output&quot;)</div></pre></td></tr></table></figure>\n<p>第二层全连接将上一层产生的 1024 个节点归类到 10 个节点上，，得到最后的输出。即使经过 droupout 之后，实体依然是 1024 个节点，只是其中一部分不再参与计算。这个网络结构最后的输出是10个节点的 evidence 的值。</p>\n<h4 id=\"3-2-4-Softmax回归处理\"><a href=\"#3-2-4-Softmax回归处理\" class=\"headerlink\" title=\"3.2.4 Softmax回归处理\"></a>3.2.4 Softmax回归处理</h4><p>至此，整个计算图就定义完了，接下来定义一些训练中的必要单元来告知框架如何训练。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">with tf.name_scope(&apos;loss&apos;):</div><div class=\"line\">  cross_entropy = tf.losses.sparse_softmax_cross_entropy(</div><div class=\"line\">      labels=y_, logits=y_conv)</div><div class=\"line\">cross_entropy = tf.reduce_mean(cross_entropy)</div></pre></td></tr></table></figure>\n<p>定义损失函数使用 softmax 交叉熵的，关于 softmax 和交叉熵，这里引用<a href=\"https://blog.csdn.net/chaipp0607/article/details/73392175\" target=\"_blank\" rel=\"external\">传送门</a>一段描述。</p>\n<p>神经网络的原始输出不是一个概率值，实质上只是输入的数值做了复杂的加权和与非线性处理之后的一个值而已，那么如何将这个输出变为概率分布？ </p>\n<p>这就是 softmax 层的作用，假设神经网络的原始输出为 y1,y2,….,yn，那么经过 softmax 回归处理之后的输出为： </p>\n<p><img src=\"https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/Tensorflow%E5%85%A5%E9%97%A8/Snip20180504_3.png\" alt=\"\"></p>\n<p>经过 softmax 的公式后，所有节点的和变成了 1，之前神经网络输出的每个节点的权重值变成了每个节点的概率值。</p>\n<p>单个节点的输出变成的一个概率值，经过 softmax 处理后结果作为神经网络最后的输出。label</p>\n<h4 id=\"3-2-5-交叉熵的原理\"><a href=\"#3-2-5-交叉熵的原理\" class=\"headerlink\" title=\"3.2.5 交叉熵的原理\"></a>3.2.5 交叉熵的原理</h4><p>交叉熵刻画的是实际输出（概率）与期望输出（概率）的距离，也就是交叉熵的值越小，两个概率分布就越接近。假设概率分布 p 为期望输出，概率分布 q 为实际输出，H(p,q) 为交叉熵，则：</p>\n<p><img src=\"https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/Tensorflow%E5%85%A5%E9%97%A8/Snip20180504_4.png\" alt=\"\"></p>\n<p>这个公式如何表征距离呢，举个例子：<br>假设 N=3，期望输出为 p = (1,0,0)，实际输出 q1 = (0.5,0.2,0.3)，q2 = (0.8,0.1,0.1)，那么：</p>\n<p><img src=\"https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/Tensorflow%E5%85%A5%E9%97%A8/Snip20180504_5.png\" alt=\"\"></p>\n<p>很显然，q2 与 p 更为接近，它的交叉熵也更小。<br>除此之外，交叉熵还有另一种表达形式，还是使用上面的假设条件：</p>\n<p><img src=\"https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/Tensorflow%E5%85%A5%E9%97%A8/Snip20180504_6.png\" alt=\"\"></p>\n<p>其结果为：</p>\n<p><img src=\"https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/Tensorflow%E5%85%A5%E9%97%A8/Snip20180504_7.png\" alt=\"\"></p>\n<p>以上的所有说明针对的都是单个样例的情况，而在实际的使用训练过程中，数据往往是组合成为一个 batch 来使用，所以对用的神经网络的输出应该是一个 m*n 的二维矩阵，其中 m 为 batch 的个数，n为分类数目，而对应的 label 也是一个二维矩阵，还是拿上面的数据，组合成一个 batch=2 的矩阵：</p>\n<p><img src=\"https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/Tensorflow%E5%85%A5%E9%97%A8/Snip20180504_8.png\" alt=\"\"></p>\n<p>所以交叉熵的结果应该是一个列向量（根据第一种方法）： </p>\n<p><img src=\"https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/Tensorflow%E5%85%A5%E9%97%A8/Snip20180504_9.png\" alt=\"\"></p>\n<p>而对于一个 batch，最后取平均为 0.2。</p>\n<p>tf.losses.sparse_softmax_cross_entropy 是 TensorFlow 将以上两个过程封装后的产物，最后的结果是一个 batch 的概率值，reduce_mean 用来取得概率的平均值。综上作为整个网络的损失函数。</p>\n<h4 id=\"3-2-6-训练方法-梯度下降\"><a href=\"#3-2-6-训练方法-梯度下降\" class=\"headerlink\" title=\"3.2.6 训练方法-梯度下降\"></a>3.2.6 训练方法-梯度下降</h4><p>然后定义梯度下降的方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">with tf.name_scope(&apos;adam_optimizer&apos;):</div><div class=\"line\">  train_step = tf.train.AdamOptimizer(1e-4).minimize(cross_entropy)</div></pre></td></tr></table></figure>\n<p>以下降步速，即学习率为1e-4的速度最小化损失函数 cross_entropy。这样就能定义训练的目的是为了让损失函数越来越来，每次参数的变化值为1e-4。</p>\n<h4 id=\"3-2-7-准确度\"><a href=\"#3-2-7-准确度\" class=\"headerlink\" title=\"3.2.7 准确度\"></a>3.2.7 准确度</h4><p>定义准确度的计算方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">with tf.name_scope(&apos;accuracy&apos;):</div><div class=\"line\">  correct_prediction = tf.equal(tf.argmax(y_conv, 1), y_)</div><div class=\"line\">  correct_prediction = tf.cast(correct_prediction, tf.float32)</div><div class=\"line\">accuracy = tf.reduce_mean(correct_prediction)</div></pre></td></tr></table></figure>\n<p>y_conv 是网络输出的原始结果，也就是图片在最后 10 个节点上的权重值，比如 [314, -423, 342…] ，最后权重值最大的节点是我们的期望节点，比如这里第三个节点的权重值最大，那这幅图片可能就是数字 2，tf.argmax 是取出权重值最大的下标。y_ 是我们给的 label 值，把这两个值相比较得出准确度。最后依然用 tf.reduce_mean 算出 batch 的平均准确度。</p>\n<h4 id=\"3-2-8-计算图可视化\"><a href=\"#3-2-8-计算图可视化\" class=\"headerlink\" title=\"3.2.8 计算图可视化\"></a>3.2.8 计算图可视化</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">graph_location = tempfile.mkdtemp()</div><div class=\"line\">print(&apos;Saving graph to: %s&apos; % graph_location)</div><div class=\"line\">train_writer = tf.summary.FileWriter(graph_location)</div><div class=\"line\">train_writer.add_graph(tf.get_default_graph())</div></pre></td></tr></table></figure>\n<p>这是 TensorFlow 提供的计算图可视化的方法，这里暂时没起到作用。</p>\n<h4 id=\"3-2-9-启动计算图\"><a href=\"#3-2-9-启动计算图\" class=\"headerlink\" title=\"3.2.9 启动计算图\"></a>3.2.9 启动计算图</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">with tf.Session() as sess:</div><div class=\"line\">  sess.run(tf.global_variables_initializer())</div><div class=\"line\">  for i in range(20000):</div><div class=\"line\">    batch = mnist.train.next_batch(50)</div><div class=\"line\">    if i % 100 == 0:</div><div class=\"line\">      train_accuracy = accuracy.eval(feed_dict=&#123;</div><div class=\"line\">          x: batch[0], y_: batch[1], keep_prob: 1.0&#125;)</div><div class=\"line\">      print(&apos;step %d, training accuracy %g&apos; % (i, train_accuracy))</div><div class=\"line\">    train_step.run(feed_dict=&#123;x: batch[0], y_: batch[1], keep_prob: 0.5&#125;)</div><div class=\"line\"></div><div class=\"line\">  print(&apos;test accuracy %g&apos; % accuracy.eval(feed_dict=&#123;</div><div class=\"line\">      x: mnist.test.images, y_: mnist.test.labels, keep_prob: 1.0&#125;))</div></pre></td></tr></table></figure>\n<p>这里就是前面提到的将计算图和计算数据给 CPU 计算，TensorFlow 将和 CPU 的一个交互过程定义为 session，启动 session 后，开始运行。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sess.run(tf.global_variables_initializer())</div></pre></td></tr></table></figure>\n<p>首先将前面定义的所有变量初始化，注意前面在定义图的时候只是定义了变量初始化的方法，而没有真正去做初始化，真正运行是在这个地方。</p>\n<p>然后循环 20000 次，每次从训练集中取出50个图片数据作为一个 batch。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">train_step.run(feed_dict=&#123;x: batch[0], y_: batch[1], keep_prob: 0.5&#125;)</div></pre></td></tr></table></figure>\n<p>开始训练，train_step 是前面定义的梯度下降的方法，以这种方法开始训练。参数是图片数据，正确的 labels，和 droupout 的参数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">if i % 100 == 0:</div><div class=\"line\">        train_accuracy = accuracy.eval(feed_dict=&#123;</div><div class=\"line\">            x: batch[0], y_: batch[1], keep_prob: 1.0&#125;)</div><div class=\"line\">        print(&apos;step %d, training accuracy %g&apos; % (i, train_accuracy))</div></pre></td></tr></table></figure>\n<p>每训练 100 次，输出一下当前的准确率，是为了开发者感知的。测试准确率的时候，是不需要 droupout 操作的，所以 keep_prob 是1。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">print(&apos;test accuracy %g&apos; % accuracy.eval(feed_dict=&#123;</div><div class=\"line\">        x: mnist.test.images, y_: mnist.test.labels, keep_prob: 1.0&#125;))</div></pre></td></tr></table></figure>\n<p>20000 次训练之后，输出最终的准确率。</p>\n<p>输出结果类似这样的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">step 0, training accuracy 0.16</div><div class=\"line\">step 100, training accuracy 0.9</div><div class=\"line\">step 200, training accuracy 0.94</div><div class=\"line\">step 300, training accuracy 0.9</div><div class=\"line\">step 400, training accuracy 0.96</div><div class=\"line\">...</div><div class=\"line\">test accuracy 0.9446</div></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>至此，整个模型的训练过程就完全结束了。通过这个例子，我们知道了一个 CNN 网络是怎么工作的，并且如何用 TensorFlow 来实现一个 CNN 网络。下一篇文章，我将写一下如果改造这个例子，来解决我的一个实际问题。</p>\n","excerpt":"","more":"<h2 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1. 前言\"></a>1. 前言</h2><p>人工智能自从阿尔法狗大败李世石后就异常火爆，最近工作中需要探索 AI 在移动端的应用，趁着这个计划入门下深度学习吧。</p>\n<p>深度学习的入门曲线还是很陡峭的，看了很多资料，询问了从事相关工作的朋友后终于有点感觉了，这篇文章就讲一下我在这个过程中的所见所得吧，肯定是不专业的，如果所说有什么错误，也希望大家帮忙指出，共同进步。</p>\n<p>这个入门的文章准备分以下几个部分来说：</p>\n<ul>\n<li>CNN 的原理</li>\n<li>TensorFlow 使用 CNN 网络解决 MNIST 问题的例子讲解</li>\n<li>Demo 改造解决我自己的股票图片识别问题</li>\n<li>训练出的模型部署到 iOS 端的 TensorFlow Mobile 框架中</li>\n<li>训练出的模型部署到 iOS 端的 TensorFlow Lite 框架中</li>\n</ul>\n<p>首先我做的第一件事是分清楚一些概念，之前完全不懂得时候只觉得人工智能很厉害，能解决人力解决不了的问题，但人工智能到底是什么，完全不知道。既然要学习，首先就得分清楚人工智能，机器学习，深度学习都是些什么东西，需要从哪里入手等等这些问题。这个问了从事相关工作的同学后再查阅了一些资料后，很容易的就理解了。知乎上的这个回答比较靠谱，<a href=\"https://www.zhihu.com/question/57770020\">传送门</a>，总结一下就是这两句话。</p>\n<blockquote>\n<p>机器学习：一种实现人工智能的方法</p>\n<p>深度学习：一种实现机器学习的技术</p>\n</blockquote>\n<p>而三者的关系就是</p>\n<p><img src=\"https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/Tensorflow%E5%85%A5%E9%97%A8/1.png\" alt=\"这里写图片描述\"></p>\n<p>可以看的出来，人工智能是一个很大的概念，想用机器来解决问题的一种思想都可以认为是人工智能，而这个概念早在 19 世纪 50 年代就提出了。机器学习就是实现人工智能的一种方法，一切使用数据分析帮助决策的场景都可以叫做机器学习，这个概念从 19 世纪 80 年代到现在也已经发展了快 40 年了，机器学习其实一点都不神秘，在现代生产中的应用随处可见，比如各种网站的推荐算法，垃圾邮件的过滤算法等等。而最近火热的概念其实人工智能中很小的一部分，叫做深度学习。简单来说，使用深度神经网络去解决问题的学习方法叫做深度学习。如果说广义的机器学习是人类定义好规则，让计算机去做，那么深度学习就是人类定义好规则后，让计算机去学。深度学习依赖于现在计算能力的提升飞速发展，在图像识别、语音识别等领域发挥了巨大的作用。看完这篇文章后，你应该对深度学习会有一个简单的理解。</p>\n<p>考虑到机器学习的算法实在是太多，学习需要很多时间（按照我粗浅的理解，机器学习就是一整部统计学在计算机界的应用，很大）。而深度学习就相对单纯一些，据我所知，目前比较流行的深度学习算法就只有 CNN（卷积神经网络），RNN（循环神经网络）和 DNN（深度神经网络）。DNN 是整个深度学习的基础，后面的 CNN 和 RNN 其实都是基于DNN来做的，CNN（卷积神经网络）比较擅长于提取图片特征，处理图像问题。RNN 是把前一次网络的输出作为下一次网络的输入，让整个网络有了前因后果的概念，比较擅长处理有前后时间序列关系的问题，比如语音识别，语义分析等。</p>\n<p>根据之前列的大纲，这篇文章会先讲一下 CNN 网络的概念，然后讲一下 TensorFlow 中一个很有用的例子，用 CNN 网络去解决 MNIST 问题。大纲中剩下的部分会在接下来的文章中讲解。</p>\n<h2 id=\"2-CNN神经网络\"><a href=\"#2-CNN神经网络\" class=\"headerlink\" title=\"2. CNN神经网络\"></a>2. CNN神经网络</h2><p>CNN 神经网络，全称是卷积神经网络，是目前深度学习中最常见、应用最广泛的一种网络，适合于解决图像识别，图片分类，图像预测的问题。</p>\n<p>这里有一篇讲 CNN 比较好的文章，我看到很多大V讲到 CNN 的时候也会引用这篇文章的内容。有兴趣可以先看一下这篇文章。</p>\n<p><a href=\"https://ujjwalkarn.me/2016/08/11/intuitive-explanation-convnets/\">An Intuitive Explanation of Convolutional Neural Networks</a></p>\n<p><a href=\"http://www.hackcv.com/index.php/archives/104/?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io\">译文：什么是卷积神经网络？为什么它们很重要？</a></p>\n<p>如果不考虑 CNN，可以先思考下一个自己去实现一个分类图片的程序会怎么做。我之前做了一个判断一张图片是否是自选股截图的程序，自选股截图指的是下面这种图片。</p>\n<p><img src=\"https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/Tensorflow%E5%85%A5%E9%97%A8/2.png\" alt=\"这里写图片描述\"></p>\n<p>首先我会去看这种图片有什么特征，很明显，自选股截图上面有规则的红绿方块，而其他图片是没有的。那么在程序中，我首先提取出图片的各个像素值，然后去查找这张图片中是否有这种红绿色块，查找红绿色块的算法，可以这样做，看红色的像素值的坐标是否是一个方块，或者绿色的像素值的坐标是否是一个方块。</p>\n<p>由上所知，一个典型的图片分类算法就是提取特征，比较特征。CNN 网络简单来说就是将这个过程自动化，开发人员不需要告诉网络图片的特征是什么，CNN 网络可以自动的从图片中寻找特征，并记录。这个过程是怎么做到的呢，下面来讲。</p>\n<p>输入一张图片，网络通过一系列的运算，提取出图片的特征。如下图所示：</p>\n<p><img src=\"https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/Tensorflow%E5%85%A5%E9%97%A8/3.png\" alt=\"这里写图片描述\"></p>\n<p>当然，这中间的一系列计算是有算法和参数的。训练的时候我们会给每张图片打上一个对应的标签，CNN 通过上面一系列计算出特征后，每个特征就对应着一个标签。比如</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">特征1 -&gt; 标签A </div><div class=\"line\">特征2 -&gt; 标签B </div><div class=\"line\">特征3 -&gt; 标签A</div></pre></td></tr></table></figure>\n<p>当下一张图进入训练时，CNN 网络仍然以上次训练计算出来的参数去提取特征，假如提取出的是特征 2，如果图片的标签是 B，那么证明参数正确，无需调整。如果提取出的是特征 2，但是图片的标签是 A，那么证明参数不准确，需要调整下参数。调整完参数后继续下次训练，以此类推，直到参数大概率准确的时候。</p>\n<p>很简单的去解释了 CNN 卷积神经网络是怎么工作的，当然实际的过程比这要复杂的多，提取特征需要一些算法，比如卷积、池化、激活，算法的参数也不是 1 个这么简单，而是几百万个。下面的文章中基于 TensorFlow 中一个很简单的例子 MNIST 问题的代码来讲一下 CNN 网络是怎样工作的。</p>\n<h2 id=\"3-MNIST问题\"><a href=\"#3-MNIST问题\" class=\"headerlink\" title=\"3. MNIST问题\"></a>3. MNIST问题</h2><p>MNIST 问题就相当于图像处理的 Hello World 程序，在 TensorFlow 的官方教程里已经有一个完整的 Demo。</p>\n<p><a href=\"http://www.tensorfly.cn/tfdoc/tutorials/mnist_beginners.html\">MNIST问题处理</a></p>\n<p>MNIST 问题是很常见的图片分类问题，训练集是已经编码过的手写图片，图片中是手写的 0~9 的数字，模型经过训练后，输入一张图片，可以输出 0~9 的数字。</p>\n<h3 id=\"3-1-输入集\"><a href=\"#3-1-输入集\" class=\"headerlink\" title=\"3.1 输入集\"></a>3.1 输入集</h3><p>首先我们来看一下 MNIST 问题的输入集，数据集的介绍<a href=\"http://yann.lecun.com/exdb/mnist/\">传送门</a>。</p>\n<p>整个数据集由以下四个文件构成，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">//训练集-图片数据</div><div class=\"line\">train-images-idx3-ubyte.gz:  training set images (9912422 bytes) </div><div class=\"line\">//训练集-label数据</div><div class=\"line\">train-labels-idx1-ubyte.gz:  training set labels (28881 bytes) </div><div class=\"line\">//测试集-图片数据</div><div class=\"line\">t10k-images-idx3-ubyte.gz:   test set images (1648877 bytes) </div><div class=\"line\">//测试集-label数据</div><div class=\"line\">t10k-labels-idx1-ubyte.gz:   test set labels (4542 bytes)</div></pre></td></tr></table></figure>\n<p>训练集-图片数据的格式如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">[offset] [type]          [value]          [description] </div><div class=\"line\">0000     32 bit integer  0x00000803(2051) magic number </div><div class=\"line\">0004     32 bit integer  60000            number of images </div><div class=\"line\">0008     32 bit integer  28               number of rows </div><div class=\"line\">0012     32 bit integer  28               number of columns </div><div class=\"line\">0016     unsigned byte   ??               pixel </div><div class=\"line\">0017     unsigned byte   ??               pixel </div><div class=\"line\">........ </div><div class=\"line\">xxxx     unsigned byte   ??               pixel</div></pre></td></tr></table></figure>\n<p>训练集-label 数据的格式如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">[offset] [type]          [value]          [description] </div><div class=\"line\">0000     32 bit integer  0x00000801(2049) magic number (MSB first) </div><div class=\"line\">0004     32 bit integer  60000            number of items </div><div class=\"line\">0008     unsigned byte   ??               label </div><div class=\"line\">0009     unsigned byte   ??               label </div><div class=\"line\">........ </div><div class=\"line\">xxxx     unsigned byte   ??               label</div><div class=\"line\">The labels values are 0 to 9.</div></pre></td></tr></table></figure>\n<p>测试集的数据格式和训练集是一样的。</p>\n<p>首先我们写个程序试着解析一下这些数据：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div></pre></td><td class=\"code\"><pre><div class=\"line\">#coding=utf-8</div><div class=\"line\">import os</div><div class=\"line\">import struct</div><div class=\"line\">import numpy as np</div><div class=\"line\">import matplotlib.pyplot as plt</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def load_mnist(path, kind=&apos;train&apos;):</div><div class=\"line\">    # 读取文件</div><div class=\"line\">    labels_path = os.path.join(path,</div><div class=\"line\">                               &apos;%s-labels-idx1-ubyte&apos;</div><div class=\"line\">                               % kind)</div><div class=\"line\">    images_path = os.path.join(path,</div><div class=\"line\">                               &apos;%s-images-idx3-ubyte&apos;</div><div class=\"line\">                               % kind)</div><div class=\"line\">    with open(labels_path, &apos;rb&apos;) as lbpath:</div><div class=\"line\">        # 读取magic numer，labels数量</div><div class=\"line\">        magic, n = struct.unpack(&apos;&gt;II&apos;,</div><div class=\"line\">                                 lbpath.read(8))</div><div class=\"line\">        print &apos;label magic : &apos;,</div><div class=\"line\">        print magic</div><div class=\"line\">        # 载入label数据</div><div class=\"line\">        labels = np.fromfile(lbpath,</div><div class=\"line\">                             dtype=np.uint8).reshape(n, 1)</div><div class=\"line\"></div><div class=\"line\">    with open(images_path, &apos;rb&apos;) as imgpath:</div><div class=\"line\">        # 读取magic numer，图片数量，图片宽，高</div><div class=\"line\">        magic, num, rows, cols = struct.unpack(&apos;&gt;IIII&apos;,</div><div class=\"line\">                                               imgpath.read(16))</div><div class=\"line\">        print &apos;image magic : &apos;,</div><div class=\"line\">        print magic</div><div class=\"line\">        # 载入图片数据</div><div class=\"line\">        images = np.fromfile(imgpath,</div><div class=\"line\">                             dtype=np.uint8).reshape(num, rows * cols)</div><div class=\"line\"></div><div class=\"line\">    return images, labels, rows, cols</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def show_image():</div><div class=\"line\">    images, labels, rows, cols = load_mnist(&apos;/tmp/TensorFlow/mnist/input_data/&apos;)</div><div class=\"line\">    fig, ax = plt.subplots(</div><div class=\"line\">        nrows=2,</div><div class=\"line\">        ncols=5,</div><div class=\"line\">        sharex=True,</div><div class=\"line\">        sharey=True, )</div><div class=\"line\"></div><div class=\"line\">    ax = ax.flatten()</div><div class=\"line\">    for i in range(10):</div><div class=\"line\">        img = images[i].reshape(rows, cols)</div><div class=\"line\">        print labels[i]</div><div class=\"line\">        ax[i].imshow(img, cmap=&apos;Greys&apos;, interpolation=&apos;nearest&apos;)</div><div class=\"line\"></div><div class=\"line\">    ax[0].set_xticks([])</div><div class=\"line\">    ax[0].set_yticks([])</div><div class=\"line\">    plt.tight_layout()</div><div class=\"line\">    plt.show()</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">if __name__ == &apos;__main__&apos;:</div><div class=\"line\">  show_image()</div></pre></td></tr></table></figure>\n<p>运行程序后，会显示输入集的前 10 张图片，如下图所示：</p>\n<p><img src=\"https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/Tensorflow%E5%85%A5%E9%97%A8/Snip20180503_1.png\" alt=\"\"></p>\n<p>在控制台会输出 labels</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">label magic :  2049</div><div class=\"line\">image magic :  2051</div><div class=\"line\">[5] [0] [4] [1] [9] [2] [1] [3] [1] [4]</div></pre></td></tr></table></figure>\n<p>这是一个 CNN 模型需要的典型的输入，有一些数据，每个数据都有一个 label。后面我们做自己项目的时候，也是这种数据格式。</p>\n<p>因为 MNIST 问题是个比较典型的问题，所以 TensorFlow 甚至封装了解析的方法。</p>\n<h3 id=\"3-2-MNIST问题代码解析\"><a href=\"#3-2-MNIST问题代码解析\" class=\"headerlink\" title=\"3.2 MNIST问题代码解析\"></a>3.2 MNIST问题代码解析</h3><p>完整的代码在 TensorFlow 的 /TensorFlow/git/TensorFlow/TensorFlow/examples/tutorials/mnist/mnist_deep.py 里面。</p>\n<p>我们根据程序的运行顺序来看一下。</p>\n<h4 id=\"3-2-1-读取数据\"><a href=\"#3-2-1-读取数据\" class=\"headerlink\" title=\"3.2.1 读取数据\"></a>3.2.1 读取数据</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">if __name__ == &apos;__main__&apos;:</div><div class=\"line\">  # 解析命令行参数，默认没有</div><div class=\"line\">  parser = argparse.ArgumentParser()</div><div class=\"line\">  # 添加MNIST数据集的下载地址</div><div class=\"line\">  parser.add_argument(&apos;--data_dir&apos;, type=str,</div><div class=\"line\">                      default=&apos;/tmp/TensorFlow/mnist/input_data&apos;,</div><div class=\"line\">                      help=&apos;Directory for storing input data&apos;)</div><div class=\"line\">  FLAGS, unparsed = parser.parse_known_args()</div><div class=\"line\">  # 运行main方法</div><div class=\"line\">  tf.app.run(main=main, argv=[sys.argv[0]] + unparsed)</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"># Import data</div><div class=\"line\">mnist = input_data.read_data_sets(FLAGS.data_dir)</div></pre></td></tr></table></figure>\n<p>代码将 MNIST 的下载和解析过程封装了一次，看下 read_data_sets 方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">def read_data_sets(train_dir,</div><div class=\"line\">                   fake_data=False,</div><div class=\"line\">                   one_hot=False,</div><div class=\"line\">                   dtype=dtypes.float32,</div><div class=\"line\">                   reshape=True,</div><div class=\"line\">                   validation_size=5000,</div><div class=\"line\">                   seed=None,</div><div class=\"line\">                   source_url=DEFAULT_SOURCE_URL):</div><div class=\"line\">                   ...</div><div class=\"line\">                   return base.Datasets(train=train, validation=validation, test=test)</div></pre></td></tr></table></figure>\n<p>这个方法最后返回的是一个 Datasets 格式，里面 train，validation 和 test 都是已经解析好的数据，解析方法就类似于上一节讲到的。</p>\n<p>读到这里，你可能有个疑问，MNIST 数据里面只有 train 和 test，那验证数据集 validation 是哪里来的。这里 validation 使用的就是 train 数据集。CNN 网络在每次训练完之后运行 validation 数据集，可以让开发者了解目前的准确度，在所有训练结束之后运行 test 数据集，可以知道训练出的这个模型的准确度。所以运行 validation 数据只是给开发者参考用的，这里对数据的要求不是很严苛，可以直接用 train 的数据集，而最后测试模型的准确度时使用的 test 数据集一定不能是 train 里面的数据，因为如果两个数据集有重合，可能无法准确的测试模型的准确度。</p>\n<h4 id=\"3-2-2-定义输入输出\"><a href=\"#3-2-2-定义输入输出\" class=\"headerlink\" title=\"3.2.2 定义输入输出\"></a>3.2.2 定义输入输出</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"># Create the model</div><div class=\"line\">x = tf.placeholder(tf.float32, [None, 784], name=&quot;x&quot;)</div><div class=\"line\"></div><div class=\"line\"># Define loss and optimizer</div><div class=\"line\">y_ = tf.placeholder(tf.int64, [None])</div></pre></td></tr></table></figure>\n<p>tf.placeholder 可以理解为定义占位符，这些占位符虽然定义的时候没有值，但在实际运行中会给定输入值。这里定义了两个占位符，一个是输入值 x，类型是浮点数，维度是 [None, 784]，None 代表不确定数量，784 代表 28*28，也就是一张 MNIST 输入集的图片，这里的意思是说输入层x可以是不确定数量的图片，代表着我们这个网络可以同时输入多张图片的数据。这种变量就是 TensorFlow 的张量 tensor，而每个 tensor 都可以指定名称，但是我们一般只指定具有代表性的几个 tensor 的名称，比如这个输入节点的名称是 x。</p>\n<p>而 y_ 声明的存储 label 的变量，类型是 int 类型，因为 label 是 1-10，也是不确定数量的，因为前面x输入多少图片，这里的 label 就应该有多少数量。</p>\n<p>声明一个变量为什么要如此复杂，为什么不能像我们写程序一样直接声明 float x = 5 这样。这里需要给读者讲解一下 TensorFlow 计算图和静态图的概念。训练一个深度学习网络的时候，是需要大量计算的，而深度学习框架为了加快计算速度，会直接把计算的过程扔给 CPU 或 GPU 去运行，CPU 和 GPU 运行结束后返回框架结果。举个简单的例子，如果我们要计算 3*5+2，普通的程序是先计算 3*5，得到结果之后再 +2，得到结果。如果 TensorFlow 也这样做的话，相当于让 CPU 算 3*5， CPU 算完后返回结果，然后把返回的结果和 2 再扔给 CPU 去算，最后得到结果。但是需要知道的是，每一次和CPU的交互其实都是特别浪费时间的，所以如果像普通的程序一样，那训练神经网络会特别耗时。所以有一些深度学习框架像 TensorFlow 提出了静态图的概念，首先定义好整个计算图，放在前面的例子里，就是定义好“先乘后加”，然后将需要计算的数字和这个计算图扔给 CPU，最后 CPU 会计算出一个最终的结果返回给框架，这样整个过程中框架和CPU只有一次交互。这样做可以提升计算的速度，但是有一个致命的缺点是不能调试，你不能在 3*5 之后打个断点看看结果对不对，你只能知道最后的结果是不是正确。</p>\n<p>所以 tf.placeholder 只是定义了整个计算图中的一个节点 tensor，所以必须用TensorFlow 定义 tensor 的语法。</p>\n<h4 id=\"3-2-3-定义计算图\"><a href=\"#3-2-3-定义计算图\" class=\"headerlink\" title=\"3.2.3 定义计算图\"></a>3.2.3 定义计算图</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"># Build the graph for the deep net</div><div class=\"line\">  y_conv = deepnn(x)</div></pre></td></tr></table></figure>\n<p>deepnn 这个方法是整个程序的核心，在这个方法中定义了一整个计算图。我们一层一层的看。这个 CNN 的网络用的是LeNet网络。构成是这样的。</p>\n<p><img src=\"https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/Tensorflow%E5%85%A5%E9%97%A8/4.png\" alt=\"这里写图片描述\"></p>\n<p>其中有两层卷积层，两层池化层，最后输出层是两层全连接层。代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div></pre></td><td class=\"code\"><pre><div class=\"line\">def deepnn(x):</div><div class=\"line\">  &quot;&quot;&quot;deepnn builds the graph for a deep net for classifying digits.</div><div class=\"line\"></div><div class=\"line\">  Args:</div><div class=\"line\">    x: an input tensor with the dimensions (N_examples, 784), where 784 is the</div><div class=\"line\">    number of pixels in a standard MNIST image.</div><div class=\"line\"></div><div class=\"line\">  Returns:</div><div class=\"line\">    A tuple (y, keep_prob). y is a tensor of shape (N_examples, 10), with values</div><div class=\"line\">    equal to the logits of classifying the digit into one of 10 classes (the</div><div class=\"line\">    digits 0-9). keep_prob is a scalar placeholder for the probability of</div><div class=\"line\">    dropout.</div><div class=\"line\">  &quot;&quot;&quot;</div><div class=\"line\">  # Reshape to use within a convolutional neural net.</div><div class=\"line\">  # Last dimension is for &quot;features&quot; - there is only one here, since images are</div><div class=\"line\">  # grayscale -- it would be 3 for an RGB image, 4 for RGBA, etc.</div><div class=\"line\">  with tf.name_scope(&apos;reshape&apos;):</div><div class=\"line\">    x_image = tf.reshape(x, [-1, 28, 28, 1])</div><div class=\"line\"></div><div class=\"line\">  # First convolutional layer - maps one grayscale image to 32 feature maps.</div><div class=\"line\">  with tf.name_scope(&apos;conv1&apos;):</div><div class=\"line\">    W_conv1 = weight_variable([5, 5, 1, 32])</div><div class=\"line\">    b_conv1 = bias_variable([32])</div><div class=\"line\">    h_conv1 = tf.nn.relu(conv2d(x_image, W_conv1) + b_conv1)</div><div class=\"line\"></div><div class=\"line\">  # Pooling layer - downsamples by 2X.</div><div class=\"line\">  with tf.name_scope(&apos;pool1&apos;):</div><div class=\"line\">    h_pool1 = max_pool_2x2(h_conv1)</div><div class=\"line\"></div><div class=\"line\">  # Second convolutional layer -- maps 32 feature maps to 64.</div><div class=\"line\">  with tf.name_scope(&apos;conv2&apos;):</div><div class=\"line\">    W_conv2 = weight_variable([5, 5, 32, 64])</div><div class=\"line\">    b_conv2 = bias_variable([64])</div><div class=\"line\">    h_conv2 = tf.nn.relu(conv2d(h_pool1, W_conv2) + b_conv2)</div><div class=\"line\"></div><div class=\"line\">  # Second pooling layer.</div><div class=\"line\">  with tf.name_scope(&apos;pool2&apos;):</div><div class=\"line\">    h_pool2 = max_pool_2x2(h_conv2)</div><div class=\"line\"></div><div class=\"line\">  # Fully connected layer 1 -- after 2 round of downsampling, our 28x28 image</div><div class=\"line\">  # is down to 7x7x64 feature maps -- maps this to 1024 features.</div><div class=\"line\">  with tf.name_scope(&apos;fc1&apos;):</div><div class=\"line\">    W_fc1 = weight_variable([7 * 7 * 64, 1024])</div><div class=\"line\">    b_fc1 = bias_variable([1024])</div><div class=\"line\"></div><div class=\"line\">    h_pool2_flat = tf.reshape(h_pool2, [-1, 7 * 7 * 64])</div><div class=\"line\">    h_fc1 = tf.nn.relu(tf.matmul(h_pool2_flat, W_fc1) + b_fc1)</div><div class=\"line\"></div><div class=\"line\">  # Map the 1024 features to 10 classes, one for each digit</div><div class=\"line\">  with tf.name_scope(&apos;fc2&apos;):</div><div class=\"line\">    W_fc2 = weight_variable([1024, 10])</div><div class=\"line\">    b_fc2 = bias_variable([10])</div><div class=\"line\"></div><div class=\"line\">    y_conv = tf.add(tf.matmul(h_fc1, W_fc2), b_fc2, name=&quot;output&quot;)</div><div class=\"line\">  return y_conv</div></pre></td></tr></table></figure>\n<p>下面一层一层的看这个网络是怎么工作的。</p>\n<h5 id=\"卷积层\"><a href=\"#卷积层\" class=\"headerlink\" title=\"卷积层\"></a>卷积层</h5><p>CNN 叫卷积神经网络，可以看出卷积是这个网络的核心。卷积层是用于提取图片特征，卷积的操作是用一个卷积矩阵（也叫卷积核）在输入矩阵上依次扫描，做矩阵相乘，得到的结果输入矩阵的某一个特征。这样讲是不太好理解，下面用图片说一下这个过程。</p>\n<p>假设输入矩阵是这样的<br><img src=\"https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/Tensorflow%E5%85%A5%E9%97%A8/5.png\" alt=\"这里写图片描述\"></p>\n<p>选取如下一个卷积核<br><img src=\"https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/Tensorflow%E5%85%A5%E9%97%A8/6.png\" alt=\"这里写图片描述\"></p>\n<p>用卷积核在输入矩阵上依次扫过，做矩阵相乘的操作，就可以得到输入矩阵由这个卷积核提取的特征。</p>\n<p><img src=\"https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/Tensorflow%E5%85%A5%E9%97%A8/7.gif\" alt=\"这里写图片描述\"></p>\n<blockquote>\n<p>在 CNN 的术语中，3x3 的矩阵叫做“滤波器（filter）”或者“核（kernel）”或者“特征检测器（feature detector）”，通过在图像上滑动滤波器并计算点乘得到矩阵叫做“卷积特征（Convolved Feature）”或者“激活图（Activation Map）”或者“特征图（Feature Map）”。记住滤波器在原始输入图像上的作用是特征检测器。</p>\n</blockquote>\n<p>是不是在怀疑，这种操作真的能够提取特征吗，看下对实际图片进行卷积操作的例子。</p>\n<p>输入图像如下：<br><img src=\"https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/Tensorflow%E5%85%A5%E9%97%A8/8.png\" alt=\"这里写图片描述\"></p>\n<p>用不同的卷积核进行卷积操作的结果如下：</p>\n<p><img src=\"https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/Tensorflow%E5%85%A5%E9%97%A8/10.jpeg\" alt=\"这里写图片描述\"></p>\n<p>可以看到，不同的卷积核对原图像进行处理后可以得到不同的特征图像，有的卷积核能提取边缘信息，有的卷积核能提取色彩信息，有的卷积核能提取明暗特征，等等等等。有没有觉得这一步特别像 PS 中的滤镜，其实卷积的操作和滤镜的操作是很类似的。不同的卷积就像不同的滤镜对不同的特征敏感度不同。而代码中的卷积层如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"># First convolutional layer - maps one grayscale image to 32 feature maps.</div><div class=\"line\">  with tf.name_scope(&apos;conv1&apos;):</div><div class=\"line\">    W_conv1 = weight_variable([5, 5, 1, 32])</div><div class=\"line\">    b_conv1 = bias_variable([32])</div><div class=\"line\">    h_conv1 = tf.nn.relu(conv2d(x_image, W_conv1) + b_conv1)</div></pre></td></tr></table></figure>\n<p>首先定义一个卷积核 W_conv1 变量，由于后面会多次定义变量，所以将定义变量的部分提取了方法，如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">def weight_variable(shape):</div><div class=\"line\">  &quot;&quot;&quot;weight_variable generates a weight variable of a given shape.&quot;&quot;&quot;</div><div class=\"line\">  initial = tf.truncated_normal(shape, stddev=0.1)</div><div class=\"line\">  return tf.Variable(initial)</div></pre></td></tr></table></figure>\n<p>tf.Variable 生成一个变量 tensor，参数 initial 是初始化值。initial 由truncated_normal 方法生成，shape 指定了生成变量的维度，这里是[5,5,1,32]四维的变量，初始化值是由 truncated_normal 产生的正态分布的值，这就是 truncated_normal 方法的作用，详细的说明可以看文档。</p>\n<p>相对于卷积核的声明，偏量 b_conv1 的生成要简单一点。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">def bias_variable(shape):</div><div class=\"line\">  &quot;&quot;&quot;bias_variable generates a bias variable of a given shape.&quot;&quot;&quot;</div><div class=\"line\">  initial = tf.constant(0.1, shape=shape)</div><div class=\"line\">  return tf.Variable(initial)</div></pre></td></tr></table></figure>\n<p>初始化值是固定的 0.1。<br>这两个变量的初始化值不能是 0，而要加入一些脏值，是为了打破对称性以及避免 0 梯度，提升模型训练的效率。</p>\n<p>后面的代码就是执行卷积操作，我们来看，</p>\n<p><code>conv2d(x_image, W_conv1)</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">def conv2d(x, W):</div><div class=\"line\">  &quot;&quot;&quot;conv2d returns a 2d convolution layer with full stride.&quot;&quot;&quot;</div><div class=\"line\">  return tf.nn.conv2d(x, W, strides=[1, 1, 1, 1], padding=&apos;SAME&apos;)</div></pre></td></tr></table></figure>\n<p>这个函数就是 TensorFlow 中用于做卷积的函数，2d 代表生成的是一个二维特征图，这个是什么意思呢，后面会提到。除了 conv2d，还有 conv1d 和 conv3d 函数。</p>\n<p>看下 conv2d 的函数签名。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">tf.nn.conv2d(input, filter, strides, padding, use_cudnn_on_gpu=None, name=None)</div></pre></td></tr></table></figure>\n<p>除去 name 参数用以指定该操作的 name，与方法有关的一共五个参数：</p>\n<p>第一个参数 input：指需要做卷积的输入图像，它要求是一个 tensor，具有 [batch, in_height, in_width, in_channels] 这样的 shape，具体含义是[训练时一个 batch 的图片数量, 图片高度, 图片宽度, 图像通道数]，注意这是一个 4 维的 tensor，要求类型为 float32 和 float64 其中之一</p>\n<p>第二个参数 filter：相当于 CNN 中的卷积核，它要求是一个 tensor，具有 [filter_height, filter_width, in_channels, out_channels] 这样的shape，具体含义是[卷积核的高度，卷积核的宽度，图像通道数，卷积核个数]，要求类型与参数 input 相同，有一个地方需要注意，第三维 in_channels，就是参数 input 的第四维</p>\n<p>第三个参数 strides：卷积时在图像每一维每一次移动的步长，这是一个一维的向量，长度跟前面卷积核的维度相同，这里是4。</p>\n<p>第四个参数 padding：string 类型的量，只能是 “SAME”, “VALID” 其中之一，这个值决定了不同的卷积方式</p>\n<p>第五个参数：use_cudnn_on_gpu: bool 类型，是否使用 cudnn 加速，默认为 true，cudnn 是英伟达的GPU处理单元，这里也就是用 GPU 进行加速计算。</p>\n<h6 id=\"二维特征向量\"><a href=\"#二维特征向量\" class=\"headerlink\" title=\"二维特征向量\"></a>二维特征向量</h6><p>conv2d 生成的是二维特征向量，conv2d 有两个参数是必要的，input 和 filter。我们的输入参数是一张图片，三维的数据[宽，高，颜色空间]，为了最后向量相乘的结果是二维的，filer 的第三个维度应该和 input 的第四个维度相等，也就是 in_channels 相等，这样永远都只能输出一个二维的特征向量，也就是这个函数叫 conv2d 的原因，这里比较难理解，可以仔细考虑一下。</p>\n<h6 id=\"padding参数\"><a href=\"#padding参数\" class=\"headerlink\" title=\"padding参数\"></a>padding参数</h6><p>padding 参数的可选值是 SAME 和 VALID，这个参数影响了了卷积核对输入矩阵边缘的处理，决定了输出的特征向量大小。</p>\n<p>卷积核和按照步数一步步的扫描输入矩阵，做乘法操作。但是在输入矩阵的边缘，如果输入矩阵剩余的维度小于定义的卷积核的维度，那么卷积核就无法做乘法操作了，剩余这部分边界怎么处理呢。</p>\n<p>如果 padding 是 SAME，则会在输入矩阵的两端补齐 0，使补齐后的输入矩阵维度刚好可以被卷积核处理，最后得到的特征矩阵和原来的输入矩阵维度相同。</p>\n<p><img src=\"https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/Tensorflow%E5%85%A5%E9%97%A8/11.png\" alt=\"这里写图片描述\"></p>\n<p>如果 padding 是 VALID，则会抛弃边界的节点，最后输出的特征矩阵维度和输入矩阵不相同</p>\n<p><img src=\"https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/Tensorflow%E5%85%A5%E9%97%A8/12.png\" alt=\"这里写图片描述\"></p>\n<p>再回来看代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">W_conv1 = weight_variable([5, 5, 3, 32])</div><div class=\"line\">conv2d(x_image, W_conv1)</div></pre></td></tr></table></figure>\n<p>卷积核是 5*5*3 的，一共 32 个卷积核，对图像处理后，可以得到32个特征向量，因为我们没有指定步长和 padding，所以步长默认是1，padding 是 SAME，这样的话，输出的特征矩阵就是28 <em> 28 </em> 1。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"># 第一个卷积层，从图像中提取32的特征</div><div class=\"line\">with tf.name_scope(&apos;conv1&apos;):</div><div class=\"line\">    W_conv1 = weight_variable([5, 5, 3, 32])  # y =wX+b</div><div class=\"line\">    b_conv1 = bias_variable([32])</div><div class=\"line\">    h_conv1 = tf.nn.relu(conv2d(x_image, W_conv1) + b_conv1)</div></pre></td></tr></table></figure>\n<p>做完了卷积后，进行了一个relu处理</p>\n<blockquote>\n<p>ReLU 是一个元素级别的操作（应用到各个像素），并将特征图中的所有小于 0 的像素值设置为零。ReLU 的目的是在 ConvNet 中引入非线性，因为在大部分的我们希望 ConvNet 学习的实际数据是非线性的（卷积是一个线性操作——元素级别的矩阵相乘和相加，所以我们需要通过使用非线性函数 ReLU 来引入非线性。</p>\n</blockquote>\n<p>引入非线性可以让神经网络更好的工作，这个更好的工作指的是在做反向传播的时候避免出现梯度消失的问题，原因涉及到比较深的理论，这篇文章就不多说了。</p>\n<p>这样第一个卷积操作就结束了。</p>\n<h5 id=\"池化\"><a href=\"#池化\" class=\"headerlink\" title=\"池化\"></a>池化</h5><p>卷积操作之后是一个池化层。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"># Pooling layer - downsamples by 2X.</div><div class=\"line\">  with tf.name_scope(&apos;pool1&apos;):</div><div class=\"line\">    h_pool1 = max_pool_2x2(h_conv1)</div></pre></td></tr></table></figure>\n<p>池化的作用类似于压缩，这种压缩是在缩小输入值的维度的同时还要保持输入值的特征。比如在 2*2 的 4 个像素点中取最大值，最小值或者平均值。不过经过研究，最大池化能够比较好的保持原来的特征值。</p>\n<p><img src=\"https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/Tensorflow%E5%85%A5%E9%97%A8/13.png\" alt=\"这里写图片描述\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"># 2*2的最大化池化层</div><div class=\"line\">    with tf.name_scope(&apos;pool1&apos;):</div><div class=\"line\">        h_pool1 = max_pool_2x2(h_conv1)</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">def max_pool_2x2(x):</div><div class=\"line\">  &quot;&quot;&quot;max_pool_2x2 downsamples a feature map by 2X.&quot;&quot;&quot;</div><div class=\"line\">  return tf.nn.max_pool(x, ksize=[1, 2, 2, 1],</div><div class=\"line\">                        strides=[1, 2, 2, 1], padding=&apos;SAME&apos;)</div></pre></td></tr></table></figure>\n<p>池化操作也是调用的 TensorFlow 的函数，参数 strides 和 padding 跟前面提到的 conv2d 函数的参数一致。ksize 是定义的在每个维度上池化的大小，上一步卷积之后，输出的特征向量是 1*28*28*1，所以在中间两个维度进行处理。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"># Second convolutional layer -- maps 32 feature maps to 64.</div><div class=\"line\">  with tf.name_scope(&apos;conv2&apos;):</div><div class=\"line\">    W_conv2 = weight_variable([5, 5, 32, 64])</div><div class=\"line\">    b_conv2 = bias_variable([64])</div><div class=\"line\">    h_conv2 = tf.nn.relu(conv2d(h_pool1, W_conv2) + b_conv2)</div><div class=\"line\"></div><div class=\"line\">  # Second pooling layer.</div><div class=\"line\">  with tf.name_scope(&apos;pool2&apos;):</div><div class=\"line\">    h_pool2 = max_pool_2x2(h_conv2)</div></pre></td></tr></table></figure>\n<p>后面又做了一个卷积操作和一个池化操作，这个跟前面的操作是一样的。卷积操作的输出不影响输入值的维度，但是影响输入值的深度。池化操作不影响输入值的深度但是影响输入值的维度，经过两层的卷积和 2<em>2 的池化后，输入值的维度变成了原来的 1/4。深度变成 64。也就是 7\\</em>7*64。</p>\n<p>上面的几层又叫隐藏层，表示使用者看不到的处理层。</p>\n<h5 id=\"全连接\"><a href=\"#全连接\" class=\"headerlink\" title=\"全连接\"></a>全连接</h5><p>接下来是输出层，输出层是两个全连接层。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"># Fully connected layer 1 -- after 2 round of downsampling, our 28x28 image</div><div class=\"line\"># is down to 7x7x64 feature maps -- maps this to 1024 features.</div><div class=\"line\">with tf.name_scope(&apos;fc1&apos;):</div><div class=\"line\">  W_fc1 = weight_variable([7 * 7 * 64, 1024])</div><div class=\"line\">  b_fc1 = bias_variable([1024])</div><div class=\"line\"></div><div class=\"line\">  h_pool2_flat = tf.reshape(h_pool2, [-1, 7 * 7 * 64])</div><div class=\"line\">  h_fc1 = tf.nn.relu(tf.matmul(h_pool2_flat, W_fc1) + b_fc1)</div><div class=\"line\"></div><div class=\"line\"># Map the 1024 features to 10 classes, one for each digit</div><div class=\"line\">with tf.name_scope(&apos;fc2&apos;):</div><div class=\"line\">  W_fc2 = weight_variable([1024, 10])</div><div class=\"line\">  b_fc2 = bias_variable([10])</div><div class=\"line\"></div><div class=\"line\">  y_conv = tf.add(tf.matmul(h_fc1, W_fc2), b_fc2, name=&quot;output&quot;)</div></pre></td></tr></table></figure>\n<p>全连接层，顾名思义，指的是这一层的每个节点都跟上一层的全部节点有连接。</p>\n<p><img src=\"https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/Tensorflow%E5%85%A5%E9%97%A8/Snip20180423_2.png\" alt=\"全连接节点\"></p>\n<p>比如图中全连接层的节点 a1 与上一层的所有节点 x1,x2,x3 有联系，a2 也与上一层的所有节点有联系，就这样，少一个也不行。因此解释全连接层的时候，图就是这样一个网状结构。</p>\n<p>上文中提到了联系，这里的“联系”具体指的是什么呢。如图所示，假设 x1，x2，x3 是全连接层的输入值，那么在全连接层的a1可以表示为以下的形式。</p>\n<p><img src=\"https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/Tensorflow%E5%85%A5%E9%97%A8/Snip20180423_3.png\" alt=\"\"></p>\n<p>从这个公式可以看出，a1 与 x1，x2，x3 都有联系，只是输入节点的权重值不同。同理，a2 和 a3 也可以表示为以下的形式。</p>\n<p><img src=\"https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/Tensorflow%E5%85%A5%E9%97%A8/Snip20180423_4.png\" alt=\"\"></p>\n<p>由此就可以从数学层面去理解什么叫全连接层，但是这个全连接层在实际应用中表示得意义是什么呢，简单来说，它可以作为一个分类网络，还是上面那个图，输入层是 3 个值，全连接层是 3 个节点，就代表这个全连接层可以把上一层的特征值分类为三种特征。当然，输入层和全连接层的节点数并不一定相同，比如下面这个结构。</p>\n<p><img src=\"https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/Tensorflow%E5%85%A5%E9%97%A8/Snip20180423_5.png\" alt=\"\"></p>\n<p>最后的全连接层是 10 个节点，全连接层的上一层是 15 个特征值，这样就把 15 个特征值归类为 10 种特征。举例来说，比如输出的 15 个特征标记位 t1-15，而 t1，t3，t5 三种特征可以认为都属于某一种输出 o1。而 t2，t6 两种特征可以认为属于输出 o2，以此类推，就可以把15个特征分类为 10 个输出。</p>\n<p>前面提到的MNIST问题中，全连接层有两层，第一层是 1024 个节点，第二层是 10 个节点。一般情况下，最靠近用户的输出层就是用户所期待的结果类别数，MNIST 问题中，用户期待的输出是 0-9 一共 10 个数字也就是 10 种类别，所以第二层全连接层是 10 个节点。再往前看，卷积层在每一个像素点上提取 64 个特征值，所以整个图片可以有高*宽*64个特征值，也就是 7*7*64 个特征，第一个全连接层是 1024 个节点，表示希望这个网络将这 7*7*64 个特征归类为 1024 个分类。至于为什么第一个连接层是 1024 个节点，是一个经验值的问题，这个节点的个数是可以调整的，后面会讲到全连接层对模型体积的影响，也会再说到这个经验值的问题。那么全连接层是如何分类的。一起来看一下。</p>\n<p>回顾一下全连接层的表示公式。</p>\n<p><img src=\"https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/Tensorflow%E5%85%A5%E9%97%A8/Snip20180423_3.png\" alt=\"\"></p>\n<p>这里的输入值 x1,x2,x3…，输出值 a1 和权重 W，偏移量 b 到底指的是什么呢。</p>\n<p>在MNIST的基础上，可以考虑这样一种情况。看下面这个图，对于0这个数字来说，我们经过训练之后，认为如果一张图片在中间红色部分出现了像素值，那这张图有一定概率不是 0，并且出现在红色部分的像素值越多，不是 0 的概率越大。如果在周围一圈的蓝色部分出现了像素值，那么这张图有一定概率是 0，并且出现在蓝色部分的像素值越多，是 0 的概率越大。</p>\n<p><img src=\"https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/Tensorflow%E5%85%A5%E9%97%A8/Snip20180423_6.png\" alt=\"\"></p>\n<p>这个过程用数学公式怎么表示呢，蓝色部分拥有正值的权重，红色部分拥有负值的权重，将输入图片的每个像素点与权重值进行相乘后求和，这样如果红色部分出现的像素值越多，则最后的和越小，如果蓝色部分出现的像素值越多，则最后的和越大。最后得出的结果我们称为是输入图片x是这种分类（比如分类0）的证据 evidence。这样对于一张输入的图片，最后落在每个节点上的 evidence 就可以用如下的公式表示。</p>\n<p><img src=\"https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/Tensorflow%E5%85%A5%E9%97%A8/Snip20180427_1.png\" alt=\"\"></p>\n<p>看这个公式，是不是就是全连接层的公式。所以全连接层这个过程比较绕，但是是深度学习网络的基本原理，可以仔细理解一下。</p>\n<p>反过来看代码。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"># Fully connected layer 1 -- after 2 round of downsampling, our 28x28 image</div><div class=\"line\"># is down to 7x7x64 feature maps -- maps this to 1024 features.</div><div class=\"line\">with tf.name_scope(&apos;fc1&apos;):</div><div class=\"line\">  W_fc1 = weight_variable([7 * 7 * 64, 1024])</div><div class=\"line\">  b_fc1 = bias_variable([1024])</div><div class=\"line\"></div><div class=\"line\">  h_pool2_flat = tf.reshape(h_pool2, [-1, 7 * 7 * 64])</div><div class=\"line\">  h_fc1 = tf.nn.relu(tf.matmul(h_pool2_flat, W_fc1) + b_fc1)</div></pre></td></tr></table></figure>\n<p>首先生成全连接层的权重 W_fc1 和偏量 b_fc1，这里复用了前面卷积操作生成卷积核和偏量的两个方法，虽然概念不同，但计算是相通的，所以可以复用。tf.reshape(h_pool2, [-1, 7 <em> 7 </em> 64]) 将之前层的四维 [1,7,7,64] 的输出变成一个一维的向量，因为全连接层只能处理一维的问题。后面用 tf.matmul 向量乘法实现了全连接层的操作。tf.nn.relu 和前面一样，是个激活函数。</p>\n<h5 id=\"droupout\"><a href=\"#droupout\" class=\"headerlink\" title=\"droupout\"></a>droupout</h5><p>在第一层全连接层之后，加了一个 dropout 的操作</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"># Dropout - controls the complexity of the model, prevents co-adaptation of</div><div class=\"line\"># features.</div><div class=\"line\">with tf.name_scope(&apos;dropout&apos;):</div><div class=\"line\">  keep_prob = tf.placeholder(tf.float32)</div><div class=\"line\">  h_fc1_drop = tf.nn.dropout(h_fc1, keep_prob)</div></pre></td></tr></table></figure>\n<p>droupout 的操作如下图所示：<br><img src=\"https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/Tensorflow%E5%85%A5%E9%97%A8/Snip20180504_2.png\" alt=\"\"></p>\n<p>在计算的过程中，随机的“丢弃”一些节点，简单来说，h_fc1有 1024 个节点，在 droupout 之后，如果 keep_prob 是50%，那么经过 droupout 之后，可以认为参与计算的是 512 个节点。droupout 有两个优势。</p>\n<ul>\n<li>解决过拟合的问题</li>\n<li>在训练中加入概率性</li>\n</ul>\n<p>droupout 操作之后又是一层全连接。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"># Map the 1024 features to 10 classes, one for each digit</div><div class=\"line\">with tf.name_scope(&apos;fc2&apos;):</div><div class=\"line\">  W_fc2 = weight_variable([1024, 10])</div><div class=\"line\">  b_fc2 = bias_variable([10])</div><div class=\"line\"></div><div class=\"line\">  y_conv = tf.add(tf.matmul(h_fc1, W_fc2), b_fc2, name=&quot;output&quot;)</div></pre></td></tr></table></figure>\n<p>第二层全连接将上一层产生的 1024 个节点归类到 10 个节点上，，得到最后的输出。即使经过 droupout 之后，实体依然是 1024 个节点，只是其中一部分不再参与计算。这个网络结构最后的输出是10个节点的 evidence 的值。</p>\n<h4 id=\"3-2-4-Softmax回归处理\"><a href=\"#3-2-4-Softmax回归处理\" class=\"headerlink\" title=\"3.2.4 Softmax回归处理\"></a>3.2.4 Softmax回归处理</h4><p>至此，整个计算图就定义完了，接下来定义一些训练中的必要单元来告知框架如何训练。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">with tf.name_scope(&apos;loss&apos;):</div><div class=\"line\">  cross_entropy = tf.losses.sparse_softmax_cross_entropy(</div><div class=\"line\">      labels=y_, logits=y_conv)</div><div class=\"line\">cross_entropy = tf.reduce_mean(cross_entropy)</div></pre></td></tr></table></figure>\n<p>定义损失函数使用 softmax 交叉熵的，关于 softmax 和交叉熵，这里引用<a href=\"https://blog.csdn.net/chaipp0607/article/details/73392175\">传送门</a>一段描述。</p>\n<p>神经网络的原始输出不是一个概率值，实质上只是输入的数值做了复杂的加权和与非线性处理之后的一个值而已，那么如何将这个输出变为概率分布？ </p>\n<p>这就是 softmax 层的作用，假设神经网络的原始输出为 y1,y2,….,yn，那么经过 softmax 回归处理之后的输出为： </p>\n<p><img src=\"https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/Tensorflow%E5%85%A5%E9%97%A8/Snip20180504_3.png\" alt=\"\"></p>\n<p>经过 softmax 的公式后，所有节点的和变成了 1，之前神经网络输出的每个节点的权重值变成了每个节点的概率值。</p>\n<p>单个节点的输出变成的一个概率值，经过 softmax 处理后结果作为神经网络最后的输出。label</p>\n<h4 id=\"3-2-5-交叉熵的原理\"><a href=\"#3-2-5-交叉熵的原理\" class=\"headerlink\" title=\"3.2.5 交叉熵的原理\"></a>3.2.5 交叉熵的原理</h4><p>交叉熵刻画的是实际输出（概率）与期望输出（概率）的距离，也就是交叉熵的值越小，两个概率分布就越接近。假设概率分布 p 为期望输出，概率分布 q 为实际输出，H(p,q) 为交叉熵，则：</p>\n<p><img src=\"https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/Tensorflow%E5%85%A5%E9%97%A8/Snip20180504_4.png\" alt=\"\"></p>\n<p>这个公式如何表征距离呢，举个例子：<br>假设 N=3，期望输出为 p = (1,0,0)，实际输出 q1 = (0.5,0.2,0.3)，q2 = (0.8,0.1,0.1)，那么：</p>\n<p><img src=\"https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/Tensorflow%E5%85%A5%E9%97%A8/Snip20180504_5.png\" alt=\"\"></p>\n<p>很显然，q2 与 p 更为接近，它的交叉熵也更小。<br>除此之外，交叉熵还有另一种表达形式，还是使用上面的假设条件：</p>\n<p><img src=\"https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/Tensorflow%E5%85%A5%E9%97%A8/Snip20180504_6.png\" alt=\"\"></p>\n<p>其结果为：</p>\n<p><img src=\"https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/Tensorflow%E5%85%A5%E9%97%A8/Snip20180504_7.png\" alt=\"\"></p>\n<p>以上的所有说明针对的都是单个样例的情况，而在实际的使用训练过程中，数据往往是组合成为一个 batch 来使用，所以对用的神经网络的输出应该是一个 m*n 的二维矩阵，其中 m 为 batch 的个数，n为分类数目，而对应的 label 也是一个二维矩阵，还是拿上面的数据，组合成一个 batch=2 的矩阵：</p>\n<p><img src=\"https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/Tensorflow%E5%85%A5%E9%97%A8/Snip20180504_8.png\" alt=\"\"></p>\n<p>所以交叉熵的结果应该是一个列向量（根据第一种方法）： </p>\n<p><img src=\"https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/Tensorflow%E5%85%A5%E9%97%A8/Snip20180504_9.png\" alt=\"\"></p>\n<p>而对于一个 batch，最后取平均为 0.2。</p>\n<p>tf.losses.sparse_softmax_cross_entropy 是 TensorFlow 将以上两个过程封装后的产物，最后的结果是一个 batch 的概率值，reduce_mean 用来取得概率的平均值。综上作为整个网络的损失函数。</p>\n<h4 id=\"3-2-6-训练方法-梯度下降\"><a href=\"#3-2-6-训练方法-梯度下降\" class=\"headerlink\" title=\"3.2.6 训练方法-梯度下降\"></a>3.2.6 训练方法-梯度下降</h4><p>然后定义梯度下降的方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">with tf.name_scope(&apos;adam_optimizer&apos;):</div><div class=\"line\">  train_step = tf.train.AdamOptimizer(1e-4).minimize(cross_entropy)</div></pre></td></tr></table></figure>\n<p>以下降步速，即学习率为1e-4的速度最小化损失函数 cross_entropy。这样就能定义训练的目的是为了让损失函数越来越来，每次参数的变化值为1e-4。</p>\n<h4 id=\"3-2-7-准确度\"><a href=\"#3-2-7-准确度\" class=\"headerlink\" title=\"3.2.7 准确度\"></a>3.2.7 准确度</h4><p>定义准确度的计算方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">with tf.name_scope(&apos;accuracy&apos;):</div><div class=\"line\">  correct_prediction = tf.equal(tf.argmax(y_conv, 1), y_)</div><div class=\"line\">  correct_prediction = tf.cast(correct_prediction, tf.float32)</div><div class=\"line\">accuracy = tf.reduce_mean(correct_prediction)</div></pre></td></tr></table></figure>\n<p>y_conv 是网络输出的原始结果，也就是图片在最后 10 个节点上的权重值，比如 [314, -423, 342…] ，最后权重值最大的节点是我们的期望节点，比如这里第三个节点的权重值最大，那这幅图片可能就是数字 2，tf.argmax 是取出权重值最大的下标。y_ 是我们给的 label 值，把这两个值相比较得出准确度。最后依然用 tf.reduce_mean 算出 batch 的平均准确度。</p>\n<h4 id=\"3-2-8-计算图可视化\"><a href=\"#3-2-8-计算图可视化\" class=\"headerlink\" title=\"3.2.8 计算图可视化\"></a>3.2.8 计算图可视化</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">graph_location = tempfile.mkdtemp()</div><div class=\"line\">print(&apos;Saving graph to: %s&apos; % graph_location)</div><div class=\"line\">train_writer = tf.summary.FileWriter(graph_location)</div><div class=\"line\">train_writer.add_graph(tf.get_default_graph())</div></pre></td></tr></table></figure>\n<p>这是 TensorFlow 提供的计算图可视化的方法，这里暂时没起到作用。</p>\n<h4 id=\"3-2-9-启动计算图\"><a href=\"#3-2-9-启动计算图\" class=\"headerlink\" title=\"3.2.9 启动计算图\"></a>3.2.9 启动计算图</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">with tf.Session() as sess:</div><div class=\"line\">  sess.run(tf.global_variables_initializer())</div><div class=\"line\">  for i in range(20000):</div><div class=\"line\">    batch = mnist.train.next_batch(50)</div><div class=\"line\">    if i % 100 == 0:</div><div class=\"line\">      train_accuracy = accuracy.eval(feed_dict=&#123;</div><div class=\"line\">          x: batch[0], y_: batch[1], keep_prob: 1.0&#125;)</div><div class=\"line\">      print(&apos;step %d, training accuracy %g&apos; % (i, train_accuracy))</div><div class=\"line\">    train_step.run(feed_dict=&#123;x: batch[0], y_: batch[1], keep_prob: 0.5&#125;)</div><div class=\"line\"></div><div class=\"line\">  print(&apos;test accuracy %g&apos; % accuracy.eval(feed_dict=&#123;</div><div class=\"line\">      x: mnist.test.images, y_: mnist.test.labels, keep_prob: 1.0&#125;))</div></pre></td></tr></table></figure>\n<p>这里就是前面提到的将计算图和计算数据给 CPU 计算，TensorFlow 将和 CPU 的一个交互过程定义为 session，启动 session 后，开始运行。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sess.run(tf.global_variables_initializer())</div></pre></td></tr></table></figure>\n<p>首先将前面定义的所有变量初始化，注意前面在定义图的时候只是定义了变量初始化的方法，而没有真正去做初始化，真正运行是在这个地方。</p>\n<p>然后循环 20000 次，每次从训练集中取出50个图片数据作为一个 batch。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">train_step.run(feed_dict=&#123;x: batch[0], y_: batch[1], keep_prob: 0.5&#125;)</div></pre></td></tr></table></figure>\n<p>开始训练，train_step 是前面定义的梯度下降的方法，以这种方法开始训练。参数是图片数据，正确的 labels，和 droupout 的参数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">if i % 100 == 0:</div><div class=\"line\">        train_accuracy = accuracy.eval(feed_dict=&#123;</div><div class=\"line\">            x: batch[0], y_: batch[1], keep_prob: 1.0&#125;)</div><div class=\"line\">        print(&apos;step %d, training accuracy %g&apos; % (i, train_accuracy))</div></pre></td></tr></table></figure>\n<p>每训练 100 次，输出一下当前的准确率，是为了开发者感知的。测试准确率的时候，是不需要 droupout 操作的，所以 keep_prob 是1。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">print(&apos;test accuracy %g&apos; % accuracy.eval(feed_dict=&#123;</div><div class=\"line\">        x: mnist.test.images, y_: mnist.test.labels, keep_prob: 1.0&#125;))</div></pre></td></tr></table></figure>\n<p>20000 次训练之后，输出最终的准确率。</p>\n<p>输出结果类似这样的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">step 0, training accuracy 0.16</div><div class=\"line\">step 100, training accuracy 0.9</div><div class=\"line\">step 200, training accuracy 0.94</div><div class=\"line\">step 300, training accuracy 0.9</div><div class=\"line\">step 400, training accuracy 0.96</div><div class=\"line\">...</div><div class=\"line\">test accuracy 0.9446</div></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>至此，整个模型的训练过程就完全结束了。通过这个例子，我们知道了一个 CNN 网络是怎么工作的，并且如何用 TensorFlow 来实现一个 CNN 网络。下一篇文章，我将写一下如果改造这个例子，来解决我的一个实际问题。</p>\n"},{"title":"fastjson使用过程中的坑","date":"2017-05-09T03:44:21.000Z","_content":"例行推广一下我的博客，喜欢这篇文章的朋友可以关注我的博客[http://zwgeek.com](http://zwgeek.com)\n\n最近在工作中用到了fastjson，遇到了一些坑，在这里总结一下。\n\n### 简介\n首先，介绍一下fastjson。fastjson是由alibaba开源的一套json处理器。与其他json处理器（如Gson，Jackson等）和其他的Java对象序列化反序列化方式相比，有比较明显的性能优势。详情可以参考fastjson提供的benchmark。\n\n[benchmark for fastjson](https://github.com/eishay/jvm-serializers/wiki)\n\nfastjson的使用方法也比较简单，详细使用可以参考[fastjson首页](https://github.com/Alibaba/fastjson/wiki/%E9%A6%96%E9%A1%B5)，这里只做一个简单介绍。\n\n首先可通过Gradle或Maven或直接引用jar包的方式来引入fastjson。\n```\n<dependency>\n    <groupId>com.alibaba</groupId>\n    <artifactId>fastjson</artifactId>\n    <version>VERSION_CODE</version>\n</dependency>\n```\n或\n```\ncompile 'com.alibaba:fastjson:VERSION_CODE'\n```\n\n#### 序列化方式\n```\nString jsonString = JSON.toJSONString(class);\n```\n#### 反序列化方式\n```\nClass class = JSON.parseObject(jsonString, Class.class);\n```\n#### 泛型反序列化\n泛型对象比如List的序列化方法和普通对象一样，反序列化的时候需要指定一下泛型对象，例如：\n```\nList<VO> list = JSON.parseObject(\"...\", new TypeReference<List<VO>>() {});\n```\n以上就是fastjson的简单用法，接下来说一下我在使用过程中遇到的坑。\n\n###遇到的问题\n\n### 1. 序列化的类必须有一个无参构造方法\n被序列化的类需要有一个无参的构造方法。否则会报错\n```\nException in thread \"main\" com.alibaba.fastjson.JSONException: default constructor not found. class User\n```\n如果你没有重写构造方法，那么每个类都自带一个无参的构造方法，但是如果你重写了一个有参的构造方法，那么默认的无参构造方法会被覆盖，这时候就需要你手动写一个无参的构造方法进去。所以我建议保险起见，需要被json序列化的类最好都手动写一个无参的构造方法进去。\n\n对于这个问题，我怀疑fastjson是这样处理的（没有验证代码）。它在反序列化的时候会先用无参的构造方法构造一个类实例。然后将每一个值解析出来赋值到这个实例中。所以很明显，除了无参的构造方法，你还需要保证被序列化的成员变量能被访问到，经过我测试fastjson支持以下两种访问方式。\n\n- public访问权限\n\n- get和set方法\n\n\n### 2. 子类不能重写父类成员变量\n 正如第二点提到的，fastjson是通过类的成员变量名称来识别成员变量的。所以如果子类复写的父类的成员变量，会导致fastjson识别错乱。\n\n这个问题我在Android版本的使用过程中遇到了，后来在Java版本的测试中却无法复现这个问题，所以并不是所有的复写父类的成员变量都不能被识别。只有在类结构比较复杂的时候才容易出问题，不管怎么样，我建议使用过程中尽量避免复写父类的成员变量。\n\n### 3. 混淆要对泛型进行保护\n这个问题其实也不是fastjson的问题，但这个问题却是困扰我最久的一个问题，本地运行没有问题，但是一打Release就有问题。这种情况99%是由于Proguard引起的，但我当时Proguard配置文件中已经keep了所有的类，按理说不是由于类被混淆而找不到造成的。\n\n后来我发现这个问题只有在遇到List的时候才会出错，所以开始怀疑是不是泛型在Proguard的时候出现了问题，后来发现了Proguard的官网，果然Proguard有对泛型的保护。后来在fastjson的issue中也发现有人提出了这个问题，并且发现除了泛型之外还需要对注解进行保护。\n\n[fastjson issue传送门](https://github.com/alibaba/fastjson/issues/765)\n[Proguard指南传送门](https://www.guardsquare.com/en/proguard/manual/examples#annotations)\n\n通过以上两篇文章，我们知道需要在Proguard的配置文件中加入以下属性。\n\n```\n-keepattributes Signature\n-keepattributes *Annotation*\n```\nIf your application, applet, servlet, library, etc., uses annotations, you may want to preserve them in the processed output. Annotations are represented by attributes that have no direct effect on the execution of the code. However, their values can be retrieved through introspection, allowing developers to adapt the execution behavior accordingly. By default, ProGuard treats annotation attributes as optional, and removes them in the obfuscation step.\n\nThe \"Signature\" attribute is required to be able to access generic types when compiling in JDK 5.0 and higher.\n\n由这个问题我深深的感觉到自己最Proguard的不熟悉，以前仅仅会从网上拷贝一个默认的混淆配置问题，而对于细节配置全然不知，所以我决定接下来翻译下Proguard官网。\n\n以上就是使用fastjson中遇到的问题，以及解决方案。fastjson的性能确实不错，而且对Model的入侵性低，使用简单。是序列化和反序列化的好帮手。\n\n例行推广一下我的博客，喜欢这篇文章的朋友可以关注我的博客[http://zwgeek.com](http://zwgeek.com)","source":"_posts/fastjson使用过程中的坑.md","raw":"---\ntitle: fastjson使用过程中的坑\ndate: 2017-05-09 11:44:21\ntags:\n  - FastJson\n  - Json序列化\n  - Android\ncategories: Android\n---\n例行推广一下我的博客，喜欢这篇文章的朋友可以关注我的博客[http://zwgeek.com](http://zwgeek.com)\n\n最近在工作中用到了fastjson，遇到了一些坑，在这里总结一下。\n\n### 简介\n首先，介绍一下fastjson。fastjson是由alibaba开源的一套json处理器。与其他json处理器（如Gson，Jackson等）和其他的Java对象序列化反序列化方式相比，有比较明显的性能优势。详情可以参考fastjson提供的benchmark。\n\n[benchmark for fastjson](https://github.com/eishay/jvm-serializers/wiki)\n\nfastjson的使用方法也比较简单，详细使用可以参考[fastjson首页](https://github.com/Alibaba/fastjson/wiki/%E9%A6%96%E9%A1%B5)，这里只做一个简单介绍。\n\n首先可通过Gradle或Maven或直接引用jar包的方式来引入fastjson。\n```\n<dependency>\n    <groupId>com.alibaba</groupId>\n    <artifactId>fastjson</artifactId>\n    <version>VERSION_CODE</version>\n</dependency>\n```\n或\n```\ncompile 'com.alibaba:fastjson:VERSION_CODE'\n```\n\n#### 序列化方式\n```\nString jsonString = JSON.toJSONString(class);\n```\n#### 反序列化方式\n```\nClass class = JSON.parseObject(jsonString, Class.class);\n```\n#### 泛型反序列化\n泛型对象比如List的序列化方法和普通对象一样，反序列化的时候需要指定一下泛型对象，例如：\n```\nList<VO> list = JSON.parseObject(\"...\", new TypeReference<List<VO>>() {});\n```\n以上就是fastjson的简单用法，接下来说一下我在使用过程中遇到的坑。\n\n###遇到的问题\n\n### 1. 序列化的类必须有一个无参构造方法\n被序列化的类需要有一个无参的构造方法。否则会报错\n```\nException in thread \"main\" com.alibaba.fastjson.JSONException: default constructor not found. class User\n```\n如果你没有重写构造方法，那么每个类都自带一个无参的构造方法，但是如果你重写了一个有参的构造方法，那么默认的无参构造方法会被覆盖，这时候就需要你手动写一个无参的构造方法进去。所以我建议保险起见，需要被json序列化的类最好都手动写一个无参的构造方法进去。\n\n对于这个问题，我怀疑fastjson是这样处理的（没有验证代码）。它在反序列化的时候会先用无参的构造方法构造一个类实例。然后将每一个值解析出来赋值到这个实例中。所以很明显，除了无参的构造方法，你还需要保证被序列化的成员变量能被访问到，经过我测试fastjson支持以下两种访问方式。\n\n- public访问权限\n\n- get和set方法\n\n\n### 2. 子类不能重写父类成员变量\n 正如第二点提到的，fastjson是通过类的成员变量名称来识别成员变量的。所以如果子类复写的父类的成员变量，会导致fastjson识别错乱。\n\n这个问题我在Android版本的使用过程中遇到了，后来在Java版本的测试中却无法复现这个问题，所以并不是所有的复写父类的成员变量都不能被识别。只有在类结构比较复杂的时候才容易出问题，不管怎么样，我建议使用过程中尽量避免复写父类的成员变量。\n\n### 3. 混淆要对泛型进行保护\n这个问题其实也不是fastjson的问题，但这个问题却是困扰我最久的一个问题，本地运行没有问题，但是一打Release就有问题。这种情况99%是由于Proguard引起的，但我当时Proguard配置文件中已经keep了所有的类，按理说不是由于类被混淆而找不到造成的。\n\n后来我发现这个问题只有在遇到List的时候才会出错，所以开始怀疑是不是泛型在Proguard的时候出现了问题，后来发现了Proguard的官网，果然Proguard有对泛型的保护。后来在fastjson的issue中也发现有人提出了这个问题，并且发现除了泛型之外还需要对注解进行保护。\n\n[fastjson issue传送门](https://github.com/alibaba/fastjson/issues/765)\n[Proguard指南传送门](https://www.guardsquare.com/en/proguard/manual/examples#annotations)\n\n通过以上两篇文章，我们知道需要在Proguard的配置文件中加入以下属性。\n\n```\n-keepattributes Signature\n-keepattributes *Annotation*\n```\nIf your application, applet, servlet, library, etc., uses annotations, you may want to preserve them in the processed output. Annotations are represented by attributes that have no direct effect on the execution of the code. However, their values can be retrieved through introspection, allowing developers to adapt the execution behavior accordingly. By default, ProGuard treats annotation attributes as optional, and removes them in the obfuscation step.\n\nThe \"Signature\" attribute is required to be able to access generic types when compiling in JDK 5.0 and higher.\n\n由这个问题我深深的感觉到自己最Proguard的不熟悉，以前仅仅会从网上拷贝一个默认的混淆配置问题，而对于细节配置全然不知，所以我决定接下来翻译下Proguard官网。\n\n以上就是使用fastjson中遇到的问题，以及解决方案。fastjson的性能确实不错，而且对Model的入侵性低，使用简单。是序列化和反序列化的好帮手。\n\n例行推广一下我的博客，喜欢这篇文章的朋友可以关注我的博客[http://zwgeek.com](http://zwgeek.com)","slug":"fastjson使用过程中的坑","published":1,"updated":"2024-06-14T09:25:33.678Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clxjsxtw3000olq6g5qlal9hh","content":"<p>例行推广一下我的博客，喜欢这篇文章的朋友可以关注我的博客<a href=\"http://zwgeek.com\">http://zwgeek.com</a></p>\n<p>最近在工作中用到了fastjson，遇到了一些坑，在这里总结一下。</p>\n<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>首先，介绍一下fastjson。fastjson是由alibaba开源的一套json处理器。与其他json处理器（如Gson，Jackson等）和其他的Java对象序列化反序列化方式相比，有比较明显的性能优势。详情可以参考fastjson提供的benchmark。</p>\n<p><a href=\"https://github.com/eishay/jvm-serializers/wiki\" target=\"_blank\" rel=\"external\">benchmark for fastjson</a></p>\n<p>fastjson的使用方法也比较简单，详细使用可以参考<a href=\"https://github.com/Alibaba/fastjson/wiki/%E9%A6%96%E9%A1%B5\" target=\"_blank\" rel=\"external\">fastjson首页</a>，这里只做一个简单介绍。</p>\n<p>首先可通过Gradle或Maven或直接引用jar包的方式来引入fastjson。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;dependency&gt;</div><div class=\"line\">    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</div><div class=\"line\">    &lt;artifactId&gt;fastjson&lt;/artifactId&gt;</div><div class=\"line\">    &lt;version&gt;VERSION_CODE&lt;/version&gt;</div><div class=\"line\">&lt;/dependency&gt;</div></pre></td></tr></table></figure></p>\n<p>或<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">compile &apos;com.alibaba:fastjson:VERSION_CODE&apos;</div></pre></td></tr></table></figure></p>\n<h4 id=\"序列化方式\"><a href=\"#序列化方式\" class=\"headerlink\" title=\"序列化方式\"></a>序列化方式</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">String jsonString = JSON.toJSONString(class);</div></pre></td></tr></table></figure>\n<h4 id=\"反序列化方式\"><a href=\"#反序列化方式\" class=\"headerlink\" title=\"反序列化方式\"></a>反序列化方式</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Class class = JSON.parseObject(jsonString, Class.class);</div></pre></td></tr></table></figure>\n<h4 id=\"泛型反序列化\"><a href=\"#泛型反序列化\" class=\"headerlink\" title=\"泛型反序列化\"></a>泛型反序列化</h4><p>泛型对象比如List的序列化方法和普通对象一样，反序列化的时候需要指定一下泛型对象，例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">List&lt;VO&gt; list = JSON.parseObject(&quot;...&quot;, new TypeReference&lt;List&lt;VO&gt;&gt;() &#123;&#125;);</div></pre></td></tr></table></figure></p>\n<p>以上就是fastjson的简单用法，接下来说一下我在使用过程中遇到的坑。</p>\n<p>###遇到的问题</p>\n<h3 id=\"1-序列化的类必须有一个无参构造方法\"><a href=\"#1-序列化的类必须有一个无参构造方法\" class=\"headerlink\" title=\"1. 序列化的类必须有一个无参构造方法\"></a>1. 序列化的类必须有一个无参构造方法</h3><p>被序列化的类需要有一个无参的构造方法。否则会报错<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Exception in thread &quot;main&quot; com.alibaba.fastjson.JSONException: default constructor not found. class User</div></pre></td></tr></table></figure></p>\n<p>如果你没有重写构造方法，那么每个类都自带一个无参的构造方法，但是如果你重写了一个有参的构造方法，那么默认的无参构造方法会被覆盖，这时候就需要你手动写一个无参的构造方法进去。所以我建议保险起见，需要被json序列化的类最好都手动写一个无参的构造方法进去。</p>\n<p>对于这个问题，我怀疑fastjson是这样处理的（没有验证代码）。它在反序列化的时候会先用无参的构造方法构造一个类实例。然后将每一个值解析出来赋值到这个实例中。所以很明显，除了无参的构造方法，你还需要保证被序列化的成员变量能被访问到，经过我测试fastjson支持以下两种访问方式。</p>\n<ul>\n<li><p>public访问权限</p>\n</li>\n<li><p>get和set方法</p>\n</li>\n</ul>\n<h3 id=\"2-子类不能重写父类成员变量\"><a href=\"#2-子类不能重写父类成员变量\" class=\"headerlink\" title=\"2. 子类不能重写父类成员变量\"></a>2. 子类不能重写父类成员变量</h3><p> 正如第二点提到的，fastjson是通过类的成员变量名称来识别成员变量的。所以如果子类复写的父类的成员变量，会导致fastjson识别错乱。</p>\n<p>这个问题我在Android版本的使用过程中遇到了，后来在Java版本的测试中却无法复现这个问题，所以并不是所有的复写父类的成员变量都不能被识别。只有在类结构比较复杂的时候才容易出问题，不管怎么样，我建议使用过程中尽量避免复写父类的成员变量。</p>\n<h3 id=\"3-混淆要对泛型进行保护\"><a href=\"#3-混淆要对泛型进行保护\" class=\"headerlink\" title=\"3. 混淆要对泛型进行保护\"></a>3. 混淆要对泛型进行保护</h3><p>这个问题其实也不是fastjson的问题，但这个问题却是困扰我最久的一个问题，本地运行没有问题，但是一打Release就有问题。这种情况99%是由于Proguard引起的，但我当时Proguard配置文件中已经keep了所有的类，按理说不是由于类被混淆而找不到造成的。</p>\n<p>后来我发现这个问题只有在遇到List的时候才会出错，所以开始怀疑是不是泛型在Proguard的时候出现了问题，后来发现了Proguard的官网，果然Proguard有对泛型的保护。后来在fastjson的issue中也发现有人提出了这个问题，并且发现除了泛型之外还需要对注解进行保护。</p>\n<p><a href=\"https://github.com/alibaba/fastjson/issues/765\" target=\"_blank\" rel=\"external\">fastjson issue传送门</a><br><a href=\"https://www.guardsquare.com/en/proguard/manual/examples#annotations\" target=\"_blank\" rel=\"external\">Proguard指南传送门</a></p>\n<p>通过以上两篇文章，我们知道需要在Proguard的配置文件中加入以下属性。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">-keepattributes Signature</div><div class=\"line\">-keepattributes *Annotation*</div></pre></td></tr></table></figure>\n<p>If your application, applet, servlet, library, etc., uses annotations, you may want to preserve them in the processed output. Annotations are represented by attributes that have no direct effect on the execution of the code. However, their values can be retrieved through introspection, allowing developers to adapt the execution behavior accordingly. By default, ProGuard treats annotation attributes as optional, and removes them in the obfuscation step.</p>\n<p>The “Signature” attribute is required to be able to access generic types when compiling in JDK 5.0 and higher.</p>\n<p>由这个问题我深深的感觉到自己最Proguard的不熟悉，以前仅仅会从网上拷贝一个默认的混淆配置问题，而对于细节配置全然不知，所以我决定接下来翻译下Proguard官网。</p>\n<p>以上就是使用fastjson中遇到的问题，以及解决方案。fastjson的性能确实不错，而且对Model的入侵性低，使用简单。是序列化和反序列化的好帮手。</p>\n<p>例行推广一下我的博客，喜欢这篇文章的朋友可以关注我的博客<a href=\"http://zwgeek.com\">http://zwgeek.com</a></p>\n","excerpt":"","more":"<p>例行推广一下我的博客，喜欢这篇文章的朋友可以关注我的博客<a href=\"http://zwgeek.com\">http://zwgeek.com</a></p>\n<p>最近在工作中用到了fastjson，遇到了一些坑，在这里总结一下。</p>\n<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>首先，介绍一下fastjson。fastjson是由alibaba开源的一套json处理器。与其他json处理器（如Gson，Jackson等）和其他的Java对象序列化反序列化方式相比，有比较明显的性能优势。详情可以参考fastjson提供的benchmark。</p>\n<p><a href=\"https://github.com/eishay/jvm-serializers/wiki\">benchmark for fastjson</a></p>\n<p>fastjson的使用方法也比较简单，详细使用可以参考<a href=\"https://github.com/Alibaba/fastjson/wiki/%E9%A6%96%E9%A1%B5\">fastjson首页</a>，这里只做一个简单介绍。</p>\n<p>首先可通过Gradle或Maven或直接引用jar包的方式来引入fastjson。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;dependency&gt;</div><div class=\"line\">    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</div><div class=\"line\">    &lt;artifactId&gt;fastjson&lt;/artifactId&gt;</div><div class=\"line\">    &lt;version&gt;VERSION_CODE&lt;/version&gt;</div><div class=\"line\">&lt;/dependency&gt;</div></pre></td></tr></table></figure></p>\n<p>或<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">compile &apos;com.alibaba:fastjson:VERSION_CODE&apos;</div></pre></td></tr></table></figure></p>\n<h4 id=\"序列化方式\"><a href=\"#序列化方式\" class=\"headerlink\" title=\"序列化方式\"></a>序列化方式</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">String jsonString = JSON.toJSONString(class);</div></pre></td></tr></table></figure>\n<h4 id=\"反序列化方式\"><a href=\"#反序列化方式\" class=\"headerlink\" title=\"反序列化方式\"></a>反序列化方式</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Class class = JSON.parseObject(jsonString, Class.class);</div></pre></td></tr></table></figure>\n<h4 id=\"泛型反序列化\"><a href=\"#泛型反序列化\" class=\"headerlink\" title=\"泛型反序列化\"></a>泛型反序列化</h4><p>泛型对象比如List的序列化方法和普通对象一样，反序列化的时候需要指定一下泛型对象，例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">List&lt;VO&gt; list = JSON.parseObject(&quot;...&quot;, new TypeReference&lt;List&lt;VO&gt;&gt;() &#123;&#125;);</div></pre></td></tr></table></figure></p>\n<p>以上就是fastjson的简单用法，接下来说一下我在使用过程中遇到的坑。</p>\n<p>###遇到的问题</p>\n<h3 id=\"1-序列化的类必须有一个无参构造方法\"><a href=\"#1-序列化的类必须有一个无参构造方法\" class=\"headerlink\" title=\"1. 序列化的类必须有一个无参构造方法\"></a>1. 序列化的类必须有一个无参构造方法</h3><p>被序列化的类需要有一个无参的构造方法。否则会报错<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Exception in thread &quot;main&quot; com.alibaba.fastjson.JSONException: default constructor not found. class User</div></pre></td></tr></table></figure></p>\n<p>如果你没有重写构造方法，那么每个类都自带一个无参的构造方法，但是如果你重写了一个有参的构造方法，那么默认的无参构造方法会被覆盖，这时候就需要你手动写一个无参的构造方法进去。所以我建议保险起见，需要被json序列化的类最好都手动写一个无参的构造方法进去。</p>\n<p>对于这个问题，我怀疑fastjson是这样处理的（没有验证代码）。它在反序列化的时候会先用无参的构造方法构造一个类实例。然后将每一个值解析出来赋值到这个实例中。所以很明显，除了无参的构造方法，你还需要保证被序列化的成员变量能被访问到，经过我测试fastjson支持以下两种访问方式。</p>\n<ul>\n<li><p>public访问权限</p>\n</li>\n<li><p>get和set方法</p>\n</li>\n</ul>\n<h3 id=\"2-子类不能重写父类成员变量\"><a href=\"#2-子类不能重写父类成员变量\" class=\"headerlink\" title=\"2. 子类不能重写父类成员变量\"></a>2. 子类不能重写父类成员变量</h3><p> 正如第二点提到的，fastjson是通过类的成员变量名称来识别成员变量的。所以如果子类复写的父类的成员变量，会导致fastjson识别错乱。</p>\n<p>这个问题我在Android版本的使用过程中遇到了，后来在Java版本的测试中却无法复现这个问题，所以并不是所有的复写父类的成员变量都不能被识别。只有在类结构比较复杂的时候才容易出问题，不管怎么样，我建议使用过程中尽量避免复写父类的成员变量。</p>\n<h3 id=\"3-混淆要对泛型进行保护\"><a href=\"#3-混淆要对泛型进行保护\" class=\"headerlink\" title=\"3. 混淆要对泛型进行保护\"></a>3. 混淆要对泛型进行保护</h3><p>这个问题其实也不是fastjson的问题，但这个问题却是困扰我最久的一个问题，本地运行没有问题，但是一打Release就有问题。这种情况99%是由于Proguard引起的，但我当时Proguard配置文件中已经keep了所有的类，按理说不是由于类被混淆而找不到造成的。</p>\n<p>后来我发现这个问题只有在遇到List的时候才会出错，所以开始怀疑是不是泛型在Proguard的时候出现了问题，后来发现了Proguard的官网，果然Proguard有对泛型的保护。后来在fastjson的issue中也发现有人提出了这个问题，并且发现除了泛型之外还需要对注解进行保护。</p>\n<p><a href=\"https://github.com/alibaba/fastjson/issues/765\">fastjson issue传送门</a><br><a href=\"https://www.guardsquare.com/en/proguard/manual/examples#annotations\">Proguard指南传送门</a></p>\n<p>通过以上两篇文章，我们知道需要在Proguard的配置文件中加入以下属性。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">-keepattributes Signature</div><div class=\"line\">-keepattributes *Annotation*</div></pre></td></tr></table></figure>\n<p>If your application, applet, servlet, library, etc., uses annotations, you may want to preserve them in the processed output. Annotations are represented by attributes that have no direct effect on the execution of the code. However, their values can be retrieved through introspection, allowing developers to adapt the execution behavior accordingly. By default, ProGuard treats annotation attributes as optional, and removes them in the obfuscation step.</p>\n<p>The “Signature” attribute is required to be able to access generic types when compiling in JDK 5.0 and higher.</p>\n<p>由这个问题我深深的感觉到自己最Proguard的不熟悉，以前仅仅会从网上拷贝一个默认的混淆配置问题，而对于细节配置全然不知，所以我决定接下来翻译下Proguard官网。</p>\n<p>以上就是使用fastjson中遇到的问题，以及解决方案。fastjson的性能确实不错，而且对Model的入侵性低，使用简单。是序列化和反序列化的好帮手。</p>\n<p>例行推广一下我的博客，喜欢这篇文章的朋友可以关注我的博客<a href=\"http://zwgeek.com\">http://zwgeek.com</a></p>\n"},{"title":"分类模型优劣评估","date":"2018-04-08T11:17:06.000Z","_content":"\n## 背景\n之前文章讲了如果用 tensorflow 训练模型之后，如果对模型体积有要求，或者希望优化模型网络结构的时候，我们会调整模型的一些网络结构。但是如果证明调整后的网络结构与之前的网络结构相比的优劣性呢。\n\n最简单的，我们一般会跑一个准确率，那么除了这个准确率之外还有其他的指标能证明模型的优劣吗，这篇文章给大家讲下评估分类模型优劣的其他几个指标。\n\n## 名称解释\n\n举个例子，假设一个二分类模型，模型的作用是用来区分一堆数据中真的数据和假的数据。\n\n假设一共有 22 个数据，22 个数据中真数据有 12 个，假数据有 10 个。而分类模型认为其中 8 个数据是真的，当然，这 8 个数据中有 5 个是真的，而另外 3 个是假的，却被模型错误的认为是真的。如下图所示：\n\n![](https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/%E5%88%86%E7%B1%BB%E6%A8%A1%E5%9E%8B%E4%BC%98%E5%8A%A3%E8%AF%84%E4%BC%B0/Snip20180511_9.png)\n\n那让我们定义以下概念：\n\n```\nTP = 5\nFP = 3\n\nTN = 7\nFN = 7\n```\n\n### 真正率、真阳率、灵敏度\n真正率（true positive rate, TPR），真阳率，灵敏度（sensitivity），指的是被模型预测的正样本的比例：\n\nTPR = TP / (TP + FN)\n\n在例子中指的是 5/12\n\n这个比例高适合于那些需要“宁可错杀一千，不可放过一个”的模型，比如地震预测，地震预测错多次也没关系，重要的是真的发生地震的时候一定要预测出来。\n\n### 真负率、特异度\n真负率（true negative rate, TNR），特异度（specificity），指的是被模型正确预测的负样本的比例：\n\nTNR = TN / (TN + FP)\n\n在例子中是 7/10\n\n这个比例高适合于那些需要“不能冤枉一个好人”的业务模型，比如预测一些人是否罪犯，宁可放过一些罪犯，也不能冤枉一个好人。\n\n### 假正率、假阳率\n假正率（false positive rate, FPR），假阳率，指的是被模型错误预测的正样本比例：\n\nFPR = FP / (TN + FP)\n\n在例子中指的是 3/10\n\n### 假负率\n假负率（false negative rete, FNT），指的是被模型错误预测的负样本的比例：\n\nFNR = FN / (TP + FN)\n\n在例子中指的是 7/12\n\n### 精确度、精度、查准率\n\n精度（precision）指的是模型查出来的所有数据中，有多少是准的。\n\np = TP / (TP + FP)\n\n在例子中指的是 5/8\n\n### 召回率、查全率、真正率、真阳率、灵敏度\n\n召回率（recall）指的是所有对的数据中，有多少能被模型查出来。但其实召回率就是前面提到的真阳率。\n\nr = TP / (TP + FN)\n\n在例子中指的是 5/12\n\n### F1\nF1分数（F1 Score），又被称为平衡F分数（balanced F Score），是一个兼顾精确率和召回率的调和平均数。定义如下：\n\n![](https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/%E5%88%86%E7%B1%BB%E6%A8%A1%E5%9E%8B%E4%BC%98%E5%8A%A3%E8%AF%84%E4%BC%B0/Snip20180511_5.png)\n\n但如果你的模型对精确率和召回率考虑的权重不一样时，可以定义 F-β 分数如下：\n\n![](https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/%E5%88%86%E7%B1%BB%E6%A8%A1%E5%9E%8B%E4%BC%98%E5%8A%A3%E8%AF%84%E4%BC%B0/Snip20180511_6.png)\n\n当 β 为 1 是，召回率和精确率的权重一样，也就是 F-1 分数。当 β 大于 1 时，召回率的权重高于精确率，如 F-2 分数。当 β 小于 1 时，精确率的权重高于召回率，如 F-0.5 分数。\n\n### ROC\n\nROC全称受试者工作特征曲线（receiver operating characteristic curve），又称为感受性曲线（sensitivity curve）。绘制方式是以假阳率（FPR）为横坐标，以真阳率为（TPR）为纵坐标，对于模型输出的特征值，以不同的阈值进行划分，得到曲线。\n\n举个简单的例子：\n\n假设 5 个数据点，模型输出的特征值分别是\n\n```\n[0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0]\n```\n\n其中前 5 个数据点为负，后 5 个数据点为正，也就是说，10 个数据的标签时如下形式\n\n```\n[0, 0, 0, 0, 0, 1, 1, 1, 1, 1]\n\n```\n\n那么，当我的阈值分别取以下值的时候\n\n```\n[1.  0.9 0.8 0.7 0.6 0.5 0.4 0.3 0.2 0.1]\n```\n\n假阳率和真阳率分别是以下值\n\n```\n假阳率：[0.  0.  0.  0.  0.  0.2 0.4 0.6 0.8 1. ]\n真阳率：[0.2 0.4 0.6 0.8 1.  1.  1.  1.  1.  1. ]\n```\n\n按照 ROC 的定义，得到的曲线如图\n\n![](https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/%E5%88%86%E7%B1%BB%E6%A8%A1%E5%9E%8B%E4%BC%98%E5%8A%A3%E8%AF%84%E4%BC%B0/Snip20180511_1.png)\n\n在 ROC 曲线中，左上角的点代表取这个阈值的时候，假阳率最低，真阳率最高，是最佳阈值，上图中的最佳阈值是 0.6。\n\n### AUC\nAUC（Area Under Curve）被定义为 ROC 曲线下的面积，顾名思义。这个值存在的意义是开发者希望用一个定量的数字来表示模型的性能。\n\n由上图可知，AUC 的取值范围在 0 到 1 ，越大越好。但 AUC 小于 0.5 的模型我们认为是没有意义的，分类效果太差。\n\n上图中的 AUC 是 1。\n\n### PRC\n\nPRC（Precision Recall Curve），精度召回率曲线，以召回率（查全率）为横坐标，精度（查准率）为纵坐标，和 RPC 类似，对于模型输出的特征值，以不同的阈值进行划分，得到曲线。\n\n还是上面那个例子，5 个数据点，模型输出的特征值分别是\n\n```\n[0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0]\n```\n\n其中前 5 个数据点为负，后 5 个数据点为正，也就是说，10 个数据的标签时如下形式\n\n```\n[0, 0, 0, 0, 0, 1, 1, 1, 1, 1]\n\n```\n\n那么，当我的阈值分别取以下值的时候\n\n```\n[0.6 0.7 0.8 0.9 1]\n```\n\n假阳率和真阳率分别是以下值\n\n```\n查全率（召回率）：[1.  0.8 0.6 0.4 0.2 0. ]\n查准率（精度）：[1. 1. 1. 1. 1. 1.]\n```\n\n绘制的曲线如图\n\n![](https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/%E5%88%86%E7%B1%BB%E6%A8%A1%E5%9E%8B%E4%BC%98%E5%8A%A3%E8%AF%84%E4%BC%B0/Snip20180511_4.png)\n\n在 PRC 曲线中，最右上角的点，查全率和查准率都最高，也就是最佳阈值，在这个例子中，是 0.6（在这个例子中 ROC 曲线和 PRC 曲线得到的最佳阈值是同一个数，但并不总是这样）。\n\n### 损失函数曲线\n\n损失函数曲线（Loss Curve），是以训练次数为横轴，以当次的损失率为纵轴绘制的曲线。\n\n###### 损失函数\n关于损失函数的定义可以参考其他机器学习教程，这里就不细说了，简单来说，是如下定义：\n\n![](https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/%E5%88%86%E7%B1%BB%E6%A8%A1%E5%9E%8B%E4%BC%98%E5%8A%A3%E8%AF%84%E4%BC%B0/Snip20180511_7.png)\n\n这里的 X，Y 并不是变量，而是常量，指的是 n 个样本及 n 个样本的标签值。损失函数是一个关于 f(x) 中参数的公式。\n\n每次训练后，在训练集和交叉验证集（或测试集）上分别跑下损失函数的值，大概是一个如下的曲线：\n\n![](https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/%E5%88%86%E7%B1%BB%E6%A8%A1%E5%9E%8B%E4%BC%98%E5%8A%A3%E8%AF%84%E4%BC%B0/Snip20180511_8.png)\n\n这个曲线可以显示欠拟合和过拟合的程度，从上面曲线可以看出来，在训练集上，损失函数值是逐渐趋于0的，而在验证集上损失函数在下降一段时间后开始上升，这说明出现了过拟合。\n\nMNIST 问题中的 Loss 曲线\n\n![](https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/%E5%88%86%E7%B1%BB%E6%A8%A1%E5%9E%8B%E4%BC%98%E5%8A%A3%E8%AF%84%E4%BC%B0/Snip20180511_10.png)\n\n可以看出一直没有出现过拟合的情况\n\n## ROC和PRC曲线比较\n\nROC 曲线有个很好的特性：当测试集中的正负样本的分布变化的时候，ROC 曲线能够保持不变。在实际的数据集中经常会出现类不平衡（class imbalance）现象，即负样本比正样本多很多（或者相反），而且测试数据中的正负样本的分布也可能随着时间变化。下图是 ROC 曲线和 Precision-Recall 曲线的对比：\n\n![](http://alexkong.net/images/roc-and-precall.png)\n\n在上图中，(a) 和 (c) 为ROC曲线，(b) 和 (d) 为Precision-Recall曲线。(a) 和 (b) 展示的是分类其在原始测试集（正负样本分布平衡）的结果，(c) 和 (d) 是将测试集中负样本的数量增加到原来的 10 倍后，分类器的结果。可以明显的看出，ROC 曲线基本保持原貌，而 Precision-Recall 曲线则变化较大。\n\n也就是 PRC 曲线会面临一个问题，当需要获得更高 recall 时，model 需要输出更多的样本，precision 可能会伴随出现下降/不变/升高，得到的曲线会出现浮动差异（出现锯齿），无法像 ROC 一样保证单调性。\n\n结论：AUC 用得比较多的一个重要原因是，实际环境中正负样本极不均衡，PR 曲线无法很好反映出分类器性能，而 ROC 受此影响小。\n\n\n\n## 总结\n以上各个指标都不能全面的覆盖分类器的各种性能，在实际应用中，应该合理的组合使用以上指标来判断分类器的效果。\n\n\n\n","source":"_posts/分类模型优劣评估.md","raw":"---\ntitle: 分类模型优劣评估\ndate: 2018-04-08 19:17:06\ntags:\n  - TensorFlow\n  - CNN\ncategories: AI\n---\n\n## 背景\n之前文章讲了如果用 tensorflow 训练模型之后，如果对模型体积有要求，或者希望优化模型网络结构的时候，我们会调整模型的一些网络结构。但是如果证明调整后的网络结构与之前的网络结构相比的优劣性呢。\n\n最简单的，我们一般会跑一个准确率，那么除了这个准确率之外还有其他的指标能证明模型的优劣吗，这篇文章给大家讲下评估分类模型优劣的其他几个指标。\n\n## 名称解释\n\n举个例子，假设一个二分类模型，模型的作用是用来区分一堆数据中真的数据和假的数据。\n\n假设一共有 22 个数据，22 个数据中真数据有 12 个，假数据有 10 个。而分类模型认为其中 8 个数据是真的，当然，这 8 个数据中有 5 个是真的，而另外 3 个是假的，却被模型错误的认为是真的。如下图所示：\n\n![](https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/%E5%88%86%E7%B1%BB%E6%A8%A1%E5%9E%8B%E4%BC%98%E5%8A%A3%E8%AF%84%E4%BC%B0/Snip20180511_9.png)\n\n那让我们定义以下概念：\n\n```\nTP = 5\nFP = 3\n\nTN = 7\nFN = 7\n```\n\n### 真正率、真阳率、灵敏度\n真正率（true positive rate, TPR），真阳率，灵敏度（sensitivity），指的是被模型预测的正样本的比例：\n\nTPR = TP / (TP + FN)\n\n在例子中指的是 5/12\n\n这个比例高适合于那些需要“宁可错杀一千，不可放过一个”的模型，比如地震预测，地震预测错多次也没关系，重要的是真的发生地震的时候一定要预测出来。\n\n### 真负率、特异度\n真负率（true negative rate, TNR），特异度（specificity），指的是被模型正确预测的负样本的比例：\n\nTNR = TN / (TN + FP)\n\n在例子中是 7/10\n\n这个比例高适合于那些需要“不能冤枉一个好人”的业务模型，比如预测一些人是否罪犯，宁可放过一些罪犯，也不能冤枉一个好人。\n\n### 假正率、假阳率\n假正率（false positive rate, FPR），假阳率，指的是被模型错误预测的正样本比例：\n\nFPR = FP / (TN + FP)\n\n在例子中指的是 3/10\n\n### 假负率\n假负率（false negative rete, FNT），指的是被模型错误预测的负样本的比例：\n\nFNR = FN / (TP + FN)\n\n在例子中指的是 7/12\n\n### 精确度、精度、查准率\n\n精度（precision）指的是模型查出来的所有数据中，有多少是准的。\n\np = TP / (TP + FP)\n\n在例子中指的是 5/8\n\n### 召回率、查全率、真正率、真阳率、灵敏度\n\n召回率（recall）指的是所有对的数据中，有多少能被模型查出来。但其实召回率就是前面提到的真阳率。\n\nr = TP / (TP + FN)\n\n在例子中指的是 5/12\n\n### F1\nF1分数（F1 Score），又被称为平衡F分数（balanced F Score），是一个兼顾精确率和召回率的调和平均数。定义如下：\n\n![](https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/%E5%88%86%E7%B1%BB%E6%A8%A1%E5%9E%8B%E4%BC%98%E5%8A%A3%E8%AF%84%E4%BC%B0/Snip20180511_5.png)\n\n但如果你的模型对精确率和召回率考虑的权重不一样时，可以定义 F-β 分数如下：\n\n![](https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/%E5%88%86%E7%B1%BB%E6%A8%A1%E5%9E%8B%E4%BC%98%E5%8A%A3%E8%AF%84%E4%BC%B0/Snip20180511_6.png)\n\n当 β 为 1 是，召回率和精确率的权重一样，也就是 F-1 分数。当 β 大于 1 时，召回率的权重高于精确率，如 F-2 分数。当 β 小于 1 时，精确率的权重高于召回率，如 F-0.5 分数。\n\n### ROC\n\nROC全称受试者工作特征曲线（receiver operating characteristic curve），又称为感受性曲线（sensitivity curve）。绘制方式是以假阳率（FPR）为横坐标，以真阳率为（TPR）为纵坐标，对于模型输出的特征值，以不同的阈值进行划分，得到曲线。\n\n举个简单的例子：\n\n假设 5 个数据点，模型输出的特征值分别是\n\n```\n[0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0]\n```\n\n其中前 5 个数据点为负，后 5 个数据点为正，也就是说，10 个数据的标签时如下形式\n\n```\n[0, 0, 0, 0, 0, 1, 1, 1, 1, 1]\n\n```\n\n那么，当我的阈值分别取以下值的时候\n\n```\n[1.  0.9 0.8 0.7 0.6 0.5 0.4 0.3 0.2 0.1]\n```\n\n假阳率和真阳率分别是以下值\n\n```\n假阳率：[0.  0.  0.  0.  0.  0.2 0.4 0.6 0.8 1. ]\n真阳率：[0.2 0.4 0.6 0.8 1.  1.  1.  1.  1.  1. ]\n```\n\n按照 ROC 的定义，得到的曲线如图\n\n![](https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/%E5%88%86%E7%B1%BB%E6%A8%A1%E5%9E%8B%E4%BC%98%E5%8A%A3%E8%AF%84%E4%BC%B0/Snip20180511_1.png)\n\n在 ROC 曲线中，左上角的点代表取这个阈值的时候，假阳率最低，真阳率最高，是最佳阈值，上图中的最佳阈值是 0.6。\n\n### AUC\nAUC（Area Under Curve）被定义为 ROC 曲线下的面积，顾名思义。这个值存在的意义是开发者希望用一个定量的数字来表示模型的性能。\n\n由上图可知，AUC 的取值范围在 0 到 1 ，越大越好。但 AUC 小于 0.5 的模型我们认为是没有意义的，分类效果太差。\n\n上图中的 AUC 是 1。\n\n### PRC\n\nPRC（Precision Recall Curve），精度召回率曲线，以召回率（查全率）为横坐标，精度（查准率）为纵坐标，和 RPC 类似，对于模型输出的特征值，以不同的阈值进行划分，得到曲线。\n\n还是上面那个例子，5 个数据点，模型输出的特征值分别是\n\n```\n[0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0]\n```\n\n其中前 5 个数据点为负，后 5 个数据点为正，也就是说，10 个数据的标签时如下形式\n\n```\n[0, 0, 0, 0, 0, 1, 1, 1, 1, 1]\n\n```\n\n那么，当我的阈值分别取以下值的时候\n\n```\n[0.6 0.7 0.8 0.9 1]\n```\n\n假阳率和真阳率分别是以下值\n\n```\n查全率（召回率）：[1.  0.8 0.6 0.4 0.2 0. ]\n查准率（精度）：[1. 1. 1. 1. 1. 1.]\n```\n\n绘制的曲线如图\n\n![](https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/%E5%88%86%E7%B1%BB%E6%A8%A1%E5%9E%8B%E4%BC%98%E5%8A%A3%E8%AF%84%E4%BC%B0/Snip20180511_4.png)\n\n在 PRC 曲线中，最右上角的点，查全率和查准率都最高，也就是最佳阈值，在这个例子中，是 0.6（在这个例子中 ROC 曲线和 PRC 曲线得到的最佳阈值是同一个数，但并不总是这样）。\n\n### 损失函数曲线\n\n损失函数曲线（Loss Curve），是以训练次数为横轴，以当次的损失率为纵轴绘制的曲线。\n\n###### 损失函数\n关于损失函数的定义可以参考其他机器学习教程，这里就不细说了，简单来说，是如下定义：\n\n![](https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/%E5%88%86%E7%B1%BB%E6%A8%A1%E5%9E%8B%E4%BC%98%E5%8A%A3%E8%AF%84%E4%BC%B0/Snip20180511_7.png)\n\n这里的 X，Y 并不是变量，而是常量，指的是 n 个样本及 n 个样本的标签值。损失函数是一个关于 f(x) 中参数的公式。\n\n每次训练后，在训练集和交叉验证集（或测试集）上分别跑下损失函数的值，大概是一个如下的曲线：\n\n![](https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/%E5%88%86%E7%B1%BB%E6%A8%A1%E5%9E%8B%E4%BC%98%E5%8A%A3%E8%AF%84%E4%BC%B0/Snip20180511_8.png)\n\n这个曲线可以显示欠拟合和过拟合的程度，从上面曲线可以看出来，在训练集上，损失函数值是逐渐趋于0的，而在验证集上损失函数在下降一段时间后开始上升，这说明出现了过拟合。\n\nMNIST 问题中的 Loss 曲线\n\n![](https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/%E5%88%86%E7%B1%BB%E6%A8%A1%E5%9E%8B%E4%BC%98%E5%8A%A3%E8%AF%84%E4%BC%B0/Snip20180511_10.png)\n\n可以看出一直没有出现过拟合的情况\n\n## ROC和PRC曲线比较\n\nROC 曲线有个很好的特性：当测试集中的正负样本的分布变化的时候，ROC 曲线能够保持不变。在实际的数据集中经常会出现类不平衡（class imbalance）现象，即负样本比正样本多很多（或者相反），而且测试数据中的正负样本的分布也可能随着时间变化。下图是 ROC 曲线和 Precision-Recall 曲线的对比：\n\n![](http://alexkong.net/images/roc-and-precall.png)\n\n在上图中，(a) 和 (c) 为ROC曲线，(b) 和 (d) 为Precision-Recall曲线。(a) 和 (b) 展示的是分类其在原始测试集（正负样本分布平衡）的结果，(c) 和 (d) 是将测试集中负样本的数量增加到原来的 10 倍后，分类器的结果。可以明显的看出，ROC 曲线基本保持原貌，而 Precision-Recall 曲线则变化较大。\n\n也就是 PRC 曲线会面临一个问题，当需要获得更高 recall 时，model 需要输出更多的样本，precision 可能会伴随出现下降/不变/升高，得到的曲线会出现浮动差异（出现锯齿），无法像 ROC 一样保证单调性。\n\n结论：AUC 用得比较多的一个重要原因是，实际环境中正负样本极不均衡，PR 曲线无法很好反映出分类器性能，而 ROC 受此影响小。\n\n\n\n## 总结\n以上各个指标都不能全面的覆盖分类器的各种性能，在实际应用中，应该合理的组合使用以上指标来判断分类器的效果。\n\n\n\n","slug":"分类模型优劣评估","published":1,"updated":"2024-06-14T09:25:33.678Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clxjsxtw4000rlq6gvz461m9p","content":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>之前文章讲了如果用 tensorflow 训练模型之后，如果对模型体积有要求，或者希望优化模型网络结构的时候，我们会调整模型的一些网络结构。但是如果证明调整后的网络结构与之前的网络结构相比的优劣性呢。</p>\n<p>最简单的，我们一般会跑一个准确率，那么除了这个准确率之外还有其他的指标能证明模型的优劣吗，这篇文章给大家讲下评估分类模型优劣的其他几个指标。</p>\n<h2 id=\"名称解释\"><a href=\"#名称解释\" class=\"headerlink\" title=\"名称解释\"></a>名称解释</h2><p>举个例子，假设一个二分类模型，模型的作用是用来区分一堆数据中真的数据和假的数据。</p>\n<p>假设一共有 22 个数据，22 个数据中真数据有 12 个，假数据有 10 个。而分类模型认为其中 8 个数据是真的，当然，这 8 个数据中有 5 个是真的，而另外 3 个是假的，却被模型错误的认为是真的。如下图所示：</p>\n<p><img src=\"https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/%E5%88%86%E7%B1%BB%E6%A8%A1%E5%9E%8B%E4%BC%98%E5%8A%A3%E8%AF%84%E4%BC%B0/Snip20180511_9.png\" alt=\"\"></p>\n<p>那让我们定义以下概念：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">TP = 5</div><div class=\"line\">FP = 3</div><div class=\"line\"></div><div class=\"line\">TN = 7</div><div class=\"line\">FN = 7</div></pre></td></tr></table></figure>\n<h3 id=\"真正率、真阳率、灵敏度\"><a href=\"#真正率、真阳率、灵敏度\" class=\"headerlink\" title=\"真正率、真阳率、灵敏度\"></a>真正率、真阳率、灵敏度</h3><p>真正率（true positive rate, TPR），真阳率，灵敏度（sensitivity），指的是被模型预测的正样本的比例：</p>\n<p>TPR = TP / (TP + FN)</p>\n<p>在例子中指的是 5/12</p>\n<p>这个比例高适合于那些需要“宁可错杀一千，不可放过一个”的模型，比如地震预测，地震预测错多次也没关系，重要的是真的发生地震的时候一定要预测出来。</p>\n<h3 id=\"真负率、特异度\"><a href=\"#真负率、特异度\" class=\"headerlink\" title=\"真负率、特异度\"></a>真负率、特异度</h3><p>真负率（true negative rate, TNR），特异度（specificity），指的是被模型正确预测的负样本的比例：</p>\n<p>TNR = TN / (TN + FP)</p>\n<p>在例子中是 7/10</p>\n<p>这个比例高适合于那些需要“不能冤枉一个好人”的业务模型，比如预测一些人是否罪犯，宁可放过一些罪犯，也不能冤枉一个好人。</p>\n<h3 id=\"假正率、假阳率\"><a href=\"#假正率、假阳率\" class=\"headerlink\" title=\"假正率、假阳率\"></a>假正率、假阳率</h3><p>假正率（false positive rate, FPR），假阳率，指的是被模型错误预测的正样本比例：</p>\n<p>FPR = FP / (TN + FP)</p>\n<p>在例子中指的是 3/10</p>\n<h3 id=\"假负率\"><a href=\"#假负率\" class=\"headerlink\" title=\"假负率\"></a>假负率</h3><p>假负率（false negative rete, FNT），指的是被模型错误预测的负样本的比例：</p>\n<p>FNR = FN / (TP + FN)</p>\n<p>在例子中指的是 7/12</p>\n<h3 id=\"精确度、精度、查准率\"><a href=\"#精确度、精度、查准率\" class=\"headerlink\" title=\"精确度、精度、查准率\"></a>精确度、精度、查准率</h3><p>精度（precision）指的是模型查出来的所有数据中，有多少是准的。</p>\n<p>p = TP / (TP + FP)</p>\n<p>在例子中指的是 5/8</p>\n<h3 id=\"召回率、查全率、真正率、真阳率、灵敏度\"><a href=\"#召回率、查全率、真正率、真阳率、灵敏度\" class=\"headerlink\" title=\"召回率、查全率、真正率、真阳率、灵敏度\"></a>召回率、查全率、真正率、真阳率、灵敏度</h3><p>召回率（recall）指的是所有对的数据中，有多少能被模型查出来。但其实召回率就是前面提到的真阳率。</p>\n<p>r = TP / (TP + FN)</p>\n<p>在例子中指的是 5/12</p>\n<h3 id=\"F1\"><a href=\"#F1\" class=\"headerlink\" title=\"F1\"></a>F1</h3><p>F1分数（F1 Score），又被称为平衡F分数（balanced F Score），是一个兼顾精确率和召回率的调和平均数。定义如下：</p>\n<p><img src=\"https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/%E5%88%86%E7%B1%BB%E6%A8%A1%E5%9E%8B%E4%BC%98%E5%8A%A3%E8%AF%84%E4%BC%B0/Snip20180511_5.png\" alt=\"\"></p>\n<p>但如果你的模型对精确率和召回率考虑的权重不一样时，可以定义 F-β 分数如下：</p>\n<p><img src=\"https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/%E5%88%86%E7%B1%BB%E6%A8%A1%E5%9E%8B%E4%BC%98%E5%8A%A3%E8%AF%84%E4%BC%B0/Snip20180511_6.png\" alt=\"\"></p>\n<p>当 β 为 1 是，召回率和精确率的权重一样，也就是 F-1 分数。当 β 大于 1 时，召回率的权重高于精确率，如 F-2 分数。当 β 小于 1 时，精确率的权重高于召回率，如 F-0.5 分数。</p>\n<h3 id=\"ROC\"><a href=\"#ROC\" class=\"headerlink\" title=\"ROC\"></a>ROC</h3><p>ROC全称受试者工作特征曲线（receiver operating characteristic curve），又称为感受性曲线（sensitivity curve）。绘制方式是以假阳率（FPR）为横坐标，以真阳率为（TPR）为纵坐标，对于模型输出的特征值，以不同的阈值进行划分，得到曲线。</p>\n<p>举个简单的例子：</p>\n<p>假设 5 个数据点，模型输出的特征值分别是</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0]</div></pre></td></tr></table></figure>\n<p>其中前 5 个数据点为负，后 5 个数据点为正，也就是说，10 个数据的标签时如下形式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[0, 0, 0, 0, 0, 1, 1, 1, 1, 1]</div></pre></td></tr></table></figure>\n<p>那么，当我的阈值分别取以下值的时候</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[1.  0.9 0.8 0.7 0.6 0.5 0.4 0.3 0.2 0.1]</div></pre></td></tr></table></figure>\n<p>假阳率和真阳率分别是以下值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">假阳率：[0.  0.  0.  0.  0.  0.2 0.4 0.6 0.8 1. ]</div><div class=\"line\">真阳率：[0.2 0.4 0.6 0.8 1.  1.  1.  1.  1.  1. ]</div></pre></td></tr></table></figure>\n<p>按照 ROC 的定义，得到的曲线如图</p>\n<p><img src=\"https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/%E5%88%86%E7%B1%BB%E6%A8%A1%E5%9E%8B%E4%BC%98%E5%8A%A3%E8%AF%84%E4%BC%B0/Snip20180511_1.png\" alt=\"\"></p>\n<p>在 ROC 曲线中，左上角的点代表取这个阈值的时候，假阳率最低，真阳率最高，是最佳阈值，上图中的最佳阈值是 0.6。</p>\n<h3 id=\"AUC\"><a href=\"#AUC\" class=\"headerlink\" title=\"AUC\"></a>AUC</h3><p>AUC（Area Under Curve）被定义为 ROC 曲线下的面积，顾名思义。这个值存在的意义是开发者希望用一个定量的数字来表示模型的性能。</p>\n<p>由上图可知，AUC 的取值范围在 0 到 1 ，越大越好。但 AUC 小于 0.5 的模型我们认为是没有意义的，分类效果太差。</p>\n<p>上图中的 AUC 是 1。</p>\n<h3 id=\"PRC\"><a href=\"#PRC\" class=\"headerlink\" title=\"PRC\"></a>PRC</h3><p>PRC（Precision Recall Curve），精度召回率曲线，以召回率（查全率）为横坐标，精度（查准率）为纵坐标，和 RPC 类似，对于模型输出的特征值，以不同的阈值进行划分，得到曲线。</p>\n<p>还是上面那个例子，5 个数据点，模型输出的特征值分别是</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0]</div></pre></td></tr></table></figure>\n<p>其中前 5 个数据点为负，后 5 个数据点为正，也就是说，10 个数据的标签时如下形式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[0, 0, 0, 0, 0, 1, 1, 1, 1, 1]</div></pre></td></tr></table></figure>\n<p>那么，当我的阈值分别取以下值的时候</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[0.6 0.7 0.8 0.9 1]</div></pre></td></tr></table></figure>\n<p>假阳率和真阳率分别是以下值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">查全率（召回率）：[1.  0.8 0.6 0.4 0.2 0. ]</div><div class=\"line\">查准率（精度）：[1. 1. 1. 1. 1. 1.]</div></pre></td></tr></table></figure>\n<p>绘制的曲线如图</p>\n<p><img src=\"https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/%E5%88%86%E7%B1%BB%E6%A8%A1%E5%9E%8B%E4%BC%98%E5%8A%A3%E8%AF%84%E4%BC%B0/Snip20180511_4.png\" alt=\"\"></p>\n<p>在 PRC 曲线中，最右上角的点，查全率和查准率都最高，也就是最佳阈值，在这个例子中，是 0.6（在这个例子中 ROC 曲线和 PRC 曲线得到的最佳阈值是同一个数，但并不总是这样）。</p>\n<h3 id=\"损失函数曲线\"><a href=\"#损失函数曲线\" class=\"headerlink\" title=\"损失函数曲线\"></a>损失函数曲线</h3><p>损失函数曲线（Loss Curve），是以训练次数为横轴，以当次的损失率为纵轴绘制的曲线。</p>\n<h6 id=\"损失函数\"><a href=\"#损失函数\" class=\"headerlink\" title=\"损失函数\"></a>损失函数</h6><p>关于损失函数的定义可以参考其他机器学习教程，这里就不细说了，简单来说，是如下定义：</p>\n<p><img src=\"https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/%E5%88%86%E7%B1%BB%E6%A8%A1%E5%9E%8B%E4%BC%98%E5%8A%A3%E8%AF%84%E4%BC%B0/Snip20180511_7.png\" alt=\"\"></p>\n<p>这里的 X，Y 并不是变量，而是常量，指的是 n 个样本及 n 个样本的标签值。损失函数是一个关于 f(x) 中参数的公式。</p>\n<p>每次训练后，在训练集和交叉验证集（或测试集）上分别跑下损失函数的值，大概是一个如下的曲线：</p>\n<p><img src=\"https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/%E5%88%86%E7%B1%BB%E6%A8%A1%E5%9E%8B%E4%BC%98%E5%8A%A3%E8%AF%84%E4%BC%B0/Snip20180511_8.png\" alt=\"\"></p>\n<p>这个曲线可以显示欠拟合和过拟合的程度，从上面曲线可以看出来，在训练集上，损失函数值是逐渐趋于0的，而在验证集上损失函数在下降一段时间后开始上升，这说明出现了过拟合。</p>\n<p>MNIST 问题中的 Loss 曲线</p>\n<p><img src=\"https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/%E5%88%86%E7%B1%BB%E6%A8%A1%E5%9E%8B%E4%BC%98%E5%8A%A3%E8%AF%84%E4%BC%B0/Snip20180511_10.png\" alt=\"\"></p>\n<p>可以看出一直没有出现过拟合的情况</p>\n<h2 id=\"ROC和PRC曲线比较\"><a href=\"#ROC和PRC曲线比较\" class=\"headerlink\" title=\"ROC和PRC曲线比较\"></a>ROC和PRC曲线比较</h2><p>ROC 曲线有个很好的特性：当测试集中的正负样本的分布变化的时候，ROC 曲线能够保持不变。在实际的数据集中经常会出现类不平衡（class imbalance）现象，即负样本比正样本多很多（或者相反），而且测试数据中的正负样本的分布也可能随着时间变化。下图是 ROC 曲线和 Precision-Recall 曲线的对比：</p>\n<p><img src=\"http://alexkong.net/images/roc-and-precall.png\" alt=\"\"></p>\n<p>在上图中，(a) 和 (c) 为ROC曲线，(b) 和 (d) 为Precision-Recall曲线。(a) 和 (b) 展示的是分类其在原始测试集（正负样本分布平衡）的结果，(c) 和 (d) 是将测试集中负样本的数量增加到原来的 10 倍后，分类器的结果。可以明显的看出，ROC 曲线基本保持原貌，而 Precision-Recall 曲线则变化较大。</p>\n<p>也就是 PRC 曲线会面临一个问题，当需要获得更高 recall 时，model 需要输出更多的样本，precision 可能会伴随出现下降/不变/升高，得到的曲线会出现浮动差异（出现锯齿），无法像 ROC 一样保证单调性。</p>\n<p>结论：AUC 用得比较多的一个重要原因是，实际环境中正负样本极不均衡，PR 曲线无法很好反映出分类器性能，而 ROC 受此影响小。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>以上各个指标都不能全面的覆盖分类器的各种性能，在实际应用中，应该合理的组合使用以上指标来判断分类器的效果。</p>\n","excerpt":"","more":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>之前文章讲了如果用 tensorflow 训练模型之后，如果对模型体积有要求，或者希望优化模型网络结构的时候，我们会调整模型的一些网络结构。但是如果证明调整后的网络结构与之前的网络结构相比的优劣性呢。</p>\n<p>最简单的，我们一般会跑一个准确率，那么除了这个准确率之外还有其他的指标能证明模型的优劣吗，这篇文章给大家讲下评估分类模型优劣的其他几个指标。</p>\n<h2 id=\"名称解释\"><a href=\"#名称解释\" class=\"headerlink\" title=\"名称解释\"></a>名称解释</h2><p>举个例子，假设一个二分类模型，模型的作用是用来区分一堆数据中真的数据和假的数据。</p>\n<p>假设一共有 22 个数据，22 个数据中真数据有 12 个，假数据有 10 个。而分类模型认为其中 8 个数据是真的，当然，这 8 个数据中有 5 个是真的，而另外 3 个是假的，却被模型错误的认为是真的。如下图所示：</p>\n<p><img src=\"https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/%E5%88%86%E7%B1%BB%E6%A8%A1%E5%9E%8B%E4%BC%98%E5%8A%A3%E8%AF%84%E4%BC%B0/Snip20180511_9.png\" alt=\"\"></p>\n<p>那让我们定义以下概念：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">TP = 5</div><div class=\"line\">FP = 3</div><div class=\"line\"></div><div class=\"line\">TN = 7</div><div class=\"line\">FN = 7</div></pre></td></tr></table></figure>\n<h3 id=\"真正率、真阳率、灵敏度\"><a href=\"#真正率、真阳率、灵敏度\" class=\"headerlink\" title=\"真正率、真阳率、灵敏度\"></a>真正率、真阳率、灵敏度</h3><p>真正率（true positive rate, TPR），真阳率，灵敏度（sensitivity），指的是被模型预测的正样本的比例：</p>\n<p>TPR = TP / (TP + FN)</p>\n<p>在例子中指的是 5/12</p>\n<p>这个比例高适合于那些需要“宁可错杀一千，不可放过一个”的模型，比如地震预测，地震预测错多次也没关系，重要的是真的发生地震的时候一定要预测出来。</p>\n<h3 id=\"真负率、特异度\"><a href=\"#真负率、特异度\" class=\"headerlink\" title=\"真负率、特异度\"></a>真负率、特异度</h3><p>真负率（true negative rate, TNR），特异度（specificity），指的是被模型正确预测的负样本的比例：</p>\n<p>TNR = TN / (TN + FP)</p>\n<p>在例子中是 7/10</p>\n<p>这个比例高适合于那些需要“不能冤枉一个好人”的业务模型，比如预测一些人是否罪犯，宁可放过一些罪犯，也不能冤枉一个好人。</p>\n<h3 id=\"假正率、假阳率\"><a href=\"#假正率、假阳率\" class=\"headerlink\" title=\"假正率、假阳率\"></a>假正率、假阳率</h3><p>假正率（false positive rate, FPR），假阳率，指的是被模型错误预测的正样本比例：</p>\n<p>FPR = FP / (TN + FP)</p>\n<p>在例子中指的是 3/10</p>\n<h3 id=\"假负率\"><a href=\"#假负率\" class=\"headerlink\" title=\"假负率\"></a>假负率</h3><p>假负率（false negative rete, FNT），指的是被模型错误预测的负样本的比例：</p>\n<p>FNR = FN / (TP + FN)</p>\n<p>在例子中指的是 7/12</p>\n<h3 id=\"精确度、精度、查准率\"><a href=\"#精确度、精度、查准率\" class=\"headerlink\" title=\"精确度、精度、查准率\"></a>精确度、精度、查准率</h3><p>精度（precision）指的是模型查出来的所有数据中，有多少是准的。</p>\n<p>p = TP / (TP + FP)</p>\n<p>在例子中指的是 5/8</p>\n<h3 id=\"召回率、查全率、真正率、真阳率、灵敏度\"><a href=\"#召回率、查全率、真正率、真阳率、灵敏度\" class=\"headerlink\" title=\"召回率、查全率、真正率、真阳率、灵敏度\"></a>召回率、查全率、真正率、真阳率、灵敏度</h3><p>召回率（recall）指的是所有对的数据中，有多少能被模型查出来。但其实召回率就是前面提到的真阳率。</p>\n<p>r = TP / (TP + FN)</p>\n<p>在例子中指的是 5/12</p>\n<h3 id=\"F1\"><a href=\"#F1\" class=\"headerlink\" title=\"F1\"></a>F1</h3><p>F1分数（F1 Score），又被称为平衡F分数（balanced F Score），是一个兼顾精确率和召回率的调和平均数。定义如下：</p>\n<p><img src=\"https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/%E5%88%86%E7%B1%BB%E6%A8%A1%E5%9E%8B%E4%BC%98%E5%8A%A3%E8%AF%84%E4%BC%B0/Snip20180511_5.png\" alt=\"\"></p>\n<p>但如果你的模型对精确率和召回率考虑的权重不一样时，可以定义 F-β 分数如下：</p>\n<p><img src=\"https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/%E5%88%86%E7%B1%BB%E6%A8%A1%E5%9E%8B%E4%BC%98%E5%8A%A3%E8%AF%84%E4%BC%B0/Snip20180511_6.png\" alt=\"\"></p>\n<p>当 β 为 1 是，召回率和精确率的权重一样，也就是 F-1 分数。当 β 大于 1 时，召回率的权重高于精确率，如 F-2 分数。当 β 小于 1 时，精确率的权重高于召回率，如 F-0.5 分数。</p>\n<h3 id=\"ROC\"><a href=\"#ROC\" class=\"headerlink\" title=\"ROC\"></a>ROC</h3><p>ROC全称受试者工作特征曲线（receiver operating characteristic curve），又称为感受性曲线（sensitivity curve）。绘制方式是以假阳率（FPR）为横坐标，以真阳率为（TPR）为纵坐标，对于模型输出的特征值，以不同的阈值进行划分，得到曲线。</p>\n<p>举个简单的例子：</p>\n<p>假设 5 个数据点，模型输出的特征值分别是</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0]</div></pre></td></tr></table></figure>\n<p>其中前 5 个数据点为负，后 5 个数据点为正，也就是说，10 个数据的标签时如下形式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[0, 0, 0, 0, 0, 1, 1, 1, 1, 1]</div></pre></td></tr></table></figure>\n<p>那么，当我的阈值分别取以下值的时候</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[1.  0.9 0.8 0.7 0.6 0.5 0.4 0.3 0.2 0.1]</div></pre></td></tr></table></figure>\n<p>假阳率和真阳率分别是以下值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">假阳率：[0.  0.  0.  0.  0.  0.2 0.4 0.6 0.8 1. ]</div><div class=\"line\">真阳率：[0.2 0.4 0.6 0.8 1.  1.  1.  1.  1.  1. ]</div></pre></td></tr></table></figure>\n<p>按照 ROC 的定义，得到的曲线如图</p>\n<p><img src=\"https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/%E5%88%86%E7%B1%BB%E6%A8%A1%E5%9E%8B%E4%BC%98%E5%8A%A3%E8%AF%84%E4%BC%B0/Snip20180511_1.png\" alt=\"\"></p>\n<p>在 ROC 曲线中，左上角的点代表取这个阈值的时候，假阳率最低，真阳率最高，是最佳阈值，上图中的最佳阈值是 0.6。</p>\n<h3 id=\"AUC\"><a href=\"#AUC\" class=\"headerlink\" title=\"AUC\"></a>AUC</h3><p>AUC（Area Under Curve）被定义为 ROC 曲线下的面积，顾名思义。这个值存在的意义是开发者希望用一个定量的数字来表示模型的性能。</p>\n<p>由上图可知，AUC 的取值范围在 0 到 1 ，越大越好。但 AUC 小于 0.5 的模型我们认为是没有意义的，分类效果太差。</p>\n<p>上图中的 AUC 是 1。</p>\n<h3 id=\"PRC\"><a href=\"#PRC\" class=\"headerlink\" title=\"PRC\"></a>PRC</h3><p>PRC（Precision Recall Curve），精度召回率曲线，以召回率（查全率）为横坐标，精度（查准率）为纵坐标，和 RPC 类似，对于模型输出的特征值，以不同的阈值进行划分，得到曲线。</p>\n<p>还是上面那个例子，5 个数据点，模型输出的特征值分别是</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0]</div></pre></td></tr></table></figure>\n<p>其中前 5 个数据点为负，后 5 个数据点为正，也就是说，10 个数据的标签时如下形式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[0, 0, 0, 0, 0, 1, 1, 1, 1, 1]</div></pre></td></tr></table></figure>\n<p>那么，当我的阈值分别取以下值的时候</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[0.6 0.7 0.8 0.9 1]</div></pre></td></tr></table></figure>\n<p>假阳率和真阳率分别是以下值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">查全率（召回率）：[1.  0.8 0.6 0.4 0.2 0. ]</div><div class=\"line\">查准率（精度）：[1. 1. 1. 1. 1. 1.]</div></pre></td></tr></table></figure>\n<p>绘制的曲线如图</p>\n<p><img src=\"https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/%E5%88%86%E7%B1%BB%E6%A8%A1%E5%9E%8B%E4%BC%98%E5%8A%A3%E8%AF%84%E4%BC%B0/Snip20180511_4.png\" alt=\"\"></p>\n<p>在 PRC 曲线中，最右上角的点，查全率和查准率都最高，也就是最佳阈值，在这个例子中，是 0.6（在这个例子中 ROC 曲线和 PRC 曲线得到的最佳阈值是同一个数，但并不总是这样）。</p>\n<h3 id=\"损失函数曲线\"><a href=\"#损失函数曲线\" class=\"headerlink\" title=\"损失函数曲线\"></a>损失函数曲线</h3><p>损失函数曲线（Loss Curve），是以训练次数为横轴，以当次的损失率为纵轴绘制的曲线。</p>\n<h6 id=\"损失函数\"><a href=\"#损失函数\" class=\"headerlink\" title=\"损失函数\"></a>损失函数</h6><p>关于损失函数的定义可以参考其他机器学习教程，这里就不细说了，简单来说，是如下定义：</p>\n<p><img src=\"https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/%E5%88%86%E7%B1%BB%E6%A8%A1%E5%9E%8B%E4%BC%98%E5%8A%A3%E8%AF%84%E4%BC%B0/Snip20180511_7.png\" alt=\"\"></p>\n<p>这里的 X，Y 并不是变量，而是常量，指的是 n 个样本及 n 个样本的标签值。损失函数是一个关于 f(x) 中参数的公式。</p>\n<p>每次训练后，在训练集和交叉验证集（或测试集）上分别跑下损失函数的值，大概是一个如下的曲线：</p>\n<p><img src=\"https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/%E5%88%86%E7%B1%BB%E6%A8%A1%E5%9E%8B%E4%BC%98%E5%8A%A3%E8%AF%84%E4%BC%B0/Snip20180511_8.png\" alt=\"\"></p>\n<p>这个曲线可以显示欠拟合和过拟合的程度，从上面曲线可以看出来，在训练集上，损失函数值是逐渐趋于0的，而在验证集上损失函数在下降一段时间后开始上升，这说明出现了过拟合。</p>\n<p>MNIST 问题中的 Loss 曲线</p>\n<p><img src=\"https://zgzczzw-blog-image.oss-cn-beijing.aliyuncs.com/%E5%88%86%E7%B1%BB%E6%A8%A1%E5%9E%8B%E4%BC%98%E5%8A%A3%E8%AF%84%E4%BC%B0/Snip20180511_10.png\" alt=\"\"></p>\n<p>可以看出一直没有出现过拟合的情况</p>\n<h2 id=\"ROC和PRC曲线比较\"><a href=\"#ROC和PRC曲线比较\" class=\"headerlink\" title=\"ROC和PRC曲线比较\"></a>ROC和PRC曲线比较</h2><p>ROC 曲线有个很好的特性：当测试集中的正负样本的分布变化的时候，ROC 曲线能够保持不变。在实际的数据集中经常会出现类不平衡（class imbalance）现象，即负样本比正样本多很多（或者相反），而且测试数据中的正负样本的分布也可能随着时间变化。下图是 ROC 曲线和 Precision-Recall 曲线的对比：</p>\n<p><img src=\"http://alexkong.net/images/roc-and-precall.png\" alt=\"\"></p>\n<p>在上图中，(a) 和 (c) 为ROC曲线，(b) 和 (d) 为Precision-Recall曲线。(a) 和 (b) 展示的是分类其在原始测试集（正负样本分布平衡）的结果，(c) 和 (d) 是将测试集中负样本的数量增加到原来的 10 倍后，分类器的结果。可以明显的看出，ROC 曲线基本保持原貌，而 Precision-Recall 曲线则变化较大。</p>\n<p>也就是 PRC 曲线会面临一个问题，当需要获得更高 recall 时，model 需要输出更多的样本，precision 可能会伴随出现下降/不变/升高，得到的曲线会出现浮动差异（出现锯齿），无法像 ROC 一样保证单调性。</p>\n<p>结论：AUC 用得比较多的一个重要原因是，实际环境中正负样本极不均衡，PR 曲线无法很好反映出分类器性能，而 ROC 受此影响小。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>以上各个指标都不能全面的覆盖分类器的各种性能，在实际应用中，应该合理的组合使用以上指标来判断分类器的效果。</p>\n"},{"title":"基于LinkMap分析iOSAPP各模块体积","date":"2018-01-08T08:59:22.000Z","_content":"\n\n广告时间，大家喜欢我的文章，可以关注我的博客[zwgeek.com](zwgeek.com)\n\n## 1. 前言\n\n做客户端开发经常会有需要分析客户端体积的需求。比如引入了一个第三方库，这个库到底多大呢？同时，有些动态库封装了所有架构（比如x86_64,arm）的代码，但编译的时候实际打到安装包里的只有当前架构的那部分，那么这部分体积是多少呢？有时候一个模块写了很多方法，但是这些方法都没有被调用到，编译的时候实际打进安装包里的代码又有多少呢？只有真正了解了自己的安装包体积是有哪些部分构成的，才能有针对性的去优化体积。像Android的话，简单一点可以解压开apk文件去看每个模块，或者引入的Library的大小。但是iOS的安装包是个二进制文件，这又怎么去分析呢。这篇文章给大家讲下使用Xcode提供的LinkMap文件去分析iOS安装包的体积构成，同时提供一个python的脚本，去自动化的分析iOS安装包体积。\n\n关于LinkMap的分析，也是在Bang神的指点下才知道的，所以特别鸣谢下Bang的文章[传送门：iOS APP可执行文件的组成](http://blog.cnbang.net/tech/2296/)，这篇文章跟Bang的讲的都差不多，我就是记一下自己的理解。\n\n## 2. LinkMap详解\nLinkMap，顾名思义，指的就是iOS安装包的一张地图，通过这张地图，你可以看到安装包里各个部分都是什么内容。通过分析各部分内容所占的内存空间，就可以知道各部分内容的体积大小了。\n\n### 2.1 生成LinkMap\n首先，我们要生成LinkMap，这是Xcode提供的功能，默认是不生成的，需要更改一下配置，才会去生成。需要更改的地方有两个。\n\n在Target的Build Settings中更改Write Link Map File 为 Yes，这样就可以生成Link Map文件了，但是这个文件在哪呢。通过修改Build Settings的Path To Link Map可以指定LinkMap文件的生成目录，默认是生成在Build文件加下，也可以像我这样指定直接生成在桌面上。\n\n![这里写图片描述](https://img-blog.csdn.net/2018040817355259?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pnemN6enc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n\n![这里写图片描述](https://img-blog.csdn.net/20180408173810292?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pnemN6enc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n\n修改完以上两个配置后，就可以重新Build程序了，没有什么意外的话，你指定的路径下应该已经有LinkMap文件了。接下来我们看看LinkMap文件的格式。\n\n### 2.2 LinkMap文件格式\n我这边的demo是个比较简单的Hello world程序，所以生成的LinkMap很小，不过稍微复杂一点的程序，LinkMap就会很大了。下面说下文件格式。\n\n```\n# Path\n# Arch: x86_64\n# Object files:\n# Sections:\n# Symbols:\n# Dead Stripped Symbols:\n\n```\n\n一个完整的LinkMap文件是分为这几块的，以#为分隔，我们一个个看下。\n\n#### Path\n\n```\n# Path: /tmp/xcode/TestCleanPackage-gjpgqvilgwaxwyfhkccvcfzwbtdf/Build/Products/Debug-iphonesimulator/TestCleanPackage.app/TestCleanPackage\n```\nPath记录的是这个LinkMap对应的安装包的地址。\n\n#### Arch\n```\n# Arch: x86_64\n```\nArch指的是这个LinkMap对应的架构\n\n#### Object files\n```\n# Object files:\n[  0] linker synthesized\n[  1] /tmp/xcode/TestCleanPackage-gjpgqvilgwaxwyfhkccvcfzwbtdf/Build/Intermediates.noindex/TestCleanPackage.build/Debug-iphonesimulator/TestCleanPackage.build/TestCleanPackage.app.xcent\n[  2] /tmp/xcode/TestCleanPackage-gjpgqvilgwaxwyfhkccvcfzwbtdf/Build/Intermediates.noindex/TestCleanPackage.build/Debug-iphonesimulator/TestCleanPackage.build/Objects-normal/x86_64/ViewController.o\n[  3] /tmp/xcode/TestCleanPackage-gjpgqvilgwaxwyfhkccvcfzwbtdf/Build/Intermediates.noindex/TestCleanPackage.build/Debug-iphonesimulator/TestCleanPackage.build/Objects-normal/x86_64/main.o\n[  4] /tmp/xcode/TestCleanPackage-gjpgqvilgwaxwyfhkccvcfzwbtdf/Build/Intermediates.noindex/TestCleanPackage.build/Debug-iphonesimulator/TestCleanPackage.build/Objects-normal/x86_64/UnUsedClass.o\n[  5] /tmp/xcode/TestCleanPackage-gjpgqvilgwaxwyfhkccvcfzwbtdf/Build/Intermediates.noindex/TestCleanPackage.build/Debug-iphonesimulator/TestCleanPackage.build/Objects-normal/x86_64/AppDelegate.o\n[  6] /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator11.1.sdk/System/Library/Frameworks//Foundation.framework/Foundation.tbd\n[  7] /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator11.1.sdk/usr/lib/libobjc.tbd\n[  8] /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator11.1.sdk/System/Library/Frameworks//UIKit.framework/UIKit.tbd\n```\n\nObject files是编译后生成的文件列表，比如这个程序class都编译成了.o文件，像我们比较熟悉的AppDelegate.o文件等等。还有引进来的几个库，比如UIKit.tbd。\n\n#### Sections\n```\n# Sections:\n# Address\tSize    \tSegment\tSection\n0x100001620\t0x000003C3\t__TEXT\t__text\n0x1000019E4\t0x00000036\t__TEXT\t__stubs\n0x100001A1C\t0x0000006A\t__TEXT\t__stub_helper\n0x100001A86\t0x00000A69\t__TEXT\t__objc_methname\n0x1000024EF\t0x00000048\t__TEXT\t__objc_classname\n0x100002537\t0x0000086D\t__TEXT\t__objc_methtype\n0x100002DA4\t0x0000007A\t__TEXT\t__cstring\n0x100002E1E\t0x0000018C\t__TEXT\t__entitlements\n0x100002FAC\t0x00000048\t__TEXT\t__unwind_info\n0x100003000\t0x00000010\t__DATA\t__nl_symbol_ptr\n0x100003010\t0x00000048\t__DATA\t__la_symbol_ptr\n0x100003058\t0x00000018\t__DATA\t__objc_classlist\n0x100003070\t0x00000010\t__DATA\t__objc_protolist\n0x100003080\t0x00000008\t__DATA\t__objc_imageinfo\n0x100003088\t0x00000CD8\t__DATA\t__objc_const\n0x100003D60\t0x00000020\t__DATA\t__objc_selrefs\n0x100003D80\t0x00000008\t__DATA\t__objc_classrefs\n0x100003D88\t0x00000008\t__DATA\t__objc_superrefs\n0x100003D90\t0x00000008\t__DATA\t__objc_ivar\n0x100003D98\t0x000000F0\t__DATA\t__objc_data\n0x100003E88\t0x000000C0\t__DATA\t__data\n```\n\nSection是各种数据类型所在的内存空间，Section主要分为两大类，\\_\\_Text和\\_\\_DATA。\\_\\_Text指的是程序代码，\\_\\_DATA指的是已经初始化的变量等。\n具体分类如下表所示。\n\n>以下是__TEXT段的section\n\n>__text  主程序代码\n\n>__stubs 和__stub_helper   用于动态链接库的stub\n\n>__cstring    c语言字符串\n\n>__const    const修饰的常量\n\n>__objc_methname    objc的方法名称\n\n>__objc_methtype    objc方法类型\n\n>__objc_classname    objc类方法\n\n \n\n>以下是__DATA段的section\n\n>__objc_ivars   objc类的实例变量\n\n>__objc_classlist    objc类列表\n\n>__objc_protolist    objc协议列表\n\n>__objc_imageinfo    objc镜像信息\n\n>__objc_const    objc常量\n\n>__objc_selfrefs    objc自引用(self)\n\n>__objc_protorefs    objc协议引用\n\n>__objc_superrefs    objc超类引用\n\n>__cfstring   使用Core Foundation字符串\n\n>__bss   BSS\n\n每个Section前面的两个16进制的数字代表的就是这个Section相对于安装包初始内存的偏移和这个Section的大小。比如：\n\n```\n0x100001620\t0x000003C3\t__TEXT\t__text\n```\n\n\\_\\_text这个Section的偏移地址是0x100001620，这块的大小是0x000003C3，也就是963个字节。\n\n#### Symbols\niOS开发的同学对Symbols这个单词肯定不陌生，什么Crash要有对应的符号表，编译的时候经常保持找不到Symbols等。Symbols简单来说就是类名，变量名，方法名等等符号。所以这一块也详细列出了这个安装包内各个方法所占的内存大小。\n\n```\n# Address\tSize    \tFile  Name\n0x100001620\t0x00000040\t[  2] -[ViewController viewDidLoad]\n0x100001660\t0x00000040\t[  2] -[ViewController didReceiveMemoryWarning]\n0x1000016A0\t0x00000010\t[  2] -[ViewController unusedMethod1]\n...\n```\n\n这一块太多了，我只列出一小部分，这块同样有四列，一二列和Sections的情况一样，分别是偏移地址和大小。第四列是方法的符号，类名+方法名。第三列是文件序号，这个序号是哪里来的的，就是前面提到的Object files里文件的序号，比如这里viewDidLoad的序号是2，去Object files去找序号是2的文件。\n\n```\n[  2] /tmp/xcode/TestCleanPackage-gjpgqvilgwaxwyfhkccvcfzwbtdf/Build/Intermediates.noindex/TestCleanPackage.build/Debug-iphonesimulator/TestCleanPackage.build/Objects-normal/x86_64/ViewController.o\n```\n\n也就是说这个方法来自ViewController.o这个文件。\n\n通过这种对应关系，我可以知道一个.o文件里有多少方法被编译进了安装包，每个方法所占的体积，加起来我就知道每个.o文件的大小了。后面的程序也就是把这个过程给自动化了。\n\n#### Dead Stripped Symbols\n最后还有一部分是没用的符号，这部分我也不知道是怎么产生的，但可以肯定的是这部分不应该太大。\n\n```\n# Dead Stripped Symbols:\n#        \tSize    \tFile  Name\n<<dead>> \t0x00000018\t[  2] CIE\n<<dead>> \t0x00000018\t[  3] CIE\n<<dead>> \t0x00000006\t[  5] literal string: class\n<<dead>> \t0x00000008\t[  5] literal string: v16@0:8\n<<dead>> \t0x00000018\t[  5] CIE\n```\n\n## 3.自动分析\n通过前面对LinkMap文件格式的解析，我们知道在LinkMap里，我们可以知道每个文件所占的体积大小，并且可以通过文件的前缀，知道文件所属的动态库，这样也就可以知道动态库的大小。只是这个过程太过繁琐，所以我们去把它自动化了。\n\n项目开源在：\n\n[LinkMapParser](https://github.com/zgzczzw/LinkMapParser)\n\n#### 使用方法\n##### 3.1 安装Python环境\nLinkMapParser是一个Python脚本，运行该脚本需要开发者的机器有Python的运行环境，安装Python的方法可以查阅相关资料。Python版本为2.7。\n\n##### 3.2 生成link map文件\nXcode默认是不生成link map文件的。生成link map文件需修改项目中的Build Settings，选择Target的Build Settings，修改Write Link Map File为Yes，修改Path to Link Map File为你需要的地址，然后编译程序，即可在该地址生成相应的link map文件。\n\n##### 3.3 运行工具\n该工具支持分析一个link map文件和比较两个link map文件，运行的命令分别为：\n\n###### 分析一个link map文件\n\n```\npython parselinkmap.py $map_link_file_path\n```\n输出结果类似于：\n\n```\n================================================================================\n        demoData/TestCleanPackage-LinkMap-normal-x86_64.txt各模块体积汇总\n================================================================================\nCreating Result File : demoData/BaseLinkMapResult.txt\nAppDelegate.o                                     0.01M\nViewController.o                                  0.00M\nTestCleanPackage.app.xcent                        0.00M\nUnUsedClass.o                                     0.00M\nmain.o                                            0.00M\nlibobjc.tbd                                       0.00M\nlinker synthesized                                0.00M\nFoundation.tbd                                    0.00M\nUIKit.tbd                                         0.00M\n总体积:                                           0.01M\n```\n\ndemo中只有一个Bundle，可以看出各个class文件在安装包中所占大小，如AppDelegate占用0.01M。\n\n比较两个link map文件\n\n```\npython parselinkmap.py $base_map_link_file_path $target_map_link_file_path\n```\n\nLinkMapParser会分析两个map link文件，然后比较各个模块的体积是否有变化，最后列出体积变大的模块。\n\n输出结果类似于：\n\n```\n================================================================================\n                     demoData/BaseLinkMap.txt各模块体积汇总\n================================================================================\nCreating Result File : demoData/BaseLinkMapResult.txt\nAppDelegate.o                                     0.01M\nViewController.o                                  0.00M\nTestCleanPackage.app.xcent                        0.00M\nUnUsedClass.o                                     0.00M\nmain.o                                            0.00M\nlibobjc.tbd                                       0.00M\nlinker synthesized                                0.00M\nFoundation.tbd                                    0.00M\nUIKit.tbd                                         0.00M\n总体积:                                           0.01M\n\n\n\n\n\n\n================================================================================\n                    demoData/TargetLinkMap.txt各模块体积汇总\n================================================================================\nCreating Result File : demoData/TargetLinkMapResult.txt\nAppDelegate.o                                     0.64M\nViewController.o                                  0.00M\nTestCleanPackage.app.xcent                        0.00M\nUnUsedClass.o                                     0.00M\nmain.o                                            0.00M\nlibobjc.tbd                                       0.00M\nlinker synthesized                                0.00M\nFoundation.tbd                                    0.00M\nUIKit.tbd                                         0.00M\n总体积:                                           0.64M\n\n\n\n\n\n\n================================================================================\n                                    比较结果\n================================================================================\n模块名称                                          基线大小  目标大小  是否新模块\nAppDelegate.o                                     0.01M     0.64M\n```\n\n好的，LinkMap就介绍到这里。\n\n广告时间，大家喜欢我的文章，可以关注我的博客[zwgeek.com](zwgeek.com)\n\n\n","source":"_posts/基于LinkMap分析iOSAPP各模块体积.md","raw":"---\ntitle: 基于LinkMap分析iOSAPP各模块体积\ndate: 2018-01-08 16:59:22\ntags:\n  - iOS\n  - LinkMap\n  - Python\ncategories: iOS\n---\n\n\n广告时间，大家喜欢我的文章，可以关注我的博客[zwgeek.com](zwgeek.com)\n\n## 1. 前言\n\n做客户端开发经常会有需要分析客户端体积的需求。比如引入了一个第三方库，这个库到底多大呢？同时，有些动态库封装了所有架构（比如x86_64,arm）的代码，但编译的时候实际打到安装包里的只有当前架构的那部分，那么这部分体积是多少呢？有时候一个模块写了很多方法，但是这些方法都没有被调用到，编译的时候实际打进安装包里的代码又有多少呢？只有真正了解了自己的安装包体积是有哪些部分构成的，才能有针对性的去优化体积。像Android的话，简单一点可以解压开apk文件去看每个模块，或者引入的Library的大小。但是iOS的安装包是个二进制文件，这又怎么去分析呢。这篇文章给大家讲下使用Xcode提供的LinkMap文件去分析iOS安装包的体积构成，同时提供一个python的脚本，去自动化的分析iOS安装包体积。\n\n关于LinkMap的分析，也是在Bang神的指点下才知道的，所以特别鸣谢下Bang的文章[传送门：iOS APP可执行文件的组成](http://blog.cnbang.net/tech/2296/)，这篇文章跟Bang的讲的都差不多，我就是记一下自己的理解。\n\n## 2. LinkMap详解\nLinkMap，顾名思义，指的就是iOS安装包的一张地图，通过这张地图，你可以看到安装包里各个部分都是什么内容。通过分析各部分内容所占的内存空间，就可以知道各部分内容的体积大小了。\n\n### 2.1 生成LinkMap\n首先，我们要生成LinkMap，这是Xcode提供的功能，默认是不生成的，需要更改一下配置，才会去生成。需要更改的地方有两个。\n\n在Target的Build Settings中更改Write Link Map File 为 Yes，这样就可以生成Link Map文件了，但是这个文件在哪呢。通过修改Build Settings的Path To Link Map可以指定LinkMap文件的生成目录，默认是生成在Build文件加下，也可以像我这样指定直接生成在桌面上。\n\n![这里写图片描述](https://img-blog.csdn.net/2018040817355259?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pnemN6enc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n\n![这里写图片描述](https://img-blog.csdn.net/20180408173810292?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pnemN6enc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n\n修改完以上两个配置后，就可以重新Build程序了，没有什么意外的话，你指定的路径下应该已经有LinkMap文件了。接下来我们看看LinkMap文件的格式。\n\n### 2.2 LinkMap文件格式\n我这边的demo是个比较简单的Hello world程序，所以生成的LinkMap很小，不过稍微复杂一点的程序，LinkMap就会很大了。下面说下文件格式。\n\n```\n# Path\n# Arch: x86_64\n# Object files:\n# Sections:\n# Symbols:\n# Dead Stripped Symbols:\n\n```\n\n一个完整的LinkMap文件是分为这几块的，以#为分隔，我们一个个看下。\n\n#### Path\n\n```\n# Path: /tmp/xcode/TestCleanPackage-gjpgqvilgwaxwyfhkccvcfzwbtdf/Build/Products/Debug-iphonesimulator/TestCleanPackage.app/TestCleanPackage\n```\nPath记录的是这个LinkMap对应的安装包的地址。\n\n#### Arch\n```\n# Arch: x86_64\n```\nArch指的是这个LinkMap对应的架构\n\n#### Object files\n```\n# Object files:\n[  0] linker synthesized\n[  1] /tmp/xcode/TestCleanPackage-gjpgqvilgwaxwyfhkccvcfzwbtdf/Build/Intermediates.noindex/TestCleanPackage.build/Debug-iphonesimulator/TestCleanPackage.build/TestCleanPackage.app.xcent\n[  2] /tmp/xcode/TestCleanPackage-gjpgqvilgwaxwyfhkccvcfzwbtdf/Build/Intermediates.noindex/TestCleanPackage.build/Debug-iphonesimulator/TestCleanPackage.build/Objects-normal/x86_64/ViewController.o\n[  3] /tmp/xcode/TestCleanPackage-gjpgqvilgwaxwyfhkccvcfzwbtdf/Build/Intermediates.noindex/TestCleanPackage.build/Debug-iphonesimulator/TestCleanPackage.build/Objects-normal/x86_64/main.o\n[  4] /tmp/xcode/TestCleanPackage-gjpgqvilgwaxwyfhkccvcfzwbtdf/Build/Intermediates.noindex/TestCleanPackage.build/Debug-iphonesimulator/TestCleanPackage.build/Objects-normal/x86_64/UnUsedClass.o\n[  5] /tmp/xcode/TestCleanPackage-gjpgqvilgwaxwyfhkccvcfzwbtdf/Build/Intermediates.noindex/TestCleanPackage.build/Debug-iphonesimulator/TestCleanPackage.build/Objects-normal/x86_64/AppDelegate.o\n[  6] /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator11.1.sdk/System/Library/Frameworks//Foundation.framework/Foundation.tbd\n[  7] /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator11.1.sdk/usr/lib/libobjc.tbd\n[  8] /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator11.1.sdk/System/Library/Frameworks//UIKit.framework/UIKit.tbd\n```\n\nObject files是编译后生成的文件列表，比如这个程序class都编译成了.o文件，像我们比较熟悉的AppDelegate.o文件等等。还有引进来的几个库，比如UIKit.tbd。\n\n#### Sections\n```\n# Sections:\n# Address\tSize    \tSegment\tSection\n0x100001620\t0x000003C3\t__TEXT\t__text\n0x1000019E4\t0x00000036\t__TEXT\t__stubs\n0x100001A1C\t0x0000006A\t__TEXT\t__stub_helper\n0x100001A86\t0x00000A69\t__TEXT\t__objc_methname\n0x1000024EF\t0x00000048\t__TEXT\t__objc_classname\n0x100002537\t0x0000086D\t__TEXT\t__objc_methtype\n0x100002DA4\t0x0000007A\t__TEXT\t__cstring\n0x100002E1E\t0x0000018C\t__TEXT\t__entitlements\n0x100002FAC\t0x00000048\t__TEXT\t__unwind_info\n0x100003000\t0x00000010\t__DATA\t__nl_symbol_ptr\n0x100003010\t0x00000048\t__DATA\t__la_symbol_ptr\n0x100003058\t0x00000018\t__DATA\t__objc_classlist\n0x100003070\t0x00000010\t__DATA\t__objc_protolist\n0x100003080\t0x00000008\t__DATA\t__objc_imageinfo\n0x100003088\t0x00000CD8\t__DATA\t__objc_const\n0x100003D60\t0x00000020\t__DATA\t__objc_selrefs\n0x100003D80\t0x00000008\t__DATA\t__objc_classrefs\n0x100003D88\t0x00000008\t__DATA\t__objc_superrefs\n0x100003D90\t0x00000008\t__DATA\t__objc_ivar\n0x100003D98\t0x000000F0\t__DATA\t__objc_data\n0x100003E88\t0x000000C0\t__DATA\t__data\n```\n\nSection是各种数据类型所在的内存空间，Section主要分为两大类，\\_\\_Text和\\_\\_DATA。\\_\\_Text指的是程序代码，\\_\\_DATA指的是已经初始化的变量等。\n具体分类如下表所示。\n\n>以下是__TEXT段的section\n\n>__text  主程序代码\n\n>__stubs 和__stub_helper   用于动态链接库的stub\n\n>__cstring    c语言字符串\n\n>__const    const修饰的常量\n\n>__objc_methname    objc的方法名称\n\n>__objc_methtype    objc方法类型\n\n>__objc_classname    objc类方法\n\n \n\n>以下是__DATA段的section\n\n>__objc_ivars   objc类的实例变量\n\n>__objc_classlist    objc类列表\n\n>__objc_protolist    objc协议列表\n\n>__objc_imageinfo    objc镜像信息\n\n>__objc_const    objc常量\n\n>__objc_selfrefs    objc自引用(self)\n\n>__objc_protorefs    objc协议引用\n\n>__objc_superrefs    objc超类引用\n\n>__cfstring   使用Core Foundation字符串\n\n>__bss   BSS\n\n每个Section前面的两个16进制的数字代表的就是这个Section相对于安装包初始内存的偏移和这个Section的大小。比如：\n\n```\n0x100001620\t0x000003C3\t__TEXT\t__text\n```\n\n\\_\\_text这个Section的偏移地址是0x100001620，这块的大小是0x000003C3，也就是963个字节。\n\n#### Symbols\niOS开发的同学对Symbols这个单词肯定不陌生，什么Crash要有对应的符号表，编译的时候经常保持找不到Symbols等。Symbols简单来说就是类名，变量名，方法名等等符号。所以这一块也详细列出了这个安装包内各个方法所占的内存大小。\n\n```\n# Address\tSize    \tFile  Name\n0x100001620\t0x00000040\t[  2] -[ViewController viewDidLoad]\n0x100001660\t0x00000040\t[  2] -[ViewController didReceiveMemoryWarning]\n0x1000016A0\t0x00000010\t[  2] -[ViewController unusedMethod1]\n...\n```\n\n这一块太多了，我只列出一小部分，这块同样有四列，一二列和Sections的情况一样，分别是偏移地址和大小。第四列是方法的符号，类名+方法名。第三列是文件序号，这个序号是哪里来的的，就是前面提到的Object files里文件的序号，比如这里viewDidLoad的序号是2，去Object files去找序号是2的文件。\n\n```\n[  2] /tmp/xcode/TestCleanPackage-gjpgqvilgwaxwyfhkccvcfzwbtdf/Build/Intermediates.noindex/TestCleanPackage.build/Debug-iphonesimulator/TestCleanPackage.build/Objects-normal/x86_64/ViewController.o\n```\n\n也就是说这个方法来自ViewController.o这个文件。\n\n通过这种对应关系，我可以知道一个.o文件里有多少方法被编译进了安装包，每个方法所占的体积，加起来我就知道每个.o文件的大小了。后面的程序也就是把这个过程给自动化了。\n\n#### Dead Stripped Symbols\n最后还有一部分是没用的符号，这部分我也不知道是怎么产生的，但可以肯定的是这部分不应该太大。\n\n```\n# Dead Stripped Symbols:\n#        \tSize    \tFile  Name\n<<dead>> \t0x00000018\t[  2] CIE\n<<dead>> \t0x00000018\t[  3] CIE\n<<dead>> \t0x00000006\t[  5] literal string: class\n<<dead>> \t0x00000008\t[  5] literal string: v16@0:8\n<<dead>> \t0x00000018\t[  5] CIE\n```\n\n## 3.自动分析\n通过前面对LinkMap文件格式的解析，我们知道在LinkMap里，我们可以知道每个文件所占的体积大小，并且可以通过文件的前缀，知道文件所属的动态库，这样也就可以知道动态库的大小。只是这个过程太过繁琐，所以我们去把它自动化了。\n\n项目开源在：\n\n[LinkMapParser](https://github.com/zgzczzw/LinkMapParser)\n\n#### 使用方法\n##### 3.1 安装Python环境\nLinkMapParser是一个Python脚本，运行该脚本需要开发者的机器有Python的运行环境，安装Python的方法可以查阅相关资料。Python版本为2.7。\n\n##### 3.2 生成link map文件\nXcode默认是不生成link map文件的。生成link map文件需修改项目中的Build Settings，选择Target的Build Settings，修改Write Link Map File为Yes，修改Path to Link Map File为你需要的地址，然后编译程序，即可在该地址生成相应的link map文件。\n\n##### 3.3 运行工具\n该工具支持分析一个link map文件和比较两个link map文件，运行的命令分别为：\n\n###### 分析一个link map文件\n\n```\npython parselinkmap.py $map_link_file_path\n```\n输出结果类似于：\n\n```\n================================================================================\n        demoData/TestCleanPackage-LinkMap-normal-x86_64.txt各模块体积汇总\n================================================================================\nCreating Result File : demoData/BaseLinkMapResult.txt\nAppDelegate.o                                     0.01M\nViewController.o                                  0.00M\nTestCleanPackage.app.xcent                        0.00M\nUnUsedClass.o                                     0.00M\nmain.o                                            0.00M\nlibobjc.tbd                                       0.00M\nlinker synthesized                                0.00M\nFoundation.tbd                                    0.00M\nUIKit.tbd                                         0.00M\n总体积:                                           0.01M\n```\n\ndemo中只有一个Bundle，可以看出各个class文件在安装包中所占大小，如AppDelegate占用0.01M。\n\n比较两个link map文件\n\n```\npython parselinkmap.py $base_map_link_file_path $target_map_link_file_path\n```\n\nLinkMapParser会分析两个map link文件，然后比较各个模块的体积是否有变化，最后列出体积变大的模块。\n\n输出结果类似于：\n\n```\n================================================================================\n                     demoData/BaseLinkMap.txt各模块体积汇总\n================================================================================\nCreating Result File : demoData/BaseLinkMapResult.txt\nAppDelegate.o                                     0.01M\nViewController.o                                  0.00M\nTestCleanPackage.app.xcent                        0.00M\nUnUsedClass.o                                     0.00M\nmain.o                                            0.00M\nlibobjc.tbd                                       0.00M\nlinker synthesized                                0.00M\nFoundation.tbd                                    0.00M\nUIKit.tbd                                         0.00M\n总体积:                                           0.01M\n\n\n\n\n\n\n================================================================================\n                    demoData/TargetLinkMap.txt各模块体积汇总\n================================================================================\nCreating Result File : demoData/TargetLinkMapResult.txt\nAppDelegate.o                                     0.64M\nViewController.o                                  0.00M\nTestCleanPackage.app.xcent                        0.00M\nUnUsedClass.o                                     0.00M\nmain.o                                            0.00M\nlibobjc.tbd                                       0.00M\nlinker synthesized                                0.00M\nFoundation.tbd                                    0.00M\nUIKit.tbd                                         0.00M\n总体积:                                           0.64M\n\n\n\n\n\n\n================================================================================\n                                    比较结果\n================================================================================\n模块名称                                          基线大小  目标大小  是否新模块\nAppDelegate.o                                     0.01M     0.64M\n```\n\n好的，LinkMap就介绍到这里。\n\n广告时间，大家喜欢我的文章，可以关注我的博客[zwgeek.com](zwgeek.com)\n\n\n","slug":"基于LinkMap分析iOSAPP各模块体积","published":1,"updated":"2024-06-14T09:25:33.678Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clxjsxtw6000wlq6gf6kg48vd","content":"<p>广告时间，大家喜欢我的文章，可以关注我的博客<a href=\"zwgeek.com\">zwgeek.com</a></p>\n<h2 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1. 前言\"></a>1. 前言</h2><p>做客户端开发经常会有需要分析客户端体积的需求。比如引入了一个第三方库，这个库到底多大呢？同时，有些动态库封装了所有架构（比如x86_64,arm）的代码，但编译的时候实际打到安装包里的只有当前架构的那部分，那么这部分体积是多少呢？有时候一个模块写了很多方法，但是这些方法都没有被调用到，编译的时候实际打进安装包里的代码又有多少呢？只有真正了解了自己的安装包体积是有哪些部分构成的，才能有针对性的去优化体积。像Android的话，简单一点可以解压开apk文件去看每个模块，或者引入的Library的大小。但是iOS的安装包是个二进制文件，这又怎么去分析呢。这篇文章给大家讲下使用Xcode提供的LinkMap文件去分析iOS安装包的体积构成，同时提供一个python的脚本，去自动化的分析iOS安装包体积。</p>\n<p>关于LinkMap的分析，也是在Bang神的指点下才知道的，所以特别鸣谢下Bang的文章<a href=\"http://blog.cnbang.net/tech/2296/\" target=\"_blank\" rel=\"external\">传送门：iOS APP可执行文件的组成</a>，这篇文章跟Bang的讲的都差不多，我就是记一下自己的理解。</p>\n<h2 id=\"2-LinkMap详解\"><a href=\"#2-LinkMap详解\" class=\"headerlink\" title=\"2. LinkMap详解\"></a>2. LinkMap详解</h2><p>LinkMap，顾名思义，指的就是iOS安装包的一张地图，通过这张地图，你可以看到安装包里各个部分都是什么内容。通过分析各部分内容所占的内存空间，就可以知道各部分内容的体积大小了。</p>\n<h3 id=\"2-1-生成LinkMap\"><a href=\"#2-1-生成LinkMap\" class=\"headerlink\" title=\"2.1 生成LinkMap\"></a>2.1 生成LinkMap</h3><p>首先，我们要生成LinkMap，这是Xcode提供的功能，默认是不生成的，需要更改一下配置，才会去生成。需要更改的地方有两个。</p>\n<p>在Target的Build Settings中更改Write Link Map File 为 Yes，这样就可以生成Link Map文件了，但是这个文件在哪呢。通过修改Build Settings的Path To Link Map可以指定LinkMap文件的生成目录，默认是生成在Build文件加下，也可以像我这样指定直接生成在桌面上。</p>\n<p><img src=\"https://img-blog.csdn.net/2018040817355259?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pnemN6enc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"这里写图片描述\"></p>\n<p><img src=\"https://img-blog.csdn.net/20180408173810292?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pnemN6enc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"这里写图片描述\"></p>\n<p>修改完以上两个配置后，就可以重新Build程序了，没有什么意外的话，你指定的路径下应该已经有LinkMap文件了。接下来我们看看LinkMap文件的格式。</p>\n<h3 id=\"2-2-LinkMap文件格式\"><a href=\"#2-2-LinkMap文件格式\" class=\"headerlink\" title=\"2.2 LinkMap文件格式\"></a>2.2 LinkMap文件格式</h3><p>我这边的demo是个比较简单的Hello world程序，所以生成的LinkMap很小，不过稍微复杂一点的程序，LinkMap就会很大了。下面说下文件格式。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"># Path</div><div class=\"line\"># Arch: x86_64</div><div class=\"line\"># Object files:</div><div class=\"line\"># Sections:</div><div class=\"line\"># Symbols:</div><div class=\"line\"># Dead Stripped Symbols:</div></pre></td></tr></table></figure>\n<p>一个完整的LinkMap文件是分为这几块的，以#为分隔，我们一个个看下。</p>\n<h4 id=\"Path\"><a href=\"#Path\" class=\"headerlink\" title=\"Path\"></a>Path</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"># Path: /tmp/xcode/TestCleanPackage-gjpgqvilgwaxwyfhkccvcfzwbtdf/Build/Products/Debug-iphonesimulator/TestCleanPackage.app/TestCleanPackage</div></pre></td></tr></table></figure>\n<p>Path记录的是这个LinkMap对应的安装包的地址。</p>\n<h4 id=\"Arch\"><a href=\"#Arch\" class=\"headerlink\" title=\"Arch\"></a>Arch</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"># Arch: x86_64</div></pre></td></tr></table></figure>\n<p>Arch指的是这个LinkMap对应的架构</p>\n<h4 id=\"Object-files\"><a href=\"#Object-files\" class=\"headerlink\" title=\"Object files\"></a>Object files</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"># Object files:</div><div class=\"line\">[  0] linker synthesized</div><div class=\"line\">[  1] /tmp/xcode/TestCleanPackage-gjpgqvilgwaxwyfhkccvcfzwbtdf/Build/Intermediates.noindex/TestCleanPackage.build/Debug-iphonesimulator/TestCleanPackage.build/TestCleanPackage.app.xcent</div><div class=\"line\">[  2] /tmp/xcode/TestCleanPackage-gjpgqvilgwaxwyfhkccvcfzwbtdf/Build/Intermediates.noindex/TestCleanPackage.build/Debug-iphonesimulator/TestCleanPackage.build/Objects-normal/x86_64/ViewController.o</div><div class=\"line\">[  3] /tmp/xcode/TestCleanPackage-gjpgqvilgwaxwyfhkccvcfzwbtdf/Build/Intermediates.noindex/TestCleanPackage.build/Debug-iphonesimulator/TestCleanPackage.build/Objects-normal/x86_64/main.o</div><div class=\"line\">[  4] /tmp/xcode/TestCleanPackage-gjpgqvilgwaxwyfhkccvcfzwbtdf/Build/Intermediates.noindex/TestCleanPackage.build/Debug-iphonesimulator/TestCleanPackage.build/Objects-normal/x86_64/UnUsedClass.o</div><div class=\"line\">[  5] /tmp/xcode/TestCleanPackage-gjpgqvilgwaxwyfhkccvcfzwbtdf/Build/Intermediates.noindex/TestCleanPackage.build/Debug-iphonesimulator/TestCleanPackage.build/Objects-normal/x86_64/AppDelegate.o</div><div class=\"line\">[  6] /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator11.1.sdk/System/Library/Frameworks//Foundation.framework/Foundation.tbd</div><div class=\"line\">[  7] /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator11.1.sdk/usr/lib/libobjc.tbd</div><div class=\"line\">[  8] /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator11.1.sdk/System/Library/Frameworks//UIKit.framework/UIKit.tbd</div></pre></td></tr></table></figure>\n<p>Object files是编译后生成的文件列表，比如这个程序class都编译成了.o文件，像我们比较熟悉的AppDelegate.o文件等等。还有引进来的几个库，比如UIKit.tbd。</p>\n<h4 id=\"Sections\"><a href=\"#Sections\" class=\"headerlink\" title=\"Sections\"></a>Sections</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"># Sections:</div><div class=\"line\"># Address\tSize    \tSegment\tSection</div><div class=\"line\">0x100001620\t0x000003C3\t__TEXT\t__text</div><div class=\"line\">0x1000019E4\t0x00000036\t__TEXT\t__stubs</div><div class=\"line\">0x100001A1C\t0x0000006A\t__TEXT\t__stub_helper</div><div class=\"line\">0x100001A86\t0x00000A69\t__TEXT\t__objc_methname</div><div class=\"line\">0x1000024EF\t0x00000048\t__TEXT\t__objc_classname</div><div class=\"line\">0x100002537\t0x0000086D\t__TEXT\t__objc_methtype</div><div class=\"line\">0x100002DA4\t0x0000007A\t__TEXT\t__cstring</div><div class=\"line\">0x100002E1E\t0x0000018C\t__TEXT\t__entitlements</div><div class=\"line\">0x100002FAC\t0x00000048\t__TEXT\t__unwind_info</div><div class=\"line\">0x100003000\t0x00000010\t__DATA\t__nl_symbol_ptr</div><div class=\"line\">0x100003010\t0x00000048\t__DATA\t__la_symbol_ptr</div><div class=\"line\">0x100003058\t0x00000018\t__DATA\t__objc_classlist</div><div class=\"line\">0x100003070\t0x00000010\t__DATA\t__objc_protolist</div><div class=\"line\">0x100003080\t0x00000008\t__DATA\t__objc_imageinfo</div><div class=\"line\">0x100003088\t0x00000CD8\t__DATA\t__objc_const</div><div class=\"line\">0x100003D60\t0x00000020\t__DATA\t__objc_selrefs</div><div class=\"line\">0x100003D80\t0x00000008\t__DATA\t__objc_classrefs</div><div class=\"line\">0x100003D88\t0x00000008\t__DATA\t__objc_superrefs</div><div class=\"line\">0x100003D90\t0x00000008\t__DATA\t__objc_ivar</div><div class=\"line\">0x100003D98\t0x000000F0\t__DATA\t__objc_data</div><div class=\"line\">0x100003E88\t0x000000C0\t__DATA\t__data</div></pre></td></tr></table></figure>\n<p>Section是各种数据类型所在的内存空间，Section主要分为两大类，__Text和__DATA。__Text指的是程序代码，__DATA指的是已经初始化的变量等。<br>具体分类如下表所示。</p>\n<blockquote>\n<p>以下是__TEXT段的section</p>\n<p>__text  主程序代码</p>\n<p><strong>stubs 和</strong>stub_helper   用于动态链接库的stub</p>\n<p>__cstring    c语言字符串</p>\n<p>__const    const修饰的常量</p>\n<p>__objc_methname    objc的方法名称</p>\n<p>__objc_methtype    objc方法类型</p>\n<p>__objc_classname    objc类方法</p>\n<p>以下是__DATA段的section</p>\n<p>__objc_ivars   objc类的实例变量</p>\n<p>__objc_classlist    objc类列表</p>\n<p>__objc_protolist    objc协议列表</p>\n<p>__objc_imageinfo    objc镜像信息</p>\n<p>__objc_const    objc常量</p>\n<p>__objc_selfrefs    objc自引用(self)</p>\n<p>__objc_protorefs    objc协议引用</p>\n<p>__objc_superrefs    objc超类引用</p>\n<p>__cfstring   使用Core Foundation字符串</p>\n<p>__bss   BSS</p>\n</blockquote>\n<p>每个Section前面的两个16进制的数字代表的就是这个Section相对于安装包初始内存的偏移和这个Section的大小。比如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">0x100001620\t0x000003C3\t__TEXT\t__text</div></pre></td></tr></table></figure>\n<p>__text这个Section的偏移地址是0x100001620，这块的大小是0x000003C3，也就是963个字节。</p>\n<h4 id=\"Symbols\"><a href=\"#Symbols\" class=\"headerlink\" title=\"Symbols\"></a>Symbols</h4><p>iOS开发的同学对Symbols这个单词肯定不陌生，什么Crash要有对应的符号表，编译的时候经常保持找不到Symbols等。Symbols简单来说就是类名，变量名，方法名等等符号。所以这一块也详细列出了这个安装包内各个方法所占的内存大小。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"># Address\tSize    \tFile  Name</div><div class=\"line\">0x100001620\t0x00000040\t[  2] -[ViewController viewDidLoad]</div><div class=\"line\">0x100001660\t0x00000040\t[  2] -[ViewController didReceiveMemoryWarning]</div><div class=\"line\">0x1000016A0\t0x00000010\t[  2] -[ViewController unusedMethod1]</div><div class=\"line\">...</div></pre></td></tr></table></figure>\n<p>这一块太多了，我只列出一小部分，这块同样有四列，一二列和Sections的情况一样，分别是偏移地址和大小。第四列是方法的符号，类名+方法名。第三列是文件序号，这个序号是哪里来的的，就是前面提到的Object files里文件的序号，比如这里viewDidLoad的序号是2，去Object files去找序号是2的文件。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[  2] /tmp/xcode/TestCleanPackage-gjpgqvilgwaxwyfhkccvcfzwbtdf/Build/Intermediates.noindex/TestCleanPackage.build/Debug-iphonesimulator/TestCleanPackage.build/Objects-normal/x86_64/ViewController.o</div></pre></td></tr></table></figure>\n<p>也就是说这个方法来自ViewController.o这个文件。</p>\n<p>通过这种对应关系，我可以知道一个.o文件里有多少方法被编译进了安装包，每个方法所占的体积，加起来我就知道每个.o文件的大小了。后面的程序也就是把这个过程给自动化了。</p>\n<h4 id=\"Dead-Stripped-Symbols\"><a href=\"#Dead-Stripped-Symbols\" class=\"headerlink\" title=\"Dead Stripped Symbols\"></a>Dead Stripped Symbols</h4><p>最后还有一部分是没用的符号，这部分我也不知道是怎么产生的，但可以肯定的是这部分不应该太大。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"># Dead Stripped Symbols:</div><div class=\"line\">#        \tSize    \tFile  Name</div><div class=\"line\">&lt;&lt;dead&gt;&gt; \t0x00000018\t[  2] CIE</div><div class=\"line\">&lt;&lt;dead&gt;&gt; \t0x00000018\t[  3] CIE</div><div class=\"line\">&lt;&lt;dead&gt;&gt; \t0x00000006\t[  5] literal string: class</div><div class=\"line\">&lt;&lt;dead&gt;&gt; \t0x00000008\t[  5] literal string: v16@0:8</div><div class=\"line\">&lt;&lt;dead&gt;&gt; \t0x00000018\t[  5] CIE</div></pre></td></tr></table></figure>\n<h2 id=\"3-自动分析\"><a href=\"#3-自动分析\" class=\"headerlink\" title=\"3.自动分析\"></a>3.自动分析</h2><p>通过前面对LinkMap文件格式的解析，我们知道在LinkMap里，我们可以知道每个文件所占的体积大小，并且可以通过文件的前缀，知道文件所属的动态库，这样也就可以知道动态库的大小。只是这个过程太过繁琐，所以我们去把它自动化了。</p>\n<p>项目开源在：</p>\n<p><a href=\"https://github.com/zgzczzw/LinkMapParser\" target=\"_blank\" rel=\"external\">LinkMapParser</a></p>\n<h4 id=\"使用方法\"><a href=\"#使用方法\" class=\"headerlink\" title=\"使用方法\"></a>使用方法</h4><h5 id=\"3-1-安装Python环境\"><a href=\"#3-1-安装Python环境\" class=\"headerlink\" title=\"3.1 安装Python环境\"></a>3.1 安装Python环境</h5><p>LinkMapParser是一个Python脚本，运行该脚本需要开发者的机器有Python的运行环境，安装Python的方法可以查阅相关资料。Python版本为2.7。</p>\n<h5 id=\"3-2-生成link-map文件\"><a href=\"#3-2-生成link-map文件\" class=\"headerlink\" title=\"3.2 生成link map文件\"></a>3.2 生成link map文件</h5><p>Xcode默认是不生成link map文件的。生成link map文件需修改项目中的Build Settings，选择Target的Build Settings，修改Write Link Map File为Yes，修改Path to Link Map File为你需要的地址，然后编译程序，即可在该地址生成相应的link map文件。</p>\n<h5 id=\"3-3-运行工具\"><a href=\"#3-3-运行工具\" class=\"headerlink\" title=\"3.3 运行工具\"></a>3.3 运行工具</h5><p>该工具支持分析一个link map文件和比较两个link map文件，运行的命令分别为：</p>\n<h6 id=\"分析一个link-map文件\"><a href=\"#分析一个link-map文件\" class=\"headerlink\" title=\"分析一个link map文件\"></a>分析一个link map文件</h6><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">python parselinkmap.py $map_link_file_path</div></pre></td></tr></table></figure>\n<p>输出结果类似于：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">================================================================================</div><div class=\"line\">        demoData/TestCleanPackage-LinkMap-normal-x86_64.txt各模块体积汇总</div><div class=\"line\">================================================================================</div><div class=\"line\">Creating Result File : demoData/BaseLinkMapResult.txt</div><div class=\"line\">AppDelegate.o                                     0.01M</div><div class=\"line\">ViewController.o                                  0.00M</div><div class=\"line\">TestCleanPackage.app.xcent                        0.00M</div><div class=\"line\">UnUsedClass.o                                     0.00M</div><div class=\"line\">main.o                                            0.00M</div><div class=\"line\">libobjc.tbd                                       0.00M</div><div class=\"line\">linker synthesized                                0.00M</div><div class=\"line\">Foundation.tbd                                    0.00M</div><div class=\"line\">UIKit.tbd                                         0.00M</div><div class=\"line\">总体积:                                           0.01M</div></pre></td></tr></table></figure>\n<p>demo中只有一个Bundle，可以看出各个class文件在安装包中所占大小，如AppDelegate占用0.01M。</p>\n<p>比较两个link map文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">python parselinkmap.py $base_map_link_file_path $target_map_link_file_path</div></pre></td></tr></table></figure>\n<p>LinkMapParser会分析两个map link文件，然后比较各个模块的体积是否有变化，最后列出体积变大的模块。</p>\n<p>输出结果类似于：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div></pre></td><td class=\"code\"><pre><div class=\"line\">================================================================================</div><div class=\"line\">                     demoData/BaseLinkMap.txt各模块体积汇总</div><div class=\"line\">================================================================================</div><div class=\"line\">Creating Result File : demoData/BaseLinkMapResult.txt</div><div class=\"line\">AppDelegate.o                                     0.01M</div><div class=\"line\">ViewController.o                                  0.00M</div><div class=\"line\">TestCleanPackage.app.xcent                        0.00M</div><div class=\"line\">UnUsedClass.o                                     0.00M</div><div class=\"line\">main.o                                            0.00M</div><div class=\"line\">libobjc.tbd                                       0.00M</div><div class=\"line\">linker synthesized                                0.00M</div><div class=\"line\">Foundation.tbd                                    0.00M</div><div class=\"line\">UIKit.tbd                                         0.00M</div><div class=\"line\">总体积:                                           0.01M</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">================================================================================</div><div class=\"line\">                    demoData/TargetLinkMap.txt各模块体积汇总</div><div class=\"line\">================================================================================</div><div class=\"line\">Creating Result File : demoData/TargetLinkMapResult.txt</div><div class=\"line\">AppDelegate.o                                     0.64M</div><div class=\"line\">ViewController.o                                  0.00M</div><div class=\"line\">TestCleanPackage.app.xcent                        0.00M</div><div class=\"line\">UnUsedClass.o                                     0.00M</div><div class=\"line\">main.o                                            0.00M</div><div class=\"line\">libobjc.tbd                                       0.00M</div><div class=\"line\">linker synthesized                                0.00M</div><div class=\"line\">Foundation.tbd                                    0.00M</div><div class=\"line\">UIKit.tbd                                         0.00M</div><div class=\"line\">总体积:                                           0.64M</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">================================================================================</div><div class=\"line\">                                    比较结果</div><div class=\"line\">================================================================================</div><div class=\"line\">模块名称                                          基线大小  目标大小  是否新模块</div><div class=\"line\">AppDelegate.o                                     0.01M     0.64M</div></pre></td></tr></table></figure>\n<p>好的，LinkMap就介绍到这里。</p>\n<p>广告时间，大家喜欢我的文章，可以关注我的博客<a href=\"zwgeek.com\">zwgeek.com</a></p>\n","excerpt":"","more":"<p>广告时间，大家喜欢我的文章，可以关注我的博客<a href=\"zwgeek.com\">zwgeek.com</a></p>\n<h2 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1. 前言\"></a>1. 前言</h2><p>做客户端开发经常会有需要分析客户端体积的需求。比如引入了一个第三方库，这个库到底多大呢？同时，有些动态库封装了所有架构（比如x86_64,arm）的代码，但编译的时候实际打到安装包里的只有当前架构的那部分，那么这部分体积是多少呢？有时候一个模块写了很多方法，但是这些方法都没有被调用到，编译的时候实际打进安装包里的代码又有多少呢？只有真正了解了自己的安装包体积是有哪些部分构成的，才能有针对性的去优化体积。像Android的话，简单一点可以解压开apk文件去看每个模块，或者引入的Library的大小。但是iOS的安装包是个二进制文件，这又怎么去分析呢。这篇文章给大家讲下使用Xcode提供的LinkMap文件去分析iOS安装包的体积构成，同时提供一个python的脚本，去自动化的分析iOS安装包体积。</p>\n<p>关于LinkMap的分析，也是在Bang神的指点下才知道的，所以特别鸣谢下Bang的文章<a href=\"http://blog.cnbang.net/tech/2296/\">传送门：iOS APP可执行文件的组成</a>，这篇文章跟Bang的讲的都差不多，我就是记一下自己的理解。</p>\n<h2 id=\"2-LinkMap详解\"><a href=\"#2-LinkMap详解\" class=\"headerlink\" title=\"2. LinkMap详解\"></a>2. LinkMap详解</h2><p>LinkMap，顾名思义，指的就是iOS安装包的一张地图，通过这张地图，你可以看到安装包里各个部分都是什么内容。通过分析各部分内容所占的内存空间，就可以知道各部分内容的体积大小了。</p>\n<h3 id=\"2-1-生成LinkMap\"><a href=\"#2-1-生成LinkMap\" class=\"headerlink\" title=\"2.1 生成LinkMap\"></a>2.1 生成LinkMap</h3><p>首先，我们要生成LinkMap，这是Xcode提供的功能，默认是不生成的，需要更改一下配置，才会去生成。需要更改的地方有两个。</p>\n<p>在Target的Build Settings中更改Write Link Map File 为 Yes，这样就可以生成Link Map文件了，但是这个文件在哪呢。通过修改Build Settings的Path To Link Map可以指定LinkMap文件的生成目录，默认是生成在Build文件加下，也可以像我这样指定直接生成在桌面上。</p>\n<p><img src=\"https://img-blog.csdn.net/2018040817355259?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pnemN6enc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"这里写图片描述\"></p>\n<p><img src=\"https://img-blog.csdn.net/20180408173810292?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pnemN6enc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"这里写图片描述\"></p>\n<p>修改完以上两个配置后，就可以重新Build程序了，没有什么意外的话，你指定的路径下应该已经有LinkMap文件了。接下来我们看看LinkMap文件的格式。</p>\n<h3 id=\"2-2-LinkMap文件格式\"><a href=\"#2-2-LinkMap文件格式\" class=\"headerlink\" title=\"2.2 LinkMap文件格式\"></a>2.2 LinkMap文件格式</h3><p>我这边的demo是个比较简单的Hello world程序，所以生成的LinkMap很小，不过稍微复杂一点的程序，LinkMap就会很大了。下面说下文件格式。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"># Path</div><div class=\"line\"># Arch: x86_64</div><div class=\"line\"># Object files:</div><div class=\"line\"># Sections:</div><div class=\"line\"># Symbols:</div><div class=\"line\"># Dead Stripped Symbols:</div></pre></td></tr></table></figure>\n<p>一个完整的LinkMap文件是分为这几块的，以#为分隔，我们一个个看下。</p>\n<h4 id=\"Path\"><a href=\"#Path\" class=\"headerlink\" title=\"Path\"></a>Path</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"># Path: /tmp/xcode/TestCleanPackage-gjpgqvilgwaxwyfhkccvcfzwbtdf/Build/Products/Debug-iphonesimulator/TestCleanPackage.app/TestCleanPackage</div></pre></td></tr></table></figure>\n<p>Path记录的是这个LinkMap对应的安装包的地址。</p>\n<h4 id=\"Arch\"><a href=\"#Arch\" class=\"headerlink\" title=\"Arch\"></a>Arch</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"># Arch: x86_64</div></pre></td></tr></table></figure>\n<p>Arch指的是这个LinkMap对应的架构</p>\n<h4 id=\"Object-files\"><a href=\"#Object-files\" class=\"headerlink\" title=\"Object files\"></a>Object files</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"># Object files:</div><div class=\"line\">[  0] linker synthesized</div><div class=\"line\">[  1] /tmp/xcode/TestCleanPackage-gjpgqvilgwaxwyfhkccvcfzwbtdf/Build/Intermediates.noindex/TestCleanPackage.build/Debug-iphonesimulator/TestCleanPackage.build/TestCleanPackage.app.xcent</div><div class=\"line\">[  2] /tmp/xcode/TestCleanPackage-gjpgqvilgwaxwyfhkccvcfzwbtdf/Build/Intermediates.noindex/TestCleanPackage.build/Debug-iphonesimulator/TestCleanPackage.build/Objects-normal/x86_64/ViewController.o</div><div class=\"line\">[  3] /tmp/xcode/TestCleanPackage-gjpgqvilgwaxwyfhkccvcfzwbtdf/Build/Intermediates.noindex/TestCleanPackage.build/Debug-iphonesimulator/TestCleanPackage.build/Objects-normal/x86_64/main.o</div><div class=\"line\">[  4] /tmp/xcode/TestCleanPackage-gjpgqvilgwaxwyfhkccvcfzwbtdf/Build/Intermediates.noindex/TestCleanPackage.build/Debug-iphonesimulator/TestCleanPackage.build/Objects-normal/x86_64/UnUsedClass.o</div><div class=\"line\">[  5] /tmp/xcode/TestCleanPackage-gjpgqvilgwaxwyfhkccvcfzwbtdf/Build/Intermediates.noindex/TestCleanPackage.build/Debug-iphonesimulator/TestCleanPackage.build/Objects-normal/x86_64/AppDelegate.o</div><div class=\"line\">[  6] /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator11.1.sdk/System/Library/Frameworks//Foundation.framework/Foundation.tbd</div><div class=\"line\">[  7] /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator11.1.sdk/usr/lib/libobjc.tbd</div><div class=\"line\">[  8] /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator11.1.sdk/System/Library/Frameworks//UIKit.framework/UIKit.tbd</div></pre></td></tr></table></figure>\n<p>Object files是编译后生成的文件列表，比如这个程序class都编译成了.o文件，像我们比较熟悉的AppDelegate.o文件等等。还有引进来的几个库，比如UIKit.tbd。</p>\n<h4 id=\"Sections\"><a href=\"#Sections\" class=\"headerlink\" title=\"Sections\"></a>Sections</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"># Sections:</div><div class=\"line\"># Address\tSize    \tSegment\tSection</div><div class=\"line\">0x100001620\t0x000003C3\t__TEXT\t__text</div><div class=\"line\">0x1000019E4\t0x00000036\t__TEXT\t__stubs</div><div class=\"line\">0x100001A1C\t0x0000006A\t__TEXT\t__stub_helper</div><div class=\"line\">0x100001A86\t0x00000A69\t__TEXT\t__objc_methname</div><div class=\"line\">0x1000024EF\t0x00000048\t__TEXT\t__objc_classname</div><div class=\"line\">0x100002537\t0x0000086D\t__TEXT\t__objc_methtype</div><div class=\"line\">0x100002DA4\t0x0000007A\t__TEXT\t__cstring</div><div class=\"line\">0x100002E1E\t0x0000018C\t__TEXT\t__entitlements</div><div class=\"line\">0x100002FAC\t0x00000048\t__TEXT\t__unwind_info</div><div class=\"line\">0x100003000\t0x00000010\t__DATA\t__nl_symbol_ptr</div><div class=\"line\">0x100003010\t0x00000048\t__DATA\t__la_symbol_ptr</div><div class=\"line\">0x100003058\t0x00000018\t__DATA\t__objc_classlist</div><div class=\"line\">0x100003070\t0x00000010\t__DATA\t__objc_protolist</div><div class=\"line\">0x100003080\t0x00000008\t__DATA\t__objc_imageinfo</div><div class=\"line\">0x100003088\t0x00000CD8\t__DATA\t__objc_const</div><div class=\"line\">0x100003D60\t0x00000020\t__DATA\t__objc_selrefs</div><div class=\"line\">0x100003D80\t0x00000008\t__DATA\t__objc_classrefs</div><div class=\"line\">0x100003D88\t0x00000008\t__DATA\t__objc_superrefs</div><div class=\"line\">0x100003D90\t0x00000008\t__DATA\t__objc_ivar</div><div class=\"line\">0x100003D98\t0x000000F0\t__DATA\t__objc_data</div><div class=\"line\">0x100003E88\t0x000000C0\t__DATA\t__data</div></pre></td></tr></table></figure>\n<p>Section是各种数据类型所在的内存空间，Section主要分为两大类，__Text和__DATA。__Text指的是程序代码，__DATA指的是已经初始化的变量等。<br>具体分类如下表所示。</p>\n<blockquote>\n<p>以下是__TEXT段的section</p>\n<p>__text  主程序代码</p>\n<p><strong>stubs 和</strong>stub_helper   用于动态链接库的stub</p>\n<p>__cstring    c语言字符串</p>\n<p>__const    const修饰的常量</p>\n<p>__objc_methname    objc的方法名称</p>\n<p>__objc_methtype    objc方法类型</p>\n<p>__objc_classname    objc类方法</p>\n<p>以下是__DATA段的section</p>\n<p>__objc_ivars   objc类的实例变量</p>\n<p>__objc_classlist    objc类列表</p>\n<p>__objc_protolist    objc协议列表</p>\n<p>__objc_imageinfo    objc镜像信息</p>\n<p>__objc_const    objc常量</p>\n<p>__objc_selfrefs    objc自引用(self)</p>\n<p>__objc_protorefs    objc协议引用</p>\n<p>__objc_superrefs    objc超类引用</p>\n<p>__cfstring   使用Core Foundation字符串</p>\n<p>__bss   BSS</p>\n</blockquote>\n<p>每个Section前面的两个16进制的数字代表的就是这个Section相对于安装包初始内存的偏移和这个Section的大小。比如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">0x100001620\t0x000003C3\t__TEXT\t__text</div></pre></td></tr></table></figure>\n<p>__text这个Section的偏移地址是0x100001620，这块的大小是0x000003C3，也就是963个字节。</p>\n<h4 id=\"Symbols\"><a href=\"#Symbols\" class=\"headerlink\" title=\"Symbols\"></a>Symbols</h4><p>iOS开发的同学对Symbols这个单词肯定不陌生，什么Crash要有对应的符号表，编译的时候经常保持找不到Symbols等。Symbols简单来说就是类名，变量名，方法名等等符号。所以这一块也详细列出了这个安装包内各个方法所占的内存大小。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"># Address\tSize    \tFile  Name</div><div class=\"line\">0x100001620\t0x00000040\t[  2] -[ViewController viewDidLoad]</div><div class=\"line\">0x100001660\t0x00000040\t[  2] -[ViewController didReceiveMemoryWarning]</div><div class=\"line\">0x1000016A0\t0x00000010\t[  2] -[ViewController unusedMethod1]</div><div class=\"line\">...</div></pre></td></tr></table></figure>\n<p>这一块太多了，我只列出一小部分，这块同样有四列，一二列和Sections的情况一样，分别是偏移地址和大小。第四列是方法的符号，类名+方法名。第三列是文件序号，这个序号是哪里来的的，就是前面提到的Object files里文件的序号，比如这里viewDidLoad的序号是2，去Object files去找序号是2的文件。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[  2] /tmp/xcode/TestCleanPackage-gjpgqvilgwaxwyfhkccvcfzwbtdf/Build/Intermediates.noindex/TestCleanPackage.build/Debug-iphonesimulator/TestCleanPackage.build/Objects-normal/x86_64/ViewController.o</div></pre></td></tr></table></figure>\n<p>也就是说这个方法来自ViewController.o这个文件。</p>\n<p>通过这种对应关系，我可以知道一个.o文件里有多少方法被编译进了安装包，每个方法所占的体积，加起来我就知道每个.o文件的大小了。后面的程序也就是把这个过程给自动化了。</p>\n<h4 id=\"Dead-Stripped-Symbols\"><a href=\"#Dead-Stripped-Symbols\" class=\"headerlink\" title=\"Dead Stripped Symbols\"></a>Dead Stripped Symbols</h4><p>最后还有一部分是没用的符号，这部分我也不知道是怎么产生的，但可以肯定的是这部分不应该太大。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"># Dead Stripped Symbols:</div><div class=\"line\">#        \tSize    \tFile  Name</div><div class=\"line\">&lt;&lt;dead&gt;&gt; \t0x00000018\t[  2] CIE</div><div class=\"line\">&lt;&lt;dead&gt;&gt; \t0x00000018\t[  3] CIE</div><div class=\"line\">&lt;&lt;dead&gt;&gt; \t0x00000006\t[  5] literal string: class</div><div class=\"line\">&lt;&lt;dead&gt;&gt; \t0x00000008\t[  5] literal string: v16@0:8</div><div class=\"line\">&lt;&lt;dead&gt;&gt; \t0x00000018\t[  5] CIE</div></pre></td></tr></table></figure>\n<h2 id=\"3-自动分析\"><a href=\"#3-自动分析\" class=\"headerlink\" title=\"3.自动分析\"></a>3.自动分析</h2><p>通过前面对LinkMap文件格式的解析，我们知道在LinkMap里，我们可以知道每个文件所占的体积大小，并且可以通过文件的前缀，知道文件所属的动态库，这样也就可以知道动态库的大小。只是这个过程太过繁琐，所以我们去把它自动化了。</p>\n<p>项目开源在：</p>\n<p><a href=\"https://github.com/zgzczzw/LinkMapParser\">LinkMapParser</a></p>\n<h4 id=\"使用方法\"><a href=\"#使用方法\" class=\"headerlink\" title=\"使用方法\"></a>使用方法</h4><h5 id=\"3-1-安装Python环境\"><a href=\"#3-1-安装Python环境\" class=\"headerlink\" title=\"3.1 安装Python环境\"></a>3.1 安装Python环境</h5><p>LinkMapParser是一个Python脚本，运行该脚本需要开发者的机器有Python的运行环境，安装Python的方法可以查阅相关资料。Python版本为2.7。</p>\n<h5 id=\"3-2-生成link-map文件\"><a href=\"#3-2-生成link-map文件\" class=\"headerlink\" title=\"3.2 生成link map文件\"></a>3.2 生成link map文件</h5><p>Xcode默认是不生成link map文件的。生成link map文件需修改项目中的Build Settings，选择Target的Build Settings，修改Write Link Map File为Yes，修改Path to Link Map File为你需要的地址，然后编译程序，即可在该地址生成相应的link map文件。</p>\n<h5 id=\"3-3-运行工具\"><a href=\"#3-3-运行工具\" class=\"headerlink\" title=\"3.3 运行工具\"></a>3.3 运行工具</h5><p>该工具支持分析一个link map文件和比较两个link map文件，运行的命令分别为：</p>\n<h6 id=\"分析一个link-map文件\"><a href=\"#分析一个link-map文件\" class=\"headerlink\" title=\"分析一个link map文件\"></a>分析一个link map文件</h6><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">python parselinkmap.py $map_link_file_path</div></pre></td></tr></table></figure>\n<p>输出结果类似于：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">================================================================================</div><div class=\"line\">        demoData/TestCleanPackage-LinkMap-normal-x86_64.txt各模块体积汇总</div><div class=\"line\">================================================================================</div><div class=\"line\">Creating Result File : demoData/BaseLinkMapResult.txt</div><div class=\"line\">AppDelegate.o                                     0.01M</div><div class=\"line\">ViewController.o                                  0.00M</div><div class=\"line\">TestCleanPackage.app.xcent                        0.00M</div><div class=\"line\">UnUsedClass.o                                     0.00M</div><div class=\"line\">main.o                                            0.00M</div><div class=\"line\">libobjc.tbd                                       0.00M</div><div class=\"line\">linker synthesized                                0.00M</div><div class=\"line\">Foundation.tbd                                    0.00M</div><div class=\"line\">UIKit.tbd                                         0.00M</div><div class=\"line\">总体积:                                           0.01M</div></pre></td></tr></table></figure>\n<p>demo中只有一个Bundle，可以看出各个class文件在安装包中所占大小，如AppDelegate占用0.01M。</p>\n<p>比较两个link map文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">python parselinkmap.py $base_map_link_file_path $target_map_link_file_path</div></pre></td></tr></table></figure>\n<p>LinkMapParser会分析两个map link文件，然后比较各个模块的体积是否有变化，最后列出体积变大的模块。</p>\n<p>输出结果类似于：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div></pre></td><td class=\"code\"><pre><div class=\"line\">================================================================================</div><div class=\"line\">                     demoData/BaseLinkMap.txt各模块体积汇总</div><div class=\"line\">================================================================================</div><div class=\"line\">Creating Result File : demoData/BaseLinkMapResult.txt</div><div class=\"line\">AppDelegate.o                                     0.01M</div><div class=\"line\">ViewController.o                                  0.00M</div><div class=\"line\">TestCleanPackage.app.xcent                        0.00M</div><div class=\"line\">UnUsedClass.o                                     0.00M</div><div class=\"line\">main.o                                            0.00M</div><div class=\"line\">libobjc.tbd                                       0.00M</div><div class=\"line\">linker synthesized                                0.00M</div><div class=\"line\">Foundation.tbd                                    0.00M</div><div class=\"line\">UIKit.tbd                                         0.00M</div><div class=\"line\">总体积:                                           0.01M</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">================================================================================</div><div class=\"line\">                    demoData/TargetLinkMap.txt各模块体积汇总</div><div class=\"line\">================================================================================</div><div class=\"line\">Creating Result File : demoData/TargetLinkMapResult.txt</div><div class=\"line\">AppDelegate.o                                     0.64M</div><div class=\"line\">ViewController.o                                  0.00M</div><div class=\"line\">TestCleanPackage.app.xcent                        0.00M</div><div class=\"line\">UnUsedClass.o                                     0.00M</div><div class=\"line\">main.o                                            0.00M</div><div class=\"line\">libobjc.tbd                                       0.00M</div><div class=\"line\">linker synthesized                                0.00M</div><div class=\"line\">Foundation.tbd                                    0.00M</div><div class=\"line\">UIKit.tbd                                         0.00M</div><div class=\"line\">总体积:                                           0.64M</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">================================================================================</div><div class=\"line\">                                    比较结果</div><div class=\"line\">================================================================================</div><div class=\"line\">模块名称                                          基线大小  目标大小  是否新模块</div><div class=\"line\">AppDelegate.o                                     0.01M     0.64M</div></pre></td></tr></table></figure>\n<p>好的，LinkMap就介绍到这里。</p>\n<p>广告时间，大家喜欢我的文章，可以关注我的博客<a href=\"zwgeek.com\">zwgeek.com</a></p>\n"},{"title":"基于struts2.5.2+hibernate5.2.2+spring4.3.2搭建SSH框架","date":"2016-09-03T10:42:33.000Z","_content":"\n现在在学习后端框架，最后的目标是希望搭建一个基于spring mvc + mybatis + spring的框架，因为之前接触过SSH，所以想从SSH开始，慢慢演化，也巩固一下自己的知识。\n之前每次搭建SSH框架都要在网上查各种资料，而且我也发现各种资料基于的SSH版本都比较老，新版本就会遇到各种各样的问题，所以基于这次的搭建流程，写一下遇到的问题和解决方法。\n\n## Contents\n- [Contents](#Contents)\n- [基础需求](#基础需求)\n- [配置Struts框架](#配置Struts框架)\n- [搭建Hibernate框架](#搭建Hibernate框架)\n- [DAO设计模型](#dao)\n- [搭建Spring框架，整合Struts和Hibernate](#搭建Spring框架，整合Struts和Hibernate)\n\n## 基础需求\n\n### 下载 Eclipse J2EE版\nJ2EE版带server和maven的配置，用起来比较方便，其他也没什么区别，普通版装插件也是可以达到一样效果的\n\n### 下载tomcat \n目前Eclipse J2EE版的server只支持tomcat 8 以下版本，我试过8.5.5也不支持，所以最好下7\n\n### 安装mysql\n\n具体流程可以从网上找，这个简单\n\n创建数据库 create database test；\n\n创建表 \n```java\ncreate table user(\n userId int auto_increment,  \n userName varchar(16) not null,  \n password varchar(16) not null,  \n gender int not null,  \n primary key(userId)  \n);\n```\n\n\n## 配置Struts框架\n\n### 安装struts的jar包\n\n下载struts-2.5.2包\n\n将包下面lib目录下的以下文件拷贝到项目的WEB-INF/lib下面，当然这里要先创建一个Dynamic Web Project，这个也简单，在Eclipse中点下一步下一步下一步就可以。\n\n为什么是放在WEB-INF/lib下，而不放在项目的lib下，这是因为，web项目在发布后依赖包是去寻找WEB-INF目录下的各种包的。这里我后面遇到一个奇怪的问题，也加深了对这个配置的理解，具体什么问题以后再说。然后你把包放在WEB-INF/lib下的时候，eclipse会自动拷贝一份到项目的lib下，方便编程时候的依赖。\n\n![](http://img.blog.csdn.net/20160922112818884?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n### 创建web.xml\n在WEB-INF下面创建web.xml，配置struts监听，这个web.xml其实就是整个web项目的入口，所有的配置都是从这里开始，再跳转的其他地方。格式如下\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<web-app version=\"2.5\" xmlns=\"http://java.sun.com/xml/ns/javaee\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee \n    http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\">\n    <filter>\n        <filter-name>struts2</filter-name>\n        <filter-class>\n           org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter\n        </filter-class>\n    </filter>\n \t<filter-mapping>\n  \t\t<filter-name>struts2</filter-name>\n  \t\t<url-pattern>/*</url-pattern>\n  \t\t<!--注意：千万不能写成：*.action ，如果需要：*.action应该配置在struts.xml中-->\n \t</filter-mapping>\n \n    <welcome-file-list>\n    <welcome-file>index.jsp</welcome-file>\n    </welcome-file-list>\n</web-app>\n```\n\n其实熟悉j2ee的人知道，在struts之前，j2ee最基本的跳转是用servlet来做的，struts其实也要基于servlet来做，配置一个filter，name随意。然后在filter-mapping里配置满足一定条件的url请求都交给这个filter来处理，其实也就是struts来处理。这里我们配置为/*，也就是所有的请求都转发给struts处理，这是最简单的，如果需要特殊配置可以在这里再配置。\n\n另外也要注意/* 和 /的区别，按照我个人的理解/*是所有的请求，包括/test.jsp和/test.html这种带后缀名的请求。/是不带后缀名的所有请求，像/test这样的。\n\n\n### 创建struts.xml\n\n然后所有的请求都给struts处理了，struts本身肯定还需要一个配置文件，来转发各种请求到相应的处理类，这个配置文件是struts.xml，放在src文件夹下，前面说过，web项目的配置文件都是在web-inf下面，为什么这个放在src文件夹下呢，这里就要说到一个eclipse发布映射的问题。\n\n你项目里点右键，选属性，选Deployment Assembly，可以看到这是发包时候的映射关系，src文件夹会发布到WEB-INF/classes，而struts会默认到这个文件夹下面找配置文件。\n\n![](http://img.blog.csdn.net/20160922122622832?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n回到正题，说一下struts的配置文件，格式如下\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE struts PUBLIC \"-//Apache Software Foundation//DTD Struts Configuration 2.0//EN\" \"http://struts.apache.org/dtds/struts-2.0.dtd\" >  \n<struts>  \n    <package  name =\"user_curd\"  extends =\"struts-default\"  >  \n        <global-results>  \n            <!--  下面定义的结果对所有的Action都有效  -->  \n            <result  name =\"exception\"> /error.jsp </result>  \n        </global-results>  \n  \n        <global-exception-mappings>  \n            <!--  指Action抛出Exception异常时，转入名为exception的结果。  -->  \n            <exception-mapping  exception =\"java.lang.Exception\"  result =\"exception\" />  \n        </global-exception-mappings>  \n  \n        <action  name =\"test\"  class =\"TestAction\">  \n        </action>  \n    </package>    \n</struts> \n```\n\n配置文件很好懂，下面的action部分就是请求转发，url中对\\test的请求会转发到TestAction中处理\n\n### 创建Action类\n创建Action处理类，前面也说过了，请求会转发到某个类中进行处理，很显然，我们需要定义这样的类\n在src中创建相应的类\n\n```java\npackage com.helloworld.test;\n\nimport java.io.PrintWriter;\nimport java.util.Date;\n\nimport org.apache.struts2.ServletActionContext;\n\nimport com.opensymphony.xwork2.ActionSupport;\n\npublic class TestAction extends ActionSupport\n{\n\tprivate String contentType = \"text/html;charset=utf-8\";     \n\tpublic String execute() throws Exception\n\t{\n\t\t//指定输出内容类型和编码  \n        ServletActionContext.getResponse().setContentType(contentType);   \n        //获取输出流，然后使用  \n        PrintWriter out = ServletActionContext.getResponse().getWriter();   \n        try{  \n            //输出文本信息  \n            out.print(\"Hello World\");  \n            out.print(\"Time: \" + (new Date()).getTime());   \n            out.flush();  \n            out.close();  \n        }catch(Exception ex){  \n            out.println(ex.toString());  \n        }\n\t\treturn SUCCESS;  \n\t}\n}\n```\n\nexecute方法就是处理请求的方法，具体的使用可以再查相关资料，本文只介绍搭建框架\n\n### 发包运行\n此时访问test应该会跳转到该类，然后输出信息\n\n### 配置Struts时遇到的问题：\n#### 问题1\njava.lang.ClassNotFoundException: org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter\n最新的Struts框架处理类的包名变了，其实碰到这类问题，自己去lib中看下类所在的位置就可以，每次版本更新可能会变一些东西\n\n![](http://img.blog.csdn.net/20160922123903227?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n#### 错误2\njava.util.concurrent.ExecutionException: org.apache.catalina.LifecycleException: Failed to start component [StandardEngine[Catalina].StandardHost[localhost].StandardContext[/helloworld]]\n\n这是因为lib包多了或少了，参照我前面lib库的文件，检查一下\n\n#### 错误3\nUnable to load configuration. - bean - jar:file:/Users/zzw/Documents/j2eeworkspace/.metadata/.plugins/org.eclipse.wst.server.core/tmp0/wtpwebapps/helloworld/WEB-INF/lib/struts2-gxp-plugin-2.5.2.jar!/struts-plugin.xml:8:162\n\n和上个问题一样，这是因为引用包多了，其实不要觉得我把所有包都放进了就行了，如果包多了会做一些初始化的工作，而初始化的过程中就容易有问题\n\n访问http://localhost:8080/helloworld/test成功\n\n## 搭建Hibernate框架\n\nStruts到目前为止就算成功了，接下来我们看引入Hibernate框架\n\n### 官网下载hibernate 5.2.2\n### 下载JDBC\n\nhttp://www.mysql.com/products/connector/ 下载jdbc\n\n### 配置Hibernate的Jar包\n拷贝lib\\required下的jar包到WEB-INFO\\lib目录下，Hibernate就很好，把所有需要的包都放在了required文件夹下\n\n### 创建hibernate.cfg.xml\n创建hibernate的配置文件hibernate.cfg.xml，配置数据库连接等等，也是在src目录下，格式如下\n\n```xml\n<!DOCTYPE hibernate-configuration PUBLIC\n\t\"-//Hibernate/Hibernate Configuration DTD 3.0//EN\"\n\t\"http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd\">\n\n<hibernate-configuration>\n\t<session-factory>\n\t\t<property name=\"hibernate.connection.driver_class\">com.mysql.jdbc.Driver</property>\n\t\t<property name=\"hibernate.connection.url\">jdbc:mysql://localhost:3306/User</property>\n\t\t<property name=\"hibernate.connection.username\">root</property>\n\t\t<property name=\"hibernate.connection.password\">123</property>\n\t\t<property name=\"hibernate.dialect\">org.hibernate.dialect.MySQLDialect</property>\n\t</session-factory>\n</hibernate-configuration>\n```\n\n这是最简单的配置，连接数据库的\n\n### 创建实体类\n\n我们都知道hibernate是实体-关系映射，所以要创建实体类\n\n```java\npackage com.helloworld.test;\n\npublic class User {\n\tprivate int userId;\n\n\tprivate String userName;\n\n\tprivate String passWord;\n\n\tprivate int gender;\n\n\tpublic int getUserId() {\n\t\treturn userId;\n\t}\n\n\tpublic void setUserId(int userId) {\n\t\tthis.userId = userId;\n\t}\n\n\tpublic String getUserName() {\n\t\treturn userName;\n\t}\n\n\tpublic void setUserName(String userName) {\n\t\tthis.userName = userName;\n\t}\n\n\tpublic String getPassWord() {\n\t\treturn passWord;\n\t}\n\n\tpublic void setPassWord(String passWord) {\n\t\tthis.passWord = passWord;\n\t}\n\n\tpublic int getGender() {\n\t\treturn gender;\n\t}\n\n\tpublic void setGender(int gender) {\n\t\tthis.gender = gender;\n\t}\n\n}\n```\n就是对应数据库中一个表\n\n### 配置映射关系\n明显，这个实体类和表的映射关系也需要配置\n添加User.hbm.xml文件映射表结构\n\n```xml\n<?xml version=\"1.0\"?>\n<!DOCTYPE hibernate-mapping PUBLIC \n\t\"-//Hibernate/Hibernate Mapping DTD 3.0//EN\"\n\t\"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd\">\n<hibernate-mapping>\n\t<class name=\"com.helloworld.test.User\">\n\t\t<id name=\"userId\">\n\t\t\t<generator class=\"increment\" />\n\t\t</id>\n\t\t<property name=\"userName\" />\n\t\t<property name=\"passWord\" />\n\t\t<property name=\"gender\" />\n\t</class>\n</hibernate-mapping>\n```\n\n这个映射关系配置文件可以放在任何地方，因为下一步我们会在hibernate.xml配置文件中声明这个文件的位置，我目前是放在和User类一起的位置。\n\n### 添加映射关系\n按照上一步所说，我们需要把映射关系配置文件的路径配置到hibernate.cfg.xml中去，如下：要写清楚包名，位置，就mapping配置的那部分，如果有多个映射，依次添加\n\n```xml\n<!DOCTYPE hibernate-configuration PUBLIC\n\t\"-//Hibernate/Hibernate Configuration DTD 3.0//EN\"\n\t\"http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd\">\n\n<hibernate-configuration>\n\t<session-factory>\n\t\t<property name=\"hibernate.connection.driver_class\">com.mysql.jdbc.Driver</property>\n\t\t<property name=\"hibernate.connection.url\">jdbc:mysql://localhost:3306/test</property>\n\t\t<property name=\"hibernate.connection.username\">root</property>\n\t\t<property name=\"hibernate.connection.password\">zzw</property>\n\t\t<property name=\"hibernate.dialect\">org.hibernate.dialect.MySQLDialect</property>\n\t\t<property name=\"hibernate.show_sql\">true</property>  \n\t\t<property name=\"hibernate.format_sql\">true</property>  \n\t\t<mapping resource=\"com/helloworld/test/User.hbm.xml\"/>\n\t</session-factory>\n\t\n</hibernate-configuration>\n```\n\n\n### 测试运行\nHibernate不需要发包web项目，可以本地测试，写一个Test类\n\n```java\npackage com.helloworld.test;\n\nimport java.util.List;\n\nimport org.hibernate.Session;\nimport org.hibernate.SessionFactory;\nimport org.hibernate.cfg.Configuration;\nimport org.hibernate.query.Query;\n\npublic class HibernateTest {\n\n\tpublic static void main(String[] args) {\n\t\t//读取hibernate.cfg.xml文件  \n        Configuration cfg = new Configuration().configure();  \n          \n        //建立SessionFactory  \n        SessionFactory factory = cfg.buildSessionFactory();  \n          \n        //取得session  \n        Session session = null;  \n        try {  \n            session = factory.openSession();  \n            //开启事务  \n            session.beginTransaction();  \n            User user = new User();  \n            user.setUserName(\"zzw\"); \n            user.setPassWord(\"zzw\");  \n              \n            //保存User对象  \n            session.save(user);   \n            String hql = \"from User\";  \n            Query query = session.createQuery(hql);  \n            List<User> roles = query.list();\n            for(int i=0;i<roles.size();i++){\n            \tSystem.out.print(\"从数据库加载数据的用户名为\"+roles.get(i).getUserName());  \n            }\n            //提交事务  \n            session.getTransaction().commit();  \n        }catch(Exception e) {  \n            e.printStackTrace();  \n            //回滚事务  \n            session.getTransaction().rollback();  \n        }finally {  \n            if (session != null) {  \n                if (session.isOpen()) {  \n                    //关闭session  \n                    session.close();  \n                }  \n            }  \n        }  \n\n\t}\n\n}\n```\n执行成功，这样的话Hibernate框架也算搭建完成了。\n\n## DAO设计模型\n提到Hibernate不得不提的是DAO设计模型，为了下一步Spring的配置更加清楚明了，这里我们也采用DAO的设计模型\n\n### 基础概念\n\n这里讲几个概念\nPOJO（Plain Ordinary Java Object）简单的Java对象，实际就是普通JavaBeans，是为了避免和EJB混淆所创造的简称。这里POJO其实就是User类\nDAO (Data Access Object)是一个数据访问接口，数据访问：顾名思义就是与数据库打交道。夹在业务逻辑与数据库资源中间。\n\n简单一点说，就是把数据库相关操作提到DAO中进行，与业务有关的逻辑放在Manager中，为了分层编程。举个例子来说，比如用户注册这个功能，用户注册的页面显示由RegisterAction负责，Action类中有Manager负责具体的业务，RegisterManager中有具体的业务方法register，Manager中有与数据库打交道的DAO类，RegisterManager中应该有UserDAO，负责所有对User表的操作，比如addUser，deleteUser等。这样说应该很容易理解吧，这是一种分层编程的思想，可以降低各个模块之间的耦合度，比如如果你想把用户注册改成管理员注册，只需要把UserDAO改成managerDAO就可以操作manager表了。就这样。DAO设计模式也是很推崇面向接口的编程，下面我用代码为大家讲解。\n\n### DAO类\n1，首先声明接口\n\n```java\npackage com.helloworld.dao;\n\nimport org.hibernate.HibernateException;\nimport org.hibernate.Session;\n\npublic interface BaseDao {\n\n\tpublic void saveObject(Object obj) throws HibernateException;\n\n\tpublic Session getSession();\n\n\tpublic void setSession(Session session);\n}\n```\n\n跟数据库打交道需要获取hibernate的session，所以一个简单的base接口就是几个获取session的方法\n\n\n然后我们定义HibernateSessionFactory用于在各个DAO中获取Session\n\n```java\npackage com.helloworld.daoImpl;\n\nimport org.hibernate.HibernateException;\nimport org.hibernate.Session;\nimport org.hibernate.SessionFactory;\nimport org.hibernate.boot.Metadata;\nimport org.hibernate.boot.MetadataSources;\nimport org.hibernate.boot.model.naming.ImplicitNamingStrategyJpaCompliantImpl;\nimport org.hibernate.boot.registry.StandardServiceRegistry;\nimport org.hibernate.boot.registry.StandardServiceRegistryBuilder;\nimport org.hibernate.cfg.Configuration;\nimport org.hibernate.service.ServiceRegistry;\n\npublic class HibernateSessionFactory {\n\n\tprivate static final String CFG_FILE_LOCATION = \"/Hibernate.cfg.xml\";\n\n\tprivate static final ThreadLocal<Session> threadLocal = new ThreadLocal<Session>();\n\n\tprivate static final Configuration cfg = new Configuration()\n\t\t\t.configure(CFG_FILE_LOCATION);\n\n\tprivate static ServiceRegistry registry;\n\n\tprivate static SessionFactory sessionFactory;\n\n\tpublic static Session currentSession() throws HibernateException {\n\t\tSession session = threadLocal.get();\n\n\t\tif (session == null || session.isOpen() == false) {\n\n\t\t\tif (sessionFactory == null) {\n\t\t\t\tStandardServiceRegistry standardRegistry = new StandardServiceRegistryBuilder()\n\t\t\t\t\t\t.configure().build();\n\t\t\t\tMetadata metadata = new MetadataSources(standardRegistry)\n\t\t\t\t\t\t.getMetadataBuilder()\n\t\t\t\t\t\t.applyImplicitNamingStrategy(\n\t\t\t\t\t\t\t\tImplicitNamingStrategyJpaCompliantImpl.INSTANCE)\n\t\t\t\t\t\t.build();\n\t\t\t\tsessionFactory = metadata\n\t\t\t\t\t\t.getSessionFactoryBuilder().build();\n\t\t\t}\n\n\t\t\tsession = sessionFactory.openSession();\n\t\t\tthreadLocal.set(session);\n\n\t\t}\n\n\t\treturn session;\n\t}\n\n\tpublic static void closeSession() throws HibernateException {\n\t\tSession session = threadLocal.get();\n\t\tthreadLocal.set(null);\n\t\tif (session != null) {\n\t\t\tsession.close();\n\t\t}\n\t}\n\n}\n```\n\n\n下面是跟User表打交道的UserDao\n\n```java\npackage com.helloworld.daoImpl;\n\nimport org.hibernate.HibernateException;\nimport org.hibernate.Session;\n\nimport com.helloworld.dao.BaseDao;\n\npublic class UserDao implements BaseDao{\n\tprivate Session session;  \n\tpublic UserDao(){\n\t\tsession=HiberanateSessionFactory.currentSession();\n       }  \n    @Override  \n    public Session getSession() {  \n        return session;  \n    }  \n  \n    @Override  \n    public void setSession(Session session) {  \n        this.session = session;  \n    }  \n  \n    @Override  \n    public void saveObject(Object obj) throws HibernateException {  \n        session.save(obj);  \n    }  \n}\n```\n\n### 业务逻辑类\n然后声明业务逻辑类UserManager，这里我只是举个最简单的例子,直接调用了DAO的getUsers方法，不要觉得没用，在日常事务中，我们需要在DAO方法前后做些处理，都是要在Manager中进行处理的。\n\n```java\npackage com.helloworld.manager;\n\nimport java.util.List;\n\nimport org.hibernate.HibernateException;\n\nimport com.helloworld.dao.BaseDao;\nimport com.helloworld.daoImpl.UserDao;\nimport com.helloworld.pojo.User;\n\npublic class UserManager {\n\tprivate BaseDao dao;  \n\t\n\tpublic UserManager(){\n\t\tdao = new UserDao();\n\t\tSystem.out.println(\"UserManager IN\");\n\t}\n   \n    public BaseDao getDao() {\n\t\treturn dao;\n\t}\n\n\tpublic void setDao(BaseDao dao) {\n\t\tthis.dao = dao;\n\t}\n\n\tpublic List<User> getUsers() throws HibernateException {  \n    \treturn dao.getUsers();\n    } \n}\n```\n\n这时候就可以在测试类里用manager对象进行数据库操作了。比如\n\n```java\npackage com.helloworld.test;\n\nimport java.util.List;\n\nimport org.hibernate.Session;\nimport org.hibernate.SessionFactory;\nimport org.hibernate.cfg.Configuration;\nimport org.hibernate.query.Query;\n\nimport com.helloworld.dao.BaseDao;\nimport com.helloworld.daoImpl.HibernateSessionFactory;\nimport com.helloworld.daoImpl.UserDao;\nimport com.helloworld.manager.UserManager;\nimport com.helloworld.pojo.User;\n\npublic class HibernateTest {\n\n\tpublic static void main(String[] args) {\n\t\tUserManager userManager=new UserManager();\n        userManager.getUsers()\n\n\t}\n\n}\n```\n\nDAO模型介绍到这。\n\n## 搭建Spring框架，整合Struts和Hibernate\n\n接下来用spring整合struts和hibernate\n\n前面提到的DAO设计模式，在用到的时候new 一个DAO对象进行数据库操作，这是最简单的，但是你想想这样会浪费时间，浪费内存，因为没进行一次访问都要生成一个新的对象，其实全局都可以用一个DAO对象。Spring是干嘛的，Spring有两大特性，IoC和AoP，其中IoC中的一种方式便是依赖注入，Spring全局管理一些Bean，像Session，dao都可以是bean，然后你需要的时候就给你注入，这就是依赖注入。其他的特性可以自行百度，另外Spring其实是一套门路很深的框架，不然也不会在Struts和Hibernate都渐渐退居二线的时候，它依然坚挺在第一线。有机会我准备仔细看下Spring的实现原理，与大家分享一下。\n\n总而言之，整个Spring的配置过程其实就是，配置bean，然后把bean配置到各个类中这样。\n\n### 下载4.3.2release的spring\nSpring官网改版后找了好久都没有找到直接下载Jar包的链接,下面汇总些网上提供的方法,亲测可用.\n\n直接输入地址,改相应版本即可:http://repo.springsource.org/libs-release-local/org/springframework/spring/3.2.4.RELEASE/spring-framework-3.2.4.RELEASE-dist.zip\n\n在1的方法上输入前面部分,有个树形结构可供选择:http://repo.springsource.org/libs-release-local/org/springframework/spring/\n\n同样的,,有树形结构选择需要的包下载:http://repo.spring.io/milestone/org/springframework/\n\n### 加入Spring的Jar包\n\n将Spring内libs目录下包含所有的jar包（不需要复制结尾为sources和javadoc的jar包）到项目的lib目录下。\n\n这里为了整合Struts还需要加入一个struts的包\n记得加入struts-spring-plugin的jar包，不然struts无法使用spring管理的bean对象\n\n### 创建Spring配置文件\n编写Spring的配置文件applicationContext.xml。把该文件放在WEB-INF下，跟web.xml同目录。\n\n这里我们使用C3P0来管理数据池，所以把Hibernate内lib/optional/c3p0下的c3p0-0.9.1.jar复制到lib不目下。\n\napplicationContext的配置很复杂，所有的bean都配置在里面，如下\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\txsi:schemaLocation=\"http://www.springframework.org/schema/beans\n           http://www.springframework.org/schema/beans/spring-beans-3.0.xsd\">\n\n\t<!-- 定义数据源的信息 -->\n\t<bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"\n\t\tdestroy-method=\"close\">\n\t\t<property name=\"driverClass\">\n\t\t\t<value>com.mysql.jdbc.Driver</value>\n\t\t</property>\n\t\t<property name=\"jdbcUrl\">\n\t\t\t<value>jdbc:mysql://localhost:3306/test</value>\n\t\t</property>\n\t\t<property name=\"user\">\n\t\t\t<value>root</value>\n\t\t</property>\n\t\t<property name=\"password\">\n\t\t\t<value>zzw</value>\n\t\t</property>\n\t\t<property name=\"maxPoolSize\">\n\t\t\t<value>80</value>\n\t\t</property>\n\t\t<property name=\"minPoolSize\">\n\t\t\t<value>1</value>\n\t\t</property>\n\t\t<property name=\"initialPoolSize\">\n\t\t\t<value>1</value>\n\t\t</property>\n\t\t<property name=\"maxIdleTime\">\n\t\t\t<value>20</value>\n\t\t</property>\n\t</bean>\n\n\t<!--定义Hibernate的SessionFactory -->\n\t<!-- SessionFactory使用的数据源为上面的数据源 -->\n\t<!-- 指定了Hibernate的映射文件和配置信息 -->\n\t<bean id=\"sessionFactory\"\n\t\tclass=\"org.springframework.orm.hibernate5.LocalSessionFactoryBean\">\n\t\t<property name=\"dataSource\">\n\t\t\t<ref local=\"dataSource\" />\n\t\t</property>\n\t\t<property name=\"mappingResources\">\n\t\t\t<list>\n\t\t\t\t<value>com/helloworld/pojo/User.hbm.xml</value>\n\t\t\t</list>\n\t\t</property>\n\t\t<property name=\"hibernateProperties\">\n\t\t\t<props>\n\t\t\t\t<prop key=\"hibernate.dialect\">org.hibernate.dialect.MySQLDialect</prop>\n\t\t\t\t<prop key=\"show_sql\">true</prop>\n\t\t\t\t<prop key=\"hibernate.jdbc.batch_size\">20</prop>\n\t\t\t</props>\n\t\t</property>\n\t</bean>\n\n\t<bean id=\"transactionManager\"\n\t\tclass=\"org.springframework.orm.hibernate5.HibernateTransactionManager\">\n\t\t<property name=\"sessionFactory\" ref=\"sessionFactory\" />\n\t</bean>\n\n\t<bean id=\"userDao\" class=\"com.helloworld.daoImpl.UserDao\">\n\t\t<property name=\"sessionFactory\">\n\t\t\t<ref bean=\"sessionFactory\" />\n\t\t</property>\n\t</bean>\n\n\t<!--用户注册业务逻辑类 -->\n\t<bean id=\"userManager\" class=\"com.helloworld.manager.UserManager\">\n\t\t<property name=\"dao\">\n\t\t\t<ref bean=\"userDao\" />\n\t\t</property>\n\t</bean>\n\n\t<!-- 用户注册的Action -->\n\t<bean id=\"testAction\" class=\"com.helloworld.action.TestAction\">\n\t\t<property name=\"manager\">\n\t\t\t<ref bean=\"userManager\" />\n\t\t</property>\n\t</bean>\n\n\t<!-- more bean definitions go here -->\n\n</beans>\n```\n\n从配置文件我们看出，hibernate的datasource和session的配置完全被spring接管了，所以hibernate的配置文件是可以删掉的。\n\n### 修改BaseDao和UserDao。\n\n在引入Spring后，需要用Spring进行统一的事务管理，数据源和sessionFactory都交给Spring去生成，因此接口类和实现类BaseDao和UserDao都需要做相应的修改。Spring提供了HibernateDaoSupport类来完成对数据的操作，因此UserDao在实现BaseDao的同时还需要继承HibernateDaoSupport类。并将先前session的操作修改成HibernateTemplate（可通过getHibernateTemplate（）方法来获得）的操作。\n\n```java\npackage com.helloworld.dao;\n\nimport java.util.List;\n\nimport org.hibernate.HibernateException;\nimport org.hibernate.Session;\n\nimport com.helloworld.pojo.User;\n\npublic interface BaseDao {\n\n\tpublic void saveObject(Object obj) throws HibernateException;\n\t\n\tpublic List<User> getUsers() throws HibernateException;\n}\n\n```\n\n```java\npackage com.helloworld.daoImpl;\n\nimport java.util.List;\n\nimport org.hibernate.HibernateException;\nimport org.springframework.orm.hibernate5.support.HibernateDaoSupport;\n\nimport com.helloworld.dao.BaseDao;\nimport com.helloworld.pojo.User;\n\npublic class UserDao extends HibernateDaoSupport implements BaseDao{\n\t\n\tpublic UserDao() {\n\t\tSystem.out.println(\"UserDao IN\");\n\t}\n  \n    @Override  \n    public void saveObject(Object obj) throws HibernateException {  \n    \tgetHibernateTemplate().save(obj);  \n    }  \n    \n    public List<User> getUsers() throws HibernateException{\n    \tList<User> users=getHibernateTemplate().loadAll(User.class);\n    \treturn users;\n    }\n}\n\n```\n\n其实HibernateDaoSupport也没干什么大事，就是前面说的session的set get方法，既然每个DAO都需要，那spring就提出来了呗，没什么神秘的。\n\n\n### 修改业务逻辑实现类\n\n也就是Manager的类，跟DAO一样。在没有加入Spring之前，业务逻辑实现类的Session的获得，dao的实例化，以及事务的管理都是该类执行管理的。加入Spring后，这些都交给Spring去管理。该类的dao的实例化由Spring注入。\n\n### 修改用户注册的testAction类\n\n同样，testAction类中的userManager的实例化也由Spring注入。可以仔细理解一下上面的applicationContext的配置文件，你需要某个对象，只要把该对象配置成bean，比如下面这样\n\n```xml\n<bean id=\"userManager\" class=\"com.helloworld.manager.UserManager\">\n\t\t...\n\t</bean>\n```\n\n然后用到这个bean的类配置成\n\n```xml\n<bean id=\"testAction\" class=\"com.helloworld.action.TestAction\">\n\t\t<property name=\"manager\">\n\t\t\t<ref bean=\"userManager\" />\n\t\t</property>\n\t</bean>\n```\n\n这样这个类里名字为manager的对象就会自动被注入userManager对象。记得需要有set方法，名字需对应。\n\n### 删除多余类\n\n删除Hibernate的配置文件Hibernate.cfg.xml和工厂类\nHibernateSesseionFactory类。他们的工作已经交给Spring去做，已经不再有用。\n\n### 修改web.xml\n\n加载Spring。要想启动时加载Spring的配置文件，需要在web.xml中配置对应的监听器（listenser），并指定Spring的配置文件。\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<web-app version=\"2.5\" xmlns=\"http://java.sun.com/xml/ns/javaee\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee \n    http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\">\n    \n    <listener>  \n        <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>  \n    </listener> \n    <filter>\n        <filter-name>struts2</filter-name>\n        <filter-class>\n           org.apache.struts2.dispatcher.filter.StrutsPrepareAndExecuteFilter\n        </filter-class>\n    </filter>\n \t<filter-mapping>\n  \t\t<filter-name>struts2</filter-name>\n  \t\t<url-pattern>/*</url-pattern>\n \t</filter-mapping>\n \t\n \t\n \n    <welcome-file-list>\n    <welcome-file>index.jsp</welcome-file>\n    </welcome-file-list>\n</web-app>\n```\n\n\n### 修改Struts的配置文件struts.xml\n\n把原来指定的名为register的action的class由原来的路径变为applicationContext.xml文件中该bean的id名，不需要再用具体的包名+类名。\n\n包名加类名的方式会在每次访问的时候都生成一个action对应的对象，交给spring管理后，只会在最开始的时候生成一次。如下\n\n```xml\n<action  name =\"test\"  class =\"testAction\">\n```\n\n整个项目配置之后结构如图\n\n![](http://img.blog.csdn.net/20160922132809919?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n\n在spring的配置中会遇到各种各样的问题，其他无非就是bean配置上写错了路径，类目，对象名，变量名，等等，所以仔细一点，认真检查一下，肯定能找到原因。\n\n到此为止，SSH框架已经搭建好了，但是据我所知，这套框架目前的使用率已经在降低了，有以下几个原因：\n\n1. struts除了可以做请求转发，还有页面标签，所以你如果只用请求转发的话，这个框架有点多余\n2. 现在spring推出了springMVC，是专门做请求转发用的，因为是spring自家推出的，所以和spring的协调性更好，而且在我使用中也感觉springMVC用起来更方便，轻量级\n3. HIbernate框架管理数据库很强大，但是同样的问题，重量级。目前因为移动应用的兴起，请求并发量暴增的问题，Mybatis框架对于数据库管理更轻量级，更灵活。这两个框架说不上孰优孰劣，大家可以看下资料。\n\n所以在下一篇文章中，准备先用SpringMVC代替struts。敬请期待\n","source":"_posts/基于struts2-5-2-hibernate5-2-2-spring4-3-2搭建SSH框架v2.md","raw":"---\ntitle: 基于struts2.5.2+hibernate5.2.2+spring4.3.2搭建SSH框架\ndate: 2016-09-3 18:42:33\ntags:\n  - Java Web\n  - 服务端\n  - SSH\ncategories: 服务端开发\n---\n\n现在在学习后端框架，最后的目标是希望搭建一个基于spring mvc + mybatis + spring的框架，因为之前接触过SSH，所以想从SSH开始，慢慢演化，也巩固一下自己的知识。\n之前每次搭建SSH框架都要在网上查各种资料，而且我也发现各种资料基于的SSH版本都比较老，新版本就会遇到各种各样的问题，所以基于这次的搭建流程，写一下遇到的问题和解决方法。\n\n## Contents\n- [Contents](#Contents)\n- [基础需求](#基础需求)\n- [配置Struts框架](#配置Struts框架)\n- [搭建Hibernate框架](#搭建Hibernate框架)\n- [DAO设计模型](#dao)\n- [搭建Spring框架，整合Struts和Hibernate](#搭建Spring框架，整合Struts和Hibernate)\n\n## 基础需求\n\n### 下载 Eclipse J2EE版\nJ2EE版带server和maven的配置，用起来比较方便，其他也没什么区别，普通版装插件也是可以达到一样效果的\n\n### 下载tomcat \n目前Eclipse J2EE版的server只支持tomcat 8 以下版本，我试过8.5.5也不支持，所以最好下7\n\n### 安装mysql\n\n具体流程可以从网上找，这个简单\n\n创建数据库 create database test；\n\n创建表 \n```java\ncreate table user(\n userId int auto_increment,  \n userName varchar(16) not null,  \n password varchar(16) not null,  \n gender int not null,  \n primary key(userId)  \n);\n```\n\n\n## 配置Struts框架\n\n### 安装struts的jar包\n\n下载struts-2.5.2包\n\n将包下面lib目录下的以下文件拷贝到项目的WEB-INF/lib下面，当然这里要先创建一个Dynamic Web Project，这个也简单，在Eclipse中点下一步下一步下一步就可以。\n\n为什么是放在WEB-INF/lib下，而不放在项目的lib下，这是因为，web项目在发布后依赖包是去寻找WEB-INF目录下的各种包的。这里我后面遇到一个奇怪的问题，也加深了对这个配置的理解，具体什么问题以后再说。然后你把包放在WEB-INF/lib下的时候，eclipse会自动拷贝一份到项目的lib下，方便编程时候的依赖。\n\n![](http://img.blog.csdn.net/20160922112818884?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n### 创建web.xml\n在WEB-INF下面创建web.xml，配置struts监听，这个web.xml其实就是整个web项目的入口，所有的配置都是从这里开始，再跳转的其他地方。格式如下\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<web-app version=\"2.5\" xmlns=\"http://java.sun.com/xml/ns/javaee\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee \n    http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\">\n    <filter>\n        <filter-name>struts2</filter-name>\n        <filter-class>\n           org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter\n        </filter-class>\n    </filter>\n \t<filter-mapping>\n  \t\t<filter-name>struts2</filter-name>\n  \t\t<url-pattern>/*</url-pattern>\n  \t\t<!--注意：千万不能写成：*.action ，如果需要：*.action应该配置在struts.xml中-->\n \t</filter-mapping>\n \n    <welcome-file-list>\n    <welcome-file>index.jsp</welcome-file>\n    </welcome-file-list>\n</web-app>\n```\n\n其实熟悉j2ee的人知道，在struts之前，j2ee最基本的跳转是用servlet来做的，struts其实也要基于servlet来做，配置一个filter，name随意。然后在filter-mapping里配置满足一定条件的url请求都交给这个filter来处理，其实也就是struts来处理。这里我们配置为/*，也就是所有的请求都转发给struts处理，这是最简单的，如果需要特殊配置可以在这里再配置。\n\n另外也要注意/* 和 /的区别，按照我个人的理解/*是所有的请求，包括/test.jsp和/test.html这种带后缀名的请求。/是不带后缀名的所有请求，像/test这样的。\n\n\n### 创建struts.xml\n\n然后所有的请求都给struts处理了，struts本身肯定还需要一个配置文件，来转发各种请求到相应的处理类，这个配置文件是struts.xml，放在src文件夹下，前面说过，web项目的配置文件都是在web-inf下面，为什么这个放在src文件夹下呢，这里就要说到一个eclipse发布映射的问题。\n\n你项目里点右键，选属性，选Deployment Assembly，可以看到这是发包时候的映射关系，src文件夹会发布到WEB-INF/classes，而struts会默认到这个文件夹下面找配置文件。\n\n![](http://img.blog.csdn.net/20160922122622832?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n回到正题，说一下struts的配置文件，格式如下\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE struts PUBLIC \"-//Apache Software Foundation//DTD Struts Configuration 2.0//EN\" \"http://struts.apache.org/dtds/struts-2.0.dtd\" >  \n<struts>  \n    <package  name =\"user_curd\"  extends =\"struts-default\"  >  \n        <global-results>  \n            <!--  下面定义的结果对所有的Action都有效  -->  \n            <result  name =\"exception\"> /error.jsp </result>  \n        </global-results>  \n  \n        <global-exception-mappings>  \n            <!--  指Action抛出Exception异常时，转入名为exception的结果。  -->  \n            <exception-mapping  exception =\"java.lang.Exception\"  result =\"exception\" />  \n        </global-exception-mappings>  \n  \n        <action  name =\"test\"  class =\"TestAction\">  \n        </action>  \n    </package>    \n</struts> \n```\n\n配置文件很好懂，下面的action部分就是请求转发，url中对\\test的请求会转发到TestAction中处理\n\n### 创建Action类\n创建Action处理类，前面也说过了，请求会转发到某个类中进行处理，很显然，我们需要定义这样的类\n在src中创建相应的类\n\n```java\npackage com.helloworld.test;\n\nimport java.io.PrintWriter;\nimport java.util.Date;\n\nimport org.apache.struts2.ServletActionContext;\n\nimport com.opensymphony.xwork2.ActionSupport;\n\npublic class TestAction extends ActionSupport\n{\n\tprivate String contentType = \"text/html;charset=utf-8\";     \n\tpublic String execute() throws Exception\n\t{\n\t\t//指定输出内容类型和编码  \n        ServletActionContext.getResponse().setContentType(contentType);   \n        //获取输出流，然后使用  \n        PrintWriter out = ServletActionContext.getResponse().getWriter();   \n        try{  \n            //输出文本信息  \n            out.print(\"Hello World\");  \n            out.print(\"Time: \" + (new Date()).getTime());   \n            out.flush();  \n            out.close();  \n        }catch(Exception ex){  \n            out.println(ex.toString());  \n        }\n\t\treturn SUCCESS;  \n\t}\n}\n```\n\nexecute方法就是处理请求的方法，具体的使用可以再查相关资料，本文只介绍搭建框架\n\n### 发包运行\n此时访问test应该会跳转到该类，然后输出信息\n\n### 配置Struts时遇到的问题：\n#### 问题1\njava.lang.ClassNotFoundException: org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter\n最新的Struts框架处理类的包名变了，其实碰到这类问题，自己去lib中看下类所在的位置就可以，每次版本更新可能会变一些东西\n\n![](http://img.blog.csdn.net/20160922123903227?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n#### 错误2\njava.util.concurrent.ExecutionException: org.apache.catalina.LifecycleException: Failed to start component [StandardEngine[Catalina].StandardHost[localhost].StandardContext[/helloworld]]\n\n这是因为lib包多了或少了，参照我前面lib库的文件，检查一下\n\n#### 错误3\nUnable to load configuration. - bean - jar:file:/Users/zzw/Documents/j2eeworkspace/.metadata/.plugins/org.eclipse.wst.server.core/tmp0/wtpwebapps/helloworld/WEB-INF/lib/struts2-gxp-plugin-2.5.2.jar!/struts-plugin.xml:8:162\n\n和上个问题一样，这是因为引用包多了，其实不要觉得我把所有包都放进了就行了，如果包多了会做一些初始化的工作，而初始化的过程中就容易有问题\n\n访问http://localhost:8080/helloworld/test成功\n\n## 搭建Hibernate框架\n\nStruts到目前为止就算成功了，接下来我们看引入Hibernate框架\n\n### 官网下载hibernate 5.2.2\n### 下载JDBC\n\nhttp://www.mysql.com/products/connector/ 下载jdbc\n\n### 配置Hibernate的Jar包\n拷贝lib\\required下的jar包到WEB-INFO\\lib目录下，Hibernate就很好，把所有需要的包都放在了required文件夹下\n\n### 创建hibernate.cfg.xml\n创建hibernate的配置文件hibernate.cfg.xml，配置数据库连接等等，也是在src目录下，格式如下\n\n```xml\n<!DOCTYPE hibernate-configuration PUBLIC\n\t\"-//Hibernate/Hibernate Configuration DTD 3.0//EN\"\n\t\"http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd\">\n\n<hibernate-configuration>\n\t<session-factory>\n\t\t<property name=\"hibernate.connection.driver_class\">com.mysql.jdbc.Driver</property>\n\t\t<property name=\"hibernate.connection.url\">jdbc:mysql://localhost:3306/User</property>\n\t\t<property name=\"hibernate.connection.username\">root</property>\n\t\t<property name=\"hibernate.connection.password\">123</property>\n\t\t<property name=\"hibernate.dialect\">org.hibernate.dialect.MySQLDialect</property>\n\t</session-factory>\n</hibernate-configuration>\n```\n\n这是最简单的配置，连接数据库的\n\n### 创建实体类\n\n我们都知道hibernate是实体-关系映射，所以要创建实体类\n\n```java\npackage com.helloworld.test;\n\npublic class User {\n\tprivate int userId;\n\n\tprivate String userName;\n\n\tprivate String passWord;\n\n\tprivate int gender;\n\n\tpublic int getUserId() {\n\t\treturn userId;\n\t}\n\n\tpublic void setUserId(int userId) {\n\t\tthis.userId = userId;\n\t}\n\n\tpublic String getUserName() {\n\t\treturn userName;\n\t}\n\n\tpublic void setUserName(String userName) {\n\t\tthis.userName = userName;\n\t}\n\n\tpublic String getPassWord() {\n\t\treturn passWord;\n\t}\n\n\tpublic void setPassWord(String passWord) {\n\t\tthis.passWord = passWord;\n\t}\n\n\tpublic int getGender() {\n\t\treturn gender;\n\t}\n\n\tpublic void setGender(int gender) {\n\t\tthis.gender = gender;\n\t}\n\n}\n```\n就是对应数据库中一个表\n\n### 配置映射关系\n明显，这个实体类和表的映射关系也需要配置\n添加User.hbm.xml文件映射表结构\n\n```xml\n<?xml version=\"1.0\"?>\n<!DOCTYPE hibernate-mapping PUBLIC \n\t\"-//Hibernate/Hibernate Mapping DTD 3.0//EN\"\n\t\"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd\">\n<hibernate-mapping>\n\t<class name=\"com.helloworld.test.User\">\n\t\t<id name=\"userId\">\n\t\t\t<generator class=\"increment\" />\n\t\t</id>\n\t\t<property name=\"userName\" />\n\t\t<property name=\"passWord\" />\n\t\t<property name=\"gender\" />\n\t</class>\n</hibernate-mapping>\n```\n\n这个映射关系配置文件可以放在任何地方，因为下一步我们会在hibernate.xml配置文件中声明这个文件的位置，我目前是放在和User类一起的位置。\n\n### 添加映射关系\n按照上一步所说，我们需要把映射关系配置文件的路径配置到hibernate.cfg.xml中去，如下：要写清楚包名，位置，就mapping配置的那部分，如果有多个映射，依次添加\n\n```xml\n<!DOCTYPE hibernate-configuration PUBLIC\n\t\"-//Hibernate/Hibernate Configuration DTD 3.0//EN\"\n\t\"http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd\">\n\n<hibernate-configuration>\n\t<session-factory>\n\t\t<property name=\"hibernate.connection.driver_class\">com.mysql.jdbc.Driver</property>\n\t\t<property name=\"hibernate.connection.url\">jdbc:mysql://localhost:3306/test</property>\n\t\t<property name=\"hibernate.connection.username\">root</property>\n\t\t<property name=\"hibernate.connection.password\">zzw</property>\n\t\t<property name=\"hibernate.dialect\">org.hibernate.dialect.MySQLDialect</property>\n\t\t<property name=\"hibernate.show_sql\">true</property>  \n\t\t<property name=\"hibernate.format_sql\">true</property>  \n\t\t<mapping resource=\"com/helloworld/test/User.hbm.xml\"/>\n\t</session-factory>\n\t\n</hibernate-configuration>\n```\n\n\n### 测试运行\nHibernate不需要发包web项目，可以本地测试，写一个Test类\n\n```java\npackage com.helloworld.test;\n\nimport java.util.List;\n\nimport org.hibernate.Session;\nimport org.hibernate.SessionFactory;\nimport org.hibernate.cfg.Configuration;\nimport org.hibernate.query.Query;\n\npublic class HibernateTest {\n\n\tpublic static void main(String[] args) {\n\t\t//读取hibernate.cfg.xml文件  \n        Configuration cfg = new Configuration().configure();  \n          \n        //建立SessionFactory  \n        SessionFactory factory = cfg.buildSessionFactory();  \n          \n        //取得session  \n        Session session = null;  \n        try {  \n            session = factory.openSession();  \n            //开启事务  \n            session.beginTransaction();  \n            User user = new User();  \n            user.setUserName(\"zzw\"); \n            user.setPassWord(\"zzw\");  \n              \n            //保存User对象  \n            session.save(user);   \n            String hql = \"from User\";  \n            Query query = session.createQuery(hql);  \n            List<User> roles = query.list();\n            for(int i=0;i<roles.size();i++){\n            \tSystem.out.print(\"从数据库加载数据的用户名为\"+roles.get(i).getUserName());  \n            }\n            //提交事务  \n            session.getTransaction().commit();  \n        }catch(Exception e) {  \n            e.printStackTrace();  \n            //回滚事务  \n            session.getTransaction().rollback();  \n        }finally {  \n            if (session != null) {  \n                if (session.isOpen()) {  \n                    //关闭session  \n                    session.close();  \n                }  \n            }  \n        }  \n\n\t}\n\n}\n```\n执行成功，这样的话Hibernate框架也算搭建完成了。\n\n## DAO设计模型\n提到Hibernate不得不提的是DAO设计模型，为了下一步Spring的配置更加清楚明了，这里我们也采用DAO的设计模型\n\n### 基础概念\n\n这里讲几个概念\nPOJO（Plain Ordinary Java Object）简单的Java对象，实际就是普通JavaBeans，是为了避免和EJB混淆所创造的简称。这里POJO其实就是User类\nDAO (Data Access Object)是一个数据访问接口，数据访问：顾名思义就是与数据库打交道。夹在业务逻辑与数据库资源中间。\n\n简单一点说，就是把数据库相关操作提到DAO中进行，与业务有关的逻辑放在Manager中，为了分层编程。举个例子来说，比如用户注册这个功能，用户注册的页面显示由RegisterAction负责，Action类中有Manager负责具体的业务，RegisterManager中有具体的业务方法register，Manager中有与数据库打交道的DAO类，RegisterManager中应该有UserDAO，负责所有对User表的操作，比如addUser，deleteUser等。这样说应该很容易理解吧，这是一种分层编程的思想，可以降低各个模块之间的耦合度，比如如果你想把用户注册改成管理员注册，只需要把UserDAO改成managerDAO就可以操作manager表了。就这样。DAO设计模式也是很推崇面向接口的编程，下面我用代码为大家讲解。\n\n### DAO类\n1，首先声明接口\n\n```java\npackage com.helloworld.dao;\n\nimport org.hibernate.HibernateException;\nimport org.hibernate.Session;\n\npublic interface BaseDao {\n\n\tpublic void saveObject(Object obj) throws HibernateException;\n\n\tpublic Session getSession();\n\n\tpublic void setSession(Session session);\n}\n```\n\n跟数据库打交道需要获取hibernate的session，所以一个简单的base接口就是几个获取session的方法\n\n\n然后我们定义HibernateSessionFactory用于在各个DAO中获取Session\n\n```java\npackage com.helloworld.daoImpl;\n\nimport org.hibernate.HibernateException;\nimport org.hibernate.Session;\nimport org.hibernate.SessionFactory;\nimport org.hibernate.boot.Metadata;\nimport org.hibernate.boot.MetadataSources;\nimport org.hibernate.boot.model.naming.ImplicitNamingStrategyJpaCompliantImpl;\nimport org.hibernate.boot.registry.StandardServiceRegistry;\nimport org.hibernate.boot.registry.StandardServiceRegistryBuilder;\nimport org.hibernate.cfg.Configuration;\nimport org.hibernate.service.ServiceRegistry;\n\npublic class HibernateSessionFactory {\n\n\tprivate static final String CFG_FILE_LOCATION = \"/Hibernate.cfg.xml\";\n\n\tprivate static final ThreadLocal<Session> threadLocal = new ThreadLocal<Session>();\n\n\tprivate static final Configuration cfg = new Configuration()\n\t\t\t.configure(CFG_FILE_LOCATION);\n\n\tprivate static ServiceRegistry registry;\n\n\tprivate static SessionFactory sessionFactory;\n\n\tpublic static Session currentSession() throws HibernateException {\n\t\tSession session = threadLocal.get();\n\n\t\tif (session == null || session.isOpen() == false) {\n\n\t\t\tif (sessionFactory == null) {\n\t\t\t\tStandardServiceRegistry standardRegistry = new StandardServiceRegistryBuilder()\n\t\t\t\t\t\t.configure().build();\n\t\t\t\tMetadata metadata = new MetadataSources(standardRegistry)\n\t\t\t\t\t\t.getMetadataBuilder()\n\t\t\t\t\t\t.applyImplicitNamingStrategy(\n\t\t\t\t\t\t\t\tImplicitNamingStrategyJpaCompliantImpl.INSTANCE)\n\t\t\t\t\t\t.build();\n\t\t\t\tsessionFactory = metadata\n\t\t\t\t\t\t.getSessionFactoryBuilder().build();\n\t\t\t}\n\n\t\t\tsession = sessionFactory.openSession();\n\t\t\tthreadLocal.set(session);\n\n\t\t}\n\n\t\treturn session;\n\t}\n\n\tpublic static void closeSession() throws HibernateException {\n\t\tSession session = threadLocal.get();\n\t\tthreadLocal.set(null);\n\t\tif (session != null) {\n\t\t\tsession.close();\n\t\t}\n\t}\n\n}\n```\n\n\n下面是跟User表打交道的UserDao\n\n```java\npackage com.helloworld.daoImpl;\n\nimport org.hibernate.HibernateException;\nimport org.hibernate.Session;\n\nimport com.helloworld.dao.BaseDao;\n\npublic class UserDao implements BaseDao{\n\tprivate Session session;  \n\tpublic UserDao(){\n\t\tsession=HiberanateSessionFactory.currentSession();\n       }  \n    @Override  \n    public Session getSession() {  \n        return session;  \n    }  \n  \n    @Override  \n    public void setSession(Session session) {  \n        this.session = session;  \n    }  \n  \n    @Override  \n    public void saveObject(Object obj) throws HibernateException {  \n        session.save(obj);  \n    }  \n}\n```\n\n### 业务逻辑类\n然后声明业务逻辑类UserManager，这里我只是举个最简单的例子,直接调用了DAO的getUsers方法，不要觉得没用，在日常事务中，我们需要在DAO方法前后做些处理，都是要在Manager中进行处理的。\n\n```java\npackage com.helloworld.manager;\n\nimport java.util.List;\n\nimport org.hibernate.HibernateException;\n\nimport com.helloworld.dao.BaseDao;\nimport com.helloworld.daoImpl.UserDao;\nimport com.helloworld.pojo.User;\n\npublic class UserManager {\n\tprivate BaseDao dao;  \n\t\n\tpublic UserManager(){\n\t\tdao = new UserDao();\n\t\tSystem.out.println(\"UserManager IN\");\n\t}\n   \n    public BaseDao getDao() {\n\t\treturn dao;\n\t}\n\n\tpublic void setDao(BaseDao dao) {\n\t\tthis.dao = dao;\n\t}\n\n\tpublic List<User> getUsers() throws HibernateException {  \n    \treturn dao.getUsers();\n    } \n}\n```\n\n这时候就可以在测试类里用manager对象进行数据库操作了。比如\n\n```java\npackage com.helloworld.test;\n\nimport java.util.List;\n\nimport org.hibernate.Session;\nimport org.hibernate.SessionFactory;\nimport org.hibernate.cfg.Configuration;\nimport org.hibernate.query.Query;\n\nimport com.helloworld.dao.BaseDao;\nimport com.helloworld.daoImpl.HibernateSessionFactory;\nimport com.helloworld.daoImpl.UserDao;\nimport com.helloworld.manager.UserManager;\nimport com.helloworld.pojo.User;\n\npublic class HibernateTest {\n\n\tpublic static void main(String[] args) {\n\t\tUserManager userManager=new UserManager();\n        userManager.getUsers()\n\n\t}\n\n}\n```\n\nDAO模型介绍到这。\n\n## 搭建Spring框架，整合Struts和Hibernate\n\n接下来用spring整合struts和hibernate\n\n前面提到的DAO设计模式，在用到的时候new 一个DAO对象进行数据库操作，这是最简单的，但是你想想这样会浪费时间，浪费内存，因为没进行一次访问都要生成一个新的对象，其实全局都可以用一个DAO对象。Spring是干嘛的，Spring有两大特性，IoC和AoP，其中IoC中的一种方式便是依赖注入，Spring全局管理一些Bean，像Session，dao都可以是bean，然后你需要的时候就给你注入，这就是依赖注入。其他的特性可以自行百度，另外Spring其实是一套门路很深的框架，不然也不会在Struts和Hibernate都渐渐退居二线的时候，它依然坚挺在第一线。有机会我准备仔细看下Spring的实现原理，与大家分享一下。\n\n总而言之，整个Spring的配置过程其实就是，配置bean，然后把bean配置到各个类中这样。\n\n### 下载4.3.2release的spring\nSpring官网改版后找了好久都没有找到直接下载Jar包的链接,下面汇总些网上提供的方法,亲测可用.\n\n直接输入地址,改相应版本即可:http://repo.springsource.org/libs-release-local/org/springframework/spring/3.2.4.RELEASE/spring-framework-3.2.4.RELEASE-dist.zip\n\n在1的方法上输入前面部分,有个树形结构可供选择:http://repo.springsource.org/libs-release-local/org/springframework/spring/\n\n同样的,,有树形结构选择需要的包下载:http://repo.spring.io/milestone/org/springframework/\n\n### 加入Spring的Jar包\n\n将Spring内libs目录下包含所有的jar包（不需要复制结尾为sources和javadoc的jar包）到项目的lib目录下。\n\n这里为了整合Struts还需要加入一个struts的包\n记得加入struts-spring-plugin的jar包，不然struts无法使用spring管理的bean对象\n\n### 创建Spring配置文件\n编写Spring的配置文件applicationContext.xml。把该文件放在WEB-INF下，跟web.xml同目录。\n\n这里我们使用C3P0来管理数据池，所以把Hibernate内lib/optional/c3p0下的c3p0-0.9.1.jar复制到lib不目下。\n\napplicationContext的配置很复杂，所有的bean都配置在里面，如下\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\txsi:schemaLocation=\"http://www.springframework.org/schema/beans\n           http://www.springframework.org/schema/beans/spring-beans-3.0.xsd\">\n\n\t<!-- 定义数据源的信息 -->\n\t<bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"\n\t\tdestroy-method=\"close\">\n\t\t<property name=\"driverClass\">\n\t\t\t<value>com.mysql.jdbc.Driver</value>\n\t\t</property>\n\t\t<property name=\"jdbcUrl\">\n\t\t\t<value>jdbc:mysql://localhost:3306/test</value>\n\t\t</property>\n\t\t<property name=\"user\">\n\t\t\t<value>root</value>\n\t\t</property>\n\t\t<property name=\"password\">\n\t\t\t<value>zzw</value>\n\t\t</property>\n\t\t<property name=\"maxPoolSize\">\n\t\t\t<value>80</value>\n\t\t</property>\n\t\t<property name=\"minPoolSize\">\n\t\t\t<value>1</value>\n\t\t</property>\n\t\t<property name=\"initialPoolSize\">\n\t\t\t<value>1</value>\n\t\t</property>\n\t\t<property name=\"maxIdleTime\">\n\t\t\t<value>20</value>\n\t\t</property>\n\t</bean>\n\n\t<!--定义Hibernate的SessionFactory -->\n\t<!-- SessionFactory使用的数据源为上面的数据源 -->\n\t<!-- 指定了Hibernate的映射文件和配置信息 -->\n\t<bean id=\"sessionFactory\"\n\t\tclass=\"org.springframework.orm.hibernate5.LocalSessionFactoryBean\">\n\t\t<property name=\"dataSource\">\n\t\t\t<ref local=\"dataSource\" />\n\t\t</property>\n\t\t<property name=\"mappingResources\">\n\t\t\t<list>\n\t\t\t\t<value>com/helloworld/pojo/User.hbm.xml</value>\n\t\t\t</list>\n\t\t</property>\n\t\t<property name=\"hibernateProperties\">\n\t\t\t<props>\n\t\t\t\t<prop key=\"hibernate.dialect\">org.hibernate.dialect.MySQLDialect</prop>\n\t\t\t\t<prop key=\"show_sql\">true</prop>\n\t\t\t\t<prop key=\"hibernate.jdbc.batch_size\">20</prop>\n\t\t\t</props>\n\t\t</property>\n\t</bean>\n\n\t<bean id=\"transactionManager\"\n\t\tclass=\"org.springframework.orm.hibernate5.HibernateTransactionManager\">\n\t\t<property name=\"sessionFactory\" ref=\"sessionFactory\" />\n\t</bean>\n\n\t<bean id=\"userDao\" class=\"com.helloworld.daoImpl.UserDao\">\n\t\t<property name=\"sessionFactory\">\n\t\t\t<ref bean=\"sessionFactory\" />\n\t\t</property>\n\t</bean>\n\n\t<!--用户注册业务逻辑类 -->\n\t<bean id=\"userManager\" class=\"com.helloworld.manager.UserManager\">\n\t\t<property name=\"dao\">\n\t\t\t<ref bean=\"userDao\" />\n\t\t</property>\n\t</bean>\n\n\t<!-- 用户注册的Action -->\n\t<bean id=\"testAction\" class=\"com.helloworld.action.TestAction\">\n\t\t<property name=\"manager\">\n\t\t\t<ref bean=\"userManager\" />\n\t\t</property>\n\t</bean>\n\n\t<!-- more bean definitions go here -->\n\n</beans>\n```\n\n从配置文件我们看出，hibernate的datasource和session的配置完全被spring接管了，所以hibernate的配置文件是可以删掉的。\n\n### 修改BaseDao和UserDao。\n\n在引入Spring后，需要用Spring进行统一的事务管理，数据源和sessionFactory都交给Spring去生成，因此接口类和实现类BaseDao和UserDao都需要做相应的修改。Spring提供了HibernateDaoSupport类来完成对数据的操作，因此UserDao在实现BaseDao的同时还需要继承HibernateDaoSupport类。并将先前session的操作修改成HibernateTemplate（可通过getHibernateTemplate（）方法来获得）的操作。\n\n```java\npackage com.helloworld.dao;\n\nimport java.util.List;\n\nimport org.hibernate.HibernateException;\nimport org.hibernate.Session;\n\nimport com.helloworld.pojo.User;\n\npublic interface BaseDao {\n\n\tpublic void saveObject(Object obj) throws HibernateException;\n\t\n\tpublic List<User> getUsers() throws HibernateException;\n}\n\n```\n\n```java\npackage com.helloworld.daoImpl;\n\nimport java.util.List;\n\nimport org.hibernate.HibernateException;\nimport org.springframework.orm.hibernate5.support.HibernateDaoSupport;\n\nimport com.helloworld.dao.BaseDao;\nimport com.helloworld.pojo.User;\n\npublic class UserDao extends HibernateDaoSupport implements BaseDao{\n\t\n\tpublic UserDao() {\n\t\tSystem.out.println(\"UserDao IN\");\n\t}\n  \n    @Override  \n    public void saveObject(Object obj) throws HibernateException {  \n    \tgetHibernateTemplate().save(obj);  \n    }  \n    \n    public List<User> getUsers() throws HibernateException{\n    \tList<User> users=getHibernateTemplate().loadAll(User.class);\n    \treturn users;\n    }\n}\n\n```\n\n其实HibernateDaoSupport也没干什么大事，就是前面说的session的set get方法，既然每个DAO都需要，那spring就提出来了呗，没什么神秘的。\n\n\n### 修改业务逻辑实现类\n\n也就是Manager的类，跟DAO一样。在没有加入Spring之前，业务逻辑实现类的Session的获得，dao的实例化，以及事务的管理都是该类执行管理的。加入Spring后，这些都交给Spring去管理。该类的dao的实例化由Spring注入。\n\n### 修改用户注册的testAction类\n\n同样，testAction类中的userManager的实例化也由Spring注入。可以仔细理解一下上面的applicationContext的配置文件，你需要某个对象，只要把该对象配置成bean，比如下面这样\n\n```xml\n<bean id=\"userManager\" class=\"com.helloworld.manager.UserManager\">\n\t\t...\n\t</bean>\n```\n\n然后用到这个bean的类配置成\n\n```xml\n<bean id=\"testAction\" class=\"com.helloworld.action.TestAction\">\n\t\t<property name=\"manager\">\n\t\t\t<ref bean=\"userManager\" />\n\t\t</property>\n\t</bean>\n```\n\n这样这个类里名字为manager的对象就会自动被注入userManager对象。记得需要有set方法，名字需对应。\n\n### 删除多余类\n\n删除Hibernate的配置文件Hibernate.cfg.xml和工厂类\nHibernateSesseionFactory类。他们的工作已经交给Spring去做，已经不再有用。\n\n### 修改web.xml\n\n加载Spring。要想启动时加载Spring的配置文件，需要在web.xml中配置对应的监听器（listenser），并指定Spring的配置文件。\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<web-app version=\"2.5\" xmlns=\"http://java.sun.com/xml/ns/javaee\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee \n    http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\">\n    \n    <listener>  \n        <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>  \n    </listener> \n    <filter>\n        <filter-name>struts2</filter-name>\n        <filter-class>\n           org.apache.struts2.dispatcher.filter.StrutsPrepareAndExecuteFilter\n        </filter-class>\n    </filter>\n \t<filter-mapping>\n  \t\t<filter-name>struts2</filter-name>\n  \t\t<url-pattern>/*</url-pattern>\n \t</filter-mapping>\n \t\n \t\n \n    <welcome-file-list>\n    <welcome-file>index.jsp</welcome-file>\n    </welcome-file-list>\n</web-app>\n```\n\n\n### 修改Struts的配置文件struts.xml\n\n把原来指定的名为register的action的class由原来的路径变为applicationContext.xml文件中该bean的id名，不需要再用具体的包名+类名。\n\n包名加类名的方式会在每次访问的时候都生成一个action对应的对象，交给spring管理后，只会在最开始的时候生成一次。如下\n\n```xml\n<action  name =\"test\"  class =\"testAction\">\n```\n\n整个项目配置之后结构如图\n\n![](http://img.blog.csdn.net/20160922132809919?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n\n在spring的配置中会遇到各种各样的问题，其他无非就是bean配置上写错了路径，类目，对象名，变量名，等等，所以仔细一点，认真检查一下，肯定能找到原因。\n\n到此为止，SSH框架已经搭建好了，但是据我所知，这套框架目前的使用率已经在降低了，有以下几个原因：\n\n1. struts除了可以做请求转发，还有页面标签，所以你如果只用请求转发的话，这个框架有点多余\n2. 现在spring推出了springMVC，是专门做请求转发用的，因为是spring自家推出的，所以和spring的协调性更好，而且在我使用中也感觉springMVC用起来更方便，轻量级\n3. HIbernate框架管理数据库很强大，但是同样的问题，重量级。目前因为移动应用的兴起，请求并发量暴增的问题，Mybatis框架对于数据库管理更轻量级，更灵活。这两个框架说不上孰优孰劣，大家可以看下资料。\n\n所以在下一篇文章中，准备先用SpringMVC代替struts。敬请期待\n","slug":"基于struts2-5-2-hibernate5-2-2-spring4-3-2搭建SSH框架v2","published":1,"updated":"2024-06-14T09:25:33.679Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clxjsxtw7000zlq6gik3dkvns","content":"<p>现在在学习后端框架，最后的目标是希望搭建一个基于spring mvc + mybatis + spring的框架，因为之前接触过SSH，所以想从SSH开始，慢慢演化，也巩固一下自己的知识。<br>之前每次搭建SSH框架都要在网上查各种资料，而且我也发现各种资料基于的SSH版本都比较老，新版本就会遇到各种各样的问题，所以基于这次的搭建流程，写一下遇到的问题和解决方法。</p>\n<h2 id=\"Contents\"><a href=\"#Contents\" class=\"headerlink\" title=\"Contents\"></a>Contents</h2><ul>\n<li><a href=\"#Contents\">Contents</a></li>\n<li><a href=\"#基础需求\">基础需求</a></li>\n<li><a href=\"#配置Struts框架\">配置Struts框架</a></li>\n<li><a href=\"#搭建Hibernate框架\">搭建Hibernate框架</a></li>\n<li><a href=\"#dao\">DAO设计模型</a></li>\n<li><a href=\"#搭建Spring框架，整合Struts和Hibernate\">搭建Spring框架，整合Struts和Hibernate</a></li>\n</ul>\n<h2 id=\"基础需求\"><a href=\"#基础需求\" class=\"headerlink\" title=\"基础需求\"></a>基础需求</h2><h3 id=\"下载-Eclipse-J2EE版\"><a href=\"#下载-Eclipse-J2EE版\" class=\"headerlink\" title=\"下载 Eclipse J2EE版\"></a>下载 Eclipse J2EE版</h3><p>J2EE版带server和maven的配置，用起来比较方便，其他也没什么区别，普通版装插件也是可以达到一样效果的</p>\n<h3 id=\"下载tomcat\"><a href=\"#下载tomcat\" class=\"headerlink\" title=\"下载tomcat\"></a>下载tomcat</h3><p>目前Eclipse J2EE版的server只支持tomcat 8 以下版本，我试过8.5.5也不支持，所以最好下7</p>\n<h3 id=\"安装mysql\"><a href=\"#安装mysql\" class=\"headerlink\" title=\"安装mysql\"></a>安装mysql</h3><p>具体流程可以从网上找，这个简单</p>\n<p>创建数据库 create database test；</p>\n<p>创建表<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\">create table <span class=\"title\">user</span><span class=\"params\">(</span></span></div><div class=\"line\"> userId <span class=\"keyword\">int</span> auto_increment,  </div><div class=\"line\"> userName varchar(<span class=\"number\">16</span>) not <span class=\"keyword\">null</span>,  </div><div class=\"line\"> password <span class=\"title\">varchar</span><span class=\"params\">(<span class=\"number\">16</span>)</span> not <span class=\"keyword\">null</span>,  </div><div class=\"line\"> gender <span class=\"keyword\">int</span> not <span class=\"keyword\">null</span>,  </div><div class=\"line\"> primary <span class=\"title\">key</span><span class=\"params\">(userId)</span>  </div><div class=\"line\">);</div></pre></td></tr></table></figure></p>\n<h2 id=\"配置Struts框架\"><a href=\"#配置Struts框架\" class=\"headerlink\" title=\"配置Struts框架\"></a>配置Struts框架</h2><h3 id=\"安装struts的jar包\"><a href=\"#安装struts的jar包\" class=\"headerlink\" title=\"安装struts的jar包\"></a>安装struts的jar包</h3><p>下载struts-2.5.2包</p>\n<p>将包下面lib目录下的以下文件拷贝到项目的WEB-INF/lib下面，当然这里要先创建一个Dynamic Web Project，这个也简单，在Eclipse中点下一步下一步下一步就可以。</p>\n<p>为什么是放在WEB-INF/lib下，而不放在项目的lib下，这是因为，web项目在发布后依赖包是去寻找WEB-INF目录下的各种包的。这里我后面遇到一个奇怪的问题，也加深了对这个配置的理解，具体什么问题以后再说。然后你把包放在WEB-INF/lib下的时候，eclipse会自动拷贝一份到项目的lib下，方便编程时候的依赖。</p>\n<p><img src=\"http://img.blog.csdn.net/20160922112818884?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<h3 id=\"创建web-xml\"><a href=\"#创建web-xml\" class=\"headerlink\" title=\"创建web.xml\"></a>创建web.xml</h3><p>在WEB-INF下面创建web.xml，配置struts监听，这个web.xml其实就是整个web项目的入口，所有的配置都是从这里开始，再跳转的其他地方。格式如下</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">web-app</span> <span class=\"attr\">version</span>=<span class=\"string\">\"2.5\"</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://java.sun.com/xml/ns/javaee\"</span></span></div><div class=\"line\">    <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></div><div class=\"line\">    <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"http://java.sun.com/xml/ns/javaee </span></div><div class=\"line\">    http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\"&gt;</div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">filter</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">filter-name</span>&gt;</span>struts2<span class=\"tag\">&lt;/<span class=\"name\">filter-name</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">filter-class</span>&gt;</span></div><div class=\"line\">           org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter</div><div class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">filter-class</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">filter</span>&gt;</span></div><div class=\"line\"> \t<span class=\"tag\">&lt;<span class=\"name\">filter-mapping</span>&gt;</span></div><div class=\"line\">  \t\t<span class=\"tag\">&lt;<span class=\"name\">filter-name</span>&gt;</span>struts2<span class=\"tag\">&lt;/<span class=\"name\">filter-name</span>&gt;</span></div><div class=\"line\">  \t\t<span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>/*<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span></div><div class=\"line\">  \t\t<span class=\"comment\">&lt;!--注意：千万不能写成：*.action ，如果需要：*.action应该配置在struts.xml中--&gt;</span></div><div class=\"line\"> \t<span class=\"tag\">&lt;/<span class=\"name\">filter-mapping</span>&gt;</span></div><div class=\"line\"> </div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">welcome-file-list</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">welcome-file</span>&gt;</span>index.jsp<span class=\"tag\">&lt;/<span class=\"name\">welcome-file</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">welcome-file-list</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">web-app</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>其实熟悉j2ee的人知道，在struts之前，j2ee最基本的跳转是用servlet来做的，struts其实也要基于servlet来做，配置一个filter，name随意。然后在filter-mapping里配置满足一定条件的url请求都交给这个filter来处理，其实也就是struts来处理。这里我们配置为/*，也就是所有的请求都转发给struts处理，这是最简单的，如果需要特殊配置可以在这里再配置。</p>\n<p>另外也要注意/<em> 和 /的区别，按照我个人的理解/</em>是所有的请求，包括/test.jsp和/test.html这种带后缀名的请求。/是不带后缀名的所有请求，像/test这样的。</p>\n<h3 id=\"创建struts-xml\"><a href=\"#创建struts-xml\" class=\"headerlink\" title=\"创建struts.xml\"></a>创建struts.xml</h3><p>然后所有的请求都给struts处理了，struts本身肯定还需要一个配置文件，来转发各种请求到相应的处理类，这个配置文件是struts.xml，放在src文件夹下，前面说过，web项目的配置文件都是在web-inf下面，为什么这个放在src文件夹下呢，这里就要说到一个eclipse发布映射的问题。</p>\n<p>你项目里点右键，选属性，选Deployment Assembly，可以看到这是发包时候的映射关系，src文件夹会发布到WEB-INF/classes，而struts会默认到这个文件夹下面找配置文件。</p>\n<p><img src=\"http://img.blog.csdn.net/20160922122622832?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p>回到正题，说一下struts的配置文件，格式如下</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;</div><div class=\"line\"><span class=\"meta\">&lt;!DOCTYPE struts PUBLIC \"-//Apache Software Foundation//DTD Struts Configuration 2.0//EN\" \"http://struts.apache.org/dtds/struts-2.0.dtd\" &gt;</span>  </div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">struts</span>&gt;</span>  </div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">package</span>  <span class=\"attr\">name</span> =<span class=\"string\">\"user_curd\"</span>  <span class=\"attr\">extends</span> =<span class=\"string\">\"struts-default\"</span>  &gt;</span>  </div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">global-results</span>&gt;</span>  </div><div class=\"line\">            <span class=\"comment\">&lt;!--  下面定义的结果对所有的Action都有效  --&gt;</span>  </div><div class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">result</span>  <span class=\"attr\">name</span> =<span class=\"string\">\"exception\"</span>&gt;</span> /error.jsp <span class=\"tag\">&lt;/<span class=\"name\">result</span>&gt;</span>  </div><div class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">global-results</span>&gt;</span>  </div><div class=\"line\">  </div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">global-exception-mappings</span>&gt;</span>  </div><div class=\"line\">            <span class=\"comment\">&lt;!--  指Action抛出Exception异常时，转入名为exception的结果。  --&gt;</span>  </div><div class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">exception-mapping</span>  <span class=\"attr\">exception</span> =<span class=\"string\">\"java.lang.Exception\"</span>  <span class=\"attr\">result</span> =<span class=\"string\">\"exception\"</span> /&gt;</span>  </div><div class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">global-exception-mappings</span>&gt;</span>  </div><div class=\"line\">  </div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">action</span>  <span class=\"attr\">name</span> =<span class=\"string\">\"test\"</span>  <span class=\"attr\">class</span> =<span class=\"string\">\"TestAction\"</span>&gt;</span>  </div><div class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">action</span>&gt;</span>  </div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">package</span>&gt;</span>    </div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">struts</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>配置文件很好懂，下面的action部分就是请求转发，url中对\\test的请求会转发到TestAction中处理</p>\n<h3 id=\"创建Action类\"><a href=\"#创建Action类\" class=\"headerlink\" title=\"创建Action类\"></a>创建Action类</h3><p>创建Action处理类，前面也说过了，请求会转发到某个类中进行处理，很显然，我们需要定义这样的类<br>在src中创建相应的类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> com.helloworld.test;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> java.io.PrintWriter;</div><div class=\"line\"><span class=\"keyword\">import</span> java.util.Date;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> org.apache.struts2.ServletActionContext;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> com.opensymphony.xwork2.ActionSupport;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestAction</span> <span class=\"keyword\">extends</span> <span class=\"title\">ActionSupport</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">\t<span class=\"keyword\">private</span> String contentType = <span class=\"string\">\"text/html;charset=utf-8\"</span>;     </div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">execute</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception</span></div><div class=\"line\">\t&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//指定输出内容类型和编码  </span></div><div class=\"line\">        ServletActionContext.getResponse().setContentType(contentType);   </div><div class=\"line\">        <span class=\"comment\">//获取输出流，然后使用  </span></div><div class=\"line\">        PrintWriter out = ServletActionContext.getResponse().getWriter();   </div><div class=\"line\">        <span class=\"keyword\">try</span>&#123;  </div><div class=\"line\">            <span class=\"comment\">//输出文本信息  </span></div><div class=\"line\">            out.print(<span class=\"string\">\"Hello World\"</span>);  </div><div class=\"line\">            out.print(<span class=\"string\">\"Time: \"</span> + (<span class=\"keyword\">new</span> Date()).getTime());   </div><div class=\"line\">            out.flush();  </div><div class=\"line\">            out.close();  </div><div class=\"line\">        &#125;<span class=\"keyword\">catch</span>(Exception ex)&#123;  </div><div class=\"line\">            out.println(ex.toString());  </div><div class=\"line\">        &#125;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> SUCCESS;  </div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>execute方法就是处理请求的方法，具体的使用可以再查相关资料，本文只介绍搭建框架</p>\n<h3 id=\"发包运行\"><a href=\"#发包运行\" class=\"headerlink\" title=\"发包运行\"></a>发包运行</h3><p>此时访问test应该会跳转到该类，然后输出信息</p>\n<h3 id=\"配置Struts时遇到的问题：\"><a href=\"#配置Struts时遇到的问题：\" class=\"headerlink\" title=\"配置Struts时遇到的问题：\"></a>配置Struts时遇到的问题：</h3><h4 id=\"问题1\"><a href=\"#问题1\" class=\"headerlink\" title=\"问题1\"></a>问题1</h4><p>java.lang.ClassNotFoundException: org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter<br>最新的Struts框架处理类的包名变了，其实碰到这类问题，自己去lib中看下类所在的位置就可以，每次版本更新可能会变一些东西</p>\n<p><img src=\"http://img.blog.csdn.net/20160922123903227?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<h4 id=\"错误2\"><a href=\"#错误2\" class=\"headerlink\" title=\"错误2\"></a>错误2</h4><p>java.util.concurrent.ExecutionException: org.apache.catalina.LifecycleException: Failed to start component [StandardEngine[Catalina].StandardHost[localhost].StandardContext[/helloworld]]</p>\n<p>这是因为lib包多了或少了，参照我前面lib库的文件，检查一下</p>\n<h4 id=\"错误3\"><a href=\"#错误3\" class=\"headerlink\" title=\"错误3\"></a>错误3</h4><p>Unable to load configuration. - bean - jar:file:/Users/zzw/Documents/j2eeworkspace/.metadata/.plugins/org.eclipse.wst.server.core/tmp0/wtpwebapps/helloworld/WEB-INF/lib/struts2-gxp-plugin-2.5.2.jar!/struts-plugin.xml:8:162</p>\n<p>和上个问题一样，这是因为引用包多了，其实不要觉得我把所有包都放进了就行了，如果包多了会做一些初始化的工作，而初始化的过程中就容易有问题</p>\n<p>访问<a href=\"http://localhost:8080/helloworld/test成功\" target=\"_blank\" rel=\"external\">http://localhost:8080/helloworld/test成功</a></p>\n<h2 id=\"搭建Hibernate框架\"><a href=\"#搭建Hibernate框架\" class=\"headerlink\" title=\"搭建Hibernate框架\"></a>搭建Hibernate框架</h2><p>Struts到目前为止就算成功了，接下来我们看引入Hibernate框架</p>\n<h3 id=\"官网下载hibernate-5-2-2\"><a href=\"#官网下载hibernate-5-2-2\" class=\"headerlink\" title=\"官网下载hibernate 5.2.2\"></a>官网下载hibernate 5.2.2</h3><h3 id=\"下载JDBC\"><a href=\"#下载JDBC\" class=\"headerlink\" title=\"下载JDBC\"></a>下载JDBC</h3><p><a href=\"http://www.mysql.com/products/connector/\" target=\"_blank\" rel=\"external\">http://www.mysql.com/products/connector/</a> 下载jdbc</p>\n<h3 id=\"配置Hibernate的Jar包\"><a href=\"#配置Hibernate的Jar包\" class=\"headerlink\" title=\"配置Hibernate的Jar包\"></a>配置Hibernate的Jar包</h3><p>拷贝lib\\required下的jar包到WEB-INFO\\lib目录下，Hibernate就很好，把所有需要的包都放在了required文件夹下</p>\n<h3 id=\"创建hibernate-cfg-xml\"><a href=\"#创建hibernate-cfg-xml\" class=\"headerlink\" title=\"创建hibernate.cfg.xml\"></a>创建hibernate.cfg.xml</h3><p>创建hibernate的配置文件hibernate.cfg.xml，配置数据库连接等等，也是在src目录下，格式如下</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&lt;!DOCTYPE hibernate-configuration PUBLIC</span></div><div class=\"line\">\t\"-//Hibernate/Hibernate Configuration DTD 3.0//EN\"</div><div class=\"line\">\t\"http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd\"&gt;</div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">hibernate-configuration</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">session-factory</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"hibernate.connection.driver_class\"</span>&gt;</span>com.mysql.jdbc.Driver<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"hibernate.connection.url\"</span>&gt;</span>jdbc:mysql://localhost:3306/User<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"hibernate.connection.username\"</span>&gt;</span>root<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"hibernate.connection.password\"</span>&gt;</span>123<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"hibernate.dialect\"</span>&gt;</span>org.hibernate.dialect.MySQLDialect<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">session-factory</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">hibernate-configuration</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>这是最简单的配置，连接数据库的</p>\n<h3 id=\"创建实体类\"><a href=\"#创建实体类\" class=\"headerlink\" title=\"创建实体类\"></a>创建实体类</h3><p>我们都知道hibernate是实体-关系映射，所以要创建实体类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> com.helloworld.test;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> userId;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">private</span> String userName;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">private</span> String passWord;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> gender;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getUserId</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> userId;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setUserId</span><span class=\"params\">(<span class=\"keyword\">int</span> userId)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.userId = userId;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getUserName</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> userName;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setUserName</span><span class=\"params\">(String userName)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.userName = userName;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getPassWord</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> passWord;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setPassWord</span><span class=\"params\">(String passWord)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.passWord = passWord;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getGender</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> gender;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setGender</span><span class=\"params\">(<span class=\"keyword\">int</span> gender)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.gender = gender;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>就是对应数据库中一个表</p>\n<h3 id=\"配置映射关系\"><a href=\"#配置映射关系\" class=\"headerlink\" title=\"配置映射关系\"></a>配置映射关系</h3><p>明显，这个实体类和表的映射关系也需要配置<br>添加User.hbm.xml文件映射表结构</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;?xml version=\"1.0\"?&gt;</div><div class=\"line\"><span class=\"meta\">&lt;!DOCTYPE hibernate-mapping PUBLIC </span></div><div class=\"line\">\t\"-//Hibernate/Hibernate Mapping DTD 3.0//EN\"</div><div class=\"line\">\t\"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd\"&gt;</div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">hibernate-mapping</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">class</span> <span class=\"attr\">name</span>=<span class=\"string\">\"com.helloworld.test.User\"</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">id</span> <span class=\"attr\">name</span>=<span class=\"string\">\"userId\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">generator</span> <span class=\"attr\">class</span>=<span class=\"string\">\"increment\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">id</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"userName\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"passWord\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"gender\"</span> /&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">class</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">hibernate-mapping</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>这个映射关系配置文件可以放在任何地方，因为下一步我们会在hibernate.xml配置文件中声明这个文件的位置，我目前是放在和User类一起的位置。</p>\n<h3 id=\"添加映射关系\"><a href=\"#添加映射关系\" class=\"headerlink\" title=\"添加映射关系\"></a>添加映射关系</h3><p>按照上一步所说，我们需要把映射关系配置文件的路径配置到hibernate.cfg.xml中去，如下：要写清楚包名，位置，就mapping配置的那部分，如果有多个映射，依次添加</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&lt;!DOCTYPE hibernate-configuration PUBLIC</span></div><div class=\"line\">\t\"-//Hibernate/Hibernate Configuration DTD 3.0//EN\"</div><div class=\"line\">\t\"http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd\"&gt;</div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">hibernate-configuration</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">session-factory</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"hibernate.connection.driver_class\"</span>&gt;</span>com.mysql.jdbc.Driver<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"hibernate.connection.url\"</span>&gt;</span>jdbc:mysql://localhost:3306/test<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"hibernate.connection.username\"</span>&gt;</span>root<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"hibernate.connection.password\"</span>&gt;</span>zzw<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"hibernate.dialect\"</span>&gt;</span>org.hibernate.dialect.MySQLDialect<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"hibernate.show_sql\"</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span>  </div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"hibernate.format_sql\"</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span>  </div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">mapping</span> <span class=\"attr\">resource</span>=<span class=\"string\">\"com/helloworld/test/User.hbm.xml\"</span>/&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">session-factory</span>&gt;</span></div><div class=\"line\">\t</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">hibernate-configuration</span>&gt;</span></div></pre></td></tr></table></figure>\n<h3 id=\"测试运行\"><a href=\"#测试运行\" class=\"headerlink\" title=\"测试运行\"></a>测试运行</h3><p>Hibernate不需要发包web项目，可以本地测试，写一个Test类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> com.helloworld.test;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> java.util.List;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> org.hibernate.Session;</div><div class=\"line\"><span class=\"keyword\">import</span> org.hibernate.SessionFactory;</div><div class=\"line\"><span class=\"keyword\">import</span> org.hibernate.cfg.Configuration;</div><div class=\"line\"><span class=\"keyword\">import</span> org.hibernate.query.Query;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HibernateTest</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//读取hibernate.cfg.xml文件  </span></div><div class=\"line\">        Configuration cfg = <span class=\"keyword\">new</span> Configuration().configure();  </div><div class=\"line\">          </div><div class=\"line\">        <span class=\"comment\">//建立SessionFactory  </span></div><div class=\"line\">        SessionFactory factory = cfg.buildSessionFactory();  </div><div class=\"line\">          </div><div class=\"line\">        <span class=\"comment\">//取得session  </span></div><div class=\"line\">        Session session = <span class=\"keyword\">null</span>;  </div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;  </div><div class=\"line\">            session = factory.openSession();  </div><div class=\"line\">            <span class=\"comment\">//开启事务  </span></div><div class=\"line\">            session.beginTransaction();  </div><div class=\"line\">            User user = <span class=\"keyword\">new</span> User();  </div><div class=\"line\">            user.setUserName(<span class=\"string\">\"zzw\"</span>); </div><div class=\"line\">            user.setPassWord(<span class=\"string\">\"zzw\"</span>);  </div><div class=\"line\">              </div><div class=\"line\">            <span class=\"comment\">//保存User对象  </span></div><div class=\"line\">            session.save(user);   </div><div class=\"line\">            String hql = <span class=\"string\">\"from User\"</span>;  </div><div class=\"line\">            Query query = session.createQuery(hql);  </div><div class=\"line\">            List&lt;User&gt; roles = query.list();</div><div class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;roles.size();i++)&#123;</div><div class=\"line\">            \tSystem.out.print(<span class=\"string\">\"从数据库加载数据的用户名为\"</span>+roles.get(i).getUserName());  </div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"comment\">//提交事务  </span></div><div class=\"line\">            session.getTransaction().commit();  </div><div class=\"line\">        &#125;<span class=\"keyword\">catch</span>(Exception e) &#123;  </div><div class=\"line\">            e.printStackTrace();  </div><div class=\"line\">            <span class=\"comment\">//回滚事务  </span></div><div class=\"line\">            session.getTransaction().rollback();  </div><div class=\"line\">        &#125;<span class=\"keyword\">finally</span> &#123;  </div><div class=\"line\">            <span class=\"keyword\">if</span> (session != <span class=\"keyword\">null</span>) &#123;  </div><div class=\"line\">                <span class=\"keyword\">if</span> (session.isOpen()) &#123;  </div><div class=\"line\">                    <span class=\"comment\">//关闭session  </span></div><div class=\"line\">                    session.close();  </div><div class=\"line\">                &#125;  </div><div class=\"line\">            &#125;  </div><div class=\"line\">        &#125;  </div><div class=\"line\"></div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>执行成功，这样的话Hibernate框架也算搭建完成了。</p>\n<h2 id=\"DAO设计模型\"><a href=\"#DAO设计模型\" class=\"headerlink\" title=\"DAO设计模型\"></a>DAO设计模型</h2><p>提到Hibernate不得不提的是DAO设计模型，为了下一步Spring的配置更加清楚明了，这里我们也采用DAO的设计模型</p>\n<h3 id=\"基础概念\"><a href=\"#基础概念\" class=\"headerlink\" title=\"基础概念\"></a>基础概念</h3><p>这里讲几个概念<br>POJO（Plain Ordinary Java Object）简单的Java对象，实际就是普通JavaBeans，是为了避免和EJB混淆所创造的简称。这里POJO其实就是User类<br>DAO (Data Access Object)是一个数据访问接口，数据访问：顾名思义就是与数据库打交道。夹在业务逻辑与数据库资源中间。</p>\n<p>简单一点说，就是把数据库相关操作提到DAO中进行，与业务有关的逻辑放在Manager中，为了分层编程。举个例子来说，比如用户注册这个功能，用户注册的页面显示由RegisterAction负责，Action类中有Manager负责具体的业务，RegisterManager中有具体的业务方法register，Manager中有与数据库打交道的DAO类，RegisterManager中应该有UserDAO，负责所有对User表的操作，比如addUser，deleteUser等。这样说应该很容易理解吧，这是一种分层编程的思想，可以降低各个模块之间的耦合度，比如如果你想把用户注册改成管理员注册，只需要把UserDAO改成managerDAO就可以操作manager表了。就这样。DAO设计模式也是很推崇面向接口的编程，下面我用代码为大家讲解。</p>\n<h3 id=\"DAO类\"><a href=\"#DAO类\" class=\"headerlink\" title=\"DAO类\"></a>DAO类</h3><p>1，首先声明接口</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> com.helloworld.dao;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> org.hibernate.HibernateException;</div><div class=\"line\"><span class=\"keyword\">import</span> org.hibernate.Session;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">BaseDao</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">saveObject</span><span class=\"params\">(Object obj)</span> <span class=\"keyword\">throws</span> HibernateException</span>;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> Session <span class=\"title\">getSession</span><span class=\"params\">()</span></span>;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setSession</span><span class=\"params\">(Session session)</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>跟数据库打交道需要获取hibernate的session，所以一个简单的base接口就是几个获取session的方法</p>\n<p>然后我们定义HibernateSessionFactory用于在各个DAO中获取Session</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> com.helloworld.daoImpl;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> org.hibernate.HibernateException;</div><div class=\"line\"><span class=\"keyword\">import</span> org.hibernate.Session;</div><div class=\"line\"><span class=\"keyword\">import</span> org.hibernate.SessionFactory;</div><div class=\"line\"><span class=\"keyword\">import</span> org.hibernate.boot.Metadata;</div><div class=\"line\"><span class=\"keyword\">import</span> org.hibernate.boot.MetadataSources;</div><div class=\"line\"><span class=\"keyword\">import</span> org.hibernate.boot.model.naming.ImplicitNamingStrategyJpaCompliantImpl;</div><div class=\"line\"><span class=\"keyword\">import</span> org.hibernate.boot.registry.StandardServiceRegistry;</div><div class=\"line\"><span class=\"keyword\">import</span> org.hibernate.boot.registry.StandardServiceRegistryBuilder;</div><div class=\"line\"><span class=\"keyword\">import</span> org.hibernate.cfg.Configuration;</div><div class=\"line\"><span class=\"keyword\">import</span> org.hibernate.service.ServiceRegistry;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HibernateSessionFactory</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String CFG_FILE_LOCATION = <span class=\"string\">\"/Hibernate.cfg.xml\"</span>;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ThreadLocal&lt;Session&gt; threadLocal = <span class=\"keyword\">new</span> ThreadLocal&lt;Session&gt;();</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Configuration cfg = <span class=\"keyword\">new</span> Configuration()</div><div class=\"line\">\t\t\t.configure(CFG_FILE_LOCATION);</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> ServiceRegistry registry;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> SessionFactory sessionFactory;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Session <span class=\"title\">currentSession</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> HibernateException </span>&#123;</div><div class=\"line\">\t\tSession session = threadLocal.get();</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"keyword\">if</span> (session == <span class=\"keyword\">null</span> || session.isOpen() == <span class=\"keyword\">false</span>) &#123;</div><div class=\"line\"></div><div class=\"line\">\t\t\t<span class=\"keyword\">if</span> (sessionFactory == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">\t\t\t\tStandardServiceRegistry standardRegistry = <span class=\"keyword\">new</span> StandardServiceRegistryBuilder()</div><div class=\"line\">\t\t\t\t\t\t.configure().build();</div><div class=\"line\">\t\t\t\tMetadata metadata = <span class=\"keyword\">new</span> MetadataSources(standardRegistry)</div><div class=\"line\">\t\t\t\t\t\t.getMetadataBuilder()</div><div class=\"line\">\t\t\t\t\t\t.applyImplicitNamingStrategy(</div><div class=\"line\">\t\t\t\t\t\t\t\tImplicitNamingStrategyJpaCompliantImpl.INSTANCE)</div><div class=\"line\">\t\t\t\t\t\t.build();</div><div class=\"line\">\t\t\t\tsessionFactory = metadata</div><div class=\"line\">\t\t\t\t\t\t.getSessionFactoryBuilder().build();</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\t\tsession = sessionFactory.openSession();</div><div class=\"line\">\t\t\tthreadLocal.set(session);</div><div class=\"line\"></div><div class=\"line\">\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"keyword\">return</span> session;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">closeSession</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> HibernateException </span>&#123;</div><div class=\"line\">\t\tSession session = threadLocal.get();</div><div class=\"line\">\t\tthreadLocal.set(<span class=\"keyword\">null</span>);</div><div class=\"line\">\t\t<span class=\"keyword\">if</span> (session != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">\t\t\tsession.close();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>下面是跟User表打交道的UserDao</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> com.helloworld.daoImpl;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> org.hibernate.HibernateException;</div><div class=\"line\"><span class=\"keyword\">import</span> org.hibernate.Session;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> com.helloworld.dao.BaseDao;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserDao</span> <span class=\"keyword\">implements</span> <span class=\"title\">BaseDao</span></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">private</span> Session session;  </div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">UserDao</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\tsession=HiberanateSessionFactory.currentSession();</div><div class=\"line\">       &#125;  </div><div class=\"line\">    <span class=\"meta\">@Override</span>  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Session <span class=\"title\">getSession</span><span class=\"params\">()</span> </span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">return</span> session;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">  </div><div class=\"line\">    <span class=\"meta\">@Override</span>  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setSession</span><span class=\"params\">(Session session)</span> </span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">this</span>.session = session;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">  </div><div class=\"line\">    <span class=\"meta\">@Override</span>  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">saveObject</span><span class=\"params\">(Object obj)</span> <span class=\"keyword\">throws</span> HibernateException </span>&#123;  </div><div class=\"line\">        session.save(obj);  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"业务逻辑类\"><a href=\"#业务逻辑类\" class=\"headerlink\" title=\"业务逻辑类\"></a>业务逻辑类</h3><p>然后声明业务逻辑类UserManager，这里我只是举个最简单的例子,直接调用了DAO的getUsers方法，不要觉得没用，在日常事务中，我们需要在DAO方法前后做些处理，都是要在Manager中进行处理的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> com.helloworld.manager;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> java.util.List;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> org.hibernate.HibernateException;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> com.helloworld.dao.BaseDao;</div><div class=\"line\"><span class=\"keyword\">import</span> com.helloworld.daoImpl.UserDao;</div><div class=\"line\"><span class=\"keyword\">import</span> com.helloworld.pojo.User;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserManager</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">private</span> BaseDao dao;  </div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">UserManager</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\tdao = <span class=\"keyword\">new</span> UserDao();</div><div class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"UserManager IN\"</span>);</div><div class=\"line\">\t&#125;</div><div class=\"line\">   </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> BaseDao <span class=\"title\">getDao</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> dao;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setDao</span><span class=\"params\">(BaseDao dao)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.dao = dao;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> List&lt;User&gt; <span class=\"title\">getUsers</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> HibernateException </span>&#123;  </div><div class=\"line\">    \t<span class=\"keyword\">return</span> dao.getUsers();</div><div class=\"line\">    &#125; </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这时候就可以在测试类里用manager对象进行数据库操作了。比如</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> com.helloworld.test;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> java.util.List;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> org.hibernate.Session;</div><div class=\"line\"><span class=\"keyword\">import</span> org.hibernate.SessionFactory;</div><div class=\"line\"><span class=\"keyword\">import</span> org.hibernate.cfg.Configuration;</div><div class=\"line\"><span class=\"keyword\">import</span> org.hibernate.query.Query;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> com.helloworld.dao.BaseDao;</div><div class=\"line\"><span class=\"keyword\">import</span> com.helloworld.daoImpl.HibernateSessionFactory;</div><div class=\"line\"><span class=\"keyword\">import</span> com.helloworld.daoImpl.UserDao;</div><div class=\"line\"><span class=\"keyword\">import</span> com.helloworld.manager.UserManager;</div><div class=\"line\"><span class=\"keyword\">import</span> com.helloworld.pojo.User;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HibernateTest</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">\t\tUserManager userManager=<span class=\"keyword\">new</span> UserManager();</div><div class=\"line\">        userManager.getUsers()</div><div class=\"line\"></div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>DAO模型介绍到这。</p>\n<h2 id=\"搭建Spring框架，整合Struts和Hibernate\"><a href=\"#搭建Spring框架，整合Struts和Hibernate\" class=\"headerlink\" title=\"搭建Spring框架，整合Struts和Hibernate\"></a>搭建Spring框架，整合Struts和Hibernate</h2><p>接下来用spring整合struts和hibernate</p>\n<p>前面提到的DAO设计模式，在用到的时候new 一个DAO对象进行数据库操作，这是最简单的，但是你想想这样会浪费时间，浪费内存，因为没进行一次访问都要生成一个新的对象，其实全局都可以用一个DAO对象。Spring是干嘛的，Spring有两大特性，IoC和AoP，其中IoC中的一种方式便是依赖注入，Spring全局管理一些Bean，像Session，dao都可以是bean，然后你需要的时候就给你注入，这就是依赖注入。其他的特性可以自行百度，另外Spring其实是一套门路很深的框架，不然也不会在Struts和Hibernate都渐渐退居二线的时候，它依然坚挺在第一线。有机会我准备仔细看下Spring的实现原理，与大家分享一下。</p>\n<p>总而言之，整个Spring的配置过程其实就是，配置bean，然后把bean配置到各个类中这样。</p>\n<h3 id=\"下载4-3-2release的spring\"><a href=\"#下载4-3-2release的spring\" class=\"headerlink\" title=\"下载4.3.2release的spring\"></a>下载4.3.2release的spring</h3><p>Spring官网改版后找了好久都没有找到直接下载Jar包的链接,下面汇总些网上提供的方法,亲测可用.</p>\n<p>直接输入地址,改相应版本即可:<a href=\"http://repo.springsource.org/libs-release-local/org/springframework/spring/3.2.4.RELEASE/spring-framework-3.2.4.RELEASE-dist.zip\" target=\"_blank\" rel=\"external\">http://repo.springsource.org/libs-release-local/org/springframework/spring/3.2.4.RELEASE/spring-framework-3.2.4.RELEASE-dist.zip</a></p>\n<p>在1的方法上输入前面部分,有个树形结构可供选择:<a href=\"http://repo.springsource.org/libs-release-local/org/springframework/spring/\" target=\"_blank\" rel=\"external\">http://repo.springsource.org/libs-release-local/org/springframework/spring/</a></p>\n<p>同样的,,有树形结构选择需要的包下载:<a href=\"http://repo.spring.io/milestone/org/springframework/\" target=\"_blank\" rel=\"external\">http://repo.spring.io/milestone/org/springframework/</a></p>\n<h3 id=\"加入Spring的Jar包\"><a href=\"#加入Spring的Jar包\" class=\"headerlink\" title=\"加入Spring的Jar包\"></a>加入Spring的Jar包</h3><p>将Spring内libs目录下包含所有的jar包（不需要复制结尾为sources和javadoc的jar包）到项目的lib目录下。</p>\n<p>这里为了整合Struts还需要加入一个struts的包<br>记得加入struts-spring-plugin的jar包，不然struts无法使用spring管理的bean对象</p>\n<h3 id=\"创建Spring配置文件\"><a href=\"#创建Spring配置文件\" class=\"headerlink\" title=\"创建Spring配置文件\"></a>创建Spring配置文件</h3><p>编写Spring的配置文件applicationContext.xml。把该文件放在WEB-INF下，跟web.xml同目录。</p>\n<p>这里我们使用C3P0来管理数据池，所以把Hibernate内lib/optional/c3p0下的c3p0-0.9.1.jar复制到lib不目下。</p>\n<p>applicationContext的配置很复杂，所有的bean都配置在里面，如下</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans\"</span></span></div><div class=\"line\">\t<span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></div><div class=\"line\">\t<span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans</span></div><div class=\"line\">           http://www.springframework.org/schema/beans/spring-beans-3.0.xsd\"&gt;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">&lt;!-- 定义数据源的信息 --&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"dataSource\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.mchange.v2.c3p0.ComboPooledDataSource\"</span></span></div><div class=\"line\">\t\t<span class=\"attr\">destroy-method</span>=<span class=\"string\">\"close\"</span>&gt;</div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"driverClass\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>com.mysql.jdbc.Driver<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"jdbcUrl\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>jdbc:mysql://localhost:3306/test<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"user\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>root<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"password\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>zzw<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"maxPoolSize\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>80<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"minPoolSize\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>1<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"initialPoolSize\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>1<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"maxIdleTime\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>20<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">&lt;!--定义Hibernate的SessionFactory --&gt;</span></div><div class=\"line\">\t<span class=\"comment\">&lt;!-- SessionFactory使用的数据源为上面的数据源 --&gt;</span></div><div class=\"line\">\t<span class=\"comment\">&lt;!-- 指定了Hibernate的映射文件和配置信息 --&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"sessionFactory\"</span></span></div><div class=\"line\">\t\t<span class=\"attr\">class</span>=<span class=\"string\">\"org.springframework.orm.hibernate5.LocalSessionFactoryBean\"</span>&gt;</div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"dataSource\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">ref</span> <span class=\"attr\">local</span>=<span class=\"string\">\"dataSource\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"mappingResources\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">list</span>&gt;</span></div><div class=\"line\">\t\t\t\t<span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>com/helloworld/pojo/User.hbm.xml<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;/<span class=\"name\">list</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"hibernateProperties\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">props</span>&gt;</span></div><div class=\"line\">\t\t\t\t<span class=\"tag\">&lt;<span class=\"name\">prop</span> <span class=\"attr\">key</span>=<span class=\"string\">\"hibernate.dialect\"</span>&gt;</span>org.hibernate.dialect.MySQLDialect<span class=\"tag\">&lt;/<span class=\"name\">prop</span>&gt;</span></div><div class=\"line\">\t\t\t\t<span class=\"tag\">&lt;<span class=\"name\">prop</span> <span class=\"attr\">key</span>=<span class=\"string\">\"show_sql\"</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">prop</span>&gt;</span></div><div class=\"line\">\t\t\t\t<span class=\"tag\">&lt;<span class=\"name\">prop</span> <span class=\"attr\">key</span>=<span class=\"string\">\"hibernate.jdbc.batch_size\"</span>&gt;</span>20<span class=\"tag\">&lt;/<span class=\"name\">prop</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;/<span class=\"name\">props</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"transactionManager\"</span></span></div><div class=\"line\">\t\t<span class=\"attr\">class</span>=<span class=\"string\">\"org.springframework.orm.hibernate5.HibernateTransactionManager\"</span>&gt;</div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"sessionFactory\"</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"sessionFactory\"</span> /&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"userDao\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.helloworld.daoImpl.UserDao\"</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"sessionFactory\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">ref</span> <span class=\"attr\">bean</span>=<span class=\"string\">\"sessionFactory\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">&lt;!--用户注册业务逻辑类 --&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"userManager\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.helloworld.manager.UserManager\"</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"dao\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">ref</span> <span class=\"attr\">bean</span>=<span class=\"string\">\"userDao\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">&lt;!-- 用户注册的Action --&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"testAction\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.helloworld.action.TestAction\"</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"manager\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">ref</span> <span class=\"attr\">bean</span>=<span class=\"string\">\"userManager\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">&lt;!-- more bean definitions go here --&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>从配置文件我们看出，hibernate的datasource和session的配置完全被spring接管了，所以hibernate的配置文件是可以删掉的。</p>\n<h3 id=\"修改BaseDao和UserDao。\"><a href=\"#修改BaseDao和UserDao。\" class=\"headerlink\" title=\"修改BaseDao和UserDao。\"></a>修改BaseDao和UserDao。</h3><p>在引入Spring后，需要用Spring进行统一的事务管理，数据源和sessionFactory都交给Spring去生成，因此接口类和实现类BaseDao和UserDao都需要做相应的修改。Spring提供了HibernateDaoSupport类来完成对数据的操作，因此UserDao在实现BaseDao的同时还需要继承HibernateDaoSupport类。并将先前session的操作修改成HibernateTemplate（可通过getHibernateTemplate（）方法来获得）的操作。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> com.helloworld.dao;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> java.util.List;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> org.hibernate.HibernateException;</div><div class=\"line\"><span class=\"keyword\">import</span> org.hibernate.Session;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> com.helloworld.pojo.User;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">BaseDao</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">saveObject</span><span class=\"params\">(Object obj)</span> <span class=\"keyword\">throws</span> HibernateException</span>;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> List&lt;User&gt; <span class=\"title\">getUsers</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> HibernateException</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> com.helloworld.daoImpl;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> java.util.List;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> org.hibernate.HibernateException;</div><div class=\"line\"><span class=\"keyword\">import</span> org.springframework.orm.hibernate5.support.HibernateDaoSupport;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> com.helloworld.dao.BaseDao;</div><div class=\"line\"><span class=\"keyword\">import</span> com.helloworld.pojo.User;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserDao</span> <span class=\"keyword\">extends</span> <span class=\"title\">HibernateDaoSupport</span> <span class=\"keyword\">implements</span> <span class=\"title\">BaseDao</span></span>&#123;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">UserDao</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"UserDao IN\"</span>);</div><div class=\"line\">\t&#125;</div><div class=\"line\">  </div><div class=\"line\">    <span class=\"meta\">@Override</span>  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">saveObject</span><span class=\"params\">(Object obj)</span> <span class=\"keyword\">throws</span> HibernateException </span>&#123;  </div><div class=\"line\">    \tgetHibernateTemplate().save(obj);  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;User&gt; <span class=\"title\">getUsers</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> HibernateException</span>&#123;</div><div class=\"line\">    \tList&lt;User&gt; users=getHibernateTemplate().loadAll(User.class);</div><div class=\"line\">    \t<span class=\"keyword\">return</span> users;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>其实HibernateDaoSupport也没干什么大事，就是前面说的session的set get方法，既然每个DAO都需要，那spring就提出来了呗，没什么神秘的。</p>\n<h3 id=\"修改业务逻辑实现类\"><a href=\"#修改业务逻辑实现类\" class=\"headerlink\" title=\"修改业务逻辑实现类\"></a>修改业务逻辑实现类</h3><p>也就是Manager的类，跟DAO一样。在没有加入Spring之前，业务逻辑实现类的Session的获得，dao的实例化，以及事务的管理都是该类执行管理的。加入Spring后，这些都交给Spring去管理。该类的dao的实例化由Spring注入。</p>\n<h3 id=\"修改用户注册的testAction类\"><a href=\"#修改用户注册的testAction类\" class=\"headerlink\" title=\"修改用户注册的testAction类\"></a>修改用户注册的testAction类</h3><p>同样，testAction类中的userManager的实例化也由Spring注入。可以仔细理解一下上面的applicationContext的配置文件，你需要某个对象，只要把该对象配置成bean，比如下面这样</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"userManager\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.helloworld.manager.UserManager\"</span>&gt;</span></div><div class=\"line\">\t\t...</div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>然后用到这个bean的类配置成</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"testAction\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.helloworld.action.TestAction\"</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"manager\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">ref</span> <span class=\"attr\">bean</span>=<span class=\"string\">\"userManager\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>这样这个类里名字为manager的对象就会自动被注入userManager对象。记得需要有set方法，名字需对应。</p>\n<h3 id=\"删除多余类\"><a href=\"#删除多余类\" class=\"headerlink\" title=\"删除多余类\"></a>删除多余类</h3><p>删除Hibernate的配置文件Hibernate.cfg.xml和工厂类<br>HibernateSesseionFactory类。他们的工作已经交给Spring去做，已经不再有用。</p>\n<h3 id=\"修改web-xml\"><a href=\"#修改web-xml\" class=\"headerlink\" title=\"修改web.xml\"></a>修改web.xml</h3><p>加载Spring。要想启动时加载Spring的配置文件，需要在web.xml中配置对应的监听器（listenser），并指定Spring的配置文件。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">web-app</span> <span class=\"attr\">version</span>=<span class=\"string\">\"2.5\"</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://java.sun.com/xml/ns/javaee\"</span></span></div><div class=\"line\">    <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></div><div class=\"line\">    <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"http://java.sun.com/xml/ns/javaee </span></div><div class=\"line\">    http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\"&gt;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">listener</span>&gt;</span>  </div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class=\"tag\">&lt;/<span class=\"name\">listener-class</span>&gt;</span>  </div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">listener</span>&gt;</span> </div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">filter</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">filter-name</span>&gt;</span>struts2<span class=\"tag\">&lt;/<span class=\"name\">filter-name</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">filter-class</span>&gt;</span></div><div class=\"line\">           org.apache.struts2.dispatcher.filter.StrutsPrepareAndExecuteFilter</div><div class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">filter-class</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">filter</span>&gt;</span></div><div class=\"line\"> \t<span class=\"tag\">&lt;<span class=\"name\">filter-mapping</span>&gt;</span></div><div class=\"line\">  \t\t<span class=\"tag\">&lt;<span class=\"name\">filter-name</span>&gt;</span>struts2<span class=\"tag\">&lt;/<span class=\"name\">filter-name</span>&gt;</span></div><div class=\"line\">  \t\t<span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>/*<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span></div><div class=\"line\"> \t<span class=\"tag\">&lt;/<span class=\"name\">filter-mapping</span>&gt;</span></div><div class=\"line\"> \t</div><div class=\"line\"> \t</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">welcome-file-list</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">welcome-file</span>&gt;</span>index.jsp<span class=\"tag\">&lt;/<span class=\"name\">welcome-file</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">welcome-file-list</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">web-app</span>&gt;</span></div></pre></td></tr></table></figure>\n<h3 id=\"修改Struts的配置文件struts-xml\"><a href=\"#修改Struts的配置文件struts-xml\" class=\"headerlink\" title=\"修改Struts的配置文件struts.xml\"></a>修改Struts的配置文件struts.xml</h3><p>把原来指定的名为register的action的class由原来的路径变为applicationContext.xml文件中该bean的id名，不需要再用具体的包名+类名。</p>\n<p>包名加类名的方式会在每次访问的时候都生成一个action对应的对象，交给spring管理后，只会在最开始的时候生成一次。如下</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">action</span>  <span class=\"attr\">name</span> =<span class=\"string\">\"test\"</span>  <span class=\"attr\">class</span> =<span class=\"string\">\"testAction\"</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>整个项目配置之后结构如图</p>\n<p><img src=\"http://img.blog.csdn.net/20160922132809919?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p>在spring的配置中会遇到各种各样的问题，其他无非就是bean配置上写错了路径，类目，对象名，变量名，等等，所以仔细一点，认真检查一下，肯定能找到原因。</p>\n<p>到此为止，SSH框架已经搭建好了，但是据我所知，这套框架目前的使用率已经在降低了，有以下几个原因：</p>\n<ol>\n<li>struts除了可以做请求转发，还有页面标签，所以你如果只用请求转发的话，这个框架有点多余</li>\n<li>现在spring推出了springMVC，是专门做请求转发用的，因为是spring自家推出的，所以和spring的协调性更好，而且在我使用中也感觉springMVC用起来更方便，轻量级</li>\n<li>HIbernate框架管理数据库很强大，但是同样的问题，重量级。目前因为移动应用的兴起，请求并发量暴增的问题，Mybatis框架对于数据库管理更轻量级，更灵活。这两个框架说不上孰优孰劣，大家可以看下资料。</li>\n</ol>\n<p>所以在下一篇文章中，准备先用SpringMVC代替struts。敬请期待</p>\n","excerpt":"","more":"<p>现在在学习后端框架，最后的目标是希望搭建一个基于spring mvc + mybatis + spring的框架，因为之前接触过SSH，所以想从SSH开始，慢慢演化，也巩固一下自己的知识。<br>之前每次搭建SSH框架都要在网上查各种资料，而且我也发现各种资料基于的SSH版本都比较老，新版本就会遇到各种各样的问题，所以基于这次的搭建流程，写一下遇到的问题和解决方法。</p>\n<h2 id=\"Contents\"><a href=\"#Contents\" class=\"headerlink\" title=\"Contents\"></a>Contents</h2><ul>\n<li><a href=\"#Contents\">Contents</a></li>\n<li><a href=\"#基础需求\">基础需求</a></li>\n<li><a href=\"#配置Struts框架\">配置Struts框架</a></li>\n<li><a href=\"#搭建Hibernate框架\">搭建Hibernate框架</a></li>\n<li><a href=\"#dao\">DAO设计模型</a></li>\n<li><a href=\"#搭建Spring框架，整合Struts和Hibernate\">搭建Spring框架，整合Struts和Hibernate</a></li>\n</ul>\n<h2 id=\"基础需求\"><a href=\"#基础需求\" class=\"headerlink\" title=\"基础需求\"></a>基础需求</h2><h3 id=\"下载-Eclipse-J2EE版\"><a href=\"#下载-Eclipse-J2EE版\" class=\"headerlink\" title=\"下载 Eclipse J2EE版\"></a>下载 Eclipse J2EE版</h3><p>J2EE版带server和maven的配置，用起来比较方便，其他也没什么区别，普通版装插件也是可以达到一样效果的</p>\n<h3 id=\"下载tomcat\"><a href=\"#下载tomcat\" class=\"headerlink\" title=\"下载tomcat\"></a>下载tomcat</h3><p>目前Eclipse J2EE版的server只支持tomcat 8 以下版本，我试过8.5.5也不支持，所以最好下7</p>\n<h3 id=\"安装mysql\"><a href=\"#安装mysql\" class=\"headerlink\" title=\"安装mysql\"></a>安装mysql</h3><p>具体流程可以从网上找，这个简单</p>\n<p>创建数据库 create database test；</p>\n<p>创建表<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\">create table <span class=\"title\">user</span><span class=\"params\">(</div><div class=\"line\"> userId <span class=\"keyword\">int</span> auto_increment,  </div><div class=\"line\"> userName varchar(<span class=\"number\">16</span>)</span> not <span class=\"keyword\">null</span>,  </div><div class=\"line\"> password <span class=\"title\">varchar</span><span class=\"params\">(<span class=\"number\">16</span>)</span> not <span class=\"keyword\">null</span>,  </div><div class=\"line\"> gender <span class=\"keyword\">int</span> not <span class=\"keyword\">null</span>,  </div><div class=\"line\"> primary <span class=\"title\">key</span><span class=\"params\">(userId)</span>  </div><div class=\"line\">)</span>;</div></pre></td></tr></table></figure></p>\n<h2 id=\"配置Struts框架\"><a href=\"#配置Struts框架\" class=\"headerlink\" title=\"配置Struts框架\"></a>配置Struts框架</h2><h3 id=\"安装struts的jar包\"><a href=\"#安装struts的jar包\" class=\"headerlink\" title=\"安装struts的jar包\"></a>安装struts的jar包</h3><p>下载struts-2.5.2包</p>\n<p>将包下面lib目录下的以下文件拷贝到项目的WEB-INF/lib下面，当然这里要先创建一个Dynamic Web Project，这个也简单，在Eclipse中点下一步下一步下一步就可以。</p>\n<p>为什么是放在WEB-INF/lib下，而不放在项目的lib下，这是因为，web项目在发布后依赖包是去寻找WEB-INF目录下的各种包的。这里我后面遇到一个奇怪的问题，也加深了对这个配置的理解，具体什么问题以后再说。然后你把包放在WEB-INF/lib下的时候，eclipse会自动拷贝一份到项目的lib下，方便编程时候的依赖。</p>\n<p><img src=\"http://img.blog.csdn.net/20160922112818884?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<h3 id=\"创建web-xml\"><a href=\"#创建web-xml\" class=\"headerlink\" title=\"创建web.xml\"></a>创建web.xml</h3><p>在WEB-INF下面创建web.xml，配置struts监听，这个web.xml其实就是整个web项目的入口，所有的配置都是从这里开始，再跳转的其他地方。格式如下</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">web-app</span> <span class=\"attr\">version</span>=<span class=\"string\">\"2.5\"</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://java.sun.com/xml/ns/javaee\"</span></div><div class=\"line\">    <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></div><div class=\"line\">    <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"http://java.sun.com/xml/ns/javaee </div><div class=\"line\">    http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">filter</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">filter-name</span>&gt;</span>struts2<span class=\"tag\">&lt;/<span class=\"name\">filter-name</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">filter-class</span>&gt;</span></div><div class=\"line\">           org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter</div><div class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">filter-class</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">filter</span>&gt;</span></div><div class=\"line\"> \t<span class=\"tag\">&lt;<span class=\"name\">filter-mapping</span>&gt;</span></div><div class=\"line\">  \t\t<span class=\"tag\">&lt;<span class=\"name\">filter-name</span>&gt;</span>struts2<span class=\"tag\">&lt;/<span class=\"name\">filter-name</span>&gt;</span></div><div class=\"line\">  \t\t<span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>/*<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span></div><div class=\"line\">  \t\t<span class=\"comment\">&lt;!--注意：千万不能写成：*.action ，如果需要：*.action应该配置在struts.xml中--&gt;</span></div><div class=\"line\"> \t<span class=\"tag\">&lt;/<span class=\"name\">filter-mapping</span>&gt;</span></div><div class=\"line\"> </div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">welcome-file-list</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">welcome-file</span>&gt;</span>index.jsp<span class=\"tag\">&lt;/<span class=\"name\">welcome-file</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">welcome-file-list</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">web-app</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>其实熟悉j2ee的人知道，在struts之前，j2ee最基本的跳转是用servlet来做的，struts其实也要基于servlet来做，配置一个filter，name随意。然后在filter-mapping里配置满足一定条件的url请求都交给这个filter来处理，其实也就是struts来处理。这里我们配置为/*，也就是所有的请求都转发给struts处理，这是最简单的，如果需要特殊配置可以在这里再配置。</p>\n<p>另外也要注意/<em> 和 /的区别，按照我个人的理解/</em>是所有的请求，包括/test.jsp和/test.html这种带后缀名的请求。/是不带后缀名的所有请求，像/test这样的。</p>\n<h3 id=\"创建struts-xml\"><a href=\"#创建struts-xml\" class=\"headerlink\" title=\"创建struts.xml\"></a>创建struts.xml</h3><p>然后所有的请求都给struts处理了，struts本身肯定还需要一个配置文件，来转发各种请求到相应的处理类，这个配置文件是struts.xml，放在src文件夹下，前面说过，web项目的配置文件都是在web-inf下面，为什么这个放在src文件夹下呢，这里就要说到一个eclipse发布映射的问题。</p>\n<p>你项目里点右键，选属性，选Deployment Assembly，可以看到这是发包时候的映射关系，src文件夹会发布到WEB-INF/classes，而struts会默认到这个文件夹下面找配置文件。</p>\n<p><img src=\"http://img.blog.csdn.net/20160922122622832?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p>回到正题，说一下struts的配置文件，格式如下</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;</div><div class=\"line\"><span class=\"meta\">&lt;!DOCTYPE struts PUBLIC \"-//Apache Software Foundation//DTD Struts Configuration 2.0//EN\" \"http://struts.apache.org/dtds/struts-2.0.dtd\" &gt;</span>  </div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">struts</span>&gt;</span>  </div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">package</span>  <span class=\"attr\">name</span> =<span class=\"string\">\"user_curd\"</span>  <span class=\"attr\">extends</span> =<span class=\"string\">\"struts-default\"</span>  &gt;</span>  </div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">global-results</span>&gt;</span>  </div><div class=\"line\">            <span class=\"comment\">&lt;!--  下面定义的结果对所有的Action都有效  --&gt;</span>  </div><div class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">result</span>  <span class=\"attr\">name</span> =<span class=\"string\">\"exception\"</span>&gt;</span> /error.jsp <span class=\"tag\">&lt;/<span class=\"name\">result</span>&gt;</span>  </div><div class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">global-results</span>&gt;</span>  </div><div class=\"line\">  </div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">global-exception-mappings</span>&gt;</span>  </div><div class=\"line\">            <span class=\"comment\">&lt;!--  指Action抛出Exception异常时，转入名为exception的结果。  --&gt;</span>  </div><div class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">exception-mapping</span>  <span class=\"attr\">exception</span> =<span class=\"string\">\"java.lang.Exception\"</span>  <span class=\"attr\">result</span> =<span class=\"string\">\"exception\"</span> /&gt;</span>  </div><div class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">global-exception-mappings</span>&gt;</span>  </div><div class=\"line\">  </div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">action</span>  <span class=\"attr\">name</span> =<span class=\"string\">\"test\"</span>  <span class=\"attr\">class</span> =<span class=\"string\">\"TestAction\"</span>&gt;</span>  </div><div class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">action</span>&gt;</span>  </div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">package</span>&gt;</span>    </div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">struts</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>配置文件很好懂，下面的action部分就是请求转发，url中对\\test的请求会转发到TestAction中处理</p>\n<h3 id=\"创建Action类\"><a href=\"#创建Action类\" class=\"headerlink\" title=\"创建Action类\"></a>创建Action类</h3><p>创建Action处理类，前面也说过了，请求会转发到某个类中进行处理，很显然，我们需要定义这样的类<br>在src中创建相应的类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> com.helloworld.test;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> java.io.PrintWriter;</div><div class=\"line\"><span class=\"keyword\">import</span> java.util.Date;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> org.apache.struts2.ServletActionContext;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> com.opensymphony.xwork2.ActionSupport;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestAction</span> <span class=\"keyword\">extends</span> <span class=\"title\">ActionSupport</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">private</span> String contentType = <span class=\"string\">\"text/html;charset=utf-8\"</span>;     </div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">execute</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception</div><div class=\"line\">\t</span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//指定输出内容类型和编码  </span></div><div class=\"line\">        ServletActionContext.getResponse().setContentType(contentType);   </div><div class=\"line\">        <span class=\"comment\">//获取输出流，然后使用  </span></div><div class=\"line\">        PrintWriter out = ServletActionContext.getResponse().getWriter();   </div><div class=\"line\">        <span class=\"keyword\">try</span>&#123;  </div><div class=\"line\">            <span class=\"comment\">//输出文本信息  </span></div><div class=\"line\">            out.print(<span class=\"string\">\"Hello World\"</span>);  </div><div class=\"line\">            out.print(<span class=\"string\">\"Time: \"</span> + (<span class=\"keyword\">new</span> Date()).getTime());   </div><div class=\"line\">            out.flush();  </div><div class=\"line\">            out.close();  </div><div class=\"line\">        &#125;<span class=\"keyword\">catch</span>(Exception ex)&#123;  </div><div class=\"line\">            out.println(ex.toString());  </div><div class=\"line\">        &#125;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> SUCCESS;  </div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>execute方法就是处理请求的方法，具体的使用可以再查相关资料，本文只介绍搭建框架</p>\n<h3 id=\"发包运行\"><a href=\"#发包运行\" class=\"headerlink\" title=\"发包运行\"></a>发包运行</h3><p>此时访问test应该会跳转到该类，然后输出信息</p>\n<h3 id=\"配置Struts时遇到的问题：\"><a href=\"#配置Struts时遇到的问题：\" class=\"headerlink\" title=\"配置Struts时遇到的问题：\"></a>配置Struts时遇到的问题：</h3><h4 id=\"问题1\"><a href=\"#问题1\" class=\"headerlink\" title=\"问题1\"></a>问题1</h4><p>java.lang.ClassNotFoundException: org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter<br>最新的Struts框架处理类的包名变了，其实碰到这类问题，自己去lib中看下类所在的位置就可以，每次版本更新可能会变一些东西</p>\n<p><img src=\"http://img.blog.csdn.net/20160922123903227?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<h4 id=\"错误2\"><a href=\"#错误2\" class=\"headerlink\" title=\"错误2\"></a>错误2</h4><p>java.util.concurrent.ExecutionException: org.apache.catalina.LifecycleException: Failed to start component [StandardEngine[Catalina].StandardHost[localhost].StandardContext[/helloworld]]</p>\n<p>这是因为lib包多了或少了，参照我前面lib库的文件，检查一下</p>\n<h4 id=\"错误3\"><a href=\"#错误3\" class=\"headerlink\" title=\"错误3\"></a>错误3</h4><p>Unable to load configuration. - bean - jar:file:/Users/zzw/Documents/j2eeworkspace/.metadata/.plugins/org.eclipse.wst.server.core/tmp0/wtpwebapps/helloworld/WEB-INF/lib/struts2-gxp-plugin-2.5.2.jar!/struts-plugin.xml:8:162</p>\n<p>和上个问题一样，这是因为引用包多了，其实不要觉得我把所有包都放进了就行了，如果包多了会做一些初始化的工作，而初始化的过程中就容易有问题</p>\n<p>访问<a href=\"http://localhost:8080/helloworld/test成功\">http://localhost:8080/helloworld/test成功</a></p>\n<h2 id=\"搭建Hibernate框架\"><a href=\"#搭建Hibernate框架\" class=\"headerlink\" title=\"搭建Hibernate框架\"></a>搭建Hibernate框架</h2><p>Struts到目前为止就算成功了，接下来我们看引入Hibernate框架</p>\n<h3 id=\"官网下载hibernate-5-2-2\"><a href=\"#官网下载hibernate-5-2-2\" class=\"headerlink\" title=\"官网下载hibernate 5.2.2\"></a>官网下载hibernate 5.2.2</h3><h3 id=\"下载JDBC\"><a href=\"#下载JDBC\" class=\"headerlink\" title=\"下载JDBC\"></a>下载JDBC</h3><p><a href=\"http://www.mysql.com/products/connector/\">http://www.mysql.com/products/connector/</a> 下载jdbc</p>\n<h3 id=\"配置Hibernate的Jar包\"><a href=\"#配置Hibernate的Jar包\" class=\"headerlink\" title=\"配置Hibernate的Jar包\"></a>配置Hibernate的Jar包</h3><p>拷贝lib\\required下的jar包到WEB-INFO\\lib目录下，Hibernate就很好，把所有需要的包都放在了required文件夹下</p>\n<h3 id=\"创建hibernate-cfg-xml\"><a href=\"#创建hibernate-cfg-xml\" class=\"headerlink\" title=\"创建hibernate.cfg.xml\"></a>创建hibernate.cfg.xml</h3><p>创建hibernate的配置文件hibernate.cfg.xml，配置数据库连接等等，也是在src目录下，格式如下</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&lt;!DOCTYPE hibernate-configuration PUBLIC</div><div class=\"line\">\t\"-//Hibernate/Hibernate Configuration DTD 3.0//EN\"</div><div class=\"line\">\t\"http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd\"&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">hibernate-configuration</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">session-factory</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"hibernate.connection.driver_class\"</span>&gt;</span>com.mysql.jdbc.Driver<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"hibernate.connection.url\"</span>&gt;</span>jdbc:mysql://localhost:3306/User<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"hibernate.connection.username\"</span>&gt;</span>root<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"hibernate.connection.password\"</span>&gt;</span>123<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"hibernate.dialect\"</span>&gt;</span>org.hibernate.dialect.MySQLDialect<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">session-factory</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">hibernate-configuration</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>这是最简单的配置，连接数据库的</p>\n<h3 id=\"创建实体类\"><a href=\"#创建实体类\" class=\"headerlink\" title=\"创建实体类\"></a>创建实体类</h3><p>我们都知道hibernate是实体-关系映射，所以要创建实体类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> com.helloworld.test;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> userId;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">private</span> String userName;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">private</span> String passWord;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> gender;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getUserId</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> userId;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setUserId</span><span class=\"params\">(<span class=\"keyword\">int</span> userId)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.userId = userId;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getUserName</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> userName;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setUserName</span><span class=\"params\">(String userName)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.userName = userName;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getPassWord</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> passWord;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setPassWord</span><span class=\"params\">(String passWord)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.passWord = passWord;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getGender</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> gender;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setGender</span><span class=\"params\">(<span class=\"keyword\">int</span> gender)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.gender = gender;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>就是对应数据库中一个表</p>\n<h3 id=\"配置映射关系\"><a href=\"#配置映射关系\" class=\"headerlink\" title=\"配置映射关系\"></a>配置映射关系</h3><p>明显，这个实体类和表的映射关系也需要配置<br>添加User.hbm.xml文件映射表结构</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;?xml version=\"1.0\"?&gt;</div><div class=\"line\"><span class=\"meta\">&lt;!DOCTYPE hibernate-mapping PUBLIC </div><div class=\"line\">\t\"-//Hibernate/Hibernate Mapping DTD 3.0//EN\"</div><div class=\"line\">\t\"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd\"&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">hibernate-mapping</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">class</span> <span class=\"attr\">name</span>=<span class=\"string\">\"com.helloworld.test.User\"</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">id</span> <span class=\"attr\">name</span>=<span class=\"string\">\"userId\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">generator</span> <span class=\"attr\">class</span>=<span class=\"string\">\"increment\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">id</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"userName\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"passWord\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"gender\"</span> /&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">class</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">hibernate-mapping</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>这个映射关系配置文件可以放在任何地方，因为下一步我们会在hibernate.xml配置文件中声明这个文件的位置，我目前是放在和User类一起的位置。</p>\n<h3 id=\"添加映射关系\"><a href=\"#添加映射关系\" class=\"headerlink\" title=\"添加映射关系\"></a>添加映射关系</h3><p>按照上一步所说，我们需要把映射关系配置文件的路径配置到hibernate.cfg.xml中去，如下：要写清楚包名，位置，就mapping配置的那部分，如果有多个映射，依次添加</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&lt;!DOCTYPE hibernate-configuration PUBLIC</div><div class=\"line\">\t\"-//Hibernate/Hibernate Configuration DTD 3.0//EN\"</div><div class=\"line\">\t\"http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd\"&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">hibernate-configuration</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">session-factory</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"hibernate.connection.driver_class\"</span>&gt;</span>com.mysql.jdbc.Driver<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"hibernate.connection.url\"</span>&gt;</span>jdbc:mysql://localhost:3306/test<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"hibernate.connection.username\"</span>&gt;</span>root<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"hibernate.connection.password\"</span>&gt;</span>zzw<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"hibernate.dialect\"</span>&gt;</span>org.hibernate.dialect.MySQLDialect<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"hibernate.show_sql\"</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span>  </div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"hibernate.format_sql\"</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span>  </div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">mapping</span> <span class=\"attr\">resource</span>=<span class=\"string\">\"com/helloworld/test/User.hbm.xml\"</span>/&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">session-factory</span>&gt;</span></div><div class=\"line\">\t</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">hibernate-configuration</span>&gt;</span></div></pre></td></tr></table></figure>\n<h3 id=\"测试运行\"><a href=\"#测试运行\" class=\"headerlink\" title=\"测试运行\"></a>测试运行</h3><p>Hibernate不需要发包web项目，可以本地测试，写一个Test类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> com.helloworld.test;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> java.util.List;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> org.hibernate.Session;</div><div class=\"line\"><span class=\"keyword\">import</span> org.hibernate.SessionFactory;</div><div class=\"line\"><span class=\"keyword\">import</span> org.hibernate.cfg.Configuration;</div><div class=\"line\"><span class=\"keyword\">import</span> org.hibernate.query.Query;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HibernateTest</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//读取hibernate.cfg.xml文件  </span></div><div class=\"line\">        Configuration cfg = <span class=\"keyword\">new</span> Configuration().configure();  </div><div class=\"line\">          </div><div class=\"line\">        <span class=\"comment\">//建立SessionFactory  </span></div><div class=\"line\">        SessionFactory factory = cfg.buildSessionFactory();  </div><div class=\"line\">          </div><div class=\"line\">        <span class=\"comment\">//取得session  </span></div><div class=\"line\">        Session session = <span class=\"keyword\">null</span>;  </div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;  </div><div class=\"line\">            session = factory.openSession();  </div><div class=\"line\">            <span class=\"comment\">//开启事务  </span></div><div class=\"line\">            session.beginTransaction();  </div><div class=\"line\">            User user = <span class=\"keyword\">new</span> User();  </div><div class=\"line\">            user.setUserName(<span class=\"string\">\"zzw\"</span>); </div><div class=\"line\">            user.setPassWord(<span class=\"string\">\"zzw\"</span>);  </div><div class=\"line\">              </div><div class=\"line\">            <span class=\"comment\">//保存User对象  </span></div><div class=\"line\">            session.save(user);   </div><div class=\"line\">            String hql = <span class=\"string\">\"from User\"</span>;  </div><div class=\"line\">            Query query = session.createQuery(hql);  </div><div class=\"line\">            List&lt;User&gt; roles = query.list();</div><div class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;roles.size();i++)&#123;</div><div class=\"line\">            \tSystem.out.print(<span class=\"string\">\"从数据库加载数据的用户名为\"</span>+roles.get(i).getUserName());  </div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"comment\">//提交事务  </span></div><div class=\"line\">            session.getTransaction().commit();  </div><div class=\"line\">        &#125;<span class=\"keyword\">catch</span>(Exception e) &#123;  </div><div class=\"line\">            e.printStackTrace();  </div><div class=\"line\">            <span class=\"comment\">//回滚事务  </span></div><div class=\"line\">            session.getTransaction().rollback();  </div><div class=\"line\">        &#125;<span class=\"keyword\">finally</span> &#123;  </div><div class=\"line\">            <span class=\"keyword\">if</span> (session != <span class=\"keyword\">null</span>) &#123;  </div><div class=\"line\">                <span class=\"keyword\">if</span> (session.isOpen()) &#123;  </div><div class=\"line\">                    <span class=\"comment\">//关闭session  </span></div><div class=\"line\">                    session.close();  </div><div class=\"line\">                &#125;  </div><div class=\"line\">            &#125;  </div><div class=\"line\">        &#125;  </div><div class=\"line\"></div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>执行成功，这样的话Hibernate框架也算搭建完成了。</p>\n<h2 id=\"DAO设计模型\"><a href=\"#DAO设计模型\" class=\"headerlink\" title=\"DAO设计模型\"></a>DAO设计模型</h2><p>提到Hibernate不得不提的是DAO设计模型，为了下一步Spring的配置更加清楚明了，这里我们也采用DAO的设计模型</p>\n<h3 id=\"基础概念\"><a href=\"#基础概念\" class=\"headerlink\" title=\"基础概念\"></a>基础概念</h3><p>这里讲几个概念<br>POJO（Plain Ordinary Java Object）简单的Java对象，实际就是普通JavaBeans，是为了避免和EJB混淆所创造的简称。这里POJO其实就是User类<br>DAO (Data Access Object)是一个数据访问接口，数据访问：顾名思义就是与数据库打交道。夹在业务逻辑与数据库资源中间。</p>\n<p>简单一点说，就是把数据库相关操作提到DAO中进行，与业务有关的逻辑放在Manager中，为了分层编程。举个例子来说，比如用户注册这个功能，用户注册的页面显示由RegisterAction负责，Action类中有Manager负责具体的业务，RegisterManager中有具体的业务方法register，Manager中有与数据库打交道的DAO类，RegisterManager中应该有UserDAO，负责所有对User表的操作，比如addUser，deleteUser等。这样说应该很容易理解吧，这是一种分层编程的思想，可以降低各个模块之间的耦合度，比如如果你想把用户注册改成管理员注册，只需要把UserDAO改成managerDAO就可以操作manager表了。就这样。DAO设计模式也是很推崇面向接口的编程，下面我用代码为大家讲解。</p>\n<h3 id=\"DAO类\"><a href=\"#DAO类\" class=\"headerlink\" title=\"DAO类\"></a>DAO类</h3><p>1，首先声明接口</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> com.helloworld.dao;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> org.hibernate.HibernateException;</div><div class=\"line\"><span class=\"keyword\">import</span> org.hibernate.Session;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">BaseDao</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">saveObject</span><span class=\"params\">(Object obj)</span> <span class=\"keyword\">throws</span> HibernateException</span>;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> Session <span class=\"title\">getSession</span><span class=\"params\">()</span></span>;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setSession</span><span class=\"params\">(Session session)</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>跟数据库打交道需要获取hibernate的session，所以一个简单的base接口就是几个获取session的方法</p>\n<p>然后我们定义HibernateSessionFactory用于在各个DAO中获取Session</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> com.helloworld.daoImpl;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> org.hibernate.HibernateException;</div><div class=\"line\"><span class=\"keyword\">import</span> org.hibernate.Session;</div><div class=\"line\"><span class=\"keyword\">import</span> org.hibernate.SessionFactory;</div><div class=\"line\"><span class=\"keyword\">import</span> org.hibernate.boot.Metadata;</div><div class=\"line\"><span class=\"keyword\">import</span> org.hibernate.boot.MetadataSources;</div><div class=\"line\"><span class=\"keyword\">import</span> org.hibernate.boot.model.naming.ImplicitNamingStrategyJpaCompliantImpl;</div><div class=\"line\"><span class=\"keyword\">import</span> org.hibernate.boot.registry.StandardServiceRegistry;</div><div class=\"line\"><span class=\"keyword\">import</span> org.hibernate.boot.registry.StandardServiceRegistryBuilder;</div><div class=\"line\"><span class=\"keyword\">import</span> org.hibernate.cfg.Configuration;</div><div class=\"line\"><span class=\"keyword\">import</span> org.hibernate.service.ServiceRegistry;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HibernateSessionFactory</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String CFG_FILE_LOCATION = <span class=\"string\">\"/Hibernate.cfg.xml\"</span>;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ThreadLocal&lt;Session&gt; threadLocal = <span class=\"keyword\">new</span> ThreadLocal&lt;Session&gt;();</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Configuration cfg = <span class=\"keyword\">new</span> Configuration()</div><div class=\"line\">\t\t\t.configure(CFG_FILE_LOCATION);</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> ServiceRegistry registry;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> SessionFactory sessionFactory;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Session <span class=\"title\">currentSession</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> HibernateException </span>&#123;</div><div class=\"line\">\t\tSession session = threadLocal.get();</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"keyword\">if</span> (session == <span class=\"keyword\">null</span> || session.isOpen() == <span class=\"keyword\">false</span>) &#123;</div><div class=\"line\"></div><div class=\"line\">\t\t\t<span class=\"keyword\">if</span> (sessionFactory == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">\t\t\t\tStandardServiceRegistry standardRegistry = <span class=\"keyword\">new</span> StandardServiceRegistryBuilder()</div><div class=\"line\">\t\t\t\t\t\t.configure().build();</div><div class=\"line\">\t\t\t\tMetadata metadata = <span class=\"keyword\">new</span> MetadataSources(standardRegistry)</div><div class=\"line\">\t\t\t\t\t\t.getMetadataBuilder()</div><div class=\"line\">\t\t\t\t\t\t.applyImplicitNamingStrategy(</div><div class=\"line\">\t\t\t\t\t\t\t\tImplicitNamingStrategyJpaCompliantImpl.INSTANCE)</div><div class=\"line\">\t\t\t\t\t\t.build();</div><div class=\"line\">\t\t\t\tsessionFactory = metadata</div><div class=\"line\">\t\t\t\t\t\t.getSessionFactoryBuilder().build();</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\t\tsession = sessionFactory.openSession();</div><div class=\"line\">\t\t\tthreadLocal.set(session);</div><div class=\"line\"></div><div class=\"line\">\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"keyword\">return</span> session;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">closeSession</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> HibernateException </span>&#123;</div><div class=\"line\">\t\tSession session = threadLocal.get();</div><div class=\"line\">\t\tthreadLocal.set(<span class=\"keyword\">null</span>);</div><div class=\"line\">\t\t<span class=\"keyword\">if</span> (session != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">\t\t\tsession.close();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>下面是跟User表打交道的UserDao</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> com.helloworld.daoImpl;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> org.hibernate.HibernateException;</div><div class=\"line\"><span class=\"keyword\">import</span> org.hibernate.Session;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> com.helloworld.dao.BaseDao;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserDao</span> <span class=\"keyword\">implements</span> <span class=\"title\">BaseDao</span></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">private</span> Session session;  </div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">UserDao</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\tsession=HiberanateSessionFactory.currentSession();</div><div class=\"line\">       &#125;  </div><div class=\"line\">    <span class=\"meta\">@Override</span>  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Session <span class=\"title\">getSession</span><span class=\"params\">()</span> </span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">return</span> session;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">  </div><div class=\"line\">    <span class=\"meta\">@Override</span>  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setSession</span><span class=\"params\">(Session session)</span> </span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">this</span>.session = session;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">  </div><div class=\"line\">    <span class=\"meta\">@Override</span>  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">saveObject</span><span class=\"params\">(Object obj)</span> <span class=\"keyword\">throws</span> HibernateException </span>&#123;  </div><div class=\"line\">        session.save(obj);  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"业务逻辑类\"><a href=\"#业务逻辑类\" class=\"headerlink\" title=\"业务逻辑类\"></a>业务逻辑类</h3><p>然后声明业务逻辑类UserManager，这里我只是举个最简单的例子,直接调用了DAO的getUsers方法，不要觉得没用，在日常事务中，我们需要在DAO方法前后做些处理，都是要在Manager中进行处理的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> com.helloworld.manager;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> java.util.List;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> org.hibernate.HibernateException;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> com.helloworld.dao.BaseDao;</div><div class=\"line\"><span class=\"keyword\">import</span> com.helloworld.daoImpl.UserDao;</div><div class=\"line\"><span class=\"keyword\">import</span> com.helloworld.pojo.User;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserManager</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">private</span> BaseDao dao;  </div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">UserManager</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\tdao = <span class=\"keyword\">new</span> UserDao();</div><div class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"UserManager IN\"</span>);</div><div class=\"line\">\t&#125;</div><div class=\"line\">   </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> BaseDao <span class=\"title\">getDao</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> dao;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setDao</span><span class=\"params\">(BaseDao dao)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.dao = dao;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> List&lt;User&gt; <span class=\"title\">getUsers</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> HibernateException </span>&#123;  </div><div class=\"line\">    \t<span class=\"keyword\">return</span> dao.getUsers();</div><div class=\"line\">    &#125; </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这时候就可以在测试类里用manager对象进行数据库操作了。比如</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> com.helloworld.test;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> java.util.List;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> org.hibernate.Session;</div><div class=\"line\"><span class=\"keyword\">import</span> org.hibernate.SessionFactory;</div><div class=\"line\"><span class=\"keyword\">import</span> org.hibernate.cfg.Configuration;</div><div class=\"line\"><span class=\"keyword\">import</span> org.hibernate.query.Query;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> com.helloworld.dao.BaseDao;</div><div class=\"line\"><span class=\"keyword\">import</span> com.helloworld.daoImpl.HibernateSessionFactory;</div><div class=\"line\"><span class=\"keyword\">import</span> com.helloworld.daoImpl.UserDao;</div><div class=\"line\"><span class=\"keyword\">import</span> com.helloworld.manager.UserManager;</div><div class=\"line\"><span class=\"keyword\">import</span> com.helloworld.pojo.User;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HibernateTest</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">\t\tUserManager userManager=<span class=\"keyword\">new</span> UserManager();</div><div class=\"line\">        userManager.getUsers()</div><div class=\"line\"></div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>DAO模型介绍到这。</p>\n<h2 id=\"搭建Spring框架，整合Struts和Hibernate\"><a href=\"#搭建Spring框架，整合Struts和Hibernate\" class=\"headerlink\" title=\"搭建Spring框架，整合Struts和Hibernate\"></a>搭建Spring框架，整合Struts和Hibernate</h2><p>接下来用spring整合struts和hibernate</p>\n<p>前面提到的DAO设计模式，在用到的时候new 一个DAO对象进行数据库操作，这是最简单的，但是你想想这样会浪费时间，浪费内存，因为没进行一次访问都要生成一个新的对象，其实全局都可以用一个DAO对象。Spring是干嘛的，Spring有两大特性，IoC和AoP，其中IoC中的一种方式便是依赖注入，Spring全局管理一些Bean，像Session，dao都可以是bean，然后你需要的时候就给你注入，这就是依赖注入。其他的特性可以自行百度，另外Spring其实是一套门路很深的框架，不然也不会在Struts和Hibernate都渐渐退居二线的时候，它依然坚挺在第一线。有机会我准备仔细看下Spring的实现原理，与大家分享一下。</p>\n<p>总而言之，整个Spring的配置过程其实就是，配置bean，然后把bean配置到各个类中这样。</p>\n<h3 id=\"下载4-3-2release的spring\"><a href=\"#下载4-3-2release的spring\" class=\"headerlink\" title=\"下载4.3.2release的spring\"></a>下载4.3.2release的spring</h3><p>Spring官网改版后找了好久都没有找到直接下载Jar包的链接,下面汇总些网上提供的方法,亲测可用.</p>\n<p>直接输入地址,改相应版本即可:<a href=\"http://repo.springsource.org/libs-release-local/org/springframework/spring/3.2.4.RELEASE/spring-framework-3.2.4.RELEASE-dist.zip\">http://repo.springsource.org/libs-release-local/org/springframework/spring/3.2.4.RELEASE/spring-framework-3.2.4.RELEASE-dist.zip</a></p>\n<p>在1的方法上输入前面部分,有个树形结构可供选择:<a href=\"http://repo.springsource.org/libs-release-local/org/springframework/spring/\">http://repo.springsource.org/libs-release-local/org/springframework/spring/</a></p>\n<p>同样的,,有树形结构选择需要的包下载:<a href=\"http://repo.spring.io/milestone/org/springframework/\">http://repo.spring.io/milestone/org/springframework/</a></p>\n<h3 id=\"加入Spring的Jar包\"><a href=\"#加入Spring的Jar包\" class=\"headerlink\" title=\"加入Spring的Jar包\"></a>加入Spring的Jar包</h3><p>将Spring内libs目录下包含所有的jar包（不需要复制结尾为sources和javadoc的jar包）到项目的lib目录下。</p>\n<p>这里为了整合Struts还需要加入一个struts的包<br>记得加入struts-spring-plugin的jar包，不然struts无法使用spring管理的bean对象</p>\n<h3 id=\"创建Spring配置文件\"><a href=\"#创建Spring配置文件\" class=\"headerlink\" title=\"创建Spring配置文件\"></a>创建Spring配置文件</h3><p>编写Spring的配置文件applicationContext.xml。把该文件放在WEB-INF下，跟web.xml同目录。</p>\n<p>这里我们使用C3P0来管理数据池，所以把Hibernate内lib/optional/c3p0下的c3p0-0.9.1.jar复制到lib不目下。</p>\n<p>applicationContext的配置很复杂，所有的bean都配置在里面，如下</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans\"</span></div><div class=\"line\">\t<span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></div><div class=\"line\">\t<span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans</div><div class=\"line\">           http://www.springframework.org/schema/beans/spring-beans-3.0.xsd\"</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">&lt;!-- 定义数据源的信息 --&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"dataSource\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.mchange.v2.c3p0.ComboPooledDataSource\"</span></div><div class=\"line\">\t\t<span class=\"attr\">destroy-method</span>=<span class=\"string\">\"close\"</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"driverClass\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>com.mysql.jdbc.Driver<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"jdbcUrl\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>jdbc:mysql://localhost:3306/test<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"user\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>root<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"password\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>zzw<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"maxPoolSize\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>80<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"minPoolSize\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>1<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"initialPoolSize\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>1<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"maxIdleTime\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>20<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">&lt;!--定义Hibernate的SessionFactory --&gt;</span></div><div class=\"line\">\t<span class=\"comment\">&lt;!-- SessionFactory使用的数据源为上面的数据源 --&gt;</span></div><div class=\"line\">\t<span class=\"comment\">&lt;!-- 指定了Hibernate的映射文件和配置信息 --&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"sessionFactory\"</span></div><div class=\"line\">\t\t<span class=\"attr\">class</span>=<span class=\"string\">\"org.springframework.orm.hibernate5.LocalSessionFactoryBean\"</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"dataSource\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">ref</span> <span class=\"attr\">local</span>=<span class=\"string\">\"dataSource\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"mappingResources\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">list</span>&gt;</span></div><div class=\"line\">\t\t\t\t<span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>com/helloworld/pojo/User.hbm.xml<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;/<span class=\"name\">list</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"hibernateProperties\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">props</span>&gt;</span></div><div class=\"line\">\t\t\t\t<span class=\"tag\">&lt;<span class=\"name\">prop</span> <span class=\"attr\">key</span>=<span class=\"string\">\"hibernate.dialect\"</span>&gt;</span>org.hibernate.dialect.MySQLDialect<span class=\"tag\">&lt;/<span class=\"name\">prop</span>&gt;</span></div><div class=\"line\">\t\t\t\t<span class=\"tag\">&lt;<span class=\"name\">prop</span> <span class=\"attr\">key</span>=<span class=\"string\">\"show_sql\"</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">prop</span>&gt;</span></div><div class=\"line\">\t\t\t\t<span class=\"tag\">&lt;<span class=\"name\">prop</span> <span class=\"attr\">key</span>=<span class=\"string\">\"hibernate.jdbc.batch_size\"</span>&gt;</span>20<span class=\"tag\">&lt;/<span class=\"name\">prop</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;/<span class=\"name\">props</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"transactionManager\"</span></div><div class=\"line\">\t\t<span class=\"attr\">class</span>=<span class=\"string\">\"org.springframework.orm.hibernate5.HibernateTransactionManager\"</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"sessionFactory\"</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"sessionFactory\"</span> /&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"userDao\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.helloworld.daoImpl.UserDao\"</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"sessionFactory\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">ref</span> <span class=\"attr\">bean</span>=<span class=\"string\">\"sessionFactory\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">&lt;!--用户注册业务逻辑类 --&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"userManager\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.helloworld.manager.UserManager\"</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"dao\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">ref</span> <span class=\"attr\">bean</span>=<span class=\"string\">\"userDao\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">&lt;!-- 用户注册的Action --&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"testAction\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.helloworld.action.TestAction\"</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"manager\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">ref</span> <span class=\"attr\">bean</span>=<span class=\"string\">\"userManager\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">&lt;!-- more bean definitions go here --&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>从配置文件我们看出，hibernate的datasource和session的配置完全被spring接管了，所以hibernate的配置文件是可以删掉的。</p>\n<h3 id=\"修改BaseDao和UserDao。\"><a href=\"#修改BaseDao和UserDao。\" class=\"headerlink\" title=\"修改BaseDao和UserDao。\"></a>修改BaseDao和UserDao。</h3><p>在引入Spring后，需要用Spring进行统一的事务管理，数据源和sessionFactory都交给Spring去生成，因此接口类和实现类BaseDao和UserDao都需要做相应的修改。Spring提供了HibernateDaoSupport类来完成对数据的操作，因此UserDao在实现BaseDao的同时还需要继承HibernateDaoSupport类。并将先前session的操作修改成HibernateTemplate（可通过getHibernateTemplate（）方法来获得）的操作。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> com.helloworld.dao;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> java.util.List;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> org.hibernate.HibernateException;</div><div class=\"line\"><span class=\"keyword\">import</span> org.hibernate.Session;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> com.helloworld.pojo.User;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">BaseDao</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">saveObject</span><span class=\"params\">(Object obj)</span> <span class=\"keyword\">throws</span> HibernateException</span>;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> List&lt;User&gt; <span class=\"title\">getUsers</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> HibernateException</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> com.helloworld.daoImpl;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> java.util.List;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> org.hibernate.HibernateException;</div><div class=\"line\"><span class=\"keyword\">import</span> org.springframework.orm.hibernate5.support.HibernateDaoSupport;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> com.helloworld.dao.BaseDao;</div><div class=\"line\"><span class=\"keyword\">import</span> com.helloworld.pojo.User;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserDao</span> <span class=\"keyword\">extends</span> <span class=\"title\">HibernateDaoSupport</span> <span class=\"keyword\">implements</span> <span class=\"title\">BaseDao</span></span>&#123;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">UserDao</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"UserDao IN\"</span>);</div><div class=\"line\">\t&#125;</div><div class=\"line\">  </div><div class=\"line\">    <span class=\"meta\">@Override</span>  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">saveObject</span><span class=\"params\">(Object obj)</span> <span class=\"keyword\">throws</span> HibernateException </span>&#123;  </div><div class=\"line\">    \tgetHibernateTemplate().save(obj);  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;User&gt; <span class=\"title\">getUsers</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> HibernateException</span>&#123;</div><div class=\"line\">    \tList&lt;User&gt; users=getHibernateTemplate().loadAll(User.class);</div><div class=\"line\">    \t<span class=\"keyword\">return</span> users;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>其实HibernateDaoSupport也没干什么大事，就是前面说的session的set get方法，既然每个DAO都需要，那spring就提出来了呗，没什么神秘的。</p>\n<h3 id=\"修改业务逻辑实现类\"><a href=\"#修改业务逻辑实现类\" class=\"headerlink\" title=\"修改业务逻辑实现类\"></a>修改业务逻辑实现类</h3><p>也就是Manager的类，跟DAO一样。在没有加入Spring之前，业务逻辑实现类的Session的获得，dao的实例化，以及事务的管理都是该类执行管理的。加入Spring后，这些都交给Spring去管理。该类的dao的实例化由Spring注入。</p>\n<h3 id=\"修改用户注册的testAction类\"><a href=\"#修改用户注册的testAction类\" class=\"headerlink\" title=\"修改用户注册的testAction类\"></a>修改用户注册的testAction类</h3><p>同样，testAction类中的userManager的实例化也由Spring注入。可以仔细理解一下上面的applicationContext的配置文件，你需要某个对象，只要把该对象配置成bean，比如下面这样</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"userManager\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.helloworld.manager.UserManager\"</span>&gt;</span></div><div class=\"line\">\t\t...</div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>然后用到这个bean的类配置成</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"testAction\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.helloworld.action.TestAction\"</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"manager\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">ref</span> <span class=\"attr\">bean</span>=<span class=\"string\">\"userManager\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>这样这个类里名字为manager的对象就会自动被注入userManager对象。记得需要有set方法，名字需对应。</p>\n<h3 id=\"删除多余类\"><a href=\"#删除多余类\" class=\"headerlink\" title=\"删除多余类\"></a>删除多余类</h3><p>删除Hibernate的配置文件Hibernate.cfg.xml和工厂类<br>HibernateSesseionFactory类。他们的工作已经交给Spring去做，已经不再有用。</p>\n<h3 id=\"修改web-xml\"><a href=\"#修改web-xml\" class=\"headerlink\" title=\"修改web.xml\"></a>修改web.xml</h3><p>加载Spring。要想启动时加载Spring的配置文件，需要在web.xml中配置对应的监听器（listenser），并指定Spring的配置文件。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">web-app</span> <span class=\"attr\">version</span>=<span class=\"string\">\"2.5\"</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://java.sun.com/xml/ns/javaee\"</span></div><div class=\"line\">    <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></div><div class=\"line\">    <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"http://java.sun.com/xml/ns/javaee </div><div class=\"line\">    http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\"</span>&gt;</span></div><div class=\"line\">    </div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">listener</span>&gt;</span>  </div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class=\"tag\">&lt;/<span class=\"name\">listener-class</span>&gt;</span>  </div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">listener</span>&gt;</span> </div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">filter</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">filter-name</span>&gt;</span>struts2<span class=\"tag\">&lt;/<span class=\"name\">filter-name</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">filter-class</span>&gt;</span></div><div class=\"line\">           org.apache.struts2.dispatcher.filter.StrutsPrepareAndExecuteFilter</div><div class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">filter-class</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">filter</span>&gt;</span></div><div class=\"line\"> \t<span class=\"tag\">&lt;<span class=\"name\">filter-mapping</span>&gt;</span></div><div class=\"line\">  \t\t<span class=\"tag\">&lt;<span class=\"name\">filter-name</span>&gt;</span>struts2<span class=\"tag\">&lt;/<span class=\"name\">filter-name</span>&gt;</span></div><div class=\"line\">  \t\t<span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>/*<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span></div><div class=\"line\"> \t<span class=\"tag\">&lt;/<span class=\"name\">filter-mapping</span>&gt;</span></div><div class=\"line\"> \t</div><div class=\"line\"> \t</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">welcome-file-list</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">welcome-file</span>&gt;</span>index.jsp<span class=\"tag\">&lt;/<span class=\"name\">welcome-file</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">welcome-file-list</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">web-app</span>&gt;</span></div></pre></td></tr></table></figure>\n<h3 id=\"修改Struts的配置文件struts-xml\"><a href=\"#修改Struts的配置文件struts-xml\" class=\"headerlink\" title=\"修改Struts的配置文件struts.xml\"></a>修改Struts的配置文件struts.xml</h3><p>把原来指定的名为register的action的class由原来的路径变为applicationContext.xml文件中该bean的id名，不需要再用具体的包名+类名。</p>\n<p>包名加类名的方式会在每次访问的时候都生成一个action对应的对象，交给spring管理后，只会在最开始的时候生成一次。如下</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">action</span>  <span class=\"attr\">name</span> =<span class=\"string\">\"test\"</span>  <span class=\"attr\">class</span> =<span class=\"string\">\"testAction\"</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>整个项目配置之后结构如图</p>\n<p><img src=\"http://img.blog.csdn.net/20160922132809919?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p>在spring的配置中会遇到各种各样的问题，其他无非就是bean配置上写错了路径，类目，对象名，变量名，等等，所以仔细一点，认真检查一下，肯定能找到原因。</p>\n<p>到此为止，SSH框架已经搭建好了，但是据我所知，这套框架目前的使用率已经在降低了，有以下几个原因：</p>\n<ol>\n<li>struts除了可以做请求转发，还有页面标签，所以你如果只用请求转发的话，这个框架有点多余</li>\n<li>现在spring推出了springMVC，是专门做请求转发用的，因为是spring自家推出的，所以和spring的协调性更好，而且在我使用中也感觉springMVC用起来更方便，轻量级</li>\n<li>HIbernate框架管理数据库很强大，但是同样的问题，重量级。目前因为移动应用的兴起，请求并发量暴增的问题，Mybatis框架对于数据库管理更轻量级，更灵活。这两个框架说不上孰优孰劣，大家可以看下资料。</li>\n</ol>\n<p>所以在下一篇文章中，准备先用SpringMVC代替struts。敬请期待</p>\n"},{"title":"实现类知乎android客户端关注和取消关注的按钮点击效果","date":"2016-08-23T09:41:31.000Z","_content":"\n前端时间在看Android各个客户端上比较出色的动画效果，发现两个动画做的很好的客户端，一个是豌豆荚，一个是知乎。接下来我可能会对这两个客户端的各种效果进行模仿实现。首先让我们看知乎的关注按钮点击效果，关注按钮点击后会有一层遮挡，从你点击的位置慢慢扩散开来，然后变成被点击状态，感觉非常赞。这篇文章从以下几个方面讨论这个效果。\n\n- Android中实现类似效果的几种方式\n  - 用Ripple实现类似效果\n  - 用Paint画出类似效果\n- 反编译知乎客户端代码\n- 实现最终效果\n\n先说明一下，项目代码已上传至github，不想看长篇大论的也可以先去下代码，对照代码，哪里不懂点哪里。\n\n## Contents\n- [Contents](#Contents)\n- [Android中实现类似效果的几种方式](#Android中实现类似效果的几种方式)\n    - [用Ripple实现类似效果](#用Ripple实现类似效果)\n    - [用Paint画出类似效果](#用Paint画出类似效果)\n- [反编译知乎代码](#反编译知乎代码)\n- [知乎实现原理](#知乎实现原理)\n- [实现最终效果](#实现最终效果)\n\n代码在这\n\n[https://github.com/zgzczzw/ZHFollowButton](https://github.com/zgzczzw/ZHFollowButton)\n\n\n首先，让我们我先详细观察了一些知乎的效果，其中有一个很神奇的地方，如图：\n\n![](http://img.blog.csdn.net/20160920201423285?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n![](http://img.blog.csdn.net/20160920201821119?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n![](http://img.blog.csdn.net/20160920201844952?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n![](http://img.blog.csdn.net/20160920201912015?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n\n注意看第二张图，这个圆形在扩散的时候，圆形底下的字还在，而且新的字也在圆形上，就这个效果实现起来最难。\n\n\n## Android中实现类似效果的几种方式\n\n### 用Ripple实现类似效果\n\nripple即波纹效果，是Android API 21以后引入的一种material design的元素，是触摸反馈的一种，也就是说点击的时候会出现水波扩散的样式，demo（见最后）中第一个按钮就是用了ripple效果。\n\n实现方式很简单，实现一个这样的drawable\n\n![](http://img.blog.csdn.net/20160920201948796?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n第一个color是波纹颜色，item里面指定background正常的颜色，可以是一个shape，也可以是一个drawable，还可以是一个selector。\n\n设置为按钮的background即可\n\n![](http://img.blog.csdn.net/20160920202005481?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n如果整个程序的theme用了meterial，那基本所有的带点击效果的控件，比如button都自带这个波纹效果。不过需要注意的是这一套API是21以后才提供的，所以需要做兼容处理。\n\n效果如下：\n\n![](http://img.blog.csdn.net/20160920202022234?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n![](http://img.blog.csdn.net/20160920202034700?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n从图中可以看出即使我设置了波纹为红色（#FF0000），点击后的效果也是淡红色，我猜测因为是水波纹效果，为了不影响按钮本身展示的内容，android系统自动做了透明度的处理，另外从图中也可以明显的看出，水波纹和显示的内容是上下两层的，互不影响，水波纹是在background层面上。这个效果做普通的点击反馈还不错，但绝对实现不出知乎这种用波纹刷新出内容的效果。所以很容易能看出知乎的点击效果不是用ripple做出来的。\n\n\n\n### 用Paint画出类似效果\n\n可能很多人看到知乎关注按钮的效果后，想到的第一种实现方式就是这个，用 paint在点击的地方画圆形，然后让画的圆形半径慢慢变大，实现出扩散出去的样式，我实现了一下，代码如下：\n\n```java\n@Override\nprotected void onDraw(Canvas canvas) {\n    super.onDraw(canvas);\n    if (mShouldDoAnimation) {\n        mMaxRadius = getMeasuredWidth() + 50;\n        if (mRevealRadius > mMinBetweenWidthAndHeight / 2)\n            mRevealRadius += mRevealRadiusGap * 4;\n        else\n            mRevealRadius += mRevealRadiusGap;//半径变大\n        Paint mPaint = new Paint();\n        if (!mIsPressed) {\n            mPaint.setColor(Color.WHITE);\n        } else {\n            mPaint.setColor(Color.RED);\n        }//设置画笔颜色\n        mPaint.setStyle(Paint.Style.FILL);\n        canvas.drawCircle(mCenterX, mCenterY, mRevealRadius, mPaint);\n\n        if (mRevealRadius <= mMaxRadius) {\n            //一定时间后再刷新\n            postInvalidateDelayed(INVALIDATE_DURATION);\n        } else {\n            if (mIsPressed) {\n                setTextColor(Color.WHITE);\n                this.setBackgroundColor(Color.RED);\n            } else {\n                setTextColor(Color.BLACK);\n                this.setBackgroundColor(Color.WHITE);\n            }\n            mShouldDoAnimation = false;\n            invalidate();\n        }\n    }\n}\n```\n效果如图：\n\n![](http://img.blog.csdn.net/20160920202051969?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n![](http://img.blog.csdn.net/20160920202110748?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n![](http://img.blog.csdn.net/20160920202122766?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n![](http://img.blog.csdn.net/20160920202144061?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n![](http://img.blog.csdn.net/20160920202157467?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n\n本来觉得差不多就是这样，但是跟知乎的效果比较一下，还是能发现差别的。用paint画圆能实现的是在点击的地方画一个圆，然后半径慢慢变大慢慢扩散。但是问题在于，画的这个圆会盖住显示的内容，而且画的圆上也不能显示内容。我试过用drawText，也实现不了字和圆一起的效果，解决方法只有，\n\n- 画的过程中改背景色和上面文字。\n- 然后，画完圆之后把圆擦掉，把下面的背景色和文字显示出来。\n\n这样就会出现一次文字闪烁的问题，首先文字会消失掉，然后画完圆之后才显示出来。因为圆在扩散的时候是看不到文字的，只有等圆消失了，文字才能显示出来。而知乎的效果是文字和圆一起刷出来，而且底下的文字还在，中间也没有文字闪烁的问题，整个过程行云流水，看起来很顺畅，好像用圆形揭开了幕布一样。\n\n综上所述，知乎不是用这两种方式实现的，其实如果不是我自己实现了一下，真的以为第二种方法就是知乎采用的，但是目前看来，很遗憾，知乎采用了一种更好的方式来实现这个效果。\n\n那怎么办呢，我也没什么思路，怎么才能在画圆的时候把字也画在圆上，然后圆下面的背景也还有呢。没什么思路，看看知乎的代码吧，反编译。\n\n## 反编译知乎代码\n\n反编译的过程我简单说一下：\n\n到知乎官网下载最新的知乎apk\n用apktool反编译apk，得到资源文件\n\n![](http://img.blog.csdn.net/20160920202223063?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n在资源文件中搜索follow，这里一开始我搜的是ripple，因为我觉得这个效果总归应该和ripple有关，没结果，于是搜了follow，没想到还真搜出来了。\n\n![](http://img.blog.csdn.net/20160920202246843?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n**RevealFollowButton**这明显就是我们要的波纹展开的控件，这就好说了，下一步就是去代码里找到这个控件了。这里要记一下，这个控件的位置**com.zhihu.android.app.ui.widget.RevealFollowButton**。\n\n\n反编译代码\n将apk改名成rar，打开，可以找到里面的class文件\n\n![](http://img.blog.csdn.net/20160920202302501?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n知乎用了multidex，所以会有两个class文件，都拖出来放在dex2jar里反编译一下，就能生成两个jar包了，把jar包放在GUI里看一下，就能看到代码了，虽然代码被混淆过，但是基本逻辑还是能看出来的。\n\n## 知乎实现原理\n\n![](http://img.blog.csdn.net/20160920202319360?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n然后根据前面xml里的路径找到RevelFollowButton的位置，打开代码看就可以了。\n\n\n这是类的继承关系，RevealFollowButton继承自RevealFrameLayout，然后继承自ZHFrameLayout，这个ZHFrameLayout的父类就是FrameLayout了，从名字我们能看出，RevelFollowButton和RevealFrameLayout就是这个效果实现的两个类了。\n\n![](http://img.blog.csdn.net/20160920202333360?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n![](http://img.blog.csdn.net/20160920202347376?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n\n看到这个效果的实现是基于Framelayout，我就知道我们之前讨论的方法其实都走错了方向，如果告诉你用framelayout来实现这个效果，你会怎么做？\n\n我的想法是加入两个TextView到这个layout里，然后一个Visible一个gone，如此切换，后来看过代码后，也证明我的这个想法是对的。\n\n![](http://img.blog.csdn.net/20160920202400813?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n\n看，这里有两个TextView。如此的话，其实切换TextView是很容易实现的，问题是怎么实现波纹切换的效果，那第一件事就是看onDraw函数了，对于GroupView来说是drawChild方法。\n\n![](http://img.blog.csdn.net/20160920202919460?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\nRevealFollowButton的drawChild方法没什么内容，基本是调用了父类，那么我们来看RevealFrameLayout的drawChild方法。\n\n这里有两部分逻辑，如果满足一个条件，就做第一部分，一开始我也不知道这个条件是什么，混淆后的代码能看懂大逻辑，像这种小逻辑只能走一步看一步了。所以假设这个条件永远false吧，看第二部分，看到这里瞬间明白了，原来是采用切割画布的方式，把画布切成一个圆的，就能做到显示的内容也在圆上，而不是内容被覆盖在圆下面了。然后同理，把这个圆形区域不断扩大，然后不断刷新，就是实现波形刷出内容的效果了。代码如下吧\n\n```java\n\nprotected boolean drawChild(Canvas canvas, View paramView, long paramLong) {\n    int i = canvas.save();\n    mPath.reset();\n    //mCenterX mCenterY是点击的位置，在onTouchEvent里设置\n    //mRevealRadius是圆的半径，会渐渐变大\n    mPath.addCircle(mCenterX, mCenterY, mRevealRadius, Path.Direction.CW);\n    canvas.clipPath(this.mPath);\n    boolean bool2 = super.drawChild(canvas, paramView, paramLong);\n    canvas.restoreToCount(i);\n    return bool2;\n}\n```\n\n按照上面说的，肯定还有一个类似于定时器的东西，能不断改变圆形的半径，然后刷新，其实这个在代码里找找很容易就找到了。RevealFrameLayout里除了这个drawChild，没有别的代码了。所以我们来看RevealFollowButton。\n\n\nRevealFollowButton里面跟定时器有关的就是这句了\n\n![](http://img.blog.csdn.net/20160920202426142?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n\n一个Animator对象，其实这句代码我是没看懂的，但逻辑很简单，设置一个Animator，定时500ms，在这个过程中修改圆形半径，然后刷新。\n\n`Math.hypot(getWidth(), getHeight()))`\n\n\n其中这个方法是根据勾股定理获取三角形的斜边长度，想想我们所要绘制的圆形半径最长是多少，没错，就是TextView的对角线长度。所以，整个逻辑就很简单了。\n\n我搞了下代码，就这样吧\n\n![](http://img.blog.csdn.net/20160920202443596?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n\n整个方法的代码如下吧，还包括控制FollowTv和unFollowTv哪个显示\n\n```java\nprotected void setFollowed(boolean isFollowed, boolean needAnimate) {\n    mIsFollowed = isFollowed;\n    if (isFollowed) {\n        mUnFollowTv.setVisibility(View.VISIBLE);\n        mFollowTv.setVisibility(View.VISIBLE);\n        mFollowTv.bringToFront();\n    } else {\n        mUnFollowTv.setVisibility(View.VISIBLE);\n        mFollowTv.setVisibility(View.VISIBLE);\n        mUnFollowTv.bringToFront();\n    }\n    if (needAnimate) {\n        ValueAnimator animator = ObjectAnimator.ofFloat(mFollowTv, \"empty\", 0.0F, (float) Math.hypot(getMeasuredWidth(), getMeasuredHeight()));\n        animator.setDuration(500L);\n        animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {\n            @Override\n            public void onAnimationUpdate(ValueAnimator animation) {\n                mRevealRadius = (Float) animation.getAnimatedValue();\n                invalidate();\n            }\n        });\n        animator.start();\n    }\n}\n```\n\n根据当前状态把Follow的Textview或UnFollow的TextView显示出来，然后设置一个定时器不断扩大所要绘制圆的半径，根据这个半径裁剪画布成一个渐渐变大的圆形，然后内容就渐渐显示出来了。\n\n## 实现最终效果\n\n这个效果实现出来之后，试着运行一下，还不错，但是总觉得有地方不对，于是细细观察，终于发现了，知乎的那个效果在刷新的时候，底下的背景不是白色的，还是之前的状态，比如要变成关注的时候，背景中的未关注还是在的，而我们实现的这个，刷新的时候背景是白色的。\n\n\n这是知乎的\n\n![](http://img.blog.csdn.net/20160920202500751?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n这是我的\n\n![](http://img.blog.csdn.net/20160920202513237?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n所以还是没有知乎那么行云流水，所以我们是少了什么吗。这时候想起来了，之前在RevealFrameLayout的drawChild里有一个判断条件，当时我们不知道它的逻辑是干什么的，现在看来。那部分逻辑就是处理这个的，画子控件的时候，要画两个，FollowTextView和UnFollowTextView，要随圆形刷出的控件我们采用裁剪画布的方式慢慢画出。那作为背景的另一个控件就不需要慢慢画出，只要完全画出来就行了。所以，猜想这里这个判断条件就是判断当前控件是不是要随圆形刷出的控件，如果不是，就直接画出来就行了。所以修改代码如下：\n\n```java\nprotected boolean drawChild(Canvas canvas, View paramView, long paramLong) {\n    if (drawBackground(paramView)) {\n        return super.drawChild(canvas, paramView, paramLong);\n    }\n    int i = canvas.save();\n    mPath.reset();\n    mPath.addCircle(mCenterX, mCenterY, mRevealRadius, Path.Direction.CW);\n    canvas.clipPath(this.mPath);\n    boolean bool2 = super.drawChild(canvas, paramView, paramLong);\n    canvas.restoreToCount(i);\n    return bool2;\n}\n```\n\n判断的方法如下：\n\n```java\nprivate boolean drawBackground(View paramView) {\n    if (mIsFollowed && paramView == mUnFollowTv) {\n        return true;\n    } else if (!mIsFollowed && paramView == mFollowTv) {\n        return true;\n    }\n    return false;\n}\n```\n至此，整个效果就和知乎完全一样了，刷新过程行云流水，非常赞。效果如下\n\n![](http://img.blog.csdn.net/20160920202528190?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n![](http://img.blog.csdn.net/20160920202540940?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n![](http://img.blog.csdn.net/20160920202552455?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n![](http://img.blog.csdn.net/20160920202620051?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n![](http://img.blog.csdn.net/20160920202635129?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n![](http://img.blog.csdn.net/20160920202650911?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n\n实现代码已上传至github：\n\n[https://github.com/zgzczzw/ZHFollowButton](https://github.com/zgzczzw/ZHFollowButton)\n","source":"_posts/实现类知乎android客户端关注和取消关注的按钮点击效果v2.md","raw":"---\ntitle: 实现类知乎android客户端关注和取消关注的按钮点击效果\ndate: 2016-08-23 17:41:31\ntags:\n  - Android\n  - View\n  - 知乎\n  - 按钮点击\ncategories: Android\n---\n\n前端时间在看Android各个客户端上比较出色的动画效果，发现两个动画做的很好的客户端，一个是豌豆荚，一个是知乎。接下来我可能会对这两个客户端的各种效果进行模仿实现。首先让我们看知乎的关注按钮点击效果，关注按钮点击后会有一层遮挡，从你点击的位置慢慢扩散开来，然后变成被点击状态，感觉非常赞。这篇文章从以下几个方面讨论这个效果。\n\n- Android中实现类似效果的几种方式\n  - 用Ripple实现类似效果\n  - 用Paint画出类似效果\n- 反编译知乎客户端代码\n- 实现最终效果\n\n先说明一下，项目代码已上传至github，不想看长篇大论的也可以先去下代码，对照代码，哪里不懂点哪里。\n\n## Contents\n- [Contents](#Contents)\n- [Android中实现类似效果的几种方式](#Android中实现类似效果的几种方式)\n    - [用Ripple实现类似效果](#用Ripple实现类似效果)\n    - [用Paint画出类似效果](#用Paint画出类似效果)\n- [反编译知乎代码](#反编译知乎代码)\n- [知乎实现原理](#知乎实现原理)\n- [实现最终效果](#实现最终效果)\n\n代码在这\n\n[https://github.com/zgzczzw/ZHFollowButton](https://github.com/zgzczzw/ZHFollowButton)\n\n\n首先，让我们我先详细观察了一些知乎的效果，其中有一个很神奇的地方，如图：\n\n![](http://img.blog.csdn.net/20160920201423285?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n![](http://img.blog.csdn.net/20160920201821119?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n![](http://img.blog.csdn.net/20160920201844952?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n![](http://img.blog.csdn.net/20160920201912015?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n\n注意看第二张图，这个圆形在扩散的时候，圆形底下的字还在，而且新的字也在圆形上，就这个效果实现起来最难。\n\n\n## Android中实现类似效果的几种方式\n\n### 用Ripple实现类似效果\n\nripple即波纹效果，是Android API 21以后引入的一种material design的元素，是触摸反馈的一种，也就是说点击的时候会出现水波扩散的样式，demo（见最后）中第一个按钮就是用了ripple效果。\n\n实现方式很简单，实现一个这样的drawable\n\n![](http://img.blog.csdn.net/20160920201948796?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n第一个color是波纹颜色，item里面指定background正常的颜色，可以是一个shape，也可以是一个drawable，还可以是一个selector。\n\n设置为按钮的background即可\n\n![](http://img.blog.csdn.net/20160920202005481?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n如果整个程序的theme用了meterial，那基本所有的带点击效果的控件，比如button都自带这个波纹效果。不过需要注意的是这一套API是21以后才提供的，所以需要做兼容处理。\n\n效果如下：\n\n![](http://img.blog.csdn.net/20160920202022234?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n![](http://img.blog.csdn.net/20160920202034700?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n从图中可以看出即使我设置了波纹为红色（#FF0000），点击后的效果也是淡红色，我猜测因为是水波纹效果，为了不影响按钮本身展示的内容，android系统自动做了透明度的处理，另外从图中也可以明显的看出，水波纹和显示的内容是上下两层的，互不影响，水波纹是在background层面上。这个效果做普通的点击反馈还不错，但绝对实现不出知乎这种用波纹刷新出内容的效果。所以很容易能看出知乎的点击效果不是用ripple做出来的。\n\n\n\n### 用Paint画出类似效果\n\n可能很多人看到知乎关注按钮的效果后，想到的第一种实现方式就是这个，用 paint在点击的地方画圆形，然后让画的圆形半径慢慢变大，实现出扩散出去的样式，我实现了一下，代码如下：\n\n```java\n@Override\nprotected void onDraw(Canvas canvas) {\n    super.onDraw(canvas);\n    if (mShouldDoAnimation) {\n        mMaxRadius = getMeasuredWidth() + 50;\n        if (mRevealRadius > mMinBetweenWidthAndHeight / 2)\n            mRevealRadius += mRevealRadiusGap * 4;\n        else\n            mRevealRadius += mRevealRadiusGap;//半径变大\n        Paint mPaint = new Paint();\n        if (!mIsPressed) {\n            mPaint.setColor(Color.WHITE);\n        } else {\n            mPaint.setColor(Color.RED);\n        }//设置画笔颜色\n        mPaint.setStyle(Paint.Style.FILL);\n        canvas.drawCircle(mCenterX, mCenterY, mRevealRadius, mPaint);\n\n        if (mRevealRadius <= mMaxRadius) {\n            //一定时间后再刷新\n            postInvalidateDelayed(INVALIDATE_DURATION);\n        } else {\n            if (mIsPressed) {\n                setTextColor(Color.WHITE);\n                this.setBackgroundColor(Color.RED);\n            } else {\n                setTextColor(Color.BLACK);\n                this.setBackgroundColor(Color.WHITE);\n            }\n            mShouldDoAnimation = false;\n            invalidate();\n        }\n    }\n}\n```\n效果如图：\n\n![](http://img.blog.csdn.net/20160920202051969?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n![](http://img.blog.csdn.net/20160920202110748?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n![](http://img.blog.csdn.net/20160920202122766?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n![](http://img.blog.csdn.net/20160920202144061?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n![](http://img.blog.csdn.net/20160920202157467?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n\n本来觉得差不多就是这样，但是跟知乎的效果比较一下，还是能发现差别的。用paint画圆能实现的是在点击的地方画一个圆，然后半径慢慢变大慢慢扩散。但是问题在于，画的这个圆会盖住显示的内容，而且画的圆上也不能显示内容。我试过用drawText，也实现不了字和圆一起的效果，解决方法只有，\n\n- 画的过程中改背景色和上面文字。\n- 然后，画完圆之后把圆擦掉，把下面的背景色和文字显示出来。\n\n这样就会出现一次文字闪烁的问题，首先文字会消失掉，然后画完圆之后才显示出来。因为圆在扩散的时候是看不到文字的，只有等圆消失了，文字才能显示出来。而知乎的效果是文字和圆一起刷出来，而且底下的文字还在，中间也没有文字闪烁的问题，整个过程行云流水，看起来很顺畅，好像用圆形揭开了幕布一样。\n\n综上所述，知乎不是用这两种方式实现的，其实如果不是我自己实现了一下，真的以为第二种方法就是知乎采用的，但是目前看来，很遗憾，知乎采用了一种更好的方式来实现这个效果。\n\n那怎么办呢，我也没什么思路，怎么才能在画圆的时候把字也画在圆上，然后圆下面的背景也还有呢。没什么思路，看看知乎的代码吧，反编译。\n\n## 反编译知乎代码\n\n反编译的过程我简单说一下：\n\n到知乎官网下载最新的知乎apk\n用apktool反编译apk，得到资源文件\n\n![](http://img.blog.csdn.net/20160920202223063?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n在资源文件中搜索follow，这里一开始我搜的是ripple，因为我觉得这个效果总归应该和ripple有关，没结果，于是搜了follow，没想到还真搜出来了。\n\n![](http://img.blog.csdn.net/20160920202246843?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n**RevealFollowButton**这明显就是我们要的波纹展开的控件，这就好说了，下一步就是去代码里找到这个控件了。这里要记一下，这个控件的位置**com.zhihu.android.app.ui.widget.RevealFollowButton**。\n\n\n反编译代码\n将apk改名成rar，打开，可以找到里面的class文件\n\n![](http://img.blog.csdn.net/20160920202302501?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n知乎用了multidex，所以会有两个class文件，都拖出来放在dex2jar里反编译一下，就能生成两个jar包了，把jar包放在GUI里看一下，就能看到代码了，虽然代码被混淆过，但是基本逻辑还是能看出来的。\n\n## 知乎实现原理\n\n![](http://img.blog.csdn.net/20160920202319360?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n然后根据前面xml里的路径找到RevelFollowButton的位置，打开代码看就可以了。\n\n\n这是类的继承关系，RevealFollowButton继承自RevealFrameLayout，然后继承自ZHFrameLayout，这个ZHFrameLayout的父类就是FrameLayout了，从名字我们能看出，RevelFollowButton和RevealFrameLayout就是这个效果实现的两个类了。\n\n![](http://img.blog.csdn.net/20160920202333360?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n![](http://img.blog.csdn.net/20160920202347376?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n\n看到这个效果的实现是基于Framelayout，我就知道我们之前讨论的方法其实都走错了方向，如果告诉你用framelayout来实现这个效果，你会怎么做？\n\n我的想法是加入两个TextView到这个layout里，然后一个Visible一个gone，如此切换，后来看过代码后，也证明我的这个想法是对的。\n\n![](http://img.blog.csdn.net/20160920202400813?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n\n看，这里有两个TextView。如此的话，其实切换TextView是很容易实现的，问题是怎么实现波纹切换的效果，那第一件事就是看onDraw函数了，对于GroupView来说是drawChild方法。\n\n![](http://img.blog.csdn.net/20160920202919460?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\nRevealFollowButton的drawChild方法没什么内容，基本是调用了父类，那么我们来看RevealFrameLayout的drawChild方法。\n\n这里有两部分逻辑，如果满足一个条件，就做第一部分，一开始我也不知道这个条件是什么，混淆后的代码能看懂大逻辑，像这种小逻辑只能走一步看一步了。所以假设这个条件永远false吧，看第二部分，看到这里瞬间明白了，原来是采用切割画布的方式，把画布切成一个圆的，就能做到显示的内容也在圆上，而不是内容被覆盖在圆下面了。然后同理，把这个圆形区域不断扩大，然后不断刷新，就是实现波形刷出内容的效果了。代码如下吧\n\n```java\n\nprotected boolean drawChild(Canvas canvas, View paramView, long paramLong) {\n    int i = canvas.save();\n    mPath.reset();\n    //mCenterX mCenterY是点击的位置，在onTouchEvent里设置\n    //mRevealRadius是圆的半径，会渐渐变大\n    mPath.addCircle(mCenterX, mCenterY, mRevealRadius, Path.Direction.CW);\n    canvas.clipPath(this.mPath);\n    boolean bool2 = super.drawChild(canvas, paramView, paramLong);\n    canvas.restoreToCount(i);\n    return bool2;\n}\n```\n\n按照上面说的，肯定还有一个类似于定时器的东西，能不断改变圆形的半径，然后刷新，其实这个在代码里找找很容易就找到了。RevealFrameLayout里除了这个drawChild，没有别的代码了。所以我们来看RevealFollowButton。\n\n\nRevealFollowButton里面跟定时器有关的就是这句了\n\n![](http://img.blog.csdn.net/20160920202426142?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n\n一个Animator对象，其实这句代码我是没看懂的，但逻辑很简单，设置一个Animator，定时500ms，在这个过程中修改圆形半径，然后刷新。\n\n`Math.hypot(getWidth(), getHeight()))`\n\n\n其中这个方法是根据勾股定理获取三角形的斜边长度，想想我们所要绘制的圆形半径最长是多少，没错，就是TextView的对角线长度。所以，整个逻辑就很简单了。\n\n我搞了下代码，就这样吧\n\n![](http://img.blog.csdn.net/20160920202443596?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n\n整个方法的代码如下吧，还包括控制FollowTv和unFollowTv哪个显示\n\n```java\nprotected void setFollowed(boolean isFollowed, boolean needAnimate) {\n    mIsFollowed = isFollowed;\n    if (isFollowed) {\n        mUnFollowTv.setVisibility(View.VISIBLE);\n        mFollowTv.setVisibility(View.VISIBLE);\n        mFollowTv.bringToFront();\n    } else {\n        mUnFollowTv.setVisibility(View.VISIBLE);\n        mFollowTv.setVisibility(View.VISIBLE);\n        mUnFollowTv.bringToFront();\n    }\n    if (needAnimate) {\n        ValueAnimator animator = ObjectAnimator.ofFloat(mFollowTv, \"empty\", 0.0F, (float) Math.hypot(getMeasuredWidth(), getMeasuredHeight()));\n        animator.setDuration(500L);\n        animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {\n            @Override\n            public void onAnimationUpdate(ValueAnimator animation) {\n                mRevealRadius = (Float) animation.getAnimatedValue();\n                invalidate();\n            }\n        });\n        animator.start();\n    }\n}\n```\n\n根据当前状态把Follow的Textview或UnFollow的TextView显示出来，然后设置一个定时器不断扩大所要绘制圆的半径，根据这个半径裁剪画布成一个渐渐变大的圆形，然后内容就渐渐显示出来了。\n\n## 实现最终效果\n\n这个效果实现出来之后，试着运行一下，还不错，但是总觉得有地方不对，于是细细观察，终于发现了，知乎的那个效果在刷新的时候，底下的背景不是白色的，还是之前的状态，比如要变成关注的时候，背景中的未关注还是在的，而我们实现的这个，刷新的时候背景是白色的。\n\n\n这是知乎的\n\n![](http://img.blog.csdn.net/20160920202500751?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n这是我的\n\n![](http://img.blog.csdn.net/20160920202513237?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n所以还是没有知乎那么行云流水，所以我们是少了什么吗。这时候想起来了，之前在RevealFrameLayout的drawChild里有一个判断条件，当时我们不知道它的逻辑是干什么的，现在看来。那部分逻辑就是处理这个的，画子控件的时候，要画两个，FollowTextView和UnFollowTextView，要随圆形刷出的控件我们采用裁剪画布的方式慢慢画出。那作为背景的另一个控件就不需要慢慢画出，只要完全画出来就行了。所以，猜想这里这个判断条件就是判断当前控件是不是要随圆形刷出的控件，如果不是，就直接画出来就行了。所以修改代码如下：\n\n```java\nprotected boolean drawChild(Canvas canvas, View paramView, long paramLong) {\n    if (drawBackground(paramView)) {\n        return super.drawChild(canvas, paramView, paramLong);\n    }\n    int i = canvas.save();\n    mPath.reset();\n    mPath.addCircle(mCenterX, mCenterY, mRevealRadius, Path.Direction.CW);\n    canvas.clipPath(this.mPath);\n    boolean bool2 = super.drawChild(canvas, paramView, paramLong);\n    canvas.restoreToCount(i);\n    return bool2;\n}\n```\n\n判断的方法如下：\n\n```java\nprivate boolean drawBackground(View paramView) {\n    if (mIsFollowed && paramView == mUnFollowTv) {\n        return true;\n    } else if (!mIsFollowed && paramView == mFollowTv) {\n        return true;\n    }\n    return false;\n}\n```\n至此，整个效果就和知乎完全一样了，刷新过程行云流水，非常赞。效果如下\n\n![](http://img.blog.csdn.net/20160920202528190?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n![](http://img.blog.csdn.net/20160920202540940?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n![](http://img.blog.csdn.net/20160920202552455?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n![](http://img.blog.csdn.net/20160920202620051?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n![](http://img.blog.csdn.net/20160920202635129?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n![](http://img.blog.csdn.net/20160920202650911?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n\n实现代码已上传至github：\n\n[https://github.com/zgzczzw/ZHFollowButton](https://github.com/zgzczzw/ZHFollowButton)\n","slug":"实现类知乎android客户端关注和取消关注的按钮点击效果v2","published":1,"updated":"2024-06-14T09:25:33.680Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clxjsxtw80013lq6gc2ker5mn","content":"<p>前端时间在看Android各个客户端上比较出色的动画效果，发现两个动画做的很好的客户端，一个是豌豆荚，一个是知乎。接下来我可能会对这两个客户端的各种效果进行模仿实现。首先让我们看知乎的关注按钮点击效果，关注按钮点击后会有一层遮挡，从你点击的位置慢慢扩散开来，然后变成被点击状态，感觉非常赞。这篇文章从以下几个方面讨论这个效果。</p>\n<ul>\n<li>Android中实现类似效果的几种方式<ul>\n<li>用Ripple实现类似效果</li>\n<li>用Paint画出类似效果</li>\n</ul>\n</li>\n<li>反编译知乎客户端代码</li>\n<li>实现最终效果</li>\n</ul>\n<p>先说明一下，项目代码已上传至github，不想看长篇大论的也可以先去下代码，对照代码，哪里不懂点哪里。</p>\n<h2 id=\"Contents\"><a href=\"#Contents\" class=\"headerlink\" title=\"Contents\"></a>Contents</h2><ul>\n<li><a href=\"#Contents\">Contents</a></li>\n<li><a href=\"#Android中实现类似效果的几种方式\">Android中实现类似效果的几种方式</a><ul>\n<li><a href=\"#用Ripple实现类似效果\">用Ripple实现类似效果</a></li>\n<li><a href=\"#用Paint画出类似效果\">用Paint画出类似效果</a></li>\n</ul>\n</li>\n<li><a href=\"#反编译知乎代码\">反编译知乎代码</a></li>\n<li><a href=\"#知乎实现原理\">知乎实现原理</a></li>\n<li><a href=\"#实现最终效果\">实现最终效果</a></li>\n</ul>\n<p>代码在这</p>\n<p><a href=\"https://github.com/zgzczzw/ZHFollowButton\" target=\"_blank\" rel=\"external\">https://github.com/zgzczzw/ZHFollowButton</a></p>\n<p>首先，让我们我先详细观察了一些知乎的效果，其中有一个很神奇的地方，如图：</p>\n<p><img src=\"http://img.blog.csdn.net/20160920201423285?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p><img src=\"http://img.blog.csdn.net/20160920201821119?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p><img src=\"http://img.blog.csdn.net/20160920201844952?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p><img src=\"http://img.blog.csdn.net/20160920201912015?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p>注意看第二张图，这个圆形在扩散的时候，圆形底下的字还在，而且新的字也在圆形上，就这个效果实现起来最难。</p>\n<h2 id=\"Android中实现类似效果的几种方式\"><a href=\"#Android中实现类似效果的几种方式\" class=\"headerlink\" title=\"Android中实现类似效果的几种方式\"></a>Android中实现类似效果的几种方式</h2><h3 id=\"用Ripple实现类似效果\"><a href=\"#用Ripple实现类似效果\" class=\"headerlink\" title=\"用Ripple实现类似效果\"></a>用Ripple实现类似效果</h3><p>ripple即波纹效果，是Android API 21以后引入的一种material design的元素，是触摸反馈的一种，也就是说点击的时候会出现水波扩散的样式，demo（见最后）中第一个按钮就是用了ripple效果。</p>\n<p>实现方式很简单，实现一个这样的drawable</p>\n<p><img src=\"http://img.blog.csdn.net/20160920201948796?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p>第一个color是波纹颜色，item里面指定background正常的颜色，可以是一个shape，也可以是一个drawable，还可以是一个selector。</p>\n<p>设置为按钮的background即可</p>\n<p><img src=\"http://img.blog.csdn.net/20160920202005481?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p>如果整个程序的theme用了meterial，那基本所有的带点击效果的控件，比如button都自带这个波纹效果。不过需要注意的是这一套API是21以后才提供的，所以需要做兼容处理。</p>\n<p>效果如下：</p>\n<p><img src=\"http://img.blog.csdn.net/20160920202022234?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p><img src=\"http://img.blog.csdn.net/20160920202034700?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p>从图中可以看出即使我设置了波纹为红色（#FF0000），点击后的效果也是淡红色，我猜测因为是水波纹效果，为了不影响按钮本身展示的内容，android系统自动做了透明度的处理，另外从图中也可以明显的看出，水波纹和显示的内容是上下两层的，互不影响，水波纹是在background层面上。这个效果做普通的点击反馈还不错，但绝对实现不出知乎这种用波纹刷新出内容的效果。所以很容易能看出知乎的点击效果不是用ripple做出来的。</p>\n<h3 id=\"用Paint画出类似效果\"><a href=\"#用Paint画出类似效果\" class=\"headerlink\" title=\"用Paint画出类似效果\"></a>用Paint画出类似效果</h3><p>可能很多人看到知乎关注按钮的效果后，想到的第一种实现方式就是这个，用 paint在点击的地方画圆形，然后让画的圆形半径慢慢变大，实现出扩散出去的样式，我实现了一下，代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onDraw</span><span class=\"params\">(Canvas canvas)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>.onDraw(canvas);</div><div class=\"line\">    <span class=\"keyword\">if</span> (mShouldDoAnimation) &#123;</div><div class=\"line\">        mMaxRadius = getMeasuredWidth() + <span class=\"number\">50</span>;</div><div class=\"line\">        <span class=\"keyword\">if</span> (mRevealRadius &gt; mMinBetweenWidthAndHeight / <span class=\"number\">2</span>)</div><div class=\"line\">            mRevealRadius += mRevealRadiusGap * <span class=\"number\">4</span>;</div><div class=\"line\">        <span class=\"keyword\">else</span></div><div class=\"line\">            mRevealRadius += mRevealRadiusGap;<span class=\"comment\">//半径变大</span></div><div class=\"line\">        Paint mPaint = <span class=\"keyword\">new</span> Paint();</div><div class=\"line\">        <span class=\"keyword\">if</span> (!mIsPressed) &#123;</div><div class=\"line\">            mPaint.setColor(Color.WHITE);</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            mPaint.setColor(Color.RED);</div><div class=\"line\">        &#125;<span class=\"comment\">//设置画笔颜色</span></div><div class=\"line\">        mPaint.setStyle(Paint.Style.FILL);</div><div class=\"line\">        canvas.drawCircle(mCenterX, mCenterY, mRevealRadius, mPaint);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (mRevealRadius &lt;= mMaxRadius) &#123;</div><div class=\"line\">            <span class=\"comment\">//一定时间后再刷新</span></div><div class=\"line\">            postInvalidateDelayed(INVALIDATE_DURATION);</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (mIsPressed) &#123;</div><div class=\"line\">                setTextColor(Color.WHITE);</div><div class=\"line\">                <span class=\"keyword\">this</span>.setBackgroundColor(Color.RED);</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                setTextColor(Color.BLACK);</div><div class=\"line\">                <span class=\"keyword\">this</span>.setBackgroundColor(Color.WHITE);</div><div class=\"line\">            &#125;</div><div class=\"line\">            mShouldDoAnimation = <span class=\"keyword\">false</span>;</div><div class=\"line\">            invalidate();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>效果如图：</p>\n<p><img src=\"http://img.blog.csdn.net/20160920202051969?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p><img src=\"http://img.blog.csdn.net/20160920202110748?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p><img src=\"http://img.blog.csdn.net/20160920202122766?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p><img src=\"http://img.blog.csdn.net/20160920202144061?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p><img src=\"http://img.blog.csdn.net/20160920202157467?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p>本来觉得差不多就是这样，但是跟知乎的效果比较一下，还是能发现差别的。用paint画圆能实现的是在点击的地方画一个圆，然后半径慢慢变大慢慢扩散。但是问题在于，画的这个圆会盖住显示的内容，而且画的圆上也不能显示内容。我试过用drawText，也实现不了字和圆一起的效果，解决方法只有，</p>\n<ul>\n<li>画的过程中改背景色和上面文字。</li>\n<li>然后，画完圆之后把圆擦掉，把下面的背景色和文字显示出来。</li>\n</ul>\n<p>这样就会出现一次文字闪烁的问题，首先文字会消失掉，然后画完圆之后才显示出来。因为圆在扩散的时候是看不到文字的，只有等圆消失了，文字才能显示出来。而知乎的效果是文字和圆一起刷出来，而且底下的文字还在，中间也没有文字闪烁的问题，整个过程行云流水，看起来很顺畅，好像用圆形揭开了幕布一样。</p>\n<p>综上所述，知乎不是用这两种方式实现的，其实如果不是我自己实现了一下，真的以为第二种方法就是知乎采用的，但是目前看来，很遗憾，知乎采用了一种更好的方式来实现这个效果。</p>\n<p>那怎么办呢，我也没什么思路，怎么才能在画圆的时候把字也画在圆上，然后圆下面的背景也还有呢。没什么思路，看看知乎的代码吧，反编译。</p>\n<h2 id=\"反编译知乎代码\"><a href=\"#反编译知乎代码\" class=\"headerlink\" title=\"反编译知乎代码\"></a>反编译知乎代码</h2><p>反编译的过程我简单说一下：</p>\n<p>到知乎官网下载最新的知乎apk<br>用apktool反编译apk，得到资源文件</p>\n<p><img src=\"http://img.blog.csdn.net/20160920202223063?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p>在资源文件中搜索follow，这里一开始我搜的是ripple，因为我觉得这个效果总归应该和ripple有关，没结果，于是搜了follow，没想到还真搜出来了。</p>\n<p><img src=\"http://img.blog.csdn.net/20160920202246843?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p><strong>RevealFollowButton</strong>这明显就是我们要的波纹展开的控件，这就好说了，下一步就是去代码里找到这个控件了。这里要记一下，这个控件的位置<strong>com.zhihu.android.app.ui.widget.RevealFollowButton</strong>。</p>\n<p>反编译代码<br>将apk改名成rar，打开，可以找到里面的class文件</p>\n<p><img src=\"http://img.blog.csdn.net/20160920202302501?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p>知乎用了multidex，所以会有两个class文件，都拖出来放在dex2jar里反编译一下，就能生成两个jar包了，把jar包放在GUI里看一下，就能看到代码了，虽然代码被混淆过，但是基本逻辑还是能看出来的。</p>\n<h2 id=\"知乎实现原理\"><a href=\"#知乎实现原理\" class=\"headerlink\" title=\"知乎实现原理\"></a>知乎实现原理</h2><p><img src=\"http://img.blog.csdn.net/20160920202319360?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p>然后根据前面xml里的路径找到RevelFollowButton的位置，打开代码看就可以了。</p>\n<p>这是类的继承关系，RevealFollowButton继承自RevealFrameLayout，然后继承自ZHFrameLayout，这个ZHFrameLayout的父类就是FrameLayout了，从名字我们能看出，RevelFollowButton和RevealFrameLayout就是这个效果实现的两个类了。</p>\n<p><img src=\"http://img.blog.csdn.net/20160920202333360?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p><img src=\"http://img.blog.csdn.net/20160920202347376?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p>看到这个效果的实现是基于Framelayout，我就知道我们之前讨论的方法其实都走错了方向，如果告诉你用framelayout来实现这个效果，你会怎么做？</p>\n<p>我的想法是加入两个TextView到这个layout里，然后一个Visible一个gone，如此切换，后来看过代码后，也证明我的这个想法是对的。</p>\n<p><img src=\"http://img.blog.csdn.net/20160920202400813?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p>看，这里有两个TextView。如此的话，其实切换TextView是很容易实现的，问题是怎么实现波纹切换的效果，那第一件事就是看onDraw函数了，对于GroupView来说是drawChild方法。</p>\n<p><img src=\"http://img.blog.csdn.net/20160920202919460?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p>RevealFollowButton的drawChild方法没什么内容，基本是调用了父类，那么我们来看RevealFrameLayout的drawChild方法。</p>\n<p>这里有两部分逻辑，如果满足一个条件，就做第一部分，一开始我也不知道这个条件是什么，混淆后的代码能看懂大逻辑，像这种小逻辑只能走一步看一步了。所以假设这个条件永远false吧，看第二部分，看到这里瞬间明白了，原来是采用切割画布的方式，把画布切成一个圆的，就能做到显示的内容也在圆上，而不是内容被覆盖在圆下面了。然后同理，把这个圆形区域不断扩大，然后不断刷新，就是实现波形刷出内容的效果了。代码如下吧</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">boolean</span> <span class=\"title\">drawChild</span><span class=\"params\">(Canvas canvas, View paramView, <span class=\"keyword\">long</span> paramLong)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> i = canvas.save();</div><div class=\"line\">    mPath.reset();</div><div class=\"line\">    <span class=\"comment\">//mCenterX mCenterY是点击的位置，在onTouchEvent里设置</span></div><div class=\"line\">    <span class=\"comment\">//mRevealRadius是圆的半径，会渐渐变大</span></div><div class=\"line\">    mPath.addCircle(mCenterX, mCenterY, mRevealRadius, Path.Direction.CW);</div><div class=\"line\">    canvas.clipPath(<span class=\"keyword\">this</span>.mPath);</div><div class=\"line\">    <span class=\"keyword\">boolean</span> bool2 = <span class=\"keyword\">super</span>.drawChild(canvas, paramView, paramLong);</div><div class=\"line\">    canvas.restoreToCount(i);</div><div class=\"line\">    <span class=\"keyword\">return</span> bool2;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>按照上面说的，肯定还有一个类似于定时器的东西，能不断改变圆形的半径，然后刷新，其实这个在代码里找找很容易就找到了。RevealFrameLayout里除了这个drawChild，没有别的代码了。所以我们来看RevealFollowButton。</p>\n<p>RevealFollowButton里面跟定时器有关的就是这句了</p>\n<p><img src=\"http://img.blog.csdn.net/20160920202426142?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p>一个Animator对象，其实这句代码我是没看懂的，但逻辑很简单，设置一个Animator，定时500ms，在这个过程中修改圆形半径，然后刷新。</p>\n<p><code>Math.hypot(getWidth(), getHeight()))</code></p>\n<p>其中这个方法是根据勾股定理获取三角形的斜边长度，想想我们所要绘制的圆形半径最长是多少，没错，就是TextView的对角线长度。所以，整个逻辑就很简单了。</p>\n<p>我搞了下代码，就这样吧</p>\n<p><img src=\"http://img.blog.csdn.net/20160920202443596?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p>整个方法的代码如下吧，还包括控制FollowTv和unFollowTv哪个显示</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">setFollowed</span><span class=\"params\">(<span class=\"keyword\">boolean</span> isFollowed, <span class=\"keyword\">boolean</span> needAnimate)</span> </span>&#123;</div><div class=\"line\">    mIsFollowed = isFollowed;</div><div class=\"line\">    <span class=\"keyword\">if</span> (isFollowed) &#123;</div><div class=\"line\">        mUnFollowTv.setVisibility(View.VISIBLE);</div><div class=\"line\">        mFollowTv.setVisibility(View.VISIBLE);</div><div class=\"line\">        mFollowTv.bringToFront();</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        mUnFollowTv.setVisibility(View.VISIBLE);</div><div class=\"line\">        mFollowTv.setVisibility(View.VISIBLE);</div><div class=\"line\">        mUnFollowTv.bringToFront();</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> (needAnimate) &#123;</div><div class=\"line\">        ValueAnimator animator = ObjectAnimator.ofFloat(mFollowTv, <span class=\"string\">\"empty\"</span>, <span class=\"number\">0.0F</span>, (<span class=\"keyword\">float</span>) Math.hypot(getMeasuredWidth(), getMeasuredHeight()));</div><div class=\"line\">        animator.setDuration(<span class=\"number\">500L</span>);</div><div class=\"line\">        animator.addUpdateListener(<span class=\"keyword\">new</span> ValueAnimator.AnimatorUpdateListener() &#123;</div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onAnimationUpdate</span><span class=\"params\">(ValueAnimator animation)</span> </span>&#123;</div><div class=\"line\">                mRevealRadius = (Float) animation.getAnimatedValue();</div><div class=\"line\">                invalidate();</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div><div class=\"line\">        animator.start();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>根据当前状态把Follow的Textview或UnFollow的TextView显示出来，然后设置一个定时器不断扩大所要绘制圆的半径，根据这个半径裁剪画布成一个渐渐变大的圆形，然后内容就渐渐显示出来了。</p>\n<h2 id=\"实现最终效果\"><a href=\"#实现最终效果\" class=\"headerlink\" title=\"实现最终效果\"></a>实现最终效果</h2><p>这个效果实现出来之后，试着运行一下，还不错，但是总觉得有地方不对，于是细细观察，终于发现了，知乎的那个效果在刷新的时候，底下的背景不是白色的，还是之前的状态，比如要变成关注的时候，背景中的未关注还是在的，而我们实现的这个，刷新的时候背景是白色的。</p>\n<p>这是知乎的</p>\n<p><img src=\"http://img.blog.csdn.net/20160920202500751?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p>这是我的</p>\n<p><img src=\"http://img.blog.csdn.net/20160920202513237?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p>所以还是没有知乎那么行云流水，所以我们是少了什么吗。这时候想起来了，之前在RevealFrameLayout的drawChild里有一个判断条件，当时我们不知道它的逻辑是干什么的，现在看来。那部分逻辑就是处理这个的，画子控件的时候，要画两个，FollowTextView和UnFollowTextView，要随圆形刷出的控件我们采用裁剪画布的方式慢慢画出。那作为背景的另一个控件就不需要慢慢画出，只要完全画出来就行了。所以，猜想这里这个判断条件就是判断当前控件是不是要随圆形刷出的控件，如果不是，就直接画出来就行了。所以修改代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">boolean</span> <span class=\"title\">drawChild</span><span class=\"params\">(Canvas canvas, View paramView, <span class=\"keyword\">long</span> paramLong)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (drawBackground(paramView)) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.drawChild(canvas, paramView, paramLong);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">int</span> i = canvas.save();</div><div class=\"line\">    mPath.reset();</div><div class=\"line\">    mPath.addCircle(mCenterX, mCenterY, mRevealRadius, Path.Direction.CW);</div><div class=\"line\">    canvas.clipPath(<span class=\"keyword\">this</span>.mPath);</div><div class=\"line\">    <span class=\"keyword\">boolean</span> bool2 = <span class=\"keyword\">super</span>.drawChild(canvas, paramView, paramLong);</div><div class=\"line\">    canvas.restoreToCount(i);</div><div class=\"line\">    <span class=\"keyword\">return</span> bool2;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>判断的方法如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">drawBackground</span><span class=\"params\">(View paramView)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (mIsFollowed &amp;&amp; paramView == mUnFollowTv) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!mIsFollowed &amp;&amp; paramView == mFollowTv) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>至此，整个效果就和知乎完全一样了，刷新过程行云流水，非常赞。效果如下</p>\n<p><img src=\"http://img.blog.csdn.net/20160920202528190?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p><img src=\"http://img.blog.csdn.net/20160920202540940?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p><img src=\"http://img.blog.csdn.net/20160920202552455?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p><img src=\"http://img.blog.csdn.net/20160920202620051?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p><img src=\"http://img.blog.csdn.net/20160920202635129?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p><img src=\"http://img.blog.csdn.net/20160920202650911?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p>实现代码已上传至github：</p>\n<p><a href=\"https://github.com/zgzczzw/ZHFollowButton\" target=\"_blank\" rel=\"external\">https://github.com/zgzczzw/ZHFollowButton</a></p>\n","excerpt":"","more":"<p>前端时间在看Android各个客户端上比较出色的动画效果，发现两个动画做的很好的客户端，一个是豌豆荚，一个是知乎。接下来我可能会对这两个客户端的各种效果进行模仿实现。首先让我们看知乎的关注按钮点击效果，关注按钮点击后会有一层遮挡，从你点击的位置慢慢扩散开来，然后变成被点击状态，感觉非常赞。这篇文章从以下几个方面讨论这个效果。</p>\n<ul>\n<li>Android中实现类似效果的几种方式<ul>\n<li>用Ripple实现类似效果</li>\n<li>用Paint画出类似效果</li>\n</ul>\n</li>\n<li>反编译知乎客户端代码</li>\n<li>实现最终效果</li>\n</ul>\n<p>先说明一下，项目代码已上传至github，不想看长篇大论的也可以先去下代码，对照代码，哪里不懂点哪里。</p>\n<h2 id=\"Contents\"><a href=\"#Contents\" class=\"headerlink\" title=\"Contents\"></a>Contents</h2><ul>\n<li><a href=\"#Contents\">Contents</a></li>\n<li><a href=\"#Android中实现类似效果的几种方式\">Android中实现类似效果的几种方式</a><ul>\n<li><a href=\"#用Ripple实现类似效果\">用Ripple实现类似效果</a></li>\n<li><a href=\"#用Paint画出类似效果\">用Paint画出类似效果</a></li>\n</ul>\n</li>\n<li><a href=\"#反编译知乎代码\">反编译知乎代码</a></li>\n<li><a href=\"#知乎实现原理\">知乎实现原理</a></li>\n<li><a href=\"#实现最终效果\">实现最终效果</a></li>\n</ul>\n<p>代码在这</p>\n<p><a href=\"https://github.com/zgzczzw/ZHFollowButton\">https://github.com/zgzczzw/ZHFollowButton</a></p>\n<p>首先，让我们我先详细观察了一些知乎的效果，其中有一个很神奇的地方，如图：</p>\n<p><img src=\"http://img.blog.csdn.net/20160920201423285?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p><img src=\"http://img.blog.csdn.net/20160920201821119?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p><img src=\"http://img.blog.csdn.net/20160920201844952?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p><img src=\"http://img.blog.csdn.net/20160920201912015?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p>注意看第二张图，这个圆形在扩散的时候，圆形底下的字还在，而且新的字也在圆形上，就这个效果实现起来最难。</p>\n<h2 id=\"Android中实现类似效果的几种方式\"><a href=\"#Android中实现类似效果的几种方式\" class=\"headerlink\" title=\"Android中实现类似效果的几种方式\"></a>Android中实现类似效果的几种方式</h2><h3 id=\"用Ripple实现类似效果\"><a href=\"#用Ripple实现类似效果\" class=\"headerlink\" title=\"用Ripple实现类似效果\"></a>用Ripple实现类似效果</h3><p>ripple即波纹效果，是Android API 21以后引入的一种material design的元素，是触摸反馈的一种，也就是说点击的时候会出现水波扩散的样式，demo（见最后）中第一个按钮就是用了ripple效果。</p>\n<p>实现方式很简单，实现一个这样的drawable</p>\n<p><img src=\"http://img.blog.csdn.net/20160920201948796?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p>第一个color是波纹颜色，item里面指定background正常的颜色，可以是一个shape，也可以是一个drawable，还可以是一个selector。</p>\n<p>设置为按钮的background即可</p>\n<p><img src=\"http://img.blog.csdn.net/20160920202005481?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p>如果整个程序的theme用了meterial，那基本所有的带点击效果的控件，比如button都自带这个波纹效果。不过需要注意的是这一套API是21以后才提供的，所以需要做兼容处理。</p>\n<p>效果如下：</p>\n<p><img src=\"http://img.blog.csdn.net/20160920202022234?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p><img src=\"http://img.blog.csdn.net/20160920202034700?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p>从图中可以看出即使我设置了波纹为红色（#FF0000），点击后的效果也是淡红色，我猜测因为是水波纹效果，为了不影响按钮本身展示的内容，android系统自动做了透明度的处理，另外从图中也可以明显的看出，水波纹和显示的内容是上下两层的，互不影响，水波纹是在background层面上。这个效果做普通的点击反馈还不错，但绝对实现不出知乎这种用波纹刷新出内容的效果。所以很容易能看出知乎的点击效果不是用ripple做出来的。</p>\n<h3 id=\"用Paint画出类似效果\"><a href=\"#用Paint画出类似效果\" class=\"headerlink\" title=\"用Paint画出类似效果\"></a>用Paint画出类似效果</h3><p>可能很多人看到知乎关注按钮的效果后，想到的第一种实现方式就是这个，用 paint在点击的地方画圆形，然后让画的圆形半径慢慢变大，实现出扩散出去的样式，我实现了一下，代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onDraw</span><span class=\"params\">(Canvas canvas)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>.onDraw(canvas);</div><div class=\"line\">    <span class=\"keyword\">if</span> (mShouldDoAnimation) &#123;</div><div class=\"line\">        mMaxRadius = getMeasuredWidth() + <span class=\"number\">50</span>;</div><div class=\"line\">        <span class=\"keyword\">if</span> (mRevealRadius &gt; mMinBetweenWidthAndHeight / <span class=\"number\">2</span>)</div><div class=\"line\">            mRevealRadius += mRevealRadiusGap * <span class=\"number\">4</span>;</div><div class=\"line\">        <span class=\"keyword\">else</span></div><div class=\"line\">            mRevealRadius += mRevealRadiusGap;<span class=\"comment\">//半径变大</span></div><div class=\"line\">        Paint mPaint = <span class=\"keyword\">new</span> Paint();</div><div class=\"line\">        <span class=\"keyword\">if</span> (!mIsPressed) &#123;</div><div class=\"line\">            mPaint.setColor(Color.WHITE);</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            mPaint.setColor(Color.RED);</div><div class=\"line\">        &#125;<span class=\"comment\">//设置画笔颜色</span></div><div class=\"line\">        mPaint.setStyle(Paint.Style.FILL);</div><div class=\"line\">        canvas.drawCircle(mCenterX, mCenterY, mRevealRadius, mPaint);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (mRevealRadius &lt;= mMaxRadius) &#123;</div><div class=\"line\">            <span class=\"comment\">//一定时间后再刷新</span></div><div class=\"line\">            postInvalidateDelayed(INVALIDATE_DURATION);</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (mIsPressed) &#123;</div><div class=\"line\">                setTextColor(Color.WHITE);</div><div class=\"line\">                <span class=\"keyword\">this</span>.setBackgroundColor(Color.RED);</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                setTextColor(Color.BLACK);</div><div class=\"line\">                <span class=\"keyword\">this</span>.setBackgroundColor(Color.WHITE);</div><div class=\"line\">            &#125;</div><div class=\"line\">            mShouldDoAnimation = <span class=\"keyword\">false</span>;</div><div class=\"line\">            invalidate();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>效果如图：</p>\n<p><img src=\"http://img.blog.csdn.net/20160920202051969?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p><img src=\"http://img.blog.csdn.net/20160920202110748?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p><img src=\"http://img.blog.csdn.net/20160920202122766?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p><img src=\"http://img.blog.csdn.net/20160920202144061?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p><img src=\"http://img.blog.csdn.net/20160920202157467?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p>本来觉得差不多就是这样，但是跟知乎的效果比较一下，还是能发现差别的。用paint画圆能实现的是在点击的地方画一个圆，然后半径慢慢变大慢慢扩散。但是问题在于，画的这个圆会盖住显示的内容，而且画的圆上也不能显示内容。我试过用drawText，也实现不了字和圆一起的效果，解决方法只有，</p>\n<ul>\n<li>画的过程中改背景色和上面文字。</li>\n<li>然后，画完圆之后把圆擦掉，把下面的背景色和文字显示出来。</li>\n</ul>\n<p>这样就会出现一次文字闪烁的问题，首先文字会消失掉，然后画完圆之后才显示出来。因为圆在扩散的时候是看不到文字的，只有等圆消失了，文字才能显示出来。而知乎的效果是文字和圆一起刷出来，而且底下的文字还在，中间也没有文字闪烁的问题，整个过程行云流水，看起来很顺畅，好像用圆形揭开了幕布一样。</p>\n<p>综上所述，知乎不是用这两种方式实现的，其实如果不是我自己实现了一下，真的以为第二种方法就是知乎采用的，但是目前看来，很遗憾，知乎采用了一种更好的方式来实现这个效果。</p>\n<p>那怎么办呢，我也没什么思路，怎么才能在画圆的时候把字也画在圆上，然后圆下面的背景也还有呢。没什么思路，看看知乎的代码吧，反编译。</p>\n<h2 id=\"反编译知乎代码\"><a href=\"#反编译知乎代码\" class=\"headerlink\" title=\"反编译知乎代码\"></a>反编译知乎代码</h2><p>反编译的过程我简单说一下：</p>\n<p>到知乎官网下载最新的知乎apk<br>用apktool反编译apk，得到资源文件</p>\n<p><img src=\"http://img.blog.csdn.net/20160920202223063?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p>在资源文件中搜索follow，这里一开始我搜的是ripple，因为我觉得这个效果总归应该和ripple有关，没结果，于是搜了follow，没想到还真搜出来了。</p>\n<p><img src=\"http://img.blog.csdn.net/20160920202246843?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p><strong>RevealFollowButton</strong>这明显就是我们要的波纹展开的控件，这就好说了，下一步就是去代码里找到这个控件了。这里要记一下，这个控件的位置<strong>com.zhihu.android.app.ui.widget.RevealFollowButton</strong>。</p>\n<p>反编译代码<br>将apk改名成rar，打开，可以找到里面的class文件</p>\n<p><img src=\"http://img.blog.csdn.net/20160920202302501?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p>知乎用了multidex，所以会有两个class文件，都拖出来放在dex2jar里反编译一下，就能生成两个jar包了，把jar包放在GUI里看一下，就能看到代码了，虽然代码被混淆过，但是基本逻辑还是能看出来的。</p>\n<h2 id=\"知乎实现原理\"><a href=\"#知乎实现原理\" class=\"headerlink\" title=\"知乎实现原理\"></a>知乎实现原理</h2><p><img src=\"http://img.blog.csdn.net/20160920202319360?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p>然后根据前面xml里的路径找到RevelFollowButton的位置，打开代码看就可以了。</p>\n<p>这是类的继承关系，RevealFollowButton继承自RevealFrameLayout，然后继承自ZHFrameLayout，这个ZHFrameLayout的父类就是FrameLayout了，从名字我们能看出，RevelFollowButton和RevealFrameLayout就是这个效果实现的两个类了。</p>\n<p><img src=\"http://img.blog.csdn.net/20160920202333360?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p><img src=\"http://img.blog.csdn.net/20160920202347376?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p>看到这个效果的实现是基于Framelayout，我就知道我们之前讨论的方法其实都走错了方向，如果告诉你用framelayout来实现这个效果，你会怎么做？</p>\n<p>我的想法是加入两个TextView到这个layout里，然后一个Visible一个gone，如此切换，后来看过代码后，也证明我的这个想法是对的。</p>\n<p><img src=\"http://img.blog.csdn.net/20160920202400813?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p>看，这里有两个TextView。如此的话，其实切换TextView是很容易实现的，问题是怎么实现波纹切换的效果，那第一件事就是看onDraw函数了，对于GroupView来说是drawChild方法。</p>\n<p><img src=\"http://img.blog.csdn.net/20160920202919460?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p>RevealFollowButton的drawChild方法没什么内容，基本是调用了父类，那么我们来看RevealFrameLayout的drawChild方法。</p>\n<p>这里有两部分逻辑，如果满足一个条件，就做第一部分，一开始我也不知道这个条件是什么，混淆后的代码能看懂大逻辑，像这种小逻辑只能走一步看一步了。所以假设这个条件永远false吧，看第二部分，看到这里瞬间明白了，原来是采用切割画布的方式，把画布切成一个圆的，就能做到显示的内容也在圆上，而不是内容被覆盖在圆下面了。然后同理，把这个圆形区域不断扩大，然后不断刷新，就是实现波形刷出内容的效果了。代码如下吧</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">boolean</span> <span class=\"title\">drawChild</span><span class=\"params\">(Canvas canvas, View paramView, <span class=\"keyword\">long</span> paramLong)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> i = canvas.save();</div><div class=\"line\">    mPath.reset();</div><div class=\"line\">    <span class=\"comment\">//mCenterX mCenterY是点击的位置，在onTouchEvent里设置</span></div><div class=\"line\">    <span class=\"comment\">//mRevealRadius是圆的半径，会渐渐变大</span></div><div class=\"line\">    mPath.addCircle(mCenterX, mCenterY, mRevealRadius, Path.Direction.CW);</div><div class=\"line\">    canvas.clipPath(<span class=\"keyword\">this</span>.mPath);</div><div class=\"line\">    <span class=\"keyword\">boolean</span> bool2 = <span class=\"keyword\">super</span>.drawChild(canvas, paramView, paramLong);</div><div class=\"line\">    canvas.restoreToCount(i);</div><div class=\"line\">    <span class=\"keyword\">return</span> bool2;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>按照上面说的，肯定还有一个类似于定时器的东西，能不断改变圆形的半径，然后刷新，其实这个在代码里找找很容易就找到了。RevealFrameLayout里除了这个drawChild，没有别的代码了。所以我们来看RevealFollowButton。</p>\n<p>RevealFollowButton里面跟定时器有关的就是这句了</p>\n<p><img src=\"http://img.blog.csdn.net/20160920202426142?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p>一个Animator对象，其实这句代码我是没看懂的，但逻辑很简单，设置一个Animator，定时500ms，在这个过程中修改圆形半径，然后刷新。</p>\n<p><code>Math.hypot(getWidth(), getHeight()))</code></p>\n<p>其中这个方法是根据勾股定理获取三角形的斜边长度，想想我们所要绘制的圆形半径最长是多少，没错，就是TextView的对角线长度。所以，整个逻辑就很简单了。</p>\n<p>我搞了下代码，就这样吧</p>\n<p><img src=\"http://img.blog.csdn.net/20160920202443596?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p>整个方法的代码如下吧，还包括控制FollowTv和unFollowTv哪个显示</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">setFollowed</span><span class=\"params\">(<span class=\"keyword\">boolean</span> isFollowed, <span class=\"keyword\">boolean</span> needAnimate)</span> </span>&#123;</div><div class=\"line\">    mIsFollowed = isFollowed;</div><div class=\"line\">    <span class=\"keyword\">if</span> (isFollowed) &#123;</div><div class=\"line\">        mUnFollowTv.setVisibility(View.VISIBLE);</div><div class=\"line\">        mFollowTv.setVisibility(View.VISIBLE);</div><div class=\"line\">        mFollowTv.bringToFront();</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        mUnFollowTv.setVisibility(View.VISIBLE);</div><div class=\"line\">        mFollowTv.setVisibility(View.VISIBLE);</div><div class=\"line\">        mUnFollowTv.bringToFront();</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> (needAnimate) &#123;</div><div class=\"line\">        ValueAnimator animator = ObjectAnimator.ofFloat(mFollowTv, <span class=\"string\">\"empty\"</span>, <span class=\"number\">0.0F</span>, (<span class=\"keyword\">float</span>) Math.hypot(getMeasuredWidth(), getMeasuredHeight()));</div><div class=\"line\">        animator.setDuration(<span class=\"number\">500L</span>);</div><div class=\"line\">        animator.addUpdateListener(<span class=\"keyword\">new</span> ValueAnimator.AnimatorUpdateListener() &#123;</div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onAnimationUpdate</span><span class=\"params\">(ValueAnimator animation)</span> </span>&#123;</div><div class=\"line\">                mRevealRadius = (Float) animation.getAnimatedValue();</div><div class=\"line\">                invalidate();</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div><div class=\"line\">        animator.start();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>根据当前状态把Follow的Textview或UnFollow的TextView显示出来，然后设置一个定时器不断扩大所要绘制圆的半径，根据这个半径裁剪画布成一个渐渐变大的圆形，然后内容就渐渐显示出来了。</p>\n<h2 id=\"实现最终效果\"><a href=\"#实现最终效果\" class=\"headerlink\" title=\"实现最终效果\"></a>实现最终效果</h2><p>这个效果实现出来之后，试着运行一下，还不错，但是总觉得有地方不对，于是细细观察，终于发现了，知乎的那个效果在刷新的时候，底下的背景不是白色的，还是之前的状态，比如要变成关注的时候，背景中的未关注还是在的，而我们实现的这个，刷新的时候背景是白色的。</p>\n<p>这是知乎的</p>\n<p><img src=\"http://img.blog.csdn.net/20160920202500751?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p>这是我的</p>\n<p><img src=\"http://img.blog.csdn.net/20160920202513237?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p>所以还是没有知乎那么行云流水，所以我们是少了什么吗。这时候想起来了，之前在RevealFrameLayout的drawChild里有一个判断条件，当时我们不知道它的逻辑是干什么的，现在看来。那部分逻辑就是处理这个的，画子控件的时候，要画两个，FollowTextView和UnFollowTextView，要随圆形刷出的控件我们采用裁剪画布的方式慢慢画出。那作为背景的另一个控件就不需要慢慢画出，只要完全画出来就行了。所以，猜想这里这个判断条件就是判断当前控件是不是要随圆形刷出的控件，如果不是，就直接画出来就行了。所以修改代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">boolean</span> <span class=\"title\">drawChild</span><span class=\"params\">(Canvas canvas, View paramView, <span class=\"keyword\">long</span> paramLong)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (drawBackground(paramView)) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.drawChild(canvas, paramView, paramLong);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">int</span> i = canvas.save();</div><div class=\"line\">    mPath.reset();</div><div class=\"line\">    mPath.addCircle(mCenterX, mCenterY, mRevealRadius, Path.Direction.CW);</div><div class=\"line\">    canvas.clipPath(<span class=\"keyword\">this</span>.mPath);</div><div class=\"line\">    <span class=\"keyword\">boolean</span> bool2 = <span class=\"keyword\">super</span>.drawChild(canvas, paramView, paramLong);</div><div class=\"line\">    canvas.restoreToCount(i);</div><div class=\"line\">    <span class=\"keyword\">return</span> bool2;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>判断的方法如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">drawBackground</span><span class=\"params\">(View paramView)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (mIsFollowed &amp;&amp; paramView == mUnFollowTv) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!mIsFollowed &amp;&amp; paramView == mFollowTv) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>至此，整个效果就和知乎完全一样了，刷新过程行云流水，非常赞。效果如下</p>\n<p><img src=\"http://img.blog.csdn.net/20160920202528190?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p><img src=\"http://img.blog.csdn.net/20160920202540940?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p><img src=\"http://img.blog.csdn.net/20160920202552455?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p><img src=\"http://img.blog.csdn.net/20160920202620051?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p><img src=\"http://img.blog.csdn.net/20160920202635129?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p><img src=\"http://img.blog.csdn.net/20160920202650911?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p>实现代码已上传至github：</p>\n<p><a href=\"https://github.com/zgzczzw/ZHFollowButton\">https://github.com/zgzczzw/ZHFollowButton</a></p>\n"},{"title":"基于SpringMVC4.3.2+Spring4.3.2+MyBatis3.4.1搭建SSM框架","date":"2016-09-28T09:07:08.000Z","_content":"\n终于到了框架搭建的最后一步，实现我们的终极目标SpringMVC+Spring+MyBatis的SSM框架，这篇文章也是基于之前搭建的SpringMVC+Spring+Hibernate框架演变过来的，所以没看过之前几篇文章的同学请乘传送带。\n\n[基于struts2.5.2+hibernate5.2.2+spring4.3.2搭建SSH框架](http://zwgeek.com/2016/09/03/%E5%9F%BA%E4%BA%8Estruts2-5-2-hibernate5-2-2-spring4-3-2%E6%90%AD%E5%BB%BASSH%E6%A1%86%E6%9E%B6v2/)\n\n[搭建SpringMVC+Spring4.3.2+Hibernate5.2.2框架](http://zwgeek.com/2016/09/27/%E6%90%AD%E5%BB%BASpringMVC-Spring4-3-2-Hibernate5-2-2%E6%A1%86%E6%9E%B6/)\n\n\n目录\n\n1. [删掉Hibernate相关Jar包](#删掉Hibernate相关Jar包)\n2. [加入MyBatis的Jar包](#加入MyBatis的Jar包)\n3. [加入MyBatis Spring支持包](#加入MyBatis Spring支持包)\n4. [配置Mybatis](#配置Mybatis)\n5. [配置数据库映射](#配置数据库映射)\n6. [修改Mybatis配置文件](#修改Mybatis配置文件)\n7. [修改DAO类](#修改DAO类)\n\n\n在之前搭建SpringMVC+Spring+Hibernate的基础上，我们替换Hibernate至Mybatis，其实很简单了，所以这篇文章也很短，其他关于Spring，DAO设计模式的介绍都在之前文章中说过了。另外至于为什么最后选择使用Mybatis而不是Hibernate的原因，也在之前说过了。所以看这篇文章之前还是要看下之前两篇文章的。好，接下来我们开始替换工作。\n\n### 删掉Hibernate相关Jar包\n首先删掉Hibernate相关的jar包，在这里我删掉了所有以Hibernate开头的jar包\n\n*注意：同时要删掉spring-orm的jar包，因为这个包依赖hibernate那边的包，那边的包删掉后这个还在的话会报错*\n\n### 加入MyBatis的Jar包\n然后我们引入Mybatis需要的包\n\n\n### 加入MyBatis Spring支持包\n这个包要单独从MyBatis官网下载，注意每个版本支持的Mybatis和Spring版本不一样，官网也有说明，这里因为我们MyBatis和Spring都是用的最新版本，所以mybatis-spring要最新的1.3.1。\n\n![这里写图片描述](http://img.blog.csdn.net/20160928174741789)\n\n如果版本不对的话，会报getTimeOut的异常，如果遇到这个异常，只要检查mybatis-spring这个jar包的版本号就可以了。\n\n### 配置Mybatis\n其实Mybatis和Hibernate总体的理念是差不多的，包括POJO，DAO的设计等等，不同的是他们对数据库的映射，及操作方式。抱歉这里我也是入门级的，无法评论孰优孰劣，具体关于Mybatis和Hibernate的差异可以自行百度，然后等我用一段时间后，有什么心得也会补充进来。\n\n所以需要改的地方其实不多，除了配置文件就是几个数据库映射，下面一一为大家讲解。\n\n### 配置数据库映射\n\nMybatis对数据库的映射是可以写成xml文件的，当然还有另外一种实现是用接口，这里只说一下xml形式的方法。\n\n值得注意的是Mybatis不需要映射数据表，我简单说一下原因，大家试着理解一下。Hibernate需要映射数据表，是因为Hibernate将对某张表的增删改查操作都用HQL实现了一遍，这样有一个好处就是开发者不用关心sql语言，就算数据库换了也没关心，Hibernate会做一个HQL->SQL的转换。缺点就是对SQL的优化很难。而Mybatis与Hibernate在这个点上完全不同，Mybatis不关心表结构，你需要自己配置增删改查的SQL语句，至于优点和缺点也恰好和Hibernate相反。下面我们看下Mybatis的配置文件。\n\n\n```xml\nmapping/userMapper\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n  <!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n<!-- 为这个mapper指定一个唯一的namespace，namespace的值习惯上设置成包名+sql映射文件名，这样就能够保证namespace的值是唯一的 \n\t例如namespace=\"me.gacl.mapping.userMapper\"就是me.gacl.mapping(包名)+userMapper(userMapper.xml文件去除后缀) -->\n<mapper namespace=\"com.helloworld.mapping.userMapper\">\n\t<!-- 在select标签中编写查询的SQL语句， 设置select标签的id属性为getUser，id属性值必须是唯一的，不能够重复 使用parameterType属性指明查询时使用的参数类型，resultType属性指明查询返回的结果集类型 \n\t\tresultType=\"me.gacl.domain.User\"就表示将查询结果封装成一个User类的对象返回 User类就是users表所对应的实体类 -->\n\t<!-- 根据id查询得到一个user对象 -->\n\t<select id=\"getUser\" parameterType=\"int\" resultType=\"com.helloworld.pojo.User\">\n\t\tselect *\n\t\tfrom user where userId=#{id}\n\t</select>\n</mapper>\n```\n\n大家看到在配置文件中我们配置了一条查询语句，配置了输入参数id，和返回参数。当然配置返回参数的类型后，Mybatis可以自动将返回的语句映射成一个JAVA类。\n\n### 修改Mybatis配置文件\n\n在前面框架配置的基础上，我们删掉spring-common.xml，因为前面也说过这个common配置是对datasource和session等关于Hibernate的配置，创建spring-mybatis.xml，将mybatis配置文件写入这个文件中。这也是前面说到配置文件分开的优势，你看，如果要修改持久层框架配置，只需要简单替换就可以了。\n\n配置如下\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:p=\"http://www.springframework.org/schema/p\"\n\txmlns:context=\"http://www.springframework.org/schema/context\"\n\txmlns:mvc=\"http://www.springframework.org/schema/mvc\"\n\txsi:schemaLocation=\"http://www.springframework.org/schema/beans  \n                        http://www.springframework.org/schema/beans/spring-beans-3.1.xsd  \n                        http://www.springframework.org/schema/context  \n                        http://www.springframework.org/schema/context/spring-context-3.1.xsd  \n                        http://www.springframework.org/schema/mvc  \n                        http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd\">\n\n\t<!-- 定义数据源的信息 -->\n\t<bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"\n\t\tdestroy-method=\"close\">\n\t\t<property name=\"driverClass\">\n\t\t\t<value>com.mysql.jdbc.Driver</value>\n\t\t</property>\n\t\t<property name=\"jdbcUrl\">\n\t\t\t<value>jdbc:mysql://localhost:3306/test</value>\n\t\t</property>\n\t\t<property name=\"user\">\n\t\t\t<value>root</value>\n\t\t</property>\n\t\t<property name=\"password\">\n\t\t\t<value>zzw</value>\n\t\t</property>\n\t\t<property name=\"maxPoolSize\">\n\t\t\t<value>80</value>\n\t\t</property>\n\t\t<property name=\"minPoolSize\">\n\t\t\t<value>1</value>\n\t\t</property>\n\t\t<property name=\"initialPoolSize\">\n\t\t\t<value>1</value>\n\t\t</property>\n\t\t<property name=\"maxIdleTime\">\n\t\t\t<value>20</value>\n\t\t</property>\n\t</bean>\n\n\t<!-- spring和MyBatis完美整合，不需要mybatis的配置映射文件 -->\n\t<bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\">\n\t\t<property name=\"dataSource\" ref=\"dataSource\" />\n\t\t<!-- 自动扫描mapping.xml文件 -->\n\t\t<property name=\"mapperLocations\" value=\"classpath:com/helloworld/mapping/*.xml\"></property>\n\t</bean>\n\n\t<!-- DAO接口所在包名，Spring会自动查找其下的类 -->\n\t<bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\">\n\t\t<property name=\"basePackage\" value=\"com.helloworld.dao\" />\n\t\t<property name=\"sqlSessionFactoryBeanName\" value=\"sqlSessionFactory\"></property>\n\t</bean>\n\n\t<!-- (事务管理)transaction manager, use JtaTransactionManager for global tx -->\n\t<bean id=\"transactionManager\"\n\t\tclass=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\n\t\t<property name=\"dataSource\" ref=\"dataSource\" />\n\t</bean>\n\n</beans>\n```\n\n\n配置文件也比较容易理解，因为和Hibernate的概念都是一样的。然后只要定义了mapperLocations，Spring会自动扫描路径下的所有mapper文件，做成Bean。同样的，配置DAO所在的包名，也能自动将session注入到DAO中。\n\n### 修改DAO类\n\n前面DAO类继承HibernateDaoSupport是对Hibernate的支持，这里自然也要改掉了，Mybatis需要继承SqlSessionDaoSupport，如下：\n\n```java\npackage com.helloworld.daoImpl;\n\nimport java.sql.Connection;\n\nimport org.apache.ibatis.session.SqlSession;\nimport org.apache.ibatis.session.SqlSessionFactory;\nimport org.mybatis.spring.support.SqlSessionDaoSupport;\n\nimport com.helloworld.dao.BaseDao;\nimport com.helloworld.pojo.User;\n\npublic class UserDao extends SqlSessionDaoSupport implements BaseDao{\n\n\t/**\n\t  * 获取相关的数据库连接\n\t  */\n\t public Connection getConnection() {\n\t  return getSqlSession().getConnection();\n\t }\n\t\n\tpublic UserDao() {\n\t\tSystem.out.println(\"UserDao IN\");\n\t}\n    \n    public User getUser(){\n    \tString statement = \"com.helloworld.mapping.userMapper.getUser\";//映射sql的标识字符串\n        //执行查询返回一个唯一user对象的sql\n        User user = getSqlSession().selectOne(statement, 1);\n    \treturn user;\n    }\n\n\t@Override\n\tpublic void saveObject(Object obj)\n\t{\n\t\t// TODO Auto-generated method stub\n\t\t\n\t}\n}\n```\n\n至于Mapper文件中配置的查询文件怎么用，这里也给了一个简单的例子，非常简单，看一下就可以了。\n\n配置完成之后整个项目的目录结构如下\n\n![这里写图片描述](http://img.blog.csdn.net/20160928174844008)\n\n至此，Mybatis框架已经配置完成，可以和Hibernate一样写个Test类，看能不能正常获取到数据库中的数据，也可以将项目发布，看访问页面能不能获取的数据。\n\n如果没什么意外，现在应该已经能够通过访问页面来访问数据库然后显示给用户了。一个WEB项目最简单的流程也就跑通了，然后就可以在这个简单流程上开发自己相应的业务了。那接下来我也要去做我的业务了，开发过程中有什么心得也会发在博客中跟大家分享，敬请期待。\n\n\n\n\n\n\n\n\n","source":"_posts/基于SpringMVC4-3-2-Spring4-3-2-MyBatis3-4-1搭建SSM框架.md","raw":"---\ntitle: 基于SpringMVC4.3.2+Spring4.3.2+MyBatis3.4.1搭建SSM框架\ndate: 2016-09-28 17:07:08\ntags:\n  - Java Web\n  - 服务端\n  - SpringMVC\n  - MyBatis\n  - SSM\ncategories: 服务端开发\n---\n\n终于到了框架搭建的最后一步，实现我们的终极目标SpringMVC+Spring+MyBatis的SSM框架，这篇文章也是基于之前搭建的SpringMVC+Spring+Hibernate框架演变过来的，所以没看过之前几篇文章的同学请乘传送带。\n\n[基于struts2.5.2+hibernate5.2.2+spring4.3.2搭建SSH框架](http://zwgeek.com/2016/09/03/%E5%9F%BA%E4%BA%8Estruts2-5-2-hibernate5-2-2-spring4-3-2%E6%90%AD%E5%BB%BASSH%E6%A1%86%E6%9E%B6v2/)\n\n[搭建SpringMVC+Spring4.3.2+Hibernate5.2.2框架](http://zwgeek.com/2016/09/27/%E6%90%AD%E5%BB%BASpringMVC-Spring4-3-2-Hibernate5-2-2%E6%A1%86%E6%9E%B6/)\n\n\n目录\n\n1. [删掉Hibernate相关Jar包](#删掉Hibernate相关Jar包)\n2. [加入MyBatis的Jar包](#加入MyBatis的Jar包)\n3. [加入MyBatis Spring支持包](#加入MyBatis Spring支持包)\n4. [配置Mybatis](#配置Mybatis)\n5. [配置数据库映射](#配置数据库映射)\n6. [修改Mybatis配置文件](#修改Mybatis配置文件)\n7. [修改DAO类](#修改DAO类)\n\n\n在之前搭建SpringMVC+Spring+Hibernate的基础上，我们替换Hibernate至Mybatis，其实很简单了，所以这篇文章也很短，其他关于Spring，DAO设计模式的介绍都在之前文章中说过了。另外至于为什么最后选择使用Mybatis而不是Hibernate的原因，也在之前说过了。所以看这篇文章之前还是要看下之前两篇文章的。好，接下来我们开始替换工作。\n\n### 删掉Hibernate相关Jar包\n首先删掉Hibernate相关的jar包，在这里我删掉了所有以Hibernate开头的jar包\n\n*注意：同时要删掉spring-orm的jar包，因为这个包依赖hibernate那边的包，那边的包删掉后这个还在的话会报错*\n\n### 加入MyBatis的Jar包\n然后我们引入Mybatis需要的包\n\n\n### 加入MyBatis Spring支持包\n这个包要单独从MyBatis官网下载，注意每个版本支持的Mybatis和Spring版本不一样，官网也有说明，这里因为我们MyBatis和Spring都是用的最新版本，所以mybatis-spring要最新的1.3.1。\n\n![这里写图片描述](http://img.blog.csdn.net/20160928174741789)\n\n如果版本不对的话，会报getTimeOut的异常，如果遇到这个异常，只要检查mybatis-spring这个jar包的版本号就可以了。\n\n### 配置Mybatis\n其实Mybatis和Hibernate总体的理念是差不多的，包括POJO，DAO的设计等等，不同的是他们对数据库的映射，及操作方式。抱歉这里我也是入门级的，无法评论孰优孰劣，具体关于Mybatis和Hibernate的差异可以自行百度，然后等我用一段时间后，有什么心得也会补充进来。\n\n所以需要改的地方其实不多，除了配置文件就是几个数据库映射，下面一一为大家讲解。\n\n### 配置数据库映射\n\nMybatis对数据库的映射是可以写成xml文件的，当然还有另外一种实现是用接口，这里只说一下xml形式的方法。\n\n值得注意的是Mybatis不需要映射数据表，我简单说一下原因，大家试着理解一下。Hibernate需要映射数据表，是因为Hibernate将对某张表的增删改查操作都用HQL实现了一遍，这样有一个好处就是开发者不用关心sql语言，就算数据库换了也没关心，Hibernate会做一个HQL->SQL的转换。缺点就是对SQL的优化很难。而Mybatis与Hibernate在这个点上完全不同，Mybatis不关心表结构，你需要自己配置增删改查的SQL语句，至于优点和缺点也恰好和Hibernate相反。下面我们看下Mybatis的配置文件。\n\n\n```xml\nmapping/userMapper\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n  <!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n<!-- 为这个mapper指定一个唯一的namespace，namespace的值习惯上设置成包名+sql映射文件名，这样就能够保证namespace的值是唯一的 \n\t例如namespace=\"me.gacl.mapping.userMapper\"就是me.gacl.mapping(包名)+userMapper(userMapper.xml文件去除后缀) -->\n<mapper namespace=\"com.helloworld.mapping.userMapper\">\n\t<!-- 在select标签中编写查询的SQL语句， 设置select标签的id属性为getUser，id属性值必须是唯一的，不能够重复 使用parameterType属性指明查询时使用的参数类型，resultType属性指明查询返回的结果集类型 \n\t\tresultType=\"me.gacl.domain.User\"就表示将查询结果封装成一个User类的对象返回 User类就是users表所对应的实体类 -->\n\t<!-- 根据id查询得到一个user对象 -->\n\t<select id=\"getUser\" parameterType=\"int\" resultType=\"com.helloworld.pojo.User\">\n\t\tselect *\n\t\tfrom user where userId=#{id}\n\t</select>\n</mapper>\n```\n\n大家看到在配置文件中我们配置了一条查询语句，配置了输入参数id，和返回参数。当然配置返回参数的类型后，Mybatis可以自动将返回的语句映射成一个JAVA类。\n\n### 修改Mybatis配置文件\n\n在前面框架配置的基础上，我们删掉spring-common.xml，因为前面也说过这个common配置是对datasource和session等关于Hibernate的配置，创建spring-mybatis.xml，将mybatis配置文件写入这个文件中。这也是前面说到配置文件分开的优势，你看，如果要修改持久层框架配置，只需要简单替换就可以了。\n\n配置如下\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:p=\"http://www.springframework.org/schema/p\"\n\txmlns:context=\"http://www.springframework.org/schema/context\"\n\txmlns:mvc=\"http://www.springframework.org/schema/mvc\"\n\txsi:schemaLocation=\"http://www.springframework.org/schema/beans  \n                        http://www.springframework.org/schema/beans/spring-beans-3.1.xsd  \n                        http://www.springframework.org/schema/context  \n                        http://www.springframework.org/schema/context/spring-context-3.1.xsd  \n                        http://www.springframework.org/schema/mvc  \n                        http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd\">\n\n\t<!-- 定义数据源的信息 -->\n\t<bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"\n\t\tdestroy-method=\"close\">\n\t\t<property name=\"driverClass\">\n\t\t\t<value>com.mysql.jdbc.Driver</value>\n\t\t</property>\n\t\t<property name=\"jdbcUrl\">\n\t\t\t<value>jdbc:mysql://localhost:3306/test</value>\n\t\t</property>\n\t\t<property name=\"user\">\n\t\t\t<value>root</value>\n\t\t</property>\n\t\t<property name=\"password\">\n\t\t\t<value>zzw</value>\n\t\t</property>\n\t\t<property name=\"maxPoolSize\">\n\t\t\t<value>80</value>\n\t\t</property>\n\t\t<property name=\"minPoolSize\">\n\t\t\t<value>1</value>\n\t\t</property>\n\t\t<property name=\"initialPoolSize\">\n\t\t\t<value>1</value>\n\t\t</property>\n\t\t<property name=\"maxIdleTime\">\n\t\t\t<value>20</value>\n\t\t</property>\n\t</bean>\n\n\t<!-- spring和MyBatis完美整合，不需要mybatis的配置映射文件 -->\n\t<bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\">\n\t\t<property name=\"dataSource\" ref=\"dataSource\" />\n\t\t<!-- 自动扫描mapping.xml文件 -->\n\t\t<property name=\"mapperLocations\" value=\"classpath:com/helloworld/mapping/*.xml\"></property>\n\t</bean>\n\n\t<!-- DAO接口所在包名，Spring会自动查找其下的类 -->\n\t<bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\">\n\t\t<property name=\"basePackage\" value=\"com.helloworld.dao\" />\n\t\t<property name=\"sqlSessionFactoryBeanName\" value=\"sqlSessionFactory\"></property>\n\t</bean>\n\n\t<!-- (事务管理)transaction manager, use JtaTransactionManager for global tx -->\n\t<bean id=\"transactionManager\"\n\t\tclass=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\n\t\t<property name=\"dataSource\" ref=\"dataSource\" />\n\t</bean>\n\n</beans>\n```\n\n\n配置文件也比较容易理解，因为和Hibernate的概念都是一样的。然后只要定义了mapperLocations，Spring会自动扫描路径下的所有mapper文件，做成Bean。同样的，配置DAO所在的包名，也能自动将session注入到DAO中。\n\n### 修改DAO类\n\n前面DAO类继承HibernateDaoSupport是对Hibernate的支持，这里自然也要改掉了，Mybatis需要继承SqlSessionDaoSupport，如下：\n\n```java\npackage com.helloworld.daoImpl;\n\nimport java.sql.Connection;\n\nimport org.apache.ibatis.session.SqlSession;\nimport org.apache.ibatis.session.SqlSessionFactory;\nimport org.mybatis.spring.support.SqlSessionDaoSupport;\n\nimport com.helloworld.dao.BaseDao;\nimport com.helloworld.pojo.User;\n\npublic class UserDao extends SqlSessionDaoSupport implements BaseDao{\n\n\t/**\n\t  * 获取相关的数据库连接\n\t  */\n\t public Connection getConnection() {\n\t  return getSqlSession().getConnection();\n\t }\n\t\n\tpublic UserDao() {\n\t\tSystem.out.println(\"UserDao IN\");\n\t}\n    \n    public User getUser(){\n    \tString statement = \"com.helloworld.mapping.userMapper.getUser\";//映射sql的标识字符串\n        //执行查询返回一个唯一user对象的sql\n        User user = getSqlSession().selectOne(statement, 1);\n    \treturn user;\n    }\n\n\t@Override\n\tpublic void saveObject(Object obj)\n\t{\n\t\t// TODO Auto-generated method stub\n\t\t\n\t}\n}\n```\n\n至于Mapper文件中配置的查询文件怎么用，这里也给了一个简单的例子，非常简单，看一下就可以了。\n\n配置完成之后整个项目的目录结构如下\n\n![这里写图片描述](http://img.blog.csdn.net/20160928174844008)\n\n至此，Mybatis框架已经配置完成，可以和Hibernate一样写个Test类，看能不能正常获取到数据库中的数据，也可以将项目发布，看访问页面能不能获取的数据。\n\n如果没什么意外，现在应该已经能够通过访问页面来访问数据库然后显示给用户了。一个WEB项目最简单的流程也就跑通了，然后就可以在这个简单流程上开发自己相应的业务了。那接下来我也要去做我的业务了，开发过程中有什么心得也会发在博客中跟大家分享，敬请期待。\n\n\n\n\n\n\n\n\n","slug":"基于SpringMVC4-3-2-Spring4-3-2-MyBatis3-4-1搭建SSM框架","published":1,"updated":"2024-06-14T09:25:33.679Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clxjsxtw80014lq6gbxnkycum","content":"<p>终于到了框架搭建的最后一步，实现我们的终极目标SpringMVC+Spring+MyBatis的SSM框架，这篇文章也是基于之前搭建的SpringMVC+Spring+Hibernate框架演变过来的，所以没看过之前几篇文章的同学请乘传送带。</p>\n<p><a href=\"http://zwgeek.com/2016/09/03/%E5%9F%BA%E4%BA%8Estruts2-5-2-hibernate5-2-2-spring4-3-2%E6%90%AD%E5%BB%BASSH%E6%A1%86%E6%9E%B6v2/\">基于struts2.5.2+hibernate5.2.2+spring4.3.2搭建SSH框架</a></p>\n<p><a href=\"http://zwgeek.com/2016/09/27/%E6%90%AD%E5%BB%BASpringMVC-Spring4-3-2-Hibernate5-2-2%E6%A1%86%E6%9E%B6/\">搭建SpringMVC+Spring4.3.2+Hibernate5.2.2框架</a></p>\n<p>目录</p>\n<ol>\n<li><a href=\"#删掉Hibernate相关Jar包\">删掉Hibernate相关Jar包</a></li>\n<li><a href=\"#加入MyBatis的Jar包\">加入MyBatis的Jar包</a></li>\n<li><a href=\"#加入MyBatis Spring支持包\">加入MyBatis Spring支持包</a></li>\n<li><a href=\"#配置Mybatis\">配置Mybatis</a></li>\n<li><a href=\"#配置数据库映射\">配置数据库映射</a></li>\n<li><a href=\"#修改Mybatis配置文件\">修改Mybatis配置文件</a></li>\n<li><a href=\"#修改DAO类\">修改DAO类</a></li>\n</ol>\n<p>在之前搭建SpringMVC+Spring+Hibernate的基础上，我们替换Hibernate至Mybatis，其实很简单了，所以这篇文章也很短，其他关于Spring，DAO设计模式的介绍都在之前文章中说过了。另外至于为什么最后选择使用Mybatis而不是Hibernate的原因，也在之前说过了。所以看这篇文章之前还是要看下之前两篇文章的。好，接下来我们开始替换工作。</p>\n<h3 id=\"删掉Hibernate相关Jar包\"><a href=\"#删掉Hibernate相关Jar包\" class=\"headerlink\" title=\"删掉Hibernate相关Jar包\"></a>删掉Hibernate相关Jar包</h3><p>首先删掉Hibernate相关的jar包，在这里我删掉了所有以Hibernate开头的jar包</p>\n<p><em>注意：同时要删掉spring-orm的jar包，因为这个包依赖hibernate那边的包，那边的包删掉后这个还在的话会报错</em></p>\n<h3 id=\"加入MyBatis的Jar包\"><a href=\"#加入MyBatis的Jar包\" class=\"headerlink\" title=\"加入MyBatis的Jar包\"></a>加入MyBatis的Jar包</h3><p>然后我们引入Mybatis需要的包</p>\n<h3 id=\"加入MyBatis-Spring支持包\"><a href=\"#加入MyBatis-Spring支持包\" class=\"headerlink\" title=\"加入MyBatis Spring支持包\"></a>加入MyBatis Spring支持包</h3><p>这个包要单独从MyBatis官网下载，注意每个版本支持的Mybatis和Spring版本不一样，官网也有说明，这里因为我们MyBatis和Spring都是用的最新版本，所以mybatis-spring要最新的1.3.1。</p>\n<p><img src=\"http://img.blog.csdn.net/20160928174741789\" alt=\"这里写图片描述\"></p>\n<p>如果版本不对的话，会报getTimeOut的异常，如果遇到这个异常，只要检查mybatis-spring这个jar包的版本号就可以了。</p>\n<h3 id=\"配置Mybatis\"><a href=\"#配置Mybatis\" class=\"headerlink\" title=\"配置Mybatis\"></a>配置Mybatis</h3><p>其实Mybatis和Hibernate总体的理念是差不多的，包括POJO，DAO的设计等等，不同的是他们对数据库的映射，及操作方式。抱歉这里我也是入门级的，无法评论孰优孰劣，具体关于Mybatis和Hibernate的差异可以自行百度，然后等我用一段时间后，有什么心得也会补充进来。</p>\n<p>所以需要改的地方其实不多，除了配置文件就是几个数据库映射，下面一一为大家讲解。</p>\n<h3 id=\"配置数据库映射\"><a href=\"#配置数据库映射\" class=\"headerlink\" title=\"配置数据库映射\"></a>配置数据库映射</h3><p>Mybatis对数据库的映射是可以写成xml文件的，当然还有另外一种实现是用接口，这里只说一下xml形式的方法。</p>\n<p>值得注意的是Mybatis不需要映射数据表，我简单说一下原因，大家试着理解一下。Hibernate需要映射数据表，是因为Hibernate将对某张表的增删改查操作都用HQL实现了一遍，这样有一个好处就是开发者不用关心sql语言，就算数据库换了也没关心，Hibernate会做一个HQL-&gt;SQL的转换。缺点就是对SQL的优化很难。而Mybatis与Hibernate在这个点上完全不同，Mybatis不关心表结构，你需要自己配置增删改查的SQL语句，至于优点和缺点也恰好和Hibernate相反。下面我们看下Mybatis的配置文件。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">mapping/userMapper</div><div class=\"line\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;</div><div class=\"line\">  <span class=\"meta\">&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;</span></div><div class=\"line\"><span class=\"comment\">&lt;!-- 为这个mapper指定一个唯一的namespace，namespace的值习惯上设置成包名+sql映射文件名，这样就能够保证namespace的值是唯一的 </span></div><div class=\"line\">\t例如namespace=\"me.gacl.mapping.userMapper\"就是me.gacl.mapping(包名)+userMapper(userMapper.xml文件去除后缀) --&gt;</div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">mapper</span> <span class=\"attr\">namespace</span>=<span class=\"string\">\"com.helloworld.mapping.userMapper\"</span>&gt;</span></div><div class=\"line\">\t<span class=\"comment\">&lt;!-- 在select标签中编写查询的SQL语句， 设置select标签的id属性为getUser，id属性值必须是唯一的，不能够重复 使用parameterType属性指明查询时使用的参数类型，resultType属性指明查询返回的结果集类型 </span></div><div class=\"line\">\t\tresultType=\"me.gacl.domain.User\"就表示将查询结果封装成一个User类的对象返回 User类就是users表所对应的实体类 --&gt;</div><div class=\"line\">\t<span class=\"comment\">&lt;!-- 根据id查询得到一个user对象 --&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">id</span>=<span class=\"string\">\"getUser\"</span> <span class=\"attr\">parameterType</span>=<span class=\"string\">\"int\"</span> <span class=\"attr\">resultType</span>=<span class=\"string\">\"com.helloworld.pojo.User\"</span>&gt;</span></div><div class=\"line\">\t\tselect *</div><div class=\"line\">\t\tfrom user where userId=#&#123;id&#125;</div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">mapper</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>大家看到在配置文件中我们配置了一条查询语句，配置了输入参数id，和返回参数。当然配置返回参数的类型后，Mybatis可以自动将返回的语句映射成一个JAVA类。</p>\n<h3 id=\"修改Mybatis配置文件\"><a href=\"#修改Mybatis配置文件\" class=\"headerlink\" title=\"修改Mybatis配置文件\"></a>修改Mybatis配置文件</h3><p>在前面框架配置的基础上，我们删掉spring-common.xml，因为前面也说过这个common配置是对datasource和session等关于Hibernate的配置，创建spring-mybatis.xml，将mybatis配置文件写入这个文件中。这也是前面说到配置文件分开的优势，你看，如果要修改持久层框架配置，只需要简单替换就可以了。</p>\n<p>配置如下</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans\"</span></span></div><div class=\"line\">\t<span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span> <span class=\"attr\">xmlns:p</span>=<span class=\"string\">\"http://www.springframework.org/schema/p\"</span></div><div class=\"line\">\t<span class=\"attr\">xmlns:context</span>=<span class=\"string\">\"http://www.springframework.org/schema/context\"</span></div><div class=\"line\">\t<span class=\"attr\">xmlns:mvc</span>=<span class=\"string\">\"http://www.springframework.org/schema/mvc\"</span></div><div class=\"line\">\t<span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans  </span></div><div class=\"line\">                        http://www.springframework.org/schema/beans/spring-beans-3.1.xsd  </div><div class=\"line\">                        http://www.springframework.org/schema/context  </div><div class=\"line\">                        http://www.springframework.org/schema/context/spring-context-3.1.xsd  </div><div class=\"line\">                        http://www.springframework.org/schema/mvc  </div><div class=\"line\">                        http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd\"&gt;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">&lt;!-- 定义数据源的信息 --&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"dataSource\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.mchange.v2.c3p0.ComboPooledDataSource\"</span></span></div><div class=\"line\">\t\t<span class=\"attr\">destroy-method</span>=<span class=\"string\">\"close\"</span>&gt;</div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"driverClass\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>com.mysql.jdbc.Driver<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"jdbcUrl\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>jdbc:mysql://localhost:3306/test<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"user\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>root<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"password\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>zzw<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"maxPoolSize\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>80<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"minPoolSize\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>1<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"initialPoolSize\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>1<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"maxIdleTime\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>20<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">&lt;!-- spring和MyBatis完美整合，不需要mybatis的配置映射文件 --&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"sqlSessionFactory\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.mybatis.spring.SqlSessionFactoryBean\"</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"dataSource\"</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"dataSource\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"comment\">&lt;!-- 自动扫描mapping.xml文件 --&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"mapperLocations\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"classpath:com/helloworld/mapping/*.xml\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">&lt;!-- DAO接口所在包名，Spring会自动查找其下的类 --&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.mybatis.spring.mapper.MapperScannerConfigurer\"</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"basePackage\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"com.helloworld.dao\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"sqlSessionFactoryBeanName\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"sqlSessionFactory\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">&lt;!-- (事务管理)transaction manager, use JtaTransactionManager for global tx --&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"transactionManager\"</span></span></div><div class=\"line\">\t\t<span class=\"attr\">class</span>=<span class=\"string\">\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"</span>&gt;</div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"dataSource\"</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"dataSource\"</span> /&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>配置文件也比较容易理解，因为和Hibernate的概念都是一样的。然后只要定义了mapperLocations，Spring会自动扫描路径下的所有mapper文件，做成Bean。同样的，配置DAO所在的包名，也能自动将session注入到DAO中。</p>\n<h3 id=\"修改DAO类\"><a href=\"#修改DAO类\" class=\"headerlink\" title=\"修改DAO类\"></a>修改DAO类</h3><p>前面DAO类继承HibernateDaoSupport是对Hibernate的支持，这里自然也要改掉了，Mybatis需要继承SqlSessionDaoSupport，如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> com.helloworld.daoImpl;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> java.sql.Connection;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> org.apache.ibatis.session.SqlSession;</div><div class=\"line\"><span class=\"keyword\">import</span> org.apache.ibatis.session.SqlSessionFactory;</div><div class=\"line\"><span class=\"keyword\">import</span> org.mybatis.spring.support.SqlSessionDaoSupport;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> com.helloworld.dao.BaseDao;</div><div class=\"line\"><span class=\"keyword\">import</span> com.helloworld.pojo.User;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserDao</span> <span class=\"keyword\">extends</span> <span class=\"title\">SqlSessionDaoSupport</span> <span class=\"keyword\">implements</span> <span class=\"title\">BaseDao</span></span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">/**</span></div><div class=\"line\">\t  * 获取相关的数据库连接</div><div class=\"line\">\t  */</div><div class=\"line\">\t <span class=\"function\"><span class=\"keyword\">public</span> Connection <span class=\"title\">getConnection</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t  <span class=\"keyword\">return</span> getSqlSession().getConnection();</div><div class=\"line\">\t &#125;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">UserDao</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"UserDao IN\"</span>);</div><div class=\"line\">\t&#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> User <span class=\"title\">getUser</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">    \tString statement = <span class=\"string\">\"com.helloworld.mapping.userMapper.getUser\"</span>;<span class=\"comment\">//映射sql的标识字符串</span></div><div class=\"line\">        <span class=\"comment\">//执行查询返回一个唯一user对象的sql</span></div><div class=\"line\">        User user = getSqlSession().selectOne(statement, <span class=\"number\">1</span>);</div><div class=\"line\">    \t<span class=\"keyword\">return</span> user;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">saveObject</span><span class=\"params\">(Object obj)</span></span></div><div class=\"line\">\t&#123;</div><div class=\"line\">\t\t<span class=\"comment\">// TODO Auto-generated method stub</span></div><div class=\"line\">\t\t</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>至于Mapper文件中配置的查询文件怎么用，这里也给了一个简单的例子，非常简单，看一下就可以了。</p>\n<p>配置完成之后整个项目的目录结构如下</p>\n<p><img src=\"http://img.blog.csdn.net/20160928174844008\" alt=\"这里写图片描述\"></p>\n<p>至此，Mybatis框架已经配置完成，可以和Hibernate一样写个Test类，看能不能正常获取到数据库中的数据，也可以将项目发布，看访问页面能不能获取的数据。</p>\n<p>如果没什么意外，现在应该已经能够通过访问页面来访问数据库然后显示给用户了。一个WEB项目最简单的流程也就跑通了，然后就可以在这个简单流程上开发自己相应的业务了。那接下来我也要去做我的业务了，开发过程中有什么心得也会发在博客中跟大家分享，敬请期待。</p>\n","excerpt":"","more":"<p>终于到了框架搭建的最后一步，实现我们的终极目标SpringMVC+Spring+MyBatis的SSM框架，这篇文章也是基于之前搭建的SpringMVC+Spring+Hibernate框架演变过来的，所以没看过之前几篇文章的同学请乘传送带。</p>\n<p><a href=\"http://zwgeek.com/2016/09/03/%E5%9F%BA%E4%BA%8Estruts2-5-2-hibernate5-2-2-spring4-3-2%E6%90%AD%E5%BB%BASSH%E6%A1%86%E6%9E%B6v2/\">基于struts2.5.2+hibernate5.2.2+spring4.3.2搭建SSH框架</a></p>\n<p><a href=\"http://zwgeek.com/2016/09/27/%E6%90%AD%E5%BB%BASpringMVC-Spring4-3-2-Hibernate5-2-2%E6%A1%86%E6%9E%B6/\">搭建SpringMVC+Spring4.3.2+Hibernate5.2.2框架</a></p>\n<p>目录</p>\n<ol>\n<li><a href=\"#删掉Hibernate相关Jar包\">删掉Hibernate相关Jar包</a></li>\n<li><a href=\"#加入MyBatis的Jar包\">加入MyBatis的Jar包</a></li>\n<li><a href=\"#加入MyBatis Spring支持包\">加入MyBatis Spring支持包</a></li>\n<li><a href=\"#配置Mybatis\">配置Mybatis</a></li>\n<li><a href=\"#配置数据库映射\">配置数据库映射</a></li>\n<li><a href=\"#修改Mybatis配置文件\">修改Mybatis配置文件</a></li>\n<li><a href=\"#修改DAO类\">修改DAO类</a></li>\n</ol>\n<p>在之前搭建SpringMVC+Spring+Hibernate的基础上，我们替换Hibernate至Mybatis，其实很简单了，所以这篇文章也很短，其他关于Spring，DAO设计模式的介绍都在之前文章中说过了。另外至于为什么最后选择使用Mybatis而不是Hibernate的原因，也在之前说过了。所以看这篇文章之前还是要看下之前两篇文章的。好，接下来我们开始替换工作。</p>\n<h3 id=\"删掉Hibernate相关Jar包\"><a href=\"#删掉Hibernate相关Jar包\" class=\"headerlink\" title=\"删掉Hibernate相关Jar包\"></a>删掉Hibernate相关Jar包</h3><p>首先删掉Hibernate相关的jar包，在这里我删掉了所有以Hibernate开头的jar包</p>\n<p><em>注意：同时要删掉spring-orm的jar包，因为这个包依赖hibernate那边的包，那边的包删掉后这个还在的话会报错</em></p>\n<h3 id=\"加入MyBatis的Jar包\"><a href=\"#加入MyBatis的Jar包\" class=\"headerlink\" title=\"加入MyBatis的Jar包\"></a>加入MyBatis的Jar包</h3><p>然后我们引入Mybatis需要的包</p>\n<h3 id=\"加入MyBatis-Spring支持包\"><a href=\"#加入MyBatis-Spring支持包\" class=\"headerlink\" title=\"加入MyBatis Spring支持包\"></a>加入MyBatis Spring支持包</h3><p>这个包要单独从MyBatis官网下载，注意每个版本支持的Mybatis和Spring版本不一样，官网也有说明，这里因为我们MyBatis和Spring都是用的最新版本，所以mybatis-spring要最新的1.3.1。</p>\n<p><img src=\"http://img.blog.csdn.net/20160928174741789\" alt=\"这里写图片描述\"></p>\n<p>如果版本不对的话，会报getTimeOut的异常，如果遇到这个异常，只要检查mybatis-spring这个jar包的版本号就可以了。</p>\n<h3 id=\"配置Mybatis\"><a href=\"#配置Mybatis\" class=\"headerlink\" title=\"配置Mybatis\"></a>配置Mybatis</h3><p>其实Mybatis和Hibernate总体的理念是差不多的，包括POJO，DAO的设计等等，不同的是他们对数据库的映射，及操作方式。抱歉这里我也是入门级的，无法评论孰优孰劣，具体关于Mybatis和Hibernate的差异可以自行百度，然后等我用一段时间后，有什么心得也会补充进来。</p>\n<p>所以需要改的地方其实不多，除了配置文件就是几个数据库映射，下面一一为大家讲解。</p>\n<h3 id=\"配置数据库映射\"><a href=\"#配置数据库映射\" class=\"headerlink\" title=\"配置数据库映射\"></a>配置数据库映射</h3><p>Mybatis对数据库的映射是可以写成xml文件的，当然还有另外一种实现是用接口，这里只说一下xml形式的方法。</p>\n<p>值得注意的是Mybatis不需要映射数据表，我简单说一下原因，大家试着理解一下。Hibernate需要映射数据表，是因为Hibernate将对某张表的增删改查操作都用HQL实现了一遍，这样有一个好处就是开发者不用关心sql语言，就算数据库换了也没关心，Hibernate会做一个HQL-&gt;SQL的转换。缺点就是对SQL的优化很难。而Mybatis与Hibernate在这个点上完全不同，Mybatis不关心表结构，你需要自己配置增删改查的SQL语句，至于优点和缺点也恰好和Hibernate相反。下面我们看下Mybatis的配置文件。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">mapping/userMapper</div><div class=\"line\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;</div><div class=\"line\">  <span class=\"meta\">&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;</span></div><div class=\"line\"><span class=\"comment\">&lt;!-- 为这个mapper指定一个唯一的namespace，namespace的值习惯上设置成包名+sql映射文件名，这样就能够保证namespace的值是唯一的 </div><div class=\"line\">\t例如namespace=\"me.gacl.mapping.userMapper\"就是me.gacl.mapping(包名)+userMapper(userMapper.xml文件去除后缀) --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">mapper</span> <span class=\"attr\">namespace</span>=<span class=\"string\">\"com.helloworld.mapping.userMapper\"</span>&gt;</span></div><div class=\"line\">\t<span class=\"comment\">&lt;!-- 在select标签中编写查询的SQL语句， 设置select标签的id属性为getUser，id属性值必须是唯一的，不能够重复 使用parameterType属性指明查询时使用的参数类型，resultType属性指明查询返回的结果集类型 </div><div class=\"line\">\t\tresultType=\"me.gacl.domain.User\"就表示将查询结果封装成一个User类的对象返回 User类就是users表所对应的实体类 --&gt;</span></div><div class=\"line\">\t<span class=\"comment\">&lt;!-- 根据id查询得到一个user对象 --&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">id</span>=<span class=\"string\">\"getUser\"</span> <span class=\"attr\">parameterType</span>=<span class=\"string\">\"int\"</span> <span class=\"attr\">resultType</span>=<span class=\"string\">\"com.helloworld.pojo.User\"</span>&gt;</span></div><div class=\"line\">\t\tselect *</div><div class=\"line\">\t\tfrom user where userId=#&#123;id&#125;</div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">mapper</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>大家看到在配置文件中我们配置了一条查询语句，配置了输入参数id，和返回参数。当然配置返回参数的类型后，Mybatis可以自动将返回的语句映射成一个JAVA类。</p>\n<h3 id=\"修改Mybatis配置文件\"><a href=\"#修改Mybatis配置文件\" class=\"headerlink\" title=\"修改Mybatis配置文件\"></a>修改Mybatis配置文件</h3><p>在前面框架配置的基础上，我们删掉spring-common.xml，因为前面也说过这个common配置是对datasource和session等关于Hibernate的配置，创建spring-mybatis.xml，将mybatis配置文件写入这个文件中。这也是前面说到配置文件分开的优势，你看，如果要修改持久层框架配置，只需要简单替换就可以了。</p>\n<p>配置如下</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans\"</span></div><div class=\"line\">\t<span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span> <span class=\"attr\">xmlns:p</span>=<span class=\"string\">\"http://www.springframework.org/schema/p\"</span></div><div class=\"line\">\t<span class=\"attr\">xmlns:context</span>=<span class=\"string\">\"http://www.springframework.org/schema/context\"</span></div><div class=\"line\">\t<span class=\"attr\">xmlns:mvc</span>=<span class=\"string\">\"http://www.springframework.org/schema/mvc\"</span></div><div class=\"line\">\t<span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans  </div><div class=\"line\">                        http://www.springframework.org/schema/beans/spring-beans-3.1.xsd  </div><div class=\"line\">                        http://www.springframework.org/schema/context  </div><div class=\"line\">                        http://www.springframework.org/schema/context/spring-context-3.1.xsd  </div><div class=\"line\">                        http://www.springframework.org/schema/mvc  </div><div class=\"line\">                        http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd\"</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">&lt;!-- 定义数据源的信息 --&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"dataSource\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.mchange.v2.c3p0.ComboPooledDataSource\"</span></div><div class=\"line\">\t\t<span class=\"attr\">destroy-method</span>=<span class=\"string\">\"close\"</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"driverClass\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>com.mysql.jdbc.Driver<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"jdbcUrl\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>jdbc:mysql://localhost:3306/test<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"user\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>root<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"password\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>zzw<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"maxPoolSize\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>80<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"minPoolSize\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>1<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"initialPoolSize\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>1<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"maxIdleTime\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>20<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">&lt;!-- spring和MyBatis完美整合，不需要mybatis的配置映射文件 --&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"sqlSessionFactory\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.mybatis.spring.SqlSessionFactoryBean\"</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"dataSource\"</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"dataSource\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"comment\">&lt;!-- 自动扫描mapping.xml文件 --&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"mapperLocations\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"classpath:com/helloworld/mapping/*.xml\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">&lt;!-- DAO接口所在包名，Spring会自动查找其下的类 --&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.mybatis.spring.mapper.MapperScannerConfigurer\"</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"basePackage\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"com.helloworld.dao\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"sqlSessionFactoryBeanName\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"sqlSessionFactory\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">&lt;!-- (事务管理)transaction manager, use JtaTransactionManager for global tx --&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"transactionManager\"</span></div><div class=\"line\">\t\t<span class=\"attr\">class</span>=<span class=\"string\">\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"dataSource\"</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"dataSource\"</span> /&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>配置文件也比较容易理解，因为和Hibernate的概念都是一样的。然后只要定义了mapperLocations，Spring会自动扫描路径下的所有mapper文件，做成Bean。同样的，配置DAO所在的包名，也能自动将session注入到DAO中。</p>\n<h3 id=\"修改DAO类\"><a href=\"#修改DAO类\" class=\"headerlink\" title=\"修改DAO类\"></a>修改DAO类</h3><p>前面DAO类继承HibernateDaoSupport是对Hibernate的支持，这里自然也要改掉了，Mybatis需要继承SqlSessionDaoSupport，如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> com.helloworld.daoImpl;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> java.sql.Connection;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> org.apache.ibatis.session.SqlSession;</div><div class=\"line\"><span class=\"keyword\">import</span> org.apache.ibatis.session.SqlSessionFactory;</div><div class=\"line\"><span class=\"keyword\">import</span> org.mybatis.spring.support.SqlSessionDaoSupport;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> com.helloworld.dao.BaseDao;</div><div class=\"line\"><span class=\"keyword\">import</span> com.helloworld.pojo.User;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserDao</span> <span class=\"keyword\">extends</span> <span class=\"title\">SqlSessionDaoSupport</span> <span class=\"keyword\">implements</span> <span class=\"title\">BaseDao</span></span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">/**</div><div class=\"line\">\t  * 获取相关的数据库连接</div><div class=\"line\">\t  */</span></div><div class=\"line\">\t <span class=\"function\"><span class=\"keyword\">public</span> Connection <span class=\"title\">getConnection</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t  <span class=\"keyword\">return</span> getSqlSession().getConnection();</div><div class=\"line\">\t &#125;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">UserDao</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"UserDao IN\"</span>);</div><div class=\"line\">\t&#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> User <span class=\"title\">getUser</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">    \tString statement = <span class=\"string\">\"com.helloworld.mapping.userMapper.getUser\"</span>;<span class=\"comment\">//映射sql的标识字符串</span></div><div class=\"line\">        <span class=\"comment\">//执行查询返回一个唯一user对象的sql</span></div><div class=\"line\">        User user = getSqlSession().selectOne(statement, <span class=\"number\">1</span>);</div><div class=\"line\">    \t<span class=\"keyword\">return</span> user;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">saveObject</span><span class=\"params\">(Object obj)</span></div><div class=\"line\">\t</span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">// TODO Auto-generated method stub</span></div><div class=\"line\">\t\t</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>至于Mapper文件中配置的查询文件怎么用，这里也给了一个简单的例子，非常简单，看一下就可以了。</p>\n<p>配置完成之后整个项目的目录结构如下</p>\n<p><img src=\"http://img.blog.csdn.net/20160928174844008\" alt=\"这里写图片描述\"></p>\n<p>至此，Mybatis框架已经配置完成，可以和Hibernate一样写个Test类，看能不能正常获取到数据库中的数据，也可以将项目发布，看访问页面能不能获取的数据。</p>\n<p>如果没什么意外，现在应该已经能够通过访问页面来访问数据库然后显示给用户了。一个WEB项目最简单的流程也就跑通了，然后就可以在这个简单流程上开发自己相应的业务了。那接下来我也要去做我的业务了，开发过程中有什么心得也会发在博客中跟大家分享，敬请期待。</p>\n"},{"title":"密码字典生成工具","date":"2016-09-26T09:48:44.000Z","_content":"\n最近无事，做了一个密码字典生成工具\n\n其实这种工具网上有很多，但是很多要收费，而且没有源代码，想修改一下也很麻烦，所以我实现了一个基于Python的跨平台的，如果需要一些生成策略或者什么的改动，只要稍微改动一下就行\n\n\n详细信息可以参考readme\n\n\n代码托管在[https://github.com/zgzczzw/dictoryGenerator](https://github.com/zgzczzw/dictoryGenerator)\n\n有兴趣的同学可以联系我，共同改进\n\n接下来还想做目录扫描工具，xss扫描和sql注入扫描\n\n空的时候再写一下详细的用户说明","source":"_posts/密码字典生成工具.md","raw":"---\ntitle: 密码字典生成工具\ndate: 2016-09-26 17:48:44\ntags:\n  - python\n  - 安全\n  - 密码生成\ncategories: 安全\n---\n\n最近无事，做了一个密码字典生成工具\n\n其实这种工具网上有很多，但是很多要收费，而且没有源代码，想修改一下也很麻烦，所以我实现了一个基于Python的跨平台的，如果需要一些生成策略或者什么的改动，只要稍微改动一下就行\n\n\n详细信息可以参考readme\n\n\n代码托管在[https://github.com/zgzczzw/dictoryGenerator](https://github.com/zgzczzw/dictoryGenerator)\n\n有兴趣的同学可以联系我，共同改进\n\n接下来还想做目录扫描工具，xss扫描和sql注入扫描\n\n空的时候再写一下详细的用户说明","slug":"密码字典生成工具","published":1,"updated":"2024-06-14T09:25:33.680Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clxjsxtwa0018lq6gka2w672d","content":"<p>最近无事，做了一个密码字典生成工具</p>\n<p>其实这种工具网上有很多，但是很多要收费，而且没有源代码，想修改一下也很麻烦，所以我实现了一个基于Python的跨平台的，如果需要一些生成策略或者什么的改动，只要稍微改动一下就行</p>\n<p>详细信息可以参考readme</p>\n<p>代码托管在<a href=\"https://github.com/zgzczzw/dictoryGenerator\" target=\"_blank\" rel=\"external\">https://github.com/zgzczzw/dictoryGenerator</a></p>\n<p>有兴趣的同学可以联系我，共同改进</p>\n<p>接下来还想做目录扫描工具，xss扫描和sql注入扫描</p>\n<p>空的时候再写一下详细的用户说明</p>\n","excerpt":"","more":"<p>最近无事，做了一个密码字典生成工具</p>\n<p>其实这种工具网上有很多，但是很多要收费，而且没有源代码，想修改一下也很麻烦，所以我实现了一个基于Python的跨平台的，如果需要一些生成策略或者什么的改动，只要稍微改动一下就行</p>\n<p>详细信息可以参考readme</p>\n<p>代码托管在<a href=\"https://github.com/zgzczzw/dictoryGenerator\">https://github.com/zgzczzw/dictoryGenerator</a></p>\n<p>有兴趣的同学可以联系我，共同改进</p>\n<p>接下来还想做目录扫描工具，xss扫描和sql注入扫描</p>\n<p>空的时候再写一下详细的用户说明</p>\n"},{"title":"搭建SpringMVC+Spring4.3.2+Hibernate5.2.2框架","date":"2016-09-27T05:15:09.000Z","_content":"之前说过，我最终想搭建一个SpringMVC+Spring+MyBatis的框架，然后从SSH框架开始慢慢演化，这篇博客将讲解怎样将SSH框架中的Struts部分替换为SpringMVC做请求转发。\n\n至于为什么要替换成SpringMVC，我在[基于struts2.5.2+hibernate5.2.2+spring4.3.2搭建SSH框架](http://zwgeek.com/2016/09/03/%E5%9F%BA%E4%BA%8Estruts2-5-2-hibernate5-2-2-spring4-3-2%E6%90%AD%E5%BB%BASSH%E6%A1%86%E6%9E%B6v2/)这篇博客里说过，以下几点：\n\n- struts除了可以做请求转发，还有页面标签，所以你如果只用请求转发的话，这个框架有点多余\n- 现在spring推出了springMVC，是专门做请求转发用的，因为是spring自家推出的，所以和spring的协调性更好，而且在我使用中也感觉springMVC用起来更方便，轻量级\n\n关于SSH框架的搭建可以去这篇文章查看\n\n- [基于struts2.5.2+hibernate5.2.2+spring4.3.2搭建SSH框架](http://zwgeek.com/2016/09/03/%E5%9F%BA%E4%BA%8Estruts2-5-2-hibernate5-2-2-spring4-3-2%E6%90%AD%E5%BB%BASSH%E6%A1%86%E6%9E%B6v2/)\n\n在上面的基础上把Struts换成SpringMVC，其实很简单，为什么这么说呢，因为搭建SSH框架的时候，我们把Spring的所有jar包都加入到项目里了，不知道你有没有注意到，有这样一个jar包\n\n其实这个jar包就已经是对MVC的支持了，所以可以说我们上一个框架已经支持SpringMVC了，所以问题就变成了去掉Struts框架，所以很简单。\n\n首先可以删掉Struts的所有jar包，主要是以下两个，其他common开头的jar包因为spring也在用，所以可以不删掉。\nstruts2-core和struts2-spring-plugin，现在lib如下，可做参考：\n![](http://img.blog.csdn.net/20160927142022944)\n![](http://img.blog.csdn.net/20160927142042958)\n\n然后删掉struts.xml配置文件\n\n接下来我们来看怎么让SpringMVC生效\n\n首先把web.xml的拦截规则改成给SpringMVC拦截，如下\n\n```xml\n<servlet>\n  \t<servlet-name>springMVC</servlet-name>\n  \t<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n  \t<init-param>\n  \t\t<param-name>contextConfigLocation</param-name>\n  \t\t<param-value>classpath*:config/spring/spring-mvc.xml</param-value>\n  \t</init-param>\n  \t<load-on-startup>1</load-on-startup>\n  </servlet>\n  <servlet-mapping>\n  \t<servlet-name>springMVC</servlet-name>\n  \t<url-pattern>/</url-pattern>\n  </servlet-mapping>\n```\n\n然后在web.xml中配置SpringMVC的配置文件\n\n```xml\n<!-- 加载所有的配置文件 -->\n  <context-param>\n  \t<param-name>contextConfigLocation</param-name>\n  \t<param-value>classpath*:config/spring/spring-*.xml</param-value>\n  </context-param>\n```\n\n修改之后的web.xml如下\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://java.sun.com/xml/ns/javaee\" xmlns:web=\"http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\" id=\"WebApp_ID\" version=\"2.5\">\n  <display-name>json_test</display-name>\n  <welcome-file-list>\n    <welcome-file>login.jsp</welcome-file>\n  </welcome-file-list>\n  \n  <!-- 加载所有的配置文件 -->\n  <context-param>\n  \t<param-name>contextConfigLocation</param-name>\n  \t<param-value>classpath*:config/spring/spring-*.xml</param-value>\n  </context-param>\n  \n  <!-- 配置Spring监听 -->\n  <listener>\n  \t<listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>\n  </listener>\n  \n  <!-- 配置SpringMVC -->\n  <servlet>\n  \t<servlet-name>springMVC</servlet-name>\n  \t<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n  \t<init-param>\n  \t\t<param-name>contextConfigLocation</param-name>\n  \t\t<param-value>classpath*:config/spring/spring-mvc.xml</param-value>\n  \t</init-param>\n  \t<load-on-startup>1</load-on-startup>\n  </servlet>\n  <servlet-mapping>\n  \t<servlet-name>springMVC</servlet-name>\n  \t<url-pattern>/</url-pattern>\n  </servlet-mapping>\n  \n  <!-- 配置字符集 -->\n  <filter>\n  \t<filter-name>encodingFilter</filter-name>\n  \t<filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>\n  \t<init-param>\n  \t\t<param-name>encoding</param-name>\n  \t\t<param-value>UTF-8</param-value>\n  \t</init-param>\n  \t<init-param>\n  \t\t<param-name>forceEncoding</param-name>\n  \t\t<param-value>true</param-value>\n  \t</init-param>\n  </filter>\n  <filter-mapping>\n  \t<filter-name>encodingFilter</filter-name>\n  \t<url-pattern>/*</url-pattern>\n  </filter-mapping>\n  \n  <!-- 配置Session -->\n  <filter>\n  \t<filter-name>openSession</filter-name>\n  \t<filter-class>org.springframework.orm.hibernate5.support.OpenSessionInViewFilter</filter-class>\n  </filter>\n  <filter-mapping>\n  \t<filter-name>openSession</filter-name>\n  \t<url-pattern>/*</url-pattern>\n  </filter-mapping>\n</web-app>\n```\n\n字符集的配置是为了让所有请求和回复都用统一的字符集，比较方便。\n\nOpenSession是为了延长Session的生命周期用的，可以自行baidu一下，网上是这样写的。\n\n> OpenSessionInViewFilter是Spring提供的一个针对Hibernate的一个支持类，其主要意思是在发起一个页面请求时打开Hibernate的Session，一直保持这个Session，直到这个请求结束，具体是通过一个Filter来实现的。\n　\n\n> 由于Hibernate引入了Lazy Load特性，使得脱离Hibernate的Session周期的对象如果再想通过getter方法取到其关联对象的值，Hibernate会抛出一个LazyLoad的Exception。所以为了解决这个问题，Spring引入了这个Filter，使得Hibernate的Session的生命周期变长。\n\n另外我们来看加载配置文件的地方\n\n```xml\n<!-- 加载所有的配置文件 -->\n  <context-param>\n  \t<param-name>contextConfigLocation</param-name>\n  \t<param-value>classpath*:config/spring/spring-*.xml</param-value>\n  </context-param>\n```\n\n这句话的意思是载入config/spring/目录下的所有以spring开头的配置文件。前面说过spring的配置其实就是在配置各种bean，在配置SSH的时候我们把所有bean都写在了applicationContext里面，导致这个文件很大很复杂，这样不利于修改配置和查找异常。其实我们可以把不同的bean配置在不同的文件中，然后在web.xml中告诉程序去哪里找配置文件，就像这里这样。我们可以把关于mvc的bean配置在sprng-mvc.xml中，把业务逻辑bean配置在spring-beans中，把基础bean（比如session，datasource等）配置在spring-common.xml中。\n\n前面一篇文章也说过，eclipse在发布web项目的时候会把src目录映射成classpath目录，当然这是可以配置的。所以我们就在src目录下建立配置文件，如下\n\n![](http://img.blog.csdn.net/20160927142443663)\n\n接下来看一下mvc的配置是怎样的\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\txmlns:context=\"http://www.springframework.org/schema/context\"\n\txmlns:mvc=\"http://www.springframework.org/schema/mvc\"\n\txsi:schemaLocation=\"http://www.springframework.org/schema/beans \n\thttp://www.springframework.org/schema/beans/spring-beans.xsd\n\thttp://www.springframework.org/schema/context\n\thttp://www.springframework.org/schema/context/spring-context-3.2.xsd\n\thttp://www.springframework.org/schema/mvc\n\thttp://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd\">\n\t\n\t<!-- 注解扫描包 -->\n\t<context:component-scan base-package=\"com.mvc.controller\" />\n\n\t<!-- 开启注解 -->\n\t<mvc:annotation-driven />\n\t\n\t<!-- 静态资源(js/image)的访问 -->\n\t<mvc:resources location=\"/js/\" mapping=\"/js/**\"/>\n\n\t<!-- 定义视图解析器 -->\t\n\t<bean id=\"viewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\">\n\t\t<property name=\"prefix\" value=\"/\"></property>\n\t\t<property name=\"suffix\" value=\".jsp\"></property>\n\t</bean>\n</beans>\n```\n\n现在主流的对SpringMVC的配置时基于注解的，至于怎么注解，我们后面再说，这个配置文件中前两部分就是配置注解用的，base-package指明注解在哪些包下，你当然可以写所有的包，让框架都去扫描一遍，但没必要。在SpringMVC框架中，控制转发的类叫Controller（对应Struts中的Action），所以注解通常也都是在com.xxx.xxx.controller包中，所以这里只扫描相应的包就可以。\n\nmvc:resources定义静态文件的位置，因为我们前面在web.xml用/设置了过滤器，会拦截所有的请求，同时也会影响对静态文件的请求，这里配置之后，所有/js/**的请求都会去js文件夹去找，而不会跳转到controller控制类\n\nViewResolver是定义视图解析器，做什么用的的，简单来说，controller控制类中某个方法返回“index”的意思其实是跳转到index页面，但通常这个页面会有前缀（也就是相对路径）和后缀（扩展名），这里这样配置后，return \"index\"，就会跳转到/index.jsp页面。\n\n解析完配置文件，我们看下Controller具体怎么写，其实就是在Struts框架中的Action类。代码如下：\n\n```java\npackage com.mvc.controller;\n\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.List;\n\nimport javax.annotation.Resource;\nimport javax.servlet.http.HttpServletResponse;\n\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestMapping;\n\nimport com.mvc.manager.UserManager;\nimport com.mvc.pojo.User;\n\n@Controller\npublic class UserController\n{\n\t@Resource(name = \"userManager\") // 获取spring配置文件中bean的id为userManager的，并注入\n\tprivate UserManager userManager;\n\n\t@RequestMapping(\"/toAddUser\")\n\tpublic String toAddUser()\n\t{\n\t\treturn \"/addUser\";\n\t}\n\n\t@RequestMapping(\"/getAllUser\")\n\tpublic void getAllUser(HttpServletResponse response)\n\t{\n\t\tSystem.out.println(\"getAllUser IN\");\n\t\tList<User> user = userManager.getUsers();\n\n\t\tPrintWriter out = null;\n\t\tresponse.setContentType(\"application/json\");\n\n\t\ttry\n\t\t{\n\t\t\tout = response.getWriter();\n\t\t\tfor (int i = 0; i < user.size(); i++)\n\t\t\t{\n\t\t\t\tout.write(user.get(i).getUserName());\n\t\t\t}\n\t\t}\n\t\tcatch (IOException e)\n\t\t{\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}\n\n```\n\n关于注解的详细解析，准备在专门写一篇文章，简单来说，就是在方法上加上\n\n```java\n@RequestMapping(\"/getAllUser\")\n```\n\n注解，对getAllUser的请求就会跳转到这个方法进行处理，像前面提到的，如果方法返回字符串，处理完之后就会做相应的跳转，如果方法返回void，则不进行任何跳转。\n\n到目前为止SpringMVC就配置完了，这时你访问 http://host:port/projectName/getAllUser ，就能显示了。好，我们的第二个目标达成了，下个目标就是把Hibernate替换成Mybatis，然后就万事大吉了。\n\n再列一下其他文件吧\n\nspring-beans.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\txsi:schemaLocation=\"http://www.springframework.org/schema/beans\n           http://www.springframework.org/schema/beans/spring-beans-3.0.xsd\">\n\n\t<bean id=\"userDao\" class=\"com.mvc.daoImpl.UserDao\">\n\t\t<property name=\"sessionFactory\">\n\t\t\t<ref bean=\"sessionFactory\" />\n\t\t</property>\n\t</bean>\n\n\t<!--用户注册业务逻辑类 -->\n\t<bean id=\"userManager\" class=\"com.mvc.manager.UserManager\">\n\t\t<property name=\"dao\">\n\t\t\t<ref bean=\"userDao\" />\n\t\t</property>\n\t</bean>\n</beans>\n```\n\nspring-common.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\"\n\txmlns:mvc=\"http://www.springframework.org/schema/mvc\"\n\txsi:schemaLocation=\"http://www.springframework.org/schema/beans \n\thttp://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n\t<!-- 定义数据源的信息 -->\n\t<bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"\n\t\tdestroy-method=\"close\">\n\t\t<property name=\"driverClass\">\n\t\t\t<value>com.mysql.jdbc.Driver</value>\n\t\t</property>\n\t\t<property name=\"jdbcUrl\">\n\t\t\t<value>jdbc:mysql://localhost:3306/test</value>\n\t\t</property>\n\t\t<property name=\"user\">\n\t\t\t<value>root</value>\n\t\t</property>\n\t\t<property name=\"password\">\n\t\t\t<value>zzw</value>\n\t\t</property>\n\t\t<property name=\"maxPoolSize\">\n\t\t\t<value>80</value>\n\t\t</property>\n\t\t<property name=\"minPoolSize\">\n\t\t\t<value>1</value>\n\t\t</property>\n\t\t<property name=\"initialPoolSize\">\n\t\t\t<value>1</value>\n\t\t</property>\n\t\t<property name=\"maxIdleTime\">\n\t\t\t<value>20</value>\n\t\t</property>\n\t</bean>\n\n\t<!--定义Hibernate的SessionFactory -->\n\t<!-- SessionFactory使用的数据源为上面的数据源 -->\n\t<!-- 指定了Hibernate的映射文件和配置信息 -->\n\t<bean id=\"sessionFactory\"\n\t\tclass=\"org.springframework.orm.hibernate5.LocalSessionFactoryBean\">\n\t\t<property name=\"dataSource\" ref=\"dataSource\" />\n\t\t<property name=\"mappingResources\">\n\t\t\t<list>\n\t\t\t\t<value>com/mvc/pojo/User.hbm.xml</value>\n\t\t\t</list>\n\t\t</property>\n\t\t<property name=\"hibernateProperties\">\n\t\t\t<props>\n\t\t\t\t<prop key=\"hibernate.dialect\">org.hibernate.dialect.MySQLDialect</prop>\n\t\t\t\t<prop key=\"show_sql\">true</prop>\n\t\t\t\t<prop key=\"hibernate.jdbc.batch_size\">20</prop>\n\t\t\t</props>\n\t\t</property>\n\t</bean>\n\n\t<!-- 配置一个事务管理器 -->\n\t<bean id=\"transactionManager\"\n\t\tclass=\"org.springframework.orm.hibernate5.HibernateTransactionManager\">\n\t\t<property name=\"sessionFactory\" ref=\"sessionFactory\" />\n\t</bean>\n\n\t<!-- 配置事务，使用代理的方式 -->\n\t<bean id=\"transactionProxy\"\n\t\tclass=\"org.springframework.transaction.interceptor.TransactionProxyFactoryBean\"\n\t\tabstract=\"true\">\n\t\t<property name=\"transactionManager\" ref=\"transactionManager\"></property>\n\t\t<property name=\"transactionAttributes\">\n\t\t\t<props>\n\t\t\t\t<prop key=\"add*\">PROPAGATION_REQUIRED,-Exception</prop>\n\t\t\t\t<prop key=\"modify*\">PROPAGATION_REQUIRED,-myException</prop>\n\t\t\t\t<prop key=\"del*\">PROPAGATION_REQUIRED</prop>\n\t\t\t\t<prop key=\"*\">PROPAGATION_REQUIRED</prop>\n\t\t\t</props>\n\t\t</property>\n\t</bean>\n</beans>\n```\n\n其他像DAO类，manager类就不细说了，不懂得可以看我上一篇文章[基于struts2.5.2+hibernate5.2.2+spring4.3.2搭建SSH框架](http://zwgeek.com/2016/09/03/%E5%9F%BA%E4%BA%8Estruts2-5-2-hibernate5-2-2-spring4-3-2%E6%90%AD%E5%BB%BASSH%E6%A1%86%E6%9E%B6v2/)\n\n整个项目的结构如下\n\n![](http://img.blog.csdn.net/20160927143143944)\n","source":"_posts/搭建SpringMVC-Spring4-3-2-Hibernate5-2-2框架.md","raw":"---\ntitle: 搭建SpringMVC+Spring4.3.2+Hibernate5.2.2框架\ndate: 2016-09-27 13:15:09\ntags:\n  - Java Web\n  - 服务端\n  - SpringMVC\ncategories: 服务端开发\n---\n之前说过，我最终想搭建一个SpringMVC+Spring+MyBatis的框架，然后从SSH框架开始慢慢演化，这篇博客将讲解怎样将SSH框架中的Struts部分替换为SpringMVC做请求转发。\n\n至于为什么要替换成SpringMVC，我在[基于struts2.5.2+hibernate5.2.2+spring4.3.2搭建SSH框架](http://zwgeek.com/2016/09/03/%E5%9F%BA%E4%BA%8Estruts2-5-2-hibernate5-2-2-spring4-3-2%E6%90%AD%E5%BB%BASSH%E6%A1%86%E6%9E%B6v2/)这篇博客里说过，以下几点：\n\n- struts除了可以做请求转发，还有页面标签，所以你如果只用请求转发的话，这个框架有点多余\n- 现在spring推出了springMVC，是专门做请求转发用的，因为是spring自家推出的，所以和spring的协调性更好，而且在我使用中也感觉springMVC用起来更方便，轻量级\n\n关于SSH框架的搭建可以去这篇文章查看\n\n- [基于struts2.5.2+hibernate5.2.2+spring4.3.2搭建SSH框架](http://zwgeek.com/2016/09/03/%E5%9F%BA%E4%BA%8Estruts2-5-2-hibernate5-2-2-spring4-3-2%E6%90%AD%E5%BB%BASSH%E6%A1%86%E6%9E%B6v2/)\n\n在上面的基础上把Struts换成SpringMVC，其实很简单，为什么这么说呢，因为搭建SSH框架的时候，我们把Spring的所有jar包都加入到项目里了，不知道你有没有注意到，有这样一个jar包\n\n其实这个jar包就已经是对MVC的支持了，所以可以说我们上一个框架已经支持SpringMVC了，所以问题就变成了去掉Struts框架，所以很简单。\n\n首先可以删掉Struts的所有jar包，主要是以下两个，其他common开头的jar包因为spring也在用，所以可以不删掉。\nstruts2-core和struts2-spring-plugin，现在lib如下，可做参考：\n![](http://img.blog.csdn.net/20160927142022944)\n![](http://img.blog.csdn.net/20160927142042958)\n\n然后删掉struts.xml配置文件\n\n接下来我们来看怎么让SpringMVC生效\n\n首先把web.xml的拦截规则改成给SpringMVC拦截，如下\n\n```xml\n<servlet>\n  \t<servlet-name>springMVC</servlet-name>\n  \t<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n  \t<init-param>\n  \t\t<param-name>contextConfigLocation</param-name>\n  \t\t<param-value>classpath*:config/spring/spring-mvc.xml</param-value>\n  \t</init-param>\n  \t<load-on-startup>1</load-on-startup>\n  </servlet>\n  <servlet-mapping>\n  \t<servlet-name>springMVC</servlet-name>\n  \t<url-pattern>/</url-pattern>\n  </servlet-mapping>\n```\n\n然后在web.xml中配置SpringMVC的配置文件\n\n```xml\n<!-- 加载所有的配置文件 -->\n  <context-param>\n  \t<param-name>contextConfigLocation</param-name>\n  \t<param-value>classpath*:config/spring/spring-*.xml</param-value>\n  </context-param>\n```\n\n修改之后的web.xml如下\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://java.sun.com/xml/ns/javaee\" xmlns:web=\"http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\" id=\"WebApp_ID\" version=\"2.5\">\n  <display-name>json_test</display-name>\n  <welcome-file-list>\n    <welcome-file>login.jsp</welcome-file>\n  </welcome-file-list>\n  \n  <!-- 加载所有的配置文件 -->\n  <context-param>\n  \t<param-name>contextConfigLocation</param-name>\n  \t<param-value>classpath*:config/spring/spring-*.xml</param-value>\n  </context-param>\n  \n  <!-- 配置Spring监听 -->\n  <listener>\n  \t<listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>\n  </listener>\n  \n  <!-- 配置SpringMVC -->\n  <servlet>\n  \t<servlet-name>springMVC</servlet-name>\n  \t<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n  \t<init-param>\n  \t\t<param-name>contextConfigLocation</param-name>\n  \t\t<param-value>classpath*:config/spring/spring-mvc.xml</param-value>\n  \t</init-param>\n  \t<load-on-startup>1</load-on-startup>\n  </servlet>\n  <servlet-mapping>\n  \t<servlet-name>springMVC</servlet-name>\n  \t<url-pattern>/</url-pattern>\n  </servlet-mapping>\n  \n  <!-- 配置字符集 -->\n  <filter>\n  \t<filter-name>encodingFilter</filter-name>\n  \t<filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>\n  \t<init-param>\n  \t\t<param-name>encoding</param-name>\n  \t\t<param-value>UTF-8</param-value>\n  \t</init-param>\n  \t<init-param>\n  \t\t<param-name>forceEncoding</param-name>\n  \t\t<param-value>true</param-value>\n  \t</init-param>\n  </filter>\n  <filter-mapping>\n  \t<filter-name>encodingFilter</filter-name>\n  \t<url-pattern>/*</url-pattern>\n  </filter-mapping>\n  \n  <!-- 配置Session -->\n  <filter>\n  \t<filter-name>openSession</filter-name>\n  \t<filter-class>org.springframework.orm.hibernate5.support.OpenSessionInViewFilter</filter-class>\n  </filter>\n  <filter-mapping>\n  \t<filter-name>openSession</filter-name>\n  \t<url-pattern>/*</url-pattern>\n  </filter-mapping>\n</web-app>\n```\n\n字符集的配置是为了让所有请求和回复都用统一的字符集，比较方便。\n\nOpenSession是为了延长Session的生命周期用的，可以自行baidu一下，网上是这样写的。\n\n> OpenSessionInViewFilter是Spring提供的一个针对Hibernate的一个支持类，其主要意思是在发起一个页面请求时打开Hibernate的Session，一直保持这个Session，直到这个请求结束，具体是通过一个Filter来实现的。\n　\n\n> 由于Hibernate引入了Lazy Load特性，使得脱离Hibernate的Session周期的对象如果再想通过getter方法取到其关联对象的值，Hibernate会抛出一个LazyLoad的Exception。所以为了解决这个问题，Spring引入了这个Filter，使得Hibernate的Session的生命周期变长。\n\n另外我们来看加载配置文件的地方\n\n```xml\n<!-- 加载所有的配置文件 -->\n  <context-param>\n  \t<param-name>contextConfigLocation</param-name>\n  \t<param-value>classpath*:config/spring/spring-*.xml</param-value>\n  </context-param>\n```\n\n这句话的意思是载入config/spring/目录下的所有以spring开头的配置文件。前面说过spring的配置其实就是在配置各种bean，在配置SSH的时候我们把所有bean都写在了applicationContext里面，导致这个文件很大很复杂，这样不利于修改配置和查找异常。其实我们可以把不同的bean配置在不同的文件中，然后在web.xml中告诉程序去哪里找配置文件，就像这里这样。我们可以把关于mvc的bean配置在sprng-mvc.xml中，把业务逻辑bean配置在spring-beans中，把基础bean（比如session，datasource等）配置在spring-common.xml中。\n\n前面一篇文章也说过，eclipse在发布web项目的时候会把src目录映射成classpath目录，当然这是可以配置的。所以我们就在src目录下建立配置文件，如下\n\n![](http://img.blog.csdn.net/20160927142443663)\n\n接下来看一下mvc的配置是怎样的\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\txmlns:context=\"http://www.springframework.org/schema/context\"\n\txmlns:mvc=\"http://www.springframework.org/schema/mvc\"\n\txsi:schemaLocation=\"http://www.springframework.org/schema/beans \n\thttp://www.springframework.org/schema/beans/spring-beans.xsd\n\thttp://www.springframework.org/schema/context\n\thttp://www.springframework.org/schema/context/spring-context-3.2.xsd\n\thttp://www.springframework.org/schema/mvc\n\thttp://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd\">\n\t\n\t<!-- 注解扫描包 -->\n\t<context:component-scan base-package=\"com.mvc.controller\" />\n\n\t<!-- 开启注解 -->\n\t<mvc:annotation-driven />\n\t\n\t<!-- 静态资源(js/image)的访问 -->\n\t<mvc:resources location=\"/js/\" mapping=\"/js/**\"/>\n\n\t<!-- 定义视图解析器 -->\t\n\t<bean id=\"viewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\">\n\t\t<property name=\"prefix\" value=\"/\"></property>\n\t\t<property name=\"suffix\" value=\".jsp\"></property>\n\t</bean>\n</beans>\n```\n\n现在主流的对SpringMVC的配置时基于注解的，至于怎么注解，我们后面再说，这个配置文件中前两部分就是配置注解用的，base-package指明注解在哪些包下，你当然可以写所有的包，让框架都去扫描一遍，但没必要。在SpringMVC框架中，控制转发的类叫Controller（对应Struts中的Action），所以注解通常也都是在com.xxx.xxx.controller包中，所以这里只扫描相应的包就可以。\n\nmvc:resources定义静态文件的位置，因为我们前面在web.xml用/设置了过滤器，会拦截所有的请求，同时也会影响对静态文件的请求，这里配置之后，所有/js/**的请求都会去js文件夹去找，而不会跳转到controller控制类\n\nViewResolver是定义视图解析器，做什么用的的，简单来说，controller控制类中某个方法返回“index”的意思其实是跳转到index页面，但通常这个页面会有前缀（也就是相对路径）和后缀（扩展名），这里这样配置后，return \"index\"，就会跳转到/index.jsp页面。\n\n解析完配置文件，我们看下Controller具体怎么写，其实就是在Struts框架中的Action类。代码如下：\n\n```java\npackage com.mvc.controller;\n\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.List;\n\nimport javax.annotation.Resource;\nimport javax.servlet.http.HttpServletResponse;\n\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestMapping;\n\nimport com.mvc.manager.UserManager;\nimport com.mvc.pojo.User;\n\n@Controller\npublic class UserController\n{\n\t@Resource(name = \"userManager\") // 获取spring配置文件中bean的id为userManager的，并注入\n\tprivate UserManager userManager;\n\n\t@RequestMapping(\"/toAddUser\")\n\tpublic String toAddUser()\n\t{\n\t\treturn \"/addUser\";\n\t}\n\n\t@RequestMapping(\"/getAllUser\")\n\tpublic void getAllUser(HttpServletResponse response)\n\t{\n\t\tSystem.out.println(\"getAllUser IN\");\n\t\tList<User> user = userManager.getUsers();\n\n\t\tPrintWriter out = null;\n\t\tresponse.setContentType(\"application/json\");\n\n\t\ttry\n\t\t{\n\t\t\tout = response.getWriter();\n\t\t\tfor (int i = 0; i < user.size(); i++)\n\t\t\t{\n\t\t\t\tout.write(user.get(i).getUserName());\n\t\t\t}\n\t\t}\n\t\tcatch (IOException e)\n\t\t{\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}\n\n```\n\n关于注解的详细解析，准备在专门写一篇文章，简单来说，就是在方法上加上\n\n```java\n@RequestMapping(\"/getAllUser\")\n```\n\n注解，对getAllUser的请求就会跳转到这个方法进行处理，像前面提到的，如果方法返回字符串，处理完之后就会做相应的跳转，如果方法返回void，则不进行任何跳转。\n\n到目前为止SpringMVC就配置完了，这时你访问 http://host:port/projectName/getAllUser ，就能显示了。好，我们的第二个目标达成了，下个目标就是把Hibernate替换成Mybatis，然后就万事大吉了。\n\n再列一下其他文件吧\n\nspring-beans.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\txsi:schemaLocation=\"http://www.springframework.org/schema/beans\n           http://www.springframework.org/schema/beans/spring-beans-3.0.xsd\">\n\n\t<bean id=\"userDao\" class=\"com.mvc.daoImpl.UserDao\">\n\t\t<property name=\"sessionFactory\">\n\t\t\t<ref bean=\"sessionFactory\" />\n\t\t</property>\n\t</bean>\n\n\t<!--用户注册业务逻辑类 -->\n\t<bean id=\"userManager\" class=\"com.mvc.manager.UserManager\">\n\t\t<property name=\"dao\">\n\t\t\t<ref bean=\"userDao\" />\n\t\t</property>\n\t</bean>\n</beans>\n```\n\nspring-common.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\"\n\txmlns:mvc=\"http://www.springframework.org/schema/mvc\"\n\txsi:schemaLocation=\"http://www.springframework.org/schema/beans \n\thttp://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n\t<!-- 定义数据源的信息 -->\n\t<bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"\n\t\tdestroy-method=\"close\">\n\t\t<property name=\"driverClass\">\n\t\t\t<value>com.mysql.jdbc.Driver</value>\n\t\t</property>\n\t\t<property name=\"jdbcUrl\">\n\t\t\t<value>jdbc:mysql://localhost:3306/test</value>\n\t\t</property>\n\t\t<property name=\"user\">\n\t\t\t<value>root</value>\n\t\t</property>\n\t\t<property name=\"password\">\n\t\t\t<value>zzw</value>\n\t\t</property>\n\t\t<property name=\"maxPoolSize\">\n\t\t\t<value>80</value>\n\t\t</property>\n\t\t<property name=\"minPoolSize\">\n\t\t\t<value>1</value>\n\t\t</property>\n\t\t<property name=\"initialPoolSize\">\n\t\t\t<value>1</value>\n\t\t</property>\n\t\t<property name=\"maxIdleTime\">\n\t\t\t<value>20</value>\n\t\t</property>\n\t</bean>\n\n\t<!--定义Hibernate的SessionFactory -->\n\t<!-- SessionFactory使用的数据源为上面的数据源 -->\n\t<!-- 指定了Hibernate的映射文件和配置信息 -->\n\t<bean id=\"sessionFactory\"\n\t\tclass=\"org.springframework.orm.hibernate5.LocalSessionFactoryBean\">\n\t\t<property name=\"dataSource\" ref=\"dataSource\" />\n\t\t<property name=\"mappingResources\">\n\t\t\t<list>\n\t\t\t\t<value>com/mvc/pojo/User.hbm.xml</value>\n\t\t\t</list>\n\t\t</property>\n\t\t<property name=\"hibernateProperties\">\n\t\t\t<props>\n\t\t\t\t<prop key=\"hibernate.dialect\">org.hibernate.dialect.MySQLDialect</prop>\n\t\t\t\t<prop key=\"show_sql\">true</prop>\n\t\t\t\t<prop key=\"hibernate.jdbc.batch_size\">20</prop>\n\t\t\t</props>\n\t\t</property>\n\t</bean>\n\n\t<!-- 配置一个事务管理器 -->\n\t<bean id=\"transactionManager\"\n\t\tclass=\"org.springframework.orm.hibernate5.HibernateTransactionManager\">\n\t\t<property name=\"sessionFactory\" ref=\"sessionFactory\" />\n\t</bean>\n\n\t<!-- 配置事务，使用代理的方式 -->\n\t<bean id=\"transactionProxy\"\n\t\tclass=\"org.springframework.transaction.interceptor.TransactionProxyFactoryBean\"\n\t\tabstract=\"true\">\n\t\t<property name=\"transactionManager\" ref=\"transactionManager\"></property>\n\t\t<property name=\"transactionAttributes\">\n\t\t\t<props>\n\t\t\t\t<prop key=\"add*\">PROPAGATION_REQUIRED,-Exception</prop>\n\t\t\t\t<prop key=\"modify*\">PROPAGATION_REQUIRED,-myException</prop>\n\t\t\t\t<prop key=\"del*\">PROPAGATION_REQUIRED</prop>\n\t\t\t\t<prop key=\"*\">PROPAGATION_REQUIRED</prop>\n\t\t\t</props>\n\t\t</property>\n\t</bean>\n</beans>\n```\n\n其他像DAO类，manager类就不细说了，不懂得可以看我上一篇文章[基于struts2.5.2+hibernate5.2.2+spring4.3.2搭建SSH框架](http://zwgeek.com/2016/09/03/%E5%9F%BA%E4%BA%8Estruts2-5-2-hibernate5-2-2-spring4-3-2%E6%90%AD%E5%BB%BASSH%E6%A1%86%E6%9E%B6v2/)\n\n整个项目的结构如下\n\n![](http://img.blog.csdn.net/20160927143143944)\n","slug":"搭建SpringMVC-Spring4-3-2-Hibernate5-2-2框架","published":1,"updated":"2024-06-14T09:25:33.680Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clxjsxtwb001blq6gu0l3f4d4","content":"<p>之前说过，我最终想搭建一个SpringMVC+Spring+MyBatis的框架，然后从SSH框架开始慢慢演化，这篇博客将讲解怎样将SSH框架中的Struts部分替换为SpringMVC做请求转发。</p>\n<p>至于为什么要替换成SpringMVC，我在<a href=\"http://zwgeek.com/2016/09/03/%E5%9F%BA%E4%BA%8Estruts2-5-2-hibernate5-2-2-spring4-3-2%E6%90%AD%E5%BB%BASSH%E6%A1%86%E6%9E%B6v2/\">基于struts2.5.2+hibernate5.2.2+spring4.3.2搭建SSH框架</a>这篇博客里说过，以下几点：</p>\n<ul>\n<li>struts除了可以做请求转发，还有页面标签，所以你如果只用请求转发的话，这个框架有点多余</li>\n<li>现在spring推出了springMVC，是专门做请求转发用的，因为是spring自家推出的，所以和spring的协调性更好，而且在我使用中也感觉springMVC用起来更方便，轻量级</li>\n</ul>\n<p>关于SSH框架的搭建可以去这篇文章查看</p>\n<ul>\n<li><a href=\"http://zwgeek.com/2016/09/03/%E5%9F%BA%E4%BA%8Estruts2-5-2-hibernate5-2-2-spring4-3-2%E6%90%AD%E5%BB%BASSH%E6%A1%86%E6%9E%B6v2/\">基于struts2.5.2+hibernate5.2.2+spring4.3.2搭建SSH框架</a></li>\n</ul>\n<p>在上面的基础上把Struts换成SpringMVC，其实很简单，为什么这么说呢，因为搭建SSH框架的时候，我们把Spring的所有jar包都加入到项目里了，不知道你有没有注意到，有这样一个jar包</p>\n<p>其实这个jar包就已经是对MVC的支持了，所以可以说我们上一个框架已经支持SpringMVC了，所以问题就变成了去掉Struts框架，所以很简单。</p>\n<p>首先可以删掉Struts的所有jar包，主要是以下两个，其他common开头的jar包因为spring也在用，所以可以不删掉。<br>struts2-core和struts2-spring-plugin，现在lib如下，可做参考：<br><img src=\"http://img.blog.csdn.net/20160927142022944\" alt=\"\"><br><img src=\"http://img.blog.csdn.net/20160927142042958\" alt=\"\"></p>\n<p>然后删掉struts.xml配置文件</p>\n<p>接下来我们来看怎么让SpringMVC生效</p>\n<p>首先把web.xml的拦截规则改成给SpringMVC拦截，如下</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet</span>&gt;</span></div><div class=\"line\">  \t<span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>springMVC<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></div><div class=\"line\">  \t<span class=\"tag\">&lt;<span class=\"name\">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-class</span>&gt;</span></div><div class=\"line\">  \t<span class=\"tag\">&lt;<span class=\"name\">init-param</span>&gt;</span></div><div class=\"line\">  \t\t<span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>contextConfigLocation<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span></div><div class=\"line\">  \t\t<span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span>classpath*:config/spring/spring-mvc.xml<span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span></div><div class=\"line\">  \t<span class=\"tag\">&lt;/<span class=\"name\">init-param</span>&gt;</span></div><div class=\"line\">  \t<span class=\"tag\">&lt;<span class=\"name\">load-on-startup</span>&gt;</span>1<span class=\"tag\">&lt;/<span class=\"name\">load-on-startup</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">servlet</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">servlet-mapping</span>&gt;</span></div><div class=\"line\">  \t<span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>springMVC<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></div><div class=\"line\">  \t<span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>/<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">servlet-mapping</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>然后在web.xml中配置SpringMVC的配置文件</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">&lt;!-- 加载所有的配置文件 --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">context-param</span>&gt;</span></div><div class=\"line\">  \t<span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>contextConfigLocation<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span></div><div class=\"line\">  \t<span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span>classpath*:config/spring/spring-*.xml<span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">context-param</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>修改之后的web.xml如下<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">web-app</span> <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://java.sun.com/xml/ns/javaee\"</span> <span class=\"attr\">xmlns:web</span>=<span class=\"string\">\"http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\"</span> <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"WebApp_ID\"</span> <span class=\"attr\">version</span>=<span class=\"string\">\"2.5\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">display-name</span>&gt;</span>json_test<span class=\"tag\">&lt;/<span class=\"name\">display-name</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">welcome-file-list</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">welcome-file</span>&gt;</span>login.jsp<span class=\"tag\">&lt;/<span class=\"name\">welcome-file</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">welcome-file-list</span>&gt;</span></div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">&lt;!-- 加载所有的配置文件 --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">context-param</span>&gt;</span></div><div class=\"line\">  \t<span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>contextConfigLocation<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span></div><div class=\"line\">  \t<span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span>classpath*:config/spring/spring-*.xml<span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">context-param</span>&gt;</span></div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">&lt;!-- 配置Spring监听 --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">listener</span>&gt;</span></div><div class=\"line\">  \t<span class=\"tag\">&lt;<span class=\"name\">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class=\"tag\">&lt;/<span class=\"name\">listener-class</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">listener</span>&gt;</span></div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">&lt;!-- 配置SpringMVC --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">servlet</span>&gt;</span></div><div class=\"line\">  \t<span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>springMVC<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></div><div class=\"line\">  \t<span class=\"tag\">&lt;<span class=\"name\">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-class</span>&gt;</span></div><div class=\"line\">  \t<span class=\"tag\">&lt;<span class=\"name\">init-param</span>&gt;</span></div><div class=\"line\">  \t\t<span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>contextConfigLocation<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span></div><div class=\"line\">  \t\t<span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span>classpath*:config/spring/spring-mvc.xml<span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span></div><div class=\"line\">  \t<span class=\"tag\">&lt;/<span class=\"name\">init-param</span>&gt;</span></div><div class=\"line\">  \t<span class=\"tag\">&lt;<span class=\"name\">load-on-startup</span>&gt;</span>1<span class=\"tag\">&lt;/<span class=\"name\">load-on-startup</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">servlet</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">servlet-mapping</span>&gt;</span></div><div class=\"line\">  \t<span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>springMVC<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></div><div class=\"line\">  \t<span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>/<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">servlet-mapping</span>&gt;</span></div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">&lt;!-- 配置字符集 --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">filter</span>&gt;</span></div><div class=\"line\">  \t<span class=\"tag\">&lt;<span class=\"name\">filter-name</span>&gt;</span>encodingFilter<span class=\"tag\">&lt;/<span class=\"name\">filter-name</span>&gt;</span></div><div class=\"line\">  \t<span class=\"tag\">&lt;<span class=\"name\">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class=\"tag\">&lt;/<span class=\"name\">filter-class</span>&gt;</span></div><div class=\"line\">  \t<span class=\"tag\">&lt;<span class=\"name\">init-param</span>&gt;</span></div><div class=\"line\">  \t\t<span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>encoding<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span></div><div class=\"line\">  \t\t<span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span>UTF-8<span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span></div><div class=\"line\">  \t<span class=\"tag\">&lt;/<span class=\"name\">init-param</span>&gt;</span></div><div class=\"line\">  \t<span class=\"tag\">&lt;<span class=\"name\">init-param</span>&gt;</span></div><div class=\"line\">  \t\t<span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>forceEncoding<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span></div><div class=\"line\">  \t\t<span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span></div><div class=\"line\">  \t<span class=\"tag\">&lt;/<span class=\"name\">init-param</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">filter</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">filter-mapping</span>&gt;</span></div><div class=\"line\">  \t<span class=\"tag\">&lt;<span class=\"name\">filter-name</span>&gt;</span>encodingFilter<span class=\"tag\">&lt;/<span class=\"name\">filter-name</span>&gt;</span></div><div class=\"line\">  \t<span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>/*<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">filter-mapping</span>&gt;</span></div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">&lt;!-- 配置Session --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">filter</span>&gt;</span></div><div class=\"line\">  \t<span class=\"tag\">&lt;<span class=\"name\">filter-name</span>&gt;</span>openSession<span class=\"tag\">&lt;/<span class=\"name\">filter-name</span>&gt;</span></div><div class=\"line\">  \t<span class=\"tag\">&lt;<span class=\"name\">filter-class</span>&gt;</span>org.springframework.orm.hibernate5.support.OpenSessionInViewFilter<span class=\"tag\">&lt;/<span class=\"name\">filter-class</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">filter</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">filter-mapping</span>&gt;</span></div><div class=\"line\">  \t<span class=\"tag\">&lt;<span class=\"name\">filter-name</span>&gt;</span>openSession<span class=\"tag\">&lt;/<span class=\"name\">filter-name</span>&gt;</span></div><div class=\"line\">  \t<span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>/*<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">filter-mapping</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">web-app</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p>字符集的配置是为了让所有请求和回复都用统一的字符集，比较方便。</p>\n<p>OpenSession是为了延长Session的生命周期用的，可以自行baidu一下，网上是这样写的。</p>\n<blockquote>\n<p>OpenSessionInViewFilter是Spring提供的一个针对Hibernate的一个支持类，其主要意思是在发起一个页面请求时打开Hibernate的Session，一直保持这个Session，直到这个请求结束，具体是通过一个Filter来实现的。\n　</p>\n<p>由于Hibernate引入了Lazy Load特性，使得脱离Hibernate的Session周期的对象如果再想通过getter方法取到其关联对象的值，Hibernate会抛出一个LazyLoad的Exception。所以为了解决这个问题，Spring引入了这个Filter，使得Hibernate的Session的生命周期变长。</p>\n</blockquote>\n<p>另外我们来看加载配置文件的地方</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">&lt;!-- 加载所有的配置文件 --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">context-param</span>&gt;</span></div><div class=\"line\">  \t<span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>contextConfigLocation<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span></div><div class=\"line\">  \t<span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span>classpath*:config/spring/spring-*.xml<span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">context-param</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>这句话的意思是载入config/spring/目录下的所有以spring开头的配置文件。前面说过spring的配置其实就是在配置各种bean，在配置SSH的时候我们把所有bean都写在了applicationContext里面，导致这个文件很大很复杂，这样不利于修改配置和查找异常。其实我们可以把不同的bean配置在不同的文件中，然后在web.xml中告诉程序去哪里找配置文件，就像这里这样。我们可以把关于mvc的bean配置在sprng-mvc.xml中，把业务逻辑bean配置在spring-beans中，把基础bean（比如session，datasource等）配置在spring-common.xml中。</p>\n<p>前面一篇文章也说过，eclipse在发布web项目的时候会把src目录映射成classpath目录，当然这是可以配置的。所以我们就在src目录下建立配置文件，如下</p>\n<p><img src=\"http://img.blog.csdn.net/20160927142443663\" alt=\"\"></p>\n<p>接下来看一下mvc的配置是怎样的</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans\"</span></span></div><div class=\"line\">\t<span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></div><div class=\"line\">\t<span class=\"attr\">xmlns:context</span>=<span class=\"string\">\"http://www.springframework.org/schema/context\"</span></div><div class=\"line\">\t<span class=\"attr\">xmlns:mvc</span>=<span class=\"string\">\"http://www.springframework.org/schema/mvc\"</span></div><div class=\"line\">\t<span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans </span></div><div class=\"line\">\thttp://www.springframework.org/schema/beans/spring-beans.xsd</div><div class=\"line\">\thttp://www.springframework.org/schema/context</div><div class=\"line\">\thttp://www.springframework.org/schema/context/spring-context-3.2.xsd</div><div class=\"line\">\thttp://www.springframework.org/schema/mvc</div><div class=\"line\">\thttp://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd\"&gt;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"comment\">&lt;!-- 注解扫描包 --&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">context:component-scan</span> <span class=\"attr\">base-package</span>=<span class=\"string\">\"com.mvc.controller\"</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">&lt;!-- 开启注解 --&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">mvc:annotation-driven</span> /&gt;</span></div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"comment\">&lt;!-- 静态资源(js/image)的访问 --&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">mvc:resources</span> <span class=\"attr\">location</span>=<span class=\"string\">\"/js/\"</span> <span class=\"attr\">mapping</span>=<span class=\"string\">\"/js/**\"</span>/&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">&lt;!-- 定义视图解析器 --&gt;</span>\t</div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"viewResolver\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.springframework.web.servlet.view.InternalResourceViewResolver\"</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"prefix\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"/\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"suffix\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\".jsp\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>现在主流的对SpringMVC的配置时基于注解的，至于怎么注解，我们后面再说，这个配置文件中前两部分就是配置注解用的，base-package指明注解在哪些包下，你当然可以写所有的包，让框架都去扫描一遍，但没必要。在SpringMVC框架中，控制转发的类叫Controller（对应Struts中的Action），所以注解通常也都是在com.xxx.xxx.controller包中，所以这里只扫描相应的包就可以。</p>\n<p>mvc:resources定义静态文件的位置，因为我们前面在web.xml用/设置了过滤器，会拦截所有的请求，同时也会影响对静态文件的请求，这里配置之后，所有/js/**的请求都会去js文件夹去找，而不会跳转到controller控制类</p>\n<p>ViewResolver是定义视图解析器，做什么用的的，简单来说，controller控制类中某个方法返回“index”的意思其实是跳转到index页面，但通常这个页面会有前缀（也就是相对路径）和后缀（扩展名），这里这样配置后，return “index”，就会跳转到/index.jsp页面。</p>\n<p>解析完配置文件，我们看下Controller具体怎么写，其实就是在Struts框架中的Action类。代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> com.mvc.controller;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</div><div class=\"line\"><span class=\"keyword\">import</span> java.io.PrintWriter;</div><div class=\"line\"><span class=\"keyword\">import</span> java.util.List;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> javax.annotation.Resource;</div><div class=\"line\"><span class=\"keyword\">import</span> javax.servlet.http.HttpServletResponse;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> org.springframework.stereotype.Controller;</div><div class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.RequestMapping;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> com.mvc.manager.UserManager;</div><div class=\"line\"><span class=\"keyword\">import</span> com.mvc.pojo.User;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@Controller</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserController</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">\t<span class=\"meta\">@Resource</span>(name = <span class=\"string\">\"userManager\"</span>) <span class=\"comment\">// 获取spring配置文件中bean的id为userManager的，并注入</span></div><div class=\"line\">\t<span class=\"keyword\">private</span> UserManager userManager;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/toAddUser\"</span>)</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toAddUser</span><span class=\"params\">()</span></span></div><div class=\"line\">\t&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">\"/addUser\"</span>;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/getAllUser\"</span>)</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">getAllUser</span><span class=\"params\">(HttpServletResponse response)</span></span></div><div class=\"line\">\t&#123;</div><div class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"getAllUser IN\"</span>);</div><div class=\"line\">\t\tList&lt;User&gt; user = userManager.getUsers();</div><div class=\"line\"></div><div class=\"line\">\t\tPrintWriter out = <span class=\"keyword\">null</span>;</div><div class=\"line\">\t\tresponse.setContentType(<span class=\"string\">\"application/json\"</span>);</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"keyword\">try</span></div><div class=\"line\">\t\t&#123;</div><div class=\"line\">\t\t\tout = response.getWriter();</div><div class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; user.size(); i++)</div><div class=\"line\">\t\t\t&#123;</div><div class=\"line\">\t\t\t\tout.write(user.get(i).getUserName());</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t<span class=\"keyword\">catch</span> (IOException e)</div><div class=\"line\">\t\t&#123;</div><div class=\"line\">\t\t\te.printStackTrace();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>关于注解的详细解析，准备在专门写一篇文章，简单来说，就是在方法上加上</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/getAllUser\"</span>)</div></pre></td></tr></table></figure>\n<p>注解，对getAllUser的请求就会跳转到这个方法进行处理，像前面提到的，如果方法返回字符串，处理完之后就会做相应的跳转，如果方法返回void，则不进行任何跳转。</p>\n<p>到目前为止SpringMVC就配置完了，这时你访问 <a href=\"http://host:port/projectName/getAllUser\" target=\"_blank\" rel=\"external\">http://host:port/projectName/getAllUser</a> ，就能显示了。好，我们的第二个目标达成了，下个目标就是把Hibernate替换成Mybatis，然后就万事大吉了。</p>\n<p>再列一下其他文件吧</p>\n<p>spring-beans.xml</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans\"</span></span></div><div class=\"line\">\t<span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></div><div class=\"line\">\t<span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans</span></div><div class=\"line\">           http://www.springframework.org/schema/beans/spring-beans-3.0.xsd\"&gt;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"userDao\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.mvc.daoImpl.UserDao\"</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"sessionFactory\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">ref</span> <span class=\"attr\">bean</span>=<span class=\"string\">\"sessionFactory\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">&lt;!--用户注册业务逻辑类 --&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"userManager\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.mvc.manager.UserManager\"</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"dao\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">ref</span> <span class=\"attr\">bean</span>=<span class=\"string\">\"userDao\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>spring-common.xml</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans\"</span></span></div><div class=\"line\">\t<span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span> <span class=\"attr\">xmlns:context</span>=<span class=\"string\">\"http://www.springframework.org/schema/context\"</span></div><div class=\"line\">\t<span class=\"attr\">xmlns:mvc</span>=<span class=\"string\">\"http://www.springframework.org/schema/mvc\"</span></div><div class=\"line\">\t<span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans </span></div><div class=\"line\">\thttp://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">&lt;!-- 定义数据源的信息 --&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"dataSource\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.mchange.v2.c3p0.ComboPooledDataSource\"</span></span></div><div class=\"line\">\t\t<span class=\"attr\">destroy-method</span>=<span class=\"string\">\"close\"</span>&gt;</div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"driverClass\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>com.mysql.jdbc.Driver<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"jdbcUrl\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>jdbc:mysql://localhost:3306/test<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"user\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>root<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"password\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>zzw<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"maxPoolSize\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>80<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"minPoolSize\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>1<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"initialPoolSize\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>1<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"maxIdleTime\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>20<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">&lt;!--定义Hibernate的SessionFactory --&gt;</span></div><div class=\"line\">\t<span class=\"comment\">&lt;!-- SessionFactory使用的数据源为上面的数据源 --&gt;</span></div><div class=\"line\">\t<span class=\"comment\">&lt;!-- 指定了Hibernate的映射文件和配置信息 --&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"sessionFactory\"</span></span></div><div class=\"line\">\t\t<span class=\"attr\">class</span>=<span class=\"string\">\"org.springframework.orm.hibernate5.LocalSessionFactoryBean\"</span>&gt;</div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"dataSource\"</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"dataSource\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"mappingResources\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">list</span>&gt;</span></div><div class=\"line\">\t\t\t\t<span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>com/mvc/pojo/User.hbm.xml<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;/<span class=\"name\">list</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"hibernateProperties\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">props</span>&gt;</span></div><div class=\"line\">\t\t\t\t<span class=\"tag\">&lt;<span class=\"name\">prop</span> <span class=\"attr\">key</span>=<span class=\"string\">\"hibernate.dialect\"</span>&gt;</span>org.hibernate.dialect.MySQLDialect<span class=\"tag\">&lt;/<span class=\"name\">prop</span>&gt;</span></div><div class=\"line\">\t\t\t\t<span class=\"tag\">&lt;<span class=\"name\">prop</span> <span class=\"attr\">key</span>=<span class=\"string\">\"show_sql\"</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">prop</span>&gt;</span></div><div class=\"line\">\t\t\t\t<span class=\"tag\">&lt;<span class=\"name\">prop</span> <span class=\"attr\">key</span>=<span class=\"string\">\"hibernate.jdbc.batch_size\"</span>&gt;</span>20<span class=\"tag\">&lt;/<span class=\"name\">prop</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;/<span class=\"name\">props</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">&lt;!-- 配置一个事务管理器 --&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"transactionManager\"</span></span></div><div class=\"line\">\t\t<span class=\"attr\">class</span>=<span class=\"string\">\"org.springframework.orm.hibernate5.HibernateTransactionManager\"</span>&gt;</div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"sessionFactory\"</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"sessionFactory\"</span> /&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">&lt;!-- 配置事务，使用代理的方式 --&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"transactionProxy\"</span></span></div><div class=\"line\">\t\t<span class=\"attr\">class</span>=<span class=\"string\">\"org.springframework.transaction.interceptor.TransactionProxyFactoryBean\"</span></div><div class=\"line\">\t\t<span class=\"attr\">abstract</span>=<span class=\"string\">\"true\"</span>&gt;</div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"transactionManager\"</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"transactionManager\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"transactionAttributes\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">props</span>&gt;</span></div><div class=\"line\">\t\t\t\t<span class=\"tag\">&lt;<span class=\"name\">prop</span> <span class=\"attr\">key</span>=<span class=\"string\">\"add*\"</span>&gt;</span>PROPAGATION_REQUIRED,-Exception<span class=\"tag\">&lt;/<span class=\"name\">prop</span>&gt;</span></div><div class=\"line\">\t\t\t\t<span class=\"tag\">&lt;<span class=\"name\">prop</span> <span class=\"attr\">key</span>=<span class=\"string\">\"modify*\"</span>&gt;</span>PROPAGATION_REQUIRED,-myException<span class=\"tag\">&lt;/<span class=\"name\">prop</span>&gt;</span></div><div class=\"line\">\t\t\t\t<span class=\"tag\">&lt;<span class=\"name\">prop</span> <span class=\"attr\">key</span>=<span class=\"string\">\"del*\"</span>&gt;</span>PROPAGATION_REQUIRED<span class=\"tag\">&lt;/<span class=\"name\">prop</span>&gt;</span></div><div class=\"line\">\t\t\t\t<span class=\"tag\">&lt;<span class=\"name\">prop</span> <span class=\"attr\">key</span>=<span class=\"string\">\"*\"</span>&gt;</span>PROPAGATION_REQUIRED<span class=\"tag\">&lt;/<span class=\"name\">prop</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;/<span class=\"name\">props</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>其他像DAO类，manager类就不细说了，不懂得可以看我上一篇文章<a href=\"http://zwgeek.com/2016/09/03/%E5%9F%BA%E4%BA%8Estruts2-5-2-hibernate5-2-2-spring4-3-2%E6%90%AD%E5%BB%BASSH%E6%A1%86%E6%9E%B6v2/\">基于struts2.5.2+hibernate5.2.2+spring4.3.2搭建SSH框架</a></p>\n<p>整个项目的结构如下</p>\n<p><img src=\"http://img.blog.csdn.net/20160927143143944\" alt=\"\"></p>\n","excerpt":"","more":"<p>之前说过，我最终想搭建一个SpringMVC+Spring+MyBatis的框架，然后从SSH框架开始慢慢演化，这篇博客将讲解怎样将SSH框架中的Struts部分替换为SpringMVC做请求转发。</p>\n<p>至于为什么要替换成SpringMVC，我在<a href=\"http://zwgeek.com/2016/09/03/%E5%9F%BA%E4%BA%8Estruts2-5-2-hibernate5-2-2-spring4-3-2%E6%90%AD%E5%BB%BASSH%E6%A1%86%E6%9E%B6v2/\">基于struts2.5.2+hibernate5.2.2+spring4.3.2搭建SSH框架</a>这篇博客里说过，以下几点：</p>\n<ul>\n<li>struts除了可以做请求转发，还有页面标签，所以你如果只用请求转发的话，这个框架有点多余</li>\n<li>现在spring推出了springMVC，是专门做请求转发用的，因为是spring自家推出的，所以和spring的协调性更好，而且在我使用中也感觉springMVC用起来更方便，轻量级</li>\n</ul>\n<p>关于SSH框架的搭建可以去这篇文章查看</p>\n<ul>\n<li><a href=\"http://zwgeek.com/2016/09/03/%E5%9F%BA%E4%BA%8Estruts2-5-2-hibernate5-2-2-spring4-3-2%E6%90%AD%E5%BB%BASSH%E6%A1%86%E6%9E%B6v2/\">基于struts2.5.2+hibernate5.2.2+spring4.3.2搭建SSH框架</a></li>\n</ul>\n<p>在上面的基础上把Struts换成SpringMVC，其实很简单，为什么这么说呢，因为搭建SSH框架的时候，我们把Spring的所有jar包都加入到项目里了，不知道你有没有注意到，有这样一个jar包</p>\n<p>其实这个jar包就已经是对MVC的支持了，所以可以说我们上一个框架已经支持SpringMVC了，所以问题就变成了去掉Struts框架，所以很简单。</p>\n<p>首先可以删掉Struts的所有jar包，主要是以下两个，其他common开头的jar包因为spring也在用，所以可以不删掉。<br>struts2-core和struts2-spring-plugin，现在lib如下，可做参考：<br><img src=\"http://img.blog.csdn.net/20160927142022944\" alt=\"\"><br><img src=\"http://img.blog.csdn.net/20160927142042958\" alt=\"\"></p>\n<p>然后删掉struts.xml配置文件</p>\n<p>接下来我们来看怎么让SpringMVC生效</p>\n<p>首先把web.xml的拦截规则改成给SpringMVC拦截，如下</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet</span>&gt;</span></div><div class=\"line\">  \t<span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>springMVC<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></div><div class=\"line\">  \t<span class=\"tag\">&lt;<span class=\"name\">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-class</span>&gt;</span></div><div class=\"line\">  \t<span class=\"tag\">&lt;<span class=\"name\">init-param</span>&gt;</span></div><div class=\"line\">  \t\t<span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>contextConfigLocation<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span></div><div class=\"line\">  \t\t<span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span>classpath*:config/spring/spring-mvc.xml<span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span></div><div class=\"line\">  \t<span class=\"tag\">&lt;/<span class=\"name\">init-param</span>&gt;</span></div><div class=\"line\">  \t<span class=\"tag\">&lt;<span class=\"name\">load-on-startup</span>&gt;</span>1<span class=\"tag\">&lt;/<span class=\"name\">load-on-startup</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">servlet</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">servlet-mapping</span>&gt;</span></div><div class=\"line\">  \t<span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>springMVC<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></div><div class=\"line\">  \t<span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>/<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">servlet-mapping</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>然后在web.xml中配置SpringMVC的配置文件</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">&lt;!-- 加载所有的配置文件 --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">context-param</span>&gt;</span></div><div class=\"line\">  \t<span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>contextConfigLocation<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span></div><div class=\"line\">  \t<span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span>classpath*:config/spring/spring-*.xml<span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">context-param</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>修改之后的web.xml如下<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">web-app</span> <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://java.sun.com/xml/ns/javaee\"</span> <span class=\"attr\">xmlns:web</span>=<span class=\"string\">\"http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\"</span> <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"WebApp_ID\"</span> <span class=\"attr\">version</span>=<span class=\"string\">\"2.5\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">display-name</span>&gt;</span>json_test<span class=\"tag\">&lt;/<span class=\"name\">display-name</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">welcome-file-list</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">welcome-file</span>&gt;</span>login.jsp<span class=\"tag\">&lt;/<span class=\"name\">welcome-file</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">welcome-file-list</span>&gt;</span></div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">&lt;!-- 加载所有的配置文件 --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">context-param</span>&gt;</span></div><div class=\"line\">  \t<span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>contextConfigLocation<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span></div><div class=\"line\">  \t<span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span>classpath*:config/spring/spring-*.xml<span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">context-param</span>&gt;</span></div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">&lt;!-- 配置Spring监听 --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">listener</span>&gt;</span></div><div class=\"line\">  \t<span class=\"tag\">&lt;<span class=\"name\">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class=\"tag\">&lt;/<span class=\"name\">listener-class</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">listener</span>&gt;</span></div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">&lt;!-- 配置SpringMVC --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">servlet</span>&gt;</span></div><div class=\"line\">  \t<span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>springMVC<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></div><div class=\"line\">  \t<span class=\"tag\">&lt;<span class=\"name\">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-class</span>&gt;</span></div><div class=\"line\">  \t<span class=\"tag\">&lt;<span class=\"name\">init-param</span>&gt;</span></div><div class=\"line\">  \t\t<span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>contextConfigLocation<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span></div><div class=\"line\">  \t\t<span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span>classpath*:config/spring/spring-mvc.xml<span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span></div><div class=\"line\">  \t<span class=\"tag\">&lt;/<span class=\"name\">init-param</span>&gt;</span></div><div class=\"line\">  \t<span class=\"tag\">&lt;<span class=\"name\">load-on-startup</span>&gt;</span>1<span class=\"tag\">&lt;/<span class=\"name\">load-on-startup</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">servlet</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">servlet-mapping</span>&gt;</span></div><div class=\"line\">  \t<span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>springMVC<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></div><div class=\"line\">  \t<span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>/<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">servlet-mapping</span>&gt;</span></div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">&lt;!-- 配置字符集 --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">filter</span>&gt;</span></div><div class=\"line\">  \t<span class=\"tag\">&lt;<span class=\"name\">filter-name</span>&gt;</span>encodingFilter<span class=\"tag\">&lt;/<span class=\"name\">filter-name</span>&gt;</span></div><div class=\"line\">  \t<span class=\"tag\">&lt;<span class=\"name\">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class=\"tag\">&lt;/<span class=\"name\">filter-class</span>&gt;</span></div><div class=\"line\">  \t<span class=\"tag\">&lt;<span class=\"name\">init-param</span>&gt;</span></div><div class=\"line\">  \t\t<span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>encoding<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span></div><div class=\"line\">  \t\t<span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span>UTF-8<span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span></div><div class=\"line\">  \t<span class=\"tag\">&lt;/<span class=\"name\">init-param</span>&gt;</span></div><div class=\"line\">  \t<span class=\"tag\">&lt;<span class=\"name\">init-param</span>&gt;</span></div><div class=\"line\">  \t\t<span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>forceEncoding<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span></div><div class=\"line\">  \t\t<span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span></div><div class=\"line\">  \t<span class=\"tag\">&lt;/<span class=\"name\">init-param</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">filter</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">filter-mapping</span>&gt;</span></div><div class=\"line\">  \t<span class=\"tag\">&lt;<span class=\"name\">filter-name</span>&gt;</span>encodingFilter<span class=\"tag\">&lt;/<span class=\"name\">filter-name</span>&gt;</span></div><div class=\"line\">  \t<span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>/*<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">filter-mapping</span>&gt;</span></div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">&lt;!-- 配置Session --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">filter</span>&gt;</span></div><div class=\"line\">  \t<span class=\"tag\">&lt;<span class=\"name\">filter-name</span>&gt;</span>openSession<span class=\"tag\">&lt;/<span class=\"name\">filter-name</span>&gt;</span></div><div class=\"line\">  \t<span class=\"tag\">&lt;<span class=\"name\">filter-class</span>&gt;</span>org.springframework.orm.hibernate5.support.OpenSessionInViewFilter<span class=\"tag\">&lt;/<span class=\"name\">filter-class</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">filter</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">filter-mapping</span>&gt;</span></div><div class=\"line\">  \t<span class=\"tag\">&lt;<span class=\"name\">filter-name</span>&gt;</span>openSession<span class=\"tag\">&lt;/<span class=\"name\">filter-name</span>&gt;</span></div><div class=\"line\">  \t<span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>/*<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">filter-mapping</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">web-app</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p>字符集的配置是为了让所有请求和回复都用统一的字符集，比较方便。</p>\n<p>OpenSession是为了延长Session的生命周期用的，可以自行baidu一下，网上是这样写的。</p>\n<blockquote>\n<p>OpenSessionInViewFilter是Spring提供的一个针对Hibernate的一个支持类，其主要意思是在发起一个页面请求时打开Hibernate的Session，一直保持这个Session，直到这个请求结束，具体是通过一个Filter来实现的。\n　</p>\n<p>由于Hibernate引入了Lazy Load特性，使得脱离Hibernate的Session周期的对象如果再想通过getter方法取到其关联对象的值，Hibernate会抛出一个LazyLoad的Exception。所以为了解决这个问题，Spring引入了这个Filter，使得Hibernate的Session的生命周期变长。</p>\n</blockquote>\n<p>另外我们来看加载配置文件的地方</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">&lt;!-- 加载所有的配置文件 --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">context-param</span>&gt;</span></div><div class=\"line\">  \t<span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>contextConfigLocation<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span></div><div class=\"line\">  \t<span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span>classpath*:config/spring/spring-*.xml<span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">context-param</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>这句话的意思是载入config/spring/目录下的所有以spring开头的配置文件。前面说过spring的配置其实就是在配置各种bean，在配置SSH的时候我们把所有bean都写在了applicationContext里面，导致这个文件很大很复杂，这样不利于修改配置和查找异常。其实我们可以把不同的bean配置在不同的文件中，然后在web.xml中告诉程序去哪里找配置文件，就像这里这样。我们可以把关于mvc的bean配置在sprng-mvc.xml中，把业务逻辑bean配置在spring-beans中，把基础bean（比如session，datasource等）配置在spring-common.xml中。</p>\n<p>前面一篇文章也说过，eclipse在发布web项目的时候会把src目录映射成classpath目录，当然这是可以配置的。所以我们就在src目录下建立配置文件，如下</p>\n<p><img src=\"http://img.blog.csdn.net/20160927142443663\" alt=\"\"></p>\n<p>接下来看一下mvc的配置是怎样的</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans\"</span></div><div class=\"line\">\t<span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></div><div class=\"line\">\t<span class=\"attr\">xmlns:context</span>=<span class=\"string\">\"http://www.springframework.org/schema/context\"</span></div><div class=\"line\">\t<span class=\"attr\">xmlns:mvc</span>=<span class=\"string\">\"http://www.springframework.org/schema/mvc\"</span></div><div class=\"line\">\t<span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans </div><div class=\"line\">\thttp://www.springframework.org/schema/beans/spring-beans.xsd</div><div class=\"line\">\thttp://www.springframework.org/schema/context</div><div class=\"line\">\thttp://www.springframework.org/schema/context/spring-context-3.2.xsd</div><div class=\"line\">\thttp://www.springframework.org/schema/mvc</div><div class=\"line\">\thttp://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd\"</span>&gt;</span></div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"comment\">&lt;!-- 注解扫描包 --&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">context:component-scan</span> <span class=\"attr\">base-package</span>=<span class=\"string\">\"com.mvc.controller\"</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">&lt;!-- 开启注解 --&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">mvc:annotation-driven</span> /&gt;</span></div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"comment\">&lt;!-- 静态资源(js/image)的访问 --&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">mvc:resources</span> <span class=\"attr\">location</span>=<span class=\"string\">\"/js/\"</span> <span class=\"attr\">mapping</span>=<span class=\"string\">\"/js/**\"</span>/&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">&lt;!-- 定义视图解析器 --&gt;</span>\t</div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"viewResolver\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.springframework.web.servlet.view.InternalResourceViewResolver\"</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"prefix\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"/\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"suffix\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\".jsp\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>现在主流的对SpringMVC的配置时基于注解的，至于怎么注解，我们后面再说，这个配置文件中前两部分就是配置注解用的，base-package指明注解在哪些包下，你当然可以写所有的包，让框架都去扫描一遍，但没必要。在SpringMVC框架中，控制转发的类叫Controller（对应Struts中的Action），所以注解通常也都是在com.xxx.xxx.controller包中，所以这里只扫描相应的包就可以。</p>\n<p>mvc:resources定义静态文件的位置，因为我们前面在web.xml用/设置了过滤器，会拦截所有的请求，同时也会影响对静态文件的请求，这里配置之后，所有/js/**的请求都会去js文件夹去找，而不会跳转到controller控制类</p>\n<p>ViewResolver是定义视图解析器，做什么用的的，简单来说，controller控制类中某个方法返回“index”的意思其实是跳转到index页面，但通常这个页面会有前缀（也就是相对路径）和后缀（扩展名），这里这样配置后，return “index”，就会跳转到/index.jsp页面。</p>\n<p>解析完配置文件，我们看下Controller具体怎么写，其实就是在Struts框架中的Action类。代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> com.mvc.controller;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</div><div class=\"line\"><span class=\"keyword\">import</span> java.io.PrintWriter;</div><div class=\"line\"><span class=\"keyword\">import</span> java.util.List;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> javax.annotation.Resource;</div><div class=\"line\"><span class=\"keyword\">import</span> javax.servlet.http.HttpServletResponse;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> org.springframework.stereotype.Controller;</div><div class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.RequestMapping;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> com.mvc.manager.UserManager;</div><div class=\"line\"><span class=\"keyword\">import</span> com.mvc.pojo.User;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@Controller</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserController</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">\t<span class=\"meta\">@Resource</span>(name = <span class=\"string\">\"userManager\"</span>) <span class=\"comment\">// 获取spring配置文件中bean的id为userManager的，并注入</span></div><div class=\"line\">\t<span class=\"keyword\">private</span> UserManager userManager;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/toAddUser\"</span>)</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toAddUser</span><span class=\"params\">()</span></div><div class=\"line\">\t</span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">\"/addUser\"</span>;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/getAllUser\"</span>)</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">getAllUser</span><span class=\"params\">(HttpServletResponse response)</span></div><div class=\"line\">\t</span>&#123;</div><div class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"getAllUser IN\"</span>);</div><div class=\"line\">\t\tList&lt;User&gt; user = userManager.getUsers();</div><div class=\"line\"></div><div class=\"line\">\t\tPrintWriter out = <span class=\"keyword\">null</span>;</div><div class=\"line\">\t\tresponse.setContentType(<span class=\"string\">\"application/json\"</span>);</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"keyword\">try</span></div><div class=\"line\">\t\t&#123;</div><div class=\"line\">\t\t\tout = response.getWriter();</div><div class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; user.size(); i++)</div><div class=\"line\">\t\t\t&#123;</div><div class=\"line\">\t\t\t\tout.write(user.get(i).getUserName());</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t<span class=\"keyword\">catch</span> (IOException e)</div><div class=\"line\">\t\t&#123;</div><div class=\"line\">\t\t\te.printStackTrace();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>关于注解的详细解析，准备在专门写一篇文章，简单来说，就是在方法上加上</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/getAllUser\"</span>)</div></pre></td></tr></table></figure>\n<p>注解，对getAllUser的请求就会跳转到这个方法进行处理，像前面提到的，如果方法返回字符串，处理完之后就会做相应的跳转，如果方法返回void，则不进行任何跳转。</p>\n<p>到目前为止SpringMVC就配置完了，这时你访问 <a href=\"http://host:port/projectName/getAllUser\">http://host:port/projectName/getAllUser</a> ，就能显示了。好，我们的第二个目标达成了，下个目标就是把Hibernate替换成Mybatis，然后就万事大吉了。</p>\n<p>再列一下其他文件吧</p>\n<p>spring-beans.xml</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans\"</span></div><div class=\"line\">\t<span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></div><div class=\"line\">\t<span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans</div><div class=\"line\">           http://www.springframework.org/schema/beans/spring-beans-3.0.xsd\"</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"userDao\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.mvc.daoImpl.UserDao\"</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"sessionFactory\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">ref</span> <span class=\"attr\">bean</span>=<span class=\"string\">\"sessionFactory\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">&lt;!--用户注册业务逻辑类 --&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"userManager\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.mvc.manager.UserManager\"</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"dao\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">ref</span> <span class=\"attr\">bean</span>=<span class=\"string\">\"userDao\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>spring-common.xml</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans\"</span></div><div class=\"line\">\t<span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span> <span class=\"attr\">xmlns:context</span>=<span class=\"string\">\"http://www.springframework.org/schema/context\"</span></div><div class=\"line\">\t<span class=\"attr\">xmlns:mvc</span>=<span class=\"string\">\"http://www.springframework.org/schema/mvc\"</span></div><div class=\"line\">\t<span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans </div><div class=\"line\">\thttp://www.springframework.org/schema/beans/spring-beans.xsd\"</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">&lt;!-- 定义数据源的信息 --&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"dataSource\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.mchange.v2.c3p0.ComboPooledDataSource\"</span></div><div class=\"line\">\t\t<span class=\"attr\">destroy-method</span>=<span class=\"string\">\"close\"</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"driverClass\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>com.mysql.jdbc.Driver<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"jdbcUrl\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>jdbc:mysql://localhost:3306/test<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"user\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>root<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"password\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>zzw<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"maxPoolSize\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>80<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"minPoolSize\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>1<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"initialPoolSize\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>1<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"maxIdleTime\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>20<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">&lt;!--定义Hibernate的SessionFactory --&gt;</span></div><div class=\"line\">\t<span class=\"comment\">&lt;!-- SessionFactory使用的数据源为上面的数据源 --&gt;</span></div><div class=\"line\">\t<span class=\"comment\">&lt;!-- 指定了Hibernate的映射文件和配置信息 --&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"sessionFactory\"</span></div><div class=\"line\">\t\t<span class=\"attr\">class</span>=<span class=\"string\">\"org.springframework.orm.hibernate5.LocalSessionFactoryBean\"</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"dataSource\"</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"dataSource\"</span> /&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"mappingResources\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">list</span>&gt;</span></div><div class=\"line\">\t\t\t\t<span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>com/mvc/pojo/User.hbm.xml<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;/<span class=\"name\">list</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"hibernateProperties\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">props</span>&gt;</span></div><div class=\"line\">\t\t\t\t<span class=\"tag\">&lt;<span class=\"name\">prop</span> <span class=\"attr\">key</span>=<span class=\"string\">\"hibernate.dialect\"</span>&gt;</span>org.hibernate.dialect.MySQLDialect<span class=\"tag\">&lt;/<span class=\"name\">prop</span>&gt;</span></div><div class=\"line\">\t\t\t\t<span class=\"tag\">&lt;<span class=\"name\">prop</span> <span class=\"attr\">key</span>=<span class=\"string\">\"show_sql\"</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">prop</span>&gt;</span></div><div class=\"line\">\t\t\t\t<span class=\"tag\">&lt;<span class=\"name\">prop</span> <span class=\"attr\">key</span>=<span class=\"string\">\"hibernate.jdbc.batch_size\"</span>&gt;</span>20<span class=\"tag\">&lt;/<span class=\"name\">prop</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;/<span class=\"name\">props</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">&lt;!-- 配置一个事务管理器 --&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"transactionManager\"</span></div><div class=\"line\">\t\t<span class=\"attr\">class</span>=<span class=\"string\">\"org.springframework.orm.hibernate5.HibernateTransactionManager\"</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"sessionFactory\"</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"sessionFactory\"</span> /&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">&lt;!-- 配置事务，使用代理的方式 --&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"transactionProxy\"</span></div><div class=\"line\">\t\t<span class=\"attr\">class</span>=<span class=\"string\">\"org.springframework.transaction.interceptor.TransactionProxyFactoryBean\"</span></div><div class=\"line\">\t\t<span class=\"attr\">abstract</span>=<span class=\"string\">\"true\"</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"transactionManager\"</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"transactionManager\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"transactionAttributes\"</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">props</span>&gt;</span></div><div class=\"line\">\t\t\t\t<span class=\"tag\">&lt;<span class=\"name\">prop</span> <span class=\"attr\">key</span>=<span class=\"string\">\"add*\"</span>&gt;</span>PROPAGATION_REQUIRED,-Exception<span class=\"tag\">&lt;/<span class=\"name\">prop</span>&gt;</span></div><div class=\"line\">\t\t\t\t<span class=\"tag\">&lt;<span class=\"name\">prop</span> <span class=\"attr\">key</span>=<span class=\"string\">\"modify*\"</span>&gt;</span>PROPAGATION_REQUIRED,-myException<span class=\"tag\">&lt;/<span class=\"name\">prop</span>&gt;</span></div><div class=\"line\">\t\t\t\t<span class=\"tag\">&lt;<span class=\"name\">prop</span> <span class=\"attr\">key</span>=<span class=\"string\">\"del*\"</span>&gt;</span>PROPAGATION_REQUIRED<span class=\"tag\">&lt;/<span class=\"name\">prop</span>&gt;</span></div><div class=\"line\">\t\t\t\t<span class=\"tag\">&lt;<span class=\"name\">prop</span> <span class=\"attr\">key</span>=<span class=\"string\">\"*\"</span>&gt;</span>PROPAGATION_REQUIRED<span class=\"tag\">&lt;/<span class=\"name\">prop</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;/<span class=\"name\">props</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>其他像DAO类，manager类就不细说了，不懂得可以看我上一篇文章<a href=\"http://zwgeek.com/2016/09/03/%E5%9F%BA%E4%BA%8Estruts2-5-2-hibernate5-2-2-spring4-3-2%E6%90%AD%E5%BB%BASSH%E6%A1%86%E6%9E%B6v2/\">基于struts2.5.2+hibernate5.2.2+spring4.3.2搭建SSH框架</a></p>\n<p>整个项目的结构如下</p>\n<p><img src=\"http://img.blog.csdn.net/20160927143143944\" alt=\"\"></p>\n"},{"title":"蒙哥马利算法详解","date":"2016-09-29T08:58:21.000Z","_content":"这篇文章为大家梳理一下整个蒙哥马利算法的本质，蒙哥马利算法并不是一个独立的算法，而是三个相互独立又相互联系的算法集合，其中包括    \n\n* 蒙哥马利乘模，是用来计算$x\\cdot y\\ (mod\\ N)$\n* 蒙哥马利约减，是用来计算$t\\cdot \\rho^{-1}\\ (mod\\ N)$\n* 蒙哥马利幂模，是用来计算$x^y\\ (mod\\ N)$\n\n其中蒙哥马利幂乘是RSA加密算法的核心部分。\n\n### 基本概念\n梳理几个概念，试想一个集合是整数模N之后得到的  \n$Z_N=\\left\\\\{0,1,2,\\cdots,N-1\\right\\\\}$\n\n*注：N在base-b进制下有$l_N$位。  比如10进制和100进制，都属于base-10进制，因为$100=10^2$，所以b=10。在10进制下，667的$l_N=3$*\n\n这样的集合叫做N的剩余类环，任何属于这个集合Z的x满足以下两个条件： \n1. 正整数\n2. 最大长度是$l_N$  \n\n这篇文章中讲到的蒙哥马利算法就是用来计算基于$Z_N$集合上的运算，简单讲一下原因，因为RSA是基于大数运算的，通常是1024bit或2018bit，而我们的计算机不可能存储完整的大数，因为占空间太大，而且也没必要。因此，这种基于大数运算的加密体系在计算的时候都是基于$Z_N$集合的，自然，蒙哥马利算法也是基于$Z_N$。\n\n在剩余类环上，有两种重要的运算，一类是简单运算，也就是加法和减法，另一类复杂运算，也就是乘法。我们比较熟悉的是自然数集上的运算，下面看下怎么从自然数集的运算演变成剩余类环上的运算。\n\n对于加法运算，如果计算$x\\pm y\\ (mod\\ N)$ ($0\\leqslant x,y<N$)，试想自然数集上的 $x\\pm y$    \n\n$\\qquad 0\\leqslant x+y\\leqslant 2\\cdot(N-1)$  \n\n$-(N-1)\\leqslant x-y\\leqslant (N-1)$\n\n我们可以简单的通过加减N来实现从自然数到剩余类集的转换\n\n另外一类是乘法操作，也就是$x\\cdot y\\ (mod\\ N)$($0\\leqslant x,y<N$)，那么  \n\n$0\\leqslant x\\cdot y\\leqslant (N-1)^2$  \n\n如果在自然数集下，令$t=x\\cdot y$，那么对于$\\mod N$我们需要计算 \n \n$t-（N\\cdot \\lfloor\\frac{t}{N}\\rfloor）$\n\n加减操作很简单，具体的算这里就不细说了，我们用$Z_N-ADD$ 来代表剩余类环上的加法操作。既然我们可以做加法操作，那么我们就可以扩展到乘法操作，算法如下\n\n![这里写图片描述](http://img.blog.csdn.net/20160930181528853)\n\n但是这并不是一个好的解决方案，因为通常来说，我们不会直接做w位乘w位的操作，这个后面会用蒙哥马利的乘法来代替解决。\n\n对于取模操作，一般有以下几种方法\n\n1，根据以下公式，来计算取模操作\n\n$t-（N\\cdot \\lfloor\\frac{t}{N}\\rfloor）$\n\n这种解法有以下特征\n\n   - 整个计算过程是基于标准的数字表示\n   - 不需要预计算（也就是提前计算一些变量，以备使用）\n   - 涉及到一个除法操作，非常费时和复杂\n\n2，用Barrett reduction算法，这篇文章不细说，但是有以下特征\n\n   - 基于标准的数字表示\n   - 不需要预计算\n   - 需要$2 \\cdot (l_N+1) \\cdot (l_N+1)$ 次数乘运算\n\n3，用蒙哥马利约减，也就是下面要讲的算法，有以下特征  \n\n- 不是基于标准的数字表示（后文中有提到，是基于蒙哥马利表示法）\n- 需要预计算\n- 需要$2 \\cdot (l_N) \\cdot (l_N)$ 次数乘运算\n\n### 蒙哥马利预备知识\n在将蒙哥马利算法之前，先看一下在自然数下的乘法公式  \n\n计算$x\\cdot y$，想象一下我们常用的计算乘法的方法，用乘数的每一位乘上被乘数，然后把得到的结果相加，总结成公式，可以写成如下的形式。  \n\n$x\\cdot y=x\\cdot sum_{i=0}^{l_y-1}y_i \\cdot b^i$\n\n$\\qquad=sum_{i=0}^{l_y-1}y_i \\cdot x \\cdot b^i$  \n\n尝试下面一个例子，10进制下（也就是b=10），y=456（也就是$l_n=3$），计算$x\\cdot y$，公式可演变如下：  \n\n$x\\cdot y=(y\\_{0}\\cdot x\\cdot 10^{0})+(y\\_{1}\\cdot x\\cdot 10^{1})+(y\\_{2}\\cdot x\\cdot 10^{2})$  \n$\\qquad=(y\\_{0}\\cdot x\\cdot 0)+(y\\_{1}\\cdot x\\cdot 10)+(y\\_{2}\\cdot x\\cdot 100)$  \n$\\qquad=(y\\_{0}\\cdot x)+10\\cdot(y\\_{1}\\cdot x+10\\cdot(y\\_{2}\\cdot x\\cdot +10\\cdot(0)))$  \n\n最后一次演变其实就是用霍纳法则(Horner's rule)所讲的规则，关于霍纳法则，可以自行百度。\n\n这个计算过程写成代码实现的算法应该是这样的：  \n![这里写图片描述](http://img.blog.csdn.net/20161008101121827)\n\n接下来我们来看下面这样的计算，计算$(x\\cdot y)/1000$，由前面可以知道 \n\n\n$x\\cdot y=(y\\_{0}\\cdot x)+10\\cdot(y\\_{1}\\cdot x+10\\cdot(y\\_{2}\\cdot x\\cdot +10\\cdot(0)))$\n\n\n由此可以知道：\n\n$\\frac{x\\cdot y}{1000}=\\frac{(y\\_{0}\\cdot x\\cdot 10^{0})+(y\\_{1}\\cdot x\\cdot 10^{1})+(y\\_{2}\\cdot x\\cdot 10^{2})}{1000}$\n\n$\\qquad=\\frac{(y\\_{0}\\cdot x\\cdot 0)+(y\\_{1}\\cdot x\\cdot 10)+(y\\_{2}\\cdot x\\cdot 100)}{1000}$  \n\n$\\qquad=\\frac{(y\\_{0}\\cdot x)}{1000}+\\frac{(y\\_{1}\\cdot x)}{100}+\\frac{(y\\_{2}\\cdot x)}{10}$  \n\n$\\qquad=(((((y_0\\cdot x)/10)+y_1\\cdot x)/10)+y_2\\cdot x)/10$  \n\n这个计算过程写成代码实现的算法是这样的：\n![这里写图片描述](http://img.blog.csdn.net/20161008101529067)\n\n接下来我们再来看在剩余类集合下的乘法操作 $x\\cdot y/1000\\ (mod\\ 667)$  \n\n我们知道剩余类集合$Z_{667}=\\left\\\\{0,1 \\cdots 666\\right\\\\}$，是不存在小数的，而如果我们采用自然数集的计算方式的话，就会出现小数，比如前面的例子，除10就会有小数。  \n\n这个问题是这样的，我们知道$u·667 \\equiv 0 (mod 667)$（$\\equiv$表示取模相等），所以我们可以选择一个合适的u，用u乘667再加上r，使得和是一个可以除10没有小数，这样在mod 667之后依然是正确的结果。至于u怎么算出来，这篇文章会在后面的章节说明。\n\n这个过程之后$x\\cdot y/1000\\ (mod\\ 667)$  的计算算法可以写成如下的形式\n![这里写图片描述](http://img.blog.csdn.net/20161008102045043)\n\n至此，你可能还不明白上面说这一堆演变的原因，其实很简单，原来是一个$(x\\cdot y)\\ (mod\\ 667)$的运算，这个运算中的模操作，正常情况下是要通过除法实现的，而除法是一个特别复杂的运算，要涉及到很多乘法，所以在大数运算时，我们要尽量避免除法的出现。而通过以上几个步骤，我们发现$(x\\cdot y)/1000\\ (mod\\ 667)$这个操作是不用除法的。等等，算法中明明有个除10的操作，你骗谁呢。不知道你有没有发现，除数其实是我们的进制数，除进制数在计算机中是怎么做呢，其实很简单，左移操作就ok了。所以这个计算方法是不涉及到除法操作的。\n\n但是我们要计算的明明是$(x_1\\cdot y_1)\\ (mod\\ 667)$，怎么现在变成了$(x_2\\cdot y_2)/1000\\ (mod\\ 667)$，所以在下一步，我们要思考的是怎么样让$(x_1\\cdot y_1)\\ (mod\\ 667)$转变成$(x_2\\cdot y_2)/1000\\ (mod\\ 667)$这种形式。\n\n考虑这样两个算法  \n-  第一个是输入x和y，计算$x \\cdot y \\cdot \\rho^{-1}$\n-  第二个算法，输入一个t，计算$t \\cdot \\rho^{-1}$。\n\n$x\\cdot y\\ (mod\\ 667)=((x\\cdot1000)\\cdot(y\\cdot1000)/1000)/1000\\ (mod\\ 667)$\n\n是不是变成了我们需要的$(x\\cdot y)/1000\\ (mod\\ 667)$模式，而且这个转变过程是不是可以通过上面两个算法来实现，输入值如果是$(x\\cdot1000)$和$(y\\cdot1000)$，则通过第一个算法可以得到$((x\\cdot1000)\\cdot(y\\cdot1000)/1000)$，把结果作为第二个算法的输入值，则通过第二个算法可以得到$((x\\cdot1000)\\cdot(y\\cdot1000)/1000)/1000$。\n\n扯了一大顿，终于引出了今天文章的主角，前面讲到的两个算法，第一个就是蒙哥马利乘模，第二个就是蒙哥马利约减。下面我们来讲这两个算法的详解。\n\n正如前面提到的蒙哥马利算法的三个特性之一是，不是基于普通的整数表示法，而是基于蒙哥马利表示法。什么是蒙哥马利表示法呢，其实也很简单，上面我们提到，要让$(x_1\\cdot y_1)\\ (mod\\ 667)$转变成$(x_2\\cdot y_2)/1000\\ (mod\\ 667)$这种形式，我们需要将输入参数变成$(x\\cdot1000)$和$(y\\cdot1000)$，而不是x和y本身，而$(x\\cdot1000)$和$(y\\cdot1000)$ 其实就是蒙哥马利表示法。\n\n所以我们先定义几个概念：  \n\n- 蒙哥马利参数  \n给定一个N，N在b进制（例如，二进制时，b=2）下共有l位，$gcd(N,b)=1$，先预计算以下几个值(这就是前面提到的特性之一，需要预计算）：\n* * $\\rho = b^k$ 指定一个最小的k，使得$b^k>N$  \n* *  $\\omega =  -N^{-1} (mod\\ \\rho)$    \n这两个参数是做什么用的呢，你对照前面的演变过程可以猜到$\\rho $ 就是前面演变中的1000，而$\\omega$ 则是用来计算前面提到的u的。\n\n- 蒙哥马利表示法\n对于x，$0\\leqslant x\\leqslant N-1$，x的蒙哥马利表示法表示为$x=x\\cdot \\rho\\ (mod\\ N)$\n\n### 蒙哥马利约减\n\n蒙哥马利约减的定义如下\n给定一些整数t，蒙哥马利约减的计算结果是$t\\cdot \\rho^{-1}\\ (mod\\ N)$\n\n蒙哥马利约减的算法可表示为\n![这里写图片描述](http://img.blog.csdn.net/20161008105605136)\n\n蒙哥马利约减可以算作是下面要说的蒙哥马利模乘当$x=1$时的一种特殊形式，。同时它又是蒙哥马利乘模要用到的一部分，这在下一部分讲蒙哥马利乘模的时候有讲到。\n\n蒙哥马利约减可以用来计算某个值得取模操作，比如我们要计算$m(mod\\ N)$，只需要将m\n的蒙哥马利表示法$m\\cdot \\rho$作为参数，带入蒙哥马利约减，则计算结果就是$m(mod\\ N)$。\n\n### 蒙哥马利乘模\n一个蒙哥马利乘模包括整数乘法和蒙哥马利约减，现在我们有蒙哥马利表示法：  \n\n$ \\hat{x}=x\\cdot\\rho\\ (mod\\ N)$   \n$ \\hat{y}=y\\cdot\\rho\\ (mod\\ N)$  \n\n它们相乘的结果是  \n\n$t=\\hat{x}\\cdot\\hat{y}$  \n$\\ =(x\\cdot\\rho)\\cdot(y\\cdot\\rho)$\n$\\ =(x\\cdot y)\\cdot\\rho^2$\n\n最后，用一次蒙哥马利约减得到结果\n\n$ \\hat{t}=(x \\cdot y) \\cdot \\rho\\ (mod\\ N)$\n\n上面我们可以看出，给出的输入参数是$ \\hat{x}$ 和$ \\hat{y}$， 得到的结果是$(x \\cdot y) \\cdot \\rho\\ (mod\\ N)$，所以蒙哥马利乘法也可以写成如下形式，已知输入参数x和y，蒙哥马利乘法是计算$(x \\cdot y) \\cdot \\rho ^ {-1}\\ (mod\\ N)$\n\n举个例子：  \nb=10，也就是说在10进制下，N=667  \n让$b^k>N$的最小的k是3，所以$\\rho=b^k=10^3=1000$\n$\\omega=-N^{-1}\\ (mod\\ \\rho)=-667^{-1}\\ (mod\\ \\rho)=997$\n\n因为$x=421$，所以$\\hat{x}=x\\cdot\\rho(mod\\ N)=421\\cdot1000(mod\\ 667)=123$\n因为$y=422$，所以$\\hat{y}=y\\cdot\\rho(mod\\ N)=422\\cdot1000(mod\\ 667)=456$\n\n所以计算$\\hat{x}$和$\\hat{y}$蒙哥马利乘结果是 \n \n$\\hat{x}\\cdot\\hat{y}\\cdot\\rho^{-1}=(421\\cdot1000\\cdot422\\cdot1000)\\cdot1000^{-1}\\ (mod\\ 667)$\n$\\qquad\\qquad(421\\cdot422)\\cdot1000\\ (mod\\ 667)$  \n$\\qquad\\qquad(240)\\cdot1000\\ (mod\\ 667)$  \n$\\qquad\\qquad547\\ (mod\\ 667)$\n\n然后总结一下蒙哥马利约减和蒙哥马利乘法的伪代码实现，这个算法其实就是从[蒙哥马利预备知识](#蒙哥马利预备知识)讲到的算法演变来的。\n![这里写图片描述](http://img.blog.csdn.net/20161008105553673)\n\n上面的例子用这个算法可以描述为\n![这里写图片描述](http://img.blog.csdn.net/20161008130118944)\n\n蒙哥马利算法是一套很完美的算法，为什么这么说呢，你看一开始已知$x$，我们要求$\\hat{x}=x \\cdot \\rho$，这个过程可以通过蒙哥马利乘法本身来计算，输入参数$x$和$\\rho^2$，计算结果就是$\\hat{x}=x \\cdot \\rho$。然后在最后，我们知道$\\hat{x}=x \\cdot \\rho$，要求得$x$的时候，同样可以通过蒙哥马利算法本身计算，输入参数$\\hat{x}$和$1$，计算结果就是$x$。有没有一种因就是果，果就是因的感觉，这就是为什么说蒙哥马利算法是一套很完美的算法。\n\n### 蒙哥马利幂模\n最后，才说到我们最开始提到的RSA的核心幂模运算，先来看一下普通幂运算的算法是怎么得出来的。  \n> 以下资料来自于百度百科[快速模幂运算](http://baike.baidu.com/link?url=0n8jO-kkk7g7ms-6H2UCJz0sW5BkTB-wEor4aXsmCQ8A3o1u9f5AuAfAiO-PD7R4V7wxzen1AxZpiUkcy7XS0a)\n> 针对快速模幂运算这一课题，西方现代数学家提出了大量的解决方案，通常都是先将幂模运算转化为乘模运算。\n例如求D=C^15%N\n由于：a\\*b % n = (a % n)\\*(b % n) % n\n所以令：\nC1 =C\\*C % N =C^2 % N\nC2 =C1\\*C % N =C^3 % N\nC3 =C2\\*C2 % N =C^6 % N\nC4 =C3\\*C % N =C^7 % N\nC5 =C4\\*C4 % N =C^14 % N\nC6 =C5\\*C % N =C^15 % N\n即：对于E=15的幂模运算可分解为6 个乘模运算，归纳分析以上方法可以发现：\n对于任意指数E，都可采用以下算法计算D=C\\*\\*E % N：\nD=1\nWHILE E>0\nIF E%2=0\nC=C\\*C % N\nE=E/2\nELSE\nD=D\\*C % N\nE=E-1\nRETURN D\n继续分析会发现，要知道E 何时能整除 2，并不需要反复进行减一或除二的操作，只需验证E 的二进制各位是0 还是1 就可以了，从左至右或从右至左验证都可以，从左至右会更简洁，\n设E=Sum\\[i=0 to n\\](E\\*2\\*\\*i)，0<=E<=1\n则：\nD=1\nFOR i=n TO 0\nD=D\\*D % N\nIF E=1\nD=D*C % N\nRETURN D这样，模幂运算就转化成了一系列的模乘运算。\n\n\n算法可以写成如下的形式\n![这里写图片描述](http://img.blog.csdn.net/20161008105957718)\n\n如果我们现在用蒙哥马利样式稍作改变，就可以变成如下的形式：  \n![这里写图片描述](http://img.blog.csdn.net/20161008110022926)\n\n以上就是蒙哥马利算法的全部，通过蒙哥马利算法中的约减运算，我们将大数运算中的模运算变成了移位操作，极大地提高了大数模乘的效率。\n\n但是在以上的算法，可以发现还有两个变量的计算方式不是很清楚，一个是$\\omega$，前面说过$\\omega =  -N^{-1} (mod N)$ ，其实在算法中，我们看到，$omega$仅仅被用来做$\\mod b$操作，所以事实上，我们只需要计算$\\mod b$即可。\n\n尽管N有可能是合数（因为两个素数的乘积不一定是素数），但通常N和$\\rho$（也就是N和b）是互质的，也就是说$N^{\\phi(b)}=1(mob\\  b)$(费马定理)，$N^{\\phi(b)-1}=N^{-1}(mob\\  b)$\n因为$b=2^\\omega$，所以$\\phi(b)=2^{(\\omega-1)}$，写成算法是这样的\n![这里写图片描述](http://img.blog.csdn.net/20161008110739777)\n\n还有一个参数是$\\rho^2$，还记得前面说过$\\rho$是怎么得出来吗，选定一个最小的$k$，使得$b^k>N$，我们还知道$N$在$b$进制下是$l_N$位，所以当$k=l_N$的时候肯定是符合要求。\n\n$b=2^{\\omega}$ 所以$\\rho=b^k=({2^{\\omega}})^k$ \n\n$\\rho^2={({2^w})^k)}^2=2^{2\\cdot k\\cdot \\omega}=2^{2\\cdot l_N\\cdot \\omega}$，算法如下\n\n![这里写图片描述](http://img.blog.csdn.net/20161008111748040)\n\n至此整个蒙哥马利算法就全部说完了。通过这个算法，我们可以实现快速幂模。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/蒙哥马利算法详解.md","raw":"---\ntitle: 蒙哥马利算法详解\ndate: 2016-09-29 16:58:21\ntags:\n  - 蒙哥马利约减\n  - 蒙哥马利乘法\n  - 蒙哥马利幂乘\ncategories: 密码学\n---\n这篇文章为大家梳理一下整个蒙哥马利算法的本质，蒙哥马利算法并不是一个独立的算法，而是三个相互独立又相互联系的算法集合，其中包括    \n\n* 蒙哥马利乘模，是用来计算$x\\cdot y\\ (mod\\ N)$\n* 蒙哥马利约减，是用来计算$t\\cdot \\rho^{-1}\\ (mod\\ N)$\n* 蒙哥马利幂模，是用来计算$x^y\\ (mod\\ N)$\n\n其中蒙哥马利幂乘是RSA加密算法的核心部分。\n\n### 基本概念\n梳理几个概念，试想一个集合是整数模N之后得到的  \n$Z_N=\\left\\\\{0,1,2,\\cdots,N-1\\right\\\\}$\n\n*注：N在base-b进制下有$l_N$位。  比如10进制和100进制，都属于base-10进制，因为$100=10^2$，所以b=10。在10进制下，667的$l_N=3$*\n\n这样的集合叫做N的剩余类环，任何属于这个集合Z的x满足以下两个条件： \n1. 正整数\n2. 最大长度是$l_N$  \n\n这篇文章中讲到的蒙哥马利算法就是用来计算基于$Z_N$集合上的运算，简单讲一下原因，因为RSA是基于大数运算的，通常是1024bit或2018bit，而我们的计算机不可能存储完整的大数，因为占空间太大，而且也没必要。因此，这种基于大数运算的加密体系在计算的时候都是基于$Z_N$集合的，自然，蒙哥马利算法也是基于$Z_N$。\n\n在剩余类环上，有两种重要的运算，一类是简单运算，也就是加法和减法，另一类复杂运算，也就是乘法。我们比较熟悉的是自然数集上的运算，下面看下怎么从自然数集的运算演变成剩余类环上的运算。\n\n对于加法运算，如果计算$x\\pm y\\ (mod\\ N)$ ($0\\leqslant x,y<N$)，试想自然数集上的 $x\\pm y$    \n\n$\\qquad 0\\leqslant x+y\\leqslant 2\\cdot(N-1)$  \n\n$-(N-1)\\leqslant x-y\\leqslant (N-1)$\n\n我们可以简单的通过加减N来实现从自然数到剩余类集的转换\n\n另外一类是乘法操作，也就是$x\\cdot y\\ (mod\\ N)$($0\\leqslant x,y<N$)，那么  \n\n$0\\leqslant x\\cdot y\\leqslant (N-1)^2$  \n\n如果在自然数集下，令$t=x\\cdot y$，那么对于$\\mod N$我们需要计算 \n \n$t-（N\\cdot \\lfloor\\frac{t}{N}\\rfloor）$\n\n加减操作很简单，具体的算这里就不细说了，我们用$Z_N-ADD$ 来代表剩余类环上的加法操作。既然我们可以做加法操作，那么我们就可以扩展到乘法操作，算法如下\n\n![这里写图片描述](http://img.blog.csdn.net/20160930181528853)\n\n但是这并不是一个好的解决方案，因为通常来说，我们不会直接做w位乘w位的操作，这个后面会用蒙哥马利的乘法来代替解决。\n\n对于取模操作，一般有以下几种方法\n\n1，根据以下公式，来计算取模操作\n\n$t-（N\\cdot \\lfloor\\frac{t}{N}\\rfloor）$\n\n这种解法有以下特征\n\n   - 整个计算过程是基于标准的数字表示\n   - 不需要预计算（也就是提前计算一些变量，以备使用）\n   - 涉及到一个除法操作，非常费时和复杂\n\n2，用Barrett reduction算法，这篇文章不细说，但是有以下特征\n\n   - 基于标准的数字表示\n   - 不需要预计算\n   - 需要$2 \\cdot (l_N+1) \\cdot (l_N+1)$ 次数乘运算\n\n3，用蒙哥马利约减，也就是下面要讲的算法，有以下特征  \n\n- 不是基于标准的数字表示（后文中有提到，是基于蒙哥马利表示法）\n- 需要预计算\n- 需要$2 \\cdot (l_N) \\cdot (l_N)$ 次数乘运算\n\n### 蒙哥马利预备知识\n在将蒙哥马利算法之前，先看一下在自然数下的乘法公式  \n\n计算$x\\cdot y$，想象一下我们常用的计算乘法的方法，用乘数的每一位乘上被乘数，然后把得到的结果相加，总结成公式，可以写成如下的形式。  \n\n$x\\cdot y=x\\cdot sum_{i=0}^{l_y-1}y_i \\cdot b^i$\n\n$\\qquad=sum_{i=0}^{l_y-1}y_i \\cdot x \\cdot b^i$  \n\n尝试下面一个例子，10进制下（也就是b=10），y=456（也就是$l_n=3$），计算$x\\cdot y$，公式可演变如下：  \n\n$x\\cdot y=(y\\_{0}\\cdot x\\cdot 10^{0})+(y\\_{1}\\cdot x\\cdot 10^{1})+(y\\_{2}\\cdot x\\cdot 10^{2})$  \n$\\qquad=(y\\_{0}\\cdot x\\cdot 0)+(y\\_{1}\\cdot x\\cdot 10)+(y\\_{2}\\cdot x\\cdot 100)$  \n$\\qquad=(y\\_{0}\\cdot x)+10\\cdot(y\\_{1}\\cdot x+10\\cdot(y\\_{2}\\cdot x\\cdot +10\\cdot(0)))$  \n\n最后一次演变其实就是用霍纳法则(Horner's rule)所讲的规则，关于霍纳法则，可以自行百度。\n\n这个计算过程写成代码实现的算法应该是这样的：  \n![这里写图片描述](http://img.blog.csdn.net/20161008101121827)\n\n接下来我们来看下面这样的计算，计算$(x\\cdot y)/1000$，由前面可以知道 \n\n\n$x\\cdot y=(y\\_{0}\\cdot x)+10\\cdot(y\\_{1}\\cdot x+10\\cdot(y\\_{2}\\cdot x\\cdot +10\\cdot(0)))$\n\n\n由此可以知道：\n\n$\\frac{x\\cdot y}{1000}=\\frac{(y\\_{0}\\cdot x\\cdot 10^{0})+(y\\_{1}\\cdot x\\cdot 10^{1})+(y\\_{2}\\cdot x\\cdot 10^{2})}{1000}$\n\n$\\qquad=\\frac{(y\\_{0}\\cdot x\\cdot 0)+(y\\_{1}\\cdot x\\cdot 10)+(y\\_{2}\\cdot x\\cdot 100)}{1000}$  \n\n$\\qquad=\\frac{(y\\_{0}\\cdot x)}{1000}+\\frac{(y\\_{1}\\cdot x)}{100}+\\frac{(y\\_{2}\\cdot x)}{10}$  \n\n$\\qquad=(((((y_0\\cdot x)/10)+y_1\\cdot x)/10)+y_2\\cdot x)/10$  \n\n这个计算过程写成代码实现的算法是这样的：\n![这里写图片描述](http://img.blog.csdn.net/20161008101529067)\n\n接下来我们再来看在剩余类集合下的乘法操作 $x\\cdot y/1000\\ (mod\\ 667)$  \n\n我们知道剩余类集合$Z_{667}=\\left\\\\{0,1 \\cdots 666\\right\\\\}$，是不存在小数的，而如果我们采用自然数集的计算方式的话，就会出现小数，比如前面的例子，除10就会有小数。  \n\n这个问题是这样的，我们知道$u·667 \\equiv 0 (mod 667)$（$\\equiv$表示取模相等），所以我们可以选择一个合适的u，用u乘667再加上r，使得和是一个可以除10没有小数，这样在mod 667之后依然是正确的结果。至于u怎么算出来，这篇文章会在后面的章节说明。\n\n这个过程之后$x\\cdot y/1000\\ (mod\\ 667)$  的计算算法可以写成如下的形式\n![这里写图片描述](http://img.blog.csdn.net/20161008102045043)\n\n至此，你可能还不明白上面说这一堆演变的原因，其实很简单，原来是一个$(x\\cdot y)\\ (mod\\ 667)$的运算，这个运算中的模操作，正常情况下是要通过除法实现的，而除法是一个特别复杂的运算，要涉及到很多乘法，所以在大数运算时，我们要尽量避免除法的出现。而通过以上几个步骤，我们发现$(x\\cdot y)/1000\\ (mod\\ 667)$这个操作是不用除法的。等等，算法中明明有个除10的操作，你骗谁呢。不知道你有没有发现，除数其实是我们的进制数，除进制数在计算机中是怎么做呢，其实很简单，左移操作就ok了。所以这个计算方法是不涉及到除法操作的。\n\n但是我们要计算的明明是$(x_1\\cdot y_1)\\ (mod\\ 667)$，怎么现在变成了$(x_2\\cdot y_2)/1000\\ (mod\\ 667)$，所以在下一步，我们要思考的是怎么样让$(x_1\\cdot y_1)\\ (mod\\ 667)$转变成$(x_2\\cdot y_2)/1000\\ (mod\\ 667)$这种形式。\n\n考虑这样两个算法  \n-  第一个是输入x和y，计算$x \\cdot y \\cdot \\rho^{-1}$\n-  第二个算法，输入一个t，计算$t \\cdot \\rho^{-1}$。\n\n$x\\cdot y\\ (mod\\ 667)=((x\\cdot1000)\\cdot(y\\cdot1000)/1000)/1000\\ (mod\\ 667)$\n\n是不是变成了我们需要的$(x\\cdot y)/1000\\ (mod\\ 667)$模式，而且这个转变过程是不是可以通过上面两个算法来实现，输入值如果是$(x\\cdot1000)$和$(y\\cdot1000)$，则通过第一个算法可以得到$((x\\cdot1000)\\cdot(y\\cdot1000)/1000)$，把结果作为第二个算法的输入值，则通过第二个算法可以得到$((x\\cdot1000)\\cdot(y\\cdot1000)/1000)/1000$。\n\n扯了一大顿，终于引出了今天文章的主角，前面讲到的两个算法，第一个就是蒙哥马利乘模，第二个就是蒙哥马利约减。下面我们来讲这两个算法的详解。\n\n正如前面提到的蒙哥马利算法的三个特性之一是，不是基于普通的整数表示法，而是基于蒙哥马利表示法。什么是蒙哥马利表示法呢，其实也很简单，上面我们提到，要让$(x_1\\cdot y_1)\\ (mod\\ 667)$转变成$(x_2\\cdot y_2)/1000\\ (mod\\ 667)$这种形式，我们需要将输入参数变成$(x\\cdot1000)$和$(y\\cdot1000)$，而不是x和y本身，而$(x\\cdot1000)$和$(y\\cdot1000)$ 其实就是蒙哥马利表示法。\n\n所以我们先定义几个概念：  \n\n- 蒙哥马利参数  \n给定一个N，N在b进制（例如，二进制时，b=2）下共有l位，$gcd(N,b)=1$，先预计算以下几个值(这就是前面提到的特性之一，需要预计算）：\n* * $\\rho = b^k$ 指定一个最小的k，使得$b^k>N$  \n* *  $\\omega =  -N^{-1} (mod\\ \\rho)$    \n这两个参数是做什么用的呢，你对照前面的演变过程可以猜到$\\rho $ 就是前面演变中的1000，而$\\omega$ 则是用来计算前面提到的u的。\n\n- 蒙哥马利表示法\n对于x，$0\\leqslant x\\leqslant N-1$，x的蒙哥马利表示法表示为$x=x\\cdot \\rho\\ (mod\\ N)$\n\n### 蒙哥马利约减\n\n蒙哥马利约减的定义如下\n给定一些整数t，蒙哥马利约减的计算结果是$t\\cdot \\rho^{-1}\\ (mod\\ N)$\n\n蒙哥马利约减的算法可表示为\n![这里写图片描述](http://img.blog.csdn.net/20161008105605136)\n\n蒙哥马利约减可以算作是下面要说的蒙哥马利模乘当$x=1$时的一种特殊形式，。同时它又是蒙哥马利乘模要用到的一部分，这在下一部分讲蒙哥马利乘模的时候有讲到。\n\n蒙哥马利约减可以用来计算某个值得取模操作，比如我们要计算$m(mod\\ N)$，只需要将m\n的蒙哥马利表示法$m\\cdot \\rho$作为参数，带入蒙哥马利约减，则计算结果就是$m(mod\\ N)$。\n\n### 蒙哥马利乘模\n一个蒙哥马利乘模包括整数乘法和蒙哥马利约减，现在我们有蒙哥马利表示法：  \n\n$ \\hat{x}=x\\cdot\\rho\\ (mod\\ N)$   \n$ \\hat{y}=y\\cdot\\rho\\ (mod\\ N)$  \n\n它们相乘的结果是  \n\n$t=\\hat{x}\\cdot\\hat{y}$  \n$\\ =(x\\cdot\\rho)\\cdot(y\\cdot\\rho)$\n$\\ =(x\\cdot y)\\cdot\\rho^2$\n\n最后，用一次蒙哥马利约减得到结果\n\n$ \\hat{t}=(x \\cdot y) \\cdot \\rho\\ (mod\\ N)$\n\n上面我们可以看出，给出的输入参数是$ \\hat{x}$ 和$ \\hat{y}$， 得到的结果是$(x \\cdot y) \\cdot \\rho\\ (mod\\ N)$，所以蒙哥马利乘法也可以写成如下形式，已知输入参数x和y，蒙哥马利乘法是计算$(x \\cdot y) \\cdot \\rho ^ {-1}\\ (mod\\ N)$\n\n举个例子：  \nb=10，也就是说在10进制下，N=667  \n让$b^k>N$的最小的k是3，所以$\\rho=b^k=10^3=1000$\n$\\omega=-N^{-1}\\ (mod\\ \\rho)=-667^{-1}\\ (mod\\ \\rho)=997$\n\n因为$x=421$，所以$\\hat{x}=x\\cdot\\rho(mod\\ N)=421\\cdot1000(mod\\ 667)=123$\n因为$y=422$，所以$\\hat{y}=y\\cdot\\rho(mod\\ N)=422\\cdot1000(mod\\ 667)=456$\n\n所以计算$\\hat{x}$和$\\hat{y}$蒙哥马利乘结果是 \n \n$\\hat{x}\\cdot\\hat{y}\\cdot\\rho^{-1}=(421\\cdot1000\\cdot422\\cdot1000)\\cdot1000^{-1}\\ (mod\\ 667)$\n$\\qquad\\qquad(421\\cdot422)\\cdot1000\\ (mod\\ 667)$  \n$\\qquad\\qquad(240)\\cdot1000\\ (mod\\ 667)$  \n$\\qquad\\qquad547\\ (mod\\ 667)$\n\n然后总结一下蒙哥马利约减和蒙哥马利乘法的伪代码实现，这个算法其实就是从[蒙哥马利预备知识](#蒙哥马利预备知识)讲到的算法演变来的。\n![这里写图片描述](http://img.blog.csdn.net/20161008105553673)\n\n上面的例子用这个算法可以描述为\n![这里写图片描述](http://img.blog.csdn.net/20161008130118944)\n\n蒙哥马利算法是一套很完美的算法，为什么这么说呢，你看一开始已知$x$，我们要求$\\hat{x}=x \\cdot \\rho$，这个过程可以通过蒙哥马利乘法本身来计算，输入参数$x$和$\\rho^2$，计算结果就是$\\hat{x}=x \\cdot \\rho$。然后在最后，我们知道$\\hat{x}=x \\cdot \\rho$，要求得$x$的时候，同样可以通过蒙哥马利算法本身计算，输入参数$\\hat{x}$和$1$，计算结果就是$x$。有没有一种因就是果，果就是因的感觉，这就是为什么说蒙哥马利算法是一套很完美的算法。\n\n### 蒙哥马利幂模\n最后，才说到我们最开始提到的RSA的核心幂模运算，先来看一下普通幂运算的算法是怎么得出来的。  \n> 以下资料来自于百度百科[快速模幂运算](http://baike.baidu.com/link?url=0n8jO-kkk7g7ms-6H2UCJz0sW5BkTB-wEor4aXsmCQ8A3o1u9f5AuAfAiO-PD7R4V7wxzen1AxZpiUkcy7XS0a)\n> 针对快速模幂运算这一课题，西方现代数学家提出了大量的解决方案，通常都是先将幂模运算转化为乘模运算。\n例如求D=C^15%N\n由于：a\\*b % n = (a % n)\\*(b % n) % n\n所以令：\nC1 =C\\*C % N =C^2 % N\nC2 =C1\\*C % N =C^3 % N\nC3 =C2\\*C2 % N =C^6 % N\nC4 =C3\\*C % N =C^7 % N\nC5 =C4\\*C4 % N =C^14 % N\nC6 =C5\\*C % N =C^15 % N\n即：对于E=15的幂模运算可分解为6 个乘模运算，归纳分析以上方法可以发现：\n对于任意指数E，都可采用以下算法计算D=C\\*\\*E % N：\nD=1\nWHILE E>0\nIF E%2=0\nC=C\\*C % N\nE=E/2\nELSE\nD=D\\*C % N\nE=E-1\nRETURN D\n继续分析会发现，要知道E 何时能整除 2，并不需要反复进行减一或除二的操作，只需验证E 的二进制各位是0 还是1 就可以了，从左至右或从右至左验证都可以，从左至右会更简洁，\n设E=Sum\\[i=0 to n\\](E\\*2\\*\\*i)，0<=E<=1\n则：\nD=1\nFOR i=n TO 0\nD=D\\*D % N\nIF E=1\nD=D*C % N\nRETURN D这样，模幂运算就转化成了一系列的模乘运算。\n\n\n算法可以写成如下的形式\n![这里写图片描述](http://img.blog.csdn.net/20161008105957718)\n\n如果我们现在用蒙哥马利样式稍作改变，就可以变成如下的形式：  \n![这里写图片描述](http://img.blog.csdn.net/20161008110022926)\n\n以上就是蒙哥马利算法的全部，通过蒙哥马利算法中的约减运算，我们将大数运算中的模运算变成了移位操作，极大地提高了大数模乘的效率。\n\n但是在以上的算法，可以发现还有两个变量的计算方式不是很清楚，一个是$\\omega$，前面说过$\\omega =  -N^{-1} (mod N)$ ，其实在算法中，我们看到，$omega$仅仅被用来做$\\mod b$操作，所以事实上，我们只需要计算$\\mod b$即可。\n\n尽管N有可能是合数（因为两个素数的乘积不一定是素数），但通常N和$\\rho$（也就是N和b）是互质的，也就是说$N^{\\phi(b)}=1(mob\\  b)$(费马定理)，$N^{\\phi(b)-1}=N^{-1}(mob\\  b)$\n因为$b=2^\\omega$，所以$\\phi(b)=2^{(\\omega-1)}$，写成算法是这样的\n![这里写图片描述](http://img.blog.csdn.net/20161008110739777)\n\n还有一个参数是$\\rho^2$，还记得前面说过$\\rho$是怎么得出来吗，选定一个最小的$k$，使得$b^k>N$，我们还知道$N$在$b$进制下是$l_N$位，所以当$k=l_N$的时候肯定是符合要求。\n\n$b=2^{\\omega}$ 所以$\\rho=b^k=({2^{\\omega}})^k$ \n\n$\\rho^2={({2^w})^k)}^2=2^{2\\cdot k\\cdot \\omega}=2^{2\\cdot l_N\\cdot \\omega}$，算法如下\n\n![这里写图片描述](http://img.blog.csdn.net/20161008111748040)\n\n至此整个蒙哥马利算法就全部说完了。通过这个算法，我们可以实现快速幂模。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"蒙哥马利算法详解","published":1,"updated":"2024-06-14T09:25:33.681Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clxjsxtwc001glq6gseji55t1","content":"<p>这篇文章为大家梳理一下整个蒙哥马利算法的本质，蒙哥马利算法并不是一个独立的算法，而是三个相互独立又相互联系的算法集合，其中包括    </p>\n<ul>\n<li>蒙哥马利乘模，是用来计算$x\\cdot y\\ (mod\\ N)$</li>\n<li>蒙哥马利约减，是用来计算$t\\cdot \\rho^{-1}\\ (mod\\ N)$</li>\n<li>蒙哥马利幂模，是用来计算$x^y\\ (mod\\ N)$</li>\n</ul>\n<p>其中蒙哥马利幂乘是RSA加密算法的核心部分。</p>\n<h3 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h3><p>梳理几个概念，试想一个集合是整数模N之后得到的<br>$Z_N=\\left\\{0,1,2,\\cdots,N-1\\right\\}$</p>\n<p><em>注：N在base-b进制下有$l_N$位。  比如10进制和100进制，都属于base-10进制，因为$100=10^2$，所以b=10。在10进制下，667的$l_N=3$</em></p>\n<p>这样的集合叫做N的剩余类环，任何属于这个集合Z的x满足以下两个条件： </p>\n<ol>\n<li>正整数</li>\n<li>最大长度是$l_N$  </li>\n</ol>\n<p>这篇文章中讲到的蒙哥马利算法就是用来计算基于$Z_N$集合上的运算，简单讲一下原因，因为RSA是基于大数运算的，通常是1024bit或2018bit，而我们的计算机不可能存储完整的大数，因为占空间太大，而且也没必要。因此，这种基于大数运算的加密体系在计算的时候都是基于$Z_N$集合的，自然，蒙哥马利算法也是基于$Z_N$。</p>\n<p>在剩余类环上，有两种重要的运算，一类是简单运算，也就是加法和减法，另一类复杂运算，也就是乘法。我们比较熟悉的是自然数集上的运算，下面看下怎么从自然数集的运算演变成剩余类环上的运算。</p>\n<p>对于加法运算，如果计算$x\\pm y\\ (mod\\ N)$ ($0\\leqslant x,y&lt;N$)，试想自然数集上的 $x\\pm y$    </p>\n<p>$\\qquad 0\\leqslant x+y\\leqslant 2\\cdot(N-1)$  </p>\n<p>$-(N-1)\\leqslant x-y\\leqslant (N-1)$</p>\n<p>我们可以简单的通过加减N来实现从自然数到剩余类集的转换</p>\n<p>另外一类是乘法操作，也就是$x\\cdot y\\ (mod\\ N)$($0\\leqslant x,y&lt;N$)，那么  </p>\n<p>$0\\leqslant x\\cdot y\\leqslant (N-1)^2$  </p>\n<p>如果在自然数集下，令$t=x\\cdot y$，那么对于$\\mod N$我们需要计算 </p>\n<p>$t-（N\\cdot \\lfloor\\frac{t}{N}\\rfloor）$</p>\n<p>加减操作很简单，具体的算这里就不细说了，我们用$Z_N-ADD$ 来代表剩余类环上的加法操作。既然我们可以做加法操作，那么我们就可以扩展到乘法操作，算法如下</p>\n<p><img src=\"http://img.blog.csdn.net/20160930181528853\" alt=\"这里写图片描述\"></p>\n<p>但是这并不是一个好的解决方案，因为通常来说，我们不会直接做w位乘w位的操作，这个后面会用蒙哥马利的乘法来代替解决。</p>\n<p>对于取模操作，一般有以下几种方法</p>\n<p>1，根据以下公式，来计算取模操作</p>\n<p>$t-（N\\cdot \\lfloor\\frac{t}{N}\\rfloor）$</p>\n<p>这种解法有以下特征</p>\n<ul>\n<li>整个计算过程是基于标准的数字表示</li>\n<li>不需要预计算（也就是提前计算一些变量，以备使用）</li>\n<li>涉及到一个除法操作，非常费时和复杂</li>\n</ul>\n<p>2，用Barrett reduction算法，这篇文章不细说，但是有以下特征</p>\n<ul>\n<li>基于标准的数字表示</li>\n<li>不需要预计算</li>\n<li>需要$2 \\cdot (l_N+1) \\cdot (l_N+1)$ 次数乘运算</li>\n</ul>\n<p>3，用蒙哥马利约减，也就是下面要讲的算法，有以下特征  </p>\n<ul>\n<li>不是基于标准的数字表示（后文中有提到，是基于蒙哥马利表示法）</li>\n<li>需要预计算</li>\n<li>需要$2 \\cdot (l_N) \\cdot (l_N)$ 次数乘运算</li>\n</ul>\n<h3 id=\"蒙哥马利预备知识\"><a href=\"#蒙哥马利预备知识\" class=\"headerlink\" title=\"蒙哥马利预备知识\"></a>蒙哥马利预备知识</h3><p>在将蒙哥马利算法之前，先看一下在自然数下的乘法公式  </p>\n<p>计算$x\\cdot y$，想象一下我们常用的计算乘法的方法，用乘数的每一位乘上被乘数，然后把得到的结果相加，总结成公式，可以写成如下的形式。  </p>\n<p>$x\\cdot y=x\\cdot sum_{i=0}^{l_y-1}y_i \\cdot b^i$</p>\n<p>$\\qquad=sum_{i=0}^{l_y-1}y_i \\cdot x \\cdot b^i$  </p>\n<p>尝试下面一个例子，10进制下（也就是b=10），y=456（也就是$l_n=3$），计算$x\\cdot y$，公式可演变如下：  </p>\n<p>$x\\cdot y=(y_{0}\\cdot x\\cdot 10^{0})+(y_{1}\\cdot x\\cdot 10^{1})+(y_{2}\\cdot x\\cdot 10^{2})$<br>$\\qquad=(y_{0}\\cdot x\\cdot 0)+(y_{1}\\cdot x\\cdot 10)+(y_{2}\\cdot x\\cdot 100)$<br>$\\qquad=(y_{0}\\cdot x)+10\\cdot(y_{1}\\cdot x+10\\cdot(y_{2}\\cdot x\\cdot +10\\cdot(0)))$  </p>\n<p>最后一次演变其实就是用霍纳法则(Horner’s rule)所讲的规则，关于霍纳法则，可以自行百度。</p>\n<p>这个计算过程写成代码实现的算法应该是这样的：<br><img src=\"http://img.blog.csdn.net/20161008101121827\" alt=\"这里写图片描述\"></p>\n<p>接下来我们来看下面这样的计算，计算$(x\\cdot y)/1000$，由前面可以知道 </p>\n<p>$x\\cdot y=(y_{0}\\cdot x)+10\\cdot(y_{1}\\cdot x+10\\cdot(y_{2}\\cdot x\\cdot +10\\cdot(0)))$</p>\n<p>由此可以知道：</p>\n<p>$\\frac{x\\cdot y}{1000}=\\frac{(y_{0}\\cdot x\\cdot 10^{0})+(y_{1}\\cdot x\\cdot 10^{1})+(y_{2}\\cdot x\\cdot 10^{2})}{1000}$</p>\n<p>$\\qquad=\\frac{(y_{0}\\cdot x\\cdot 0)+(y_{1}\\cdot x\\cdot 10)+(y_{2}\\cdot x\\cdot 100)}{1000}$  </p>\n<p>$\\qquad=\\frac{(y_{0}\\cdot x)}{1000}+\\frac{(y_{1}\\cdot x)}{100}+\\frac{(y_{2}\\cdot x)}{10}$  </p>\n<p>$\\qquad=(((((y_0\\cdot x)/10)+y_1\\cdot x)/10)+y_2\\cdot x)/10$  </p>\n<p>这个计算过程写成代码实现的算法是这样的：<br><img src=\"http://img.blog.csdn.net/20161008101529067\" alt=\"这里写图片描述\"></p>\n<p>接下来我们再来看在剩余类集合下的乘法操作 $x\\cdot y/1000\\ (mod\\ 667)$  </p>\n<p>我们知道剩余类集合$Z_{667}=\\left\\{0,1 \\cdots 666\\right\\}$，是不存在小数的，而如果我们采用自然数集的计算方式的话，就会出现小数，比如前面的例子，除10就会有小数。  </p>\n<p>这个问题是这样的，我们知道$u·667 \\equiv 0 (mod 667)$（$\\equiv$表示取模相等），所以我们可以选择一个合适的u，用u乘667再加上r，使得和是一个可以除10没有小数，这样在mod 667之后依然是正确的结果。至于u怎么算出来，这篇文章会在后面的章节说明。</p>\n<p>这个过程之后$x\\cdot y/1000\\ (mod\\ 667)$  的计算算法可以写成如下的形式<br><img src=\"http://img.blog.csdn.net/20161008102045043\" alt=\"这里写图片描述\"></p>\n<p>至此，你可能还不明白上面说这一堆演变的原因，其实很简单，原来是一个$(x\\cdot y)\\ (mod\\ 667)$的运算，这个运算中的模操作，正常情况下是要通过除法实现的，而除法是一个特别复杂的运算，要涉及到很多乘法，所以在大数运算时，我们要尽量避免除法的出现。而通过以上几个步骤，我们发现$(x\\cdot y)/1000\\ (mod\\ 667)$这个操作是不用除法的。等等，算法中明明有个除10的操作，你骗谁呢。不知道你有没有发现，除数其实是我们的进制数，除进制数在计算机中是怎么做呢，其实很简单，左移操作就ok了。所以这个计算方法是不涉及到除法操作的。</p>\n<p>但是我们要计算的明明是$(x_1\\cdot y_1)\\ (mod\\ 667)$，怎么现在变成了$(x_2\\cdot y_2)/1000\\ (mod\\ 667)$，所以在下一步，我们要思考的是怎么样让$(x_1\\cdot y_1)\\ (mod\\ 667)$转变成$(x_2\\cdot y_2)/1000\\ (mod\\ 667)$这种形式。</p>\n<p>考虑这样两个算法  </p>\n<ul>\n<li>第一个是输入x和y，计算$x \\cdot y \\cdot \\rho^{-1}$</li>\n<li>第二个算法，输入一个t，计算$t \\cdot \\rho^{-1}$。</li>\n</ul>\n<p>$x\\cdot y\\ (mod\\ 667)=((x\\cdot1000)\\cdot(y\\cdot1000)/1000)/1000\\ (mod\\ 667)$</p>\n<p>是不是变成了我们需要的$(x\\cdot y)/1000\\ (mod\\ 667)$模式，而且这个转变过程是不是可以通过上面两个算法来实现，输入值如果是$(x\\cdot1000)$和$(y\\cdot1000)$，则通过第一个算法可以得到$((x\\cdot1000)\\cdot(y\\cdot1000)/1000)$，把结果作为第二个算法的输入值，则通过第二个算法可以得到$((x\\cdot1000)\\cdot(y\\cdot1000)/1000)/1000$。</p>\n<p>扯了一大顿，终于引出了今天文章的主角，前面讲到的两个算法，第一个就是蒙哥马利乘模，第二个就是蒙哥马利约减。下面我们来讲这两个算法的详解。</p>\n<p>正如前面提到的蒙哥马利算法的三个特性之一是，不是基于普通的整数表示法，而是基于蒙哥马利表示法。什么是蒙哥马利表示法呢，其实也很简单，上面我们提到，要让$(x_1\\cdot y_1)\\ (mod\\ 667)$转变成$(x_2\\cdot y_2)/1000\\ (mod\\ 667)$这种形式，我们需要将输入参数变成$(x\\cdot1000)$和$(y\\cdot1000)$，而不是x和y本身，而$(x\\cdot1000)$和$(y\\cdot1000)$ 其实就是蒙哥马利表示法。</p>\n<p>所以我们先定义几个概念：  </p>\n<ul>\n<li>蒙哥马利参数<br>给定一个N，N在b进制（例如，二进制时，b=2）下共有l位，$gcd(N,b)=1$，先预计算以下几个值(这就是前面提到的特性之一，需要预计算）：</li>\n</ul>\n<ul>\n<li><ul>\n<li>$\\rho = b^k$ 指定一个最小的k，使得$b^k&gt;N$  </li>\n</ul>\n</li>\n<li><ul>\n<li>$\\omega =  -N^{-1} (mod\\ \\rho)$<br>这两个参数是做什么用的呢，你对照前面的演变过程可以猜到$\\rho $ 就是前面演变中的1000，而$\\omega$ 则是用来计算前面提到的u的。</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>蒙哥马利表示法<br>对于x，$0\\leqslant x\\leqslant N-1$，x的蒙哥马利表示法表示为$x=x\\cdot \\rho\\ (mod\\ N)$</li>\n</ul>\n<h3 id=\"蒙哥马利约减\"><a href=\"#蒙哥马利约减\" class=\"headerlink\" title=\"蒙哥马利约减\"></a>蒙哥马利约减</h3><p>蒙哥马利约减的定义如下<br>给定一些整数t，蒙哥马利约减的计算结果是$t\\cdot \\rho^{-1}\\ (mod\\ N)$</p>\n<p>蒙哥马利约减的算法可表示为<br><img src=\"http://img.blog.csdn.net/20161008105605136\" alt=\"这里写图片描述\"></p>\n<p>蒙哥马利约减可以算作是下面要说的蒙哥马利模乘当$x=1$时的一种特殊形式，。同时它又是蒙哥马利乘模要用到的一部分，这在下一部分讲蒙哥马利乘模的时候有讲到。</p>\n<p>蒙哥马利约减可以用来计算某个值得取模操作，比如我们要计算$m(mod\\ N)$，只需要将m<br>的蒙哥马利表示法$m\\cdot \\rho$作为参数，带入蒙哥马利约减，则计算结果就是$m(mod\\ N)$。</p>\n<h3 id=\"蒙哥马利乘模\"><a href=\"#蒙哥马利乘模\" class=\"headerlink\" title=\"蒙哥马利乘模\"></a>蒙哥马利乘模</h3><p>一个蒙哥马利乘模包括整数乘法和蒙哥马利约减，现在我们有蒙哥马利表示法：  </p>\n<p>$ \\hat{x}=x\\cdot\\rho\\ (mod\\ N)$<br>$ \\hat{y}=y\\cdot\\rho\\ (mod\\ N)$  </p>\n<p>它们相乘的结果是  </p>\n<p>$t=\\hat{x}\\cdot\\hat{y}$<br>$\\ =(x\\cdot\\rho)\\cdot(y\\cdot\\rho)$<br>$\\ =(x\\cdot y)\\cdot\\rho^2$</p>\n<p>最后，用一次蒙哥马利约减得到结果</p>\n<p>$ \\hat{t}=(x \\cdot y) \\cdot \\rho\\ (mod\\ N)$</p>\n<p>上面我们可以看出，给出的输入参数是$ \\hat{x}$ 和$ \\hat{y}$， 得到的结果是$(x \\cdot y) \\cdot \\rho\\ (mod\\ N)$，所以蒙哥马利乘法也可以写成如下形式，已知输入参数x和y，蒙哥马利乘法是计算$(x \\cdot y) \\cdot \\rho ^ {-1}\\ (mod\\ N)$</p>\n<p>举个例子：<br>b=10，也就是说在10进制下，N=667<br>让$b^k&gt;N$的最小的k是3，所以$\\rho=b^k=10^3=1000$<br>$\\omega=-N^{-1}\\ (mod\\ \\rho)=-667^{-1}\\ (mod\\ \\rho)=997$</p>\n<p>因为$x=421$，所以$\\hat{x}=x\\cdot\\rho(mod\\ N)=421\\cdot1000(mod\\ 667)=123$<br>因为$y=422$，所以$\\hat{y}=y\\cdot\\rho(mod\\ N)=422\\cdot1000(mod\\ 667)=456$</p>\n<p>所以计算$\\hat{x}$和$\\hat{y}$蒙哥马利乘结果是 </p>\n<p>$\\hat{x}\\cdot\\hat{y}\\cdot\\rho^{-1}=(421\\cdot1000\\cdot422\\cdot1000)\\cdot1000^{-1}\\ (mod\\ 667)$<br>$\\qquad\\qquad(421\\cdot422)\\cdot1000\\ (mod\\ 667)$<br>$\\qquad\\qquad(240)\\cdot1000\\ (mod\\ 667)$<br>$\\qquad\\qquad547\\ (mod\\ 667)$</p>\n<p>然后总结一下蒙哥马利约减和蒙哥马利乘法的伪代码实现，这个算法其实就是从<a href=\"#蒙哥马利预备知识\">蒙哥马利预备知识</a>讲到的算法演变来的。<br><img src=\"http://img.blog.csdn.net/20161008105553673\" alt=\"这里写图片描述\"></p>\n<p>上面的例子用这个算法可以描述为<br><img src=\"http://img.blog.csdn.net/20161008130118944\" alt=\"这里写图片描述\"></p>\n<p>蒙哥马利算法是一套很完美的算法，为什么这么说呢，你看一开始已知$x$，我们要求$\\hat{x}=x \\cdot \\rho$，这个过程可以通过蒙哥马利乘法本身来计算，输入参数$x$和$\\rho^2$，计算结果就是$\\hat{x}=x \\cdot \\rho$。然后在最后，我们知道$\\hat{x}=x \\cdot \\rho$，要求得$x$的时候，同样可以通过蒙哥马利算法本身计算，输入参数$\\hat{x}$和$1$，计算结果就是$x$。有没有一种因就是果，果就是因的感觉，这就是为什么说蒙哥马利算法是一套很完美的算法。</p>\n<h3 id=\"蒙哥马利幂模\"><a href=\"#蒙哥马利幂模\" class=\"headerlink\" title=\"蒙哥马利幂模\"></a>蒙哥马利幂模</h3><p>最后，才说到我们最开始提到的RSA的核心幂模运算，先来看一下普通幂运算的算法是怎么得出来的。  </p>\n<blockquote>\n<p>以下资料来自于百度百科<a href=\"http://baike.baidu.com/link?url=0n8jO-kkk7g7ms-6H2UCJz0sW5BkTB-wEor4aXsmCQ8A3o1u9f5AuAfAiO-PD7R4V7wxzen1AxZpiUkcy7XS0a\" target=\"_blank\" rel=\"external\">快速模幂运算</a><br>针对快速模幂运算这一课题，西方现代数学家提出了大量的解决方案，通常都是先将幂模运算转化为乘模运算。<br>例如求D=C^15%N<br>由于：a*b % n = (a % n)*(b % n) % n<br>所以令：<br>C1 =C*C % N =C^2 % N<br>C2 =C1*C % N =C^3 % N<br>C3 =C2*C2 % N =C^6 % N<br>C4 =C3*C % N =C^7 % N<br>C5 =C4*C4 % N =C^14 % N<br>C6 =C5*C % N =C^15 % N<br>即：对于E=15的幂模运算可分解为6 个乘模运算，归纳分析以上方法可以发现：<br>对于任意指数E，都可采用以下算法计算D=C**E % N：<br>D=1<br>WHILE E&gt;0<br>IF E%2=0<br>C=C*C % N<br>E=E/2<br>ELSE<br>D=D*C % N<br>E=E-1<br>RETURN D<br>继续分析会发现，要知道E 何时能整除 2，并不需要反复进行减一或除二的操作，只需验证E 的二进制各位是0 还是1 就可以了，从左至右或从右至左验证都可以，从左至右会更简洁，<br>设E=Sum[i=0 to n](E*2**i)，0&lt;=E&lt;=1<br>则：<br>D=1<br>FOR i=n TO 0<br>D=D*D % N<br>IF E=1<br>D=D*C % N<br>RETURN D这样，模幂运算就转化成了一系列的模乘运算。</p>\n</blockquote>\n<p>算法可以写成如下的形式<br><img src=\"http://img.blog.csdn.net/20161008105957718\" alt=\"这里写图片描述\"></p>\n<p>如果我们现在用蒙哥马利样式稍作改变，就可以变成如下的形式：<br><img src=\"http://img.blog.csdn.net/20161008110022926\" alt=\"这里写图片描述\"></p>\n<p>以上就是蒙哥马利算法的全部，通过蒙哥马利算法中的约减运算，我们将大数运算中的模运算变成了移位操作，极大地提高了大数模乘的效率。</p>\n<p>但是在以上的算法，可以发现还有两个变量的计算方式不是很清楚，一个是$\\omega$，前面说过$\\omega =  -N^{-1} (mod N)$ ，其实在算法中，我们看到，$omega$仅仅被用来做$\\mod b$操作，所以事实上，我们只需要计算$\\mod b$即可。</p>\n<p>尽管N有可能是合数（因为两个素数的乘积不一定是素数），但通常N和$\\rho$（也就是N和b）是互质的，也就是说$N^{\\phi(b)}=1(mob\\  b)$(费马定理)，$N^{\\phi(b)-1}=N^{-1}(mob\\  b)$<br>因为$b=2^\\omega$，所以$\\phi(b)=2^{(\\omega-1)}$，写成算法是这样的<br><img src=\"http://img.blog.csdn.net/20161008110739777\" alt=\"这里写图片描述\"></p>\n<p>还有一个参数是$\\rho^2$，还记得前面说过$\\rho$是怎么得出来吗，选定一个最小的$k$，使得$b^k&gt;N$，我们还知道$N$在$b$进制下是$l_N$位，所以当$k=l_N$的时候肯定是符合要求。</p>\n<p>$b=2^{\\omega}$ 所以$\\rho=b^k=({2^{\\omega}})^k$ </p>\n<p>$\\rho^2={({2^w})^k)}^2=2^{2\\cdot k\\cdot \\omega}=2^{2\\cdot l_N\\cdot \\omega}$，算法如下</p>\n<p><img src=\"http://img.blog.csdn.net/20161008111748040\" alt=\"这里写图片描述\"></p>\n<p>至此整个蒙哥马利算法就全部说完了。通过这个算法，我们可以实现快速幂模。</p>\n","excerpt":"","more":"<p>这篇文章为大家梳理一下整个蒙哥马利算法的本质，蒙哥马利算法并不是一个独立的算法，而是三个相互独立又相互联系的算法集合，其中包括    </p>\n<ul>\n<li>蒙哥马利乘模，是用来计算$x\\cdot y\\ (mod\\ N)$</li>\n<li>蒙哥马利约减，是用来计算$t\\cdot \\rho^{-1}\\ (mod\\ N)$</li>\n<li>蒙哥马利幂模，是用来计算$x^y\\ (mod\\ N)$</li>\n</ul>\n<p>其中蒙哥马利幂乘是RSA加密算法的核心部分。</p>\n<h3 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h3><p>梳理几个概念，试想一个集合是整数模N之后得到的<br>$Z_N=\\left\\{0,1,2,\\cdots,N-1\\right\\}$</p>\n<p><em>注：N在base-b进制下有$l_N$位。  比如10进制和100进制，都属于base-10进制，因为$100=10^2$，所以b=10。在10进制下，667的$l_N=3$</em></p>\n<p>这样的集合叫做N的剩余类环，任何属于这个集合Z的x满足以下两个条件： </p>\n<ol>\n<li>正整数</li>\n<li>最大长度是$l_N$  </li>\n</ol>\n<p>这篇文章中讲到的蒙哥马利算法就是用来计算基于$Z_N$集合上的运算，简单讲一下原因，因为RSA是基于大数运算的，通常是1024bit或2018bit，而我们的计算机不可能存储完整的大数，因为占空间太大，而且也没必要。因此，这种基于大数运算的加密体系在计算的时候都是基于$Z_N$集合的，自然，蒙哥马利算法也是基于$Z_N$。</p>\n<p>在剩余类环上，有两种重要的运算，一类是简单运算，也就是加法和减法，另一类复杂运算，也就是乘法。我们比较熟悉的是自然数集上的运算，下面看下怎么从自然数集的运算演变成剩余类环上的运算。</p>\n<p>对于加法运算，如果计算$x\\pm y\\ (mod\\ N)$ ($0\\leqslant x,y&lt;N$)，试想自然数集上的 $x\\pm y$    </p>\n<p>$\\qquad 0\\leqslant x+y\\leqslant 2\\cdot(N-1)$  </p>\n<p>$-(N-1)\\leqslant x-y\\leqslant (N-1)$</p>\n<p>我们可以简单的通过加减N来实现从自然数到剩余类集的转换</p>\n<p>另外一类是乘法操作，也就是$x\\cdot y\\ (mod\\ N)$($0\\leqslant x,y&lt;N$)，那么  </p>\n<p>$0\\leqslant x\\cdot y\\leqslant (N-1)^2$  </p>\n<p>如果在自然数集下，令$t=x\\cdot y$，那么对于$\\mod N$我们需要计算 </p>\n<p>$t-（N\\cdot \\lfloor\\frac{t}{N}\\rfloor）$</p>\n<p>加减操作很简单，具体的算这里就不细说了，我们用$Z_N-ADD$ 来代表剩余类环上的加法操作。既然我们可以做加法操作，那么我们就可以扩展到乘法操作，算法如下</p>\n<p><img src=\"http://img.blog.csdn.net/20160930181528853\" alt=\"这里写图片描述\"></p>\n<p>但是这并不是一个好的解决方案，因为通常来说，我们不会直接做w位乘w位的操作，这个后面会用蒙哥马利的乘法来代替解决。</p>\n<p>对于取模操作，一般有以下几种方法</p>\n<p>1，根据以下公式，来计算取模操作</p>\n<p>$t-（N\\cdot \\lfloor\\frac{t}{N}\\rfloor）$</p>\n<p>这种解法有以下特征</p>\n<ul>\n<li>整个计算过程是基于标准的数字表示</li>\n<li>不需要预计算（也就是提前计算一些变量，以备使用）</li>\n<li>涉及到一个除法操作，非常费时和复杂</li>\n</ul>\n<p>2，用Barrett reduction算法，这篇文章不细说，但是有以下特征</p>\n<ul>\n<li>基于标准的数字表示</li>\n<li>不需要预计算</li>\n<li>需要$2 \\cdot (l_N+1) \\cdot (l_N+1)$ 次数乘运算</li>\n</ul>\n<p>3，用蒙哥马利约减，也就是下面要讲的算法，有以下特征  </p>\n<ul>\n<li>不是基于标准的数字表示（后文中有提到，是基于蒙哥马利表示法）</li>\n<li>需要预计算</li>\n<li>需要$2 \\cdot (l_N) \\cdot (l_N)$ 次数乘运算</li>\n</ul>\n<h3 id=\"蒙哥马利预备知识\"><a href=\"#蒙哥马利预备知识\" class=\"headerlink\" title=\"蒙哥马利预备知识\"></a>蒙哥马利预备知识</h3><p>在将蒙哥马利算法之前，先看一下在自然数下的乘法公式  </p>\n<p>计算$x\\cdot y$，想象一下我们常用的计算乘法的方法，用乘数的每一位乘上被乘数，然后把得到的结果相加，总结成公式，可以写成如下的形式。  </p>\n<p>$x\\cdot y=x\\cdot sum_{i=0}^{l_y-1}y_i \\cdot b^i$</p>\n<p>$\\qquad=sum_{i=0}^{l_y-1}y_i \\cdot x \\cdot b^i$  </p>\n<p>尝试下面一个例子，10进制下（也就是b=10），y=456（也就是$l_n=3$），计算$x\\cdot y$，公式可演变如下：  </p>\n<p>$x\\cdot y=(y_{0}\\cdot x\\cdot 10^{0})+(y_{1}\\cdot x\\cdot 10^{1})+(y_{2}\\cdot x\\cdot 10^{2})$<br>$\\qquad=(y_{0}\\cdot x\\cdot 0)+(y_{1}\\cdot x\\cdot 10)+(y_{2}\\cdot x\\cdot 100)$<br>$\\qquad=(y_{0}\\cdot x)+10\\cdot(y_{1}\\cdot x+10\\cdot(y_{2}\\cdot x\\cdot +10\\cdot(0)))$  </p>\n<p>最后一次演变其实就是用霍纳法则(Horner’s rule)所讲的规则，关于霍纳法则，可以自行百度。</p>\n<p>这个计算过程写成代码实现的算法应该是这样的：<br><img src=\"http://img.blog.csdn.net/20161008101121827\" alt=\"这里写图片描述\"></p>\n<p>接下来我们来看下面这样的计算，计算$(x\\cdot y)/1000$，由前面可以知道 </p>\n<p>$x\\cdot y=(y_{0}\\cdot x)+10\\cdot(y_{1}\\cdot x+10\\cdot(y_{2}\\cdot x\\cdot +10\\cdot(0)))$</p>\n<p>由此可以知道：</p>\n<p>$\\frac{x\\cdot y}{1000}=\\frac{(y_{0}\\cdot x\\cdot 10^{0})+(y_{1}\\cdot x\\cdot 10^{1})+(y_{2}\\cdot x\\cdot 10^{2})}{1000}$</p>\n<p>$\\qquad=\\frac{(y_{0}\\cdot x\\cdot 0)+(y_{1}\\cdot x\\cdot 10)+(y_{2}\\cdot x\\cdot 100)}{1000}$  </p>\n<p>$\\qquad=\\frac{(y_{0}\\cdot x)}{1000}+\\frac{(y_{1}\\cdot x)}{100}+\\frac{(y_{2}\\cdot x)}{10}$  </p>\n<p>$\\qquad=(((((y_0\\cdot x)/10)+y_1\\cdot x)/10)+y_2\\cdot x)/10$  </p>\n<p>这个计算过程写成代码实现的算法是这样的：<br><img src=\"http://img.blog.csdn.net/20161008101529067\" alt=\"这里写图片描述\"></p>\n<p>接下来我们再来看在剩余类集合下的乘法操作 $x\\cdot y/1000\\ (mod\\ 667)$  </p>\n<p>我们知道剩余类集合$Z_{667}=\\left\\{0,1 \\cdots 666\\right\\}$，是不存在小数的，而如果我们采用自然数集的计算方式的话，就会出现小数，比如前面的例子，除10就会有小数。  </p>\n<p>这个问题是这样的，我们知道$u·667 \\equiv 0 (mod 667)$（$\\equiv$表示取模相等），所以我们可以选择一个合适的u，用u乘667再加上r，使得和是一个可以除10没有小数，这样在mod 667之后依然是正确的结果。至于u怎么算出来，这篇文章会在后面的章节说明。</p>\n<p>这个过程之后$x\\cdot y/1000\\ (mod\\ 667)$  的计算算法可以写成如下的形式<br><img src=\"http://img.blog.csdn.net/20161008102045043\" alt=\"这里写图片描述\"></p>\n<p>至此，你可能还不明白上面说这一堆演变的原因，其实很简单，原来是一个$(x\\cdot y)\\ (mod\\ 667)$的运算，这个运算中的模操作，正常情况下是要通过除法实现的，而除法是一个特别复杂的运算，要涉及到很多乘法，所以在大数运算时，我们要尽量避免除法的出现。而通过以上几个步骤，我们发现$(x\\cdot y)/1000\\ (mod\\ 667)$这个操作是不用除法的。等等，算法中明明有个除10的操作，你骗谁呢。不知道你有没有发现，除数其实是我们的进制数，除进制数在计算机中是怎么做呢，其实很简单，左移操作就ok了。所以这个计算方法是不涉及到除法操作的。</p>\n<p>但是我们要计算的明明是$(x_1\\cdot y_1)\\ (mod\\ 667)$，怎么现在变成了$(x_2\\cdot y_2)/1000\\ (mod\\ 667)$，所以在下一步，我们要思考的是怎么样让$(x_1\\cdot y_1)\\ (mod\\ 667)$转变成$(x_2\\cdot y_2)/1000\\ (mod\\ 667)$这种形式。</p>\n<p>考虑这样两个算法  </p>\n<ul>\n<li>第一个是输入x和y，计算$x \\cdot y \\cdot \\rho^{-1}$</li>\n<li>第二个算法，输入一个t，计算$t \\cdot \\rho^{-1}$。</li>\n</ul>\n<p>$x\\cdot y\\ (mod\\ 667)=((x\\cdot1000)\\cdot(y\\cdot1000)/1000)/1000\\ (mod\\ 667)$</p>\n<p>是不是变成了我们需要的$(x\\cdot y)/1000\\ (mod\\ 667)$模式，而且这个转变过程是不是可以通过上面两个算法来实现，输入值如果是$(x\\cdot1000)$和$(y\\cdot1000)$，则通过第一个算法可以得到$((x\\cdot1000)\\cdot(y\\cdot1000)/1000)$，把结果作为第二个算法的输入值，则通过第二个算法可以得到$((x\\cdot1000)\\cdot(y\\cdot1000)/1000)/1000$。</p>\n<p>扯了一大顿，终于引出了今天文章的主角，前面讲到的两个算法，第一个就是蒙哥马利乘模，第二个就是蒙哥马利约减。下面我们来讲这两个算法的详解。</p>\n<p>正如前面提到的蒙哥马利算法的三个特性之一是，不是基于普通的整数表示法，而是基于蒙哥马利表示法。什么是蒙哥马利表示法呢，其实也很简单，上面我们提到，要让$(x_1\\cdot y_1)\\ (mod\\ 667)$转变成$(x_2\\cdot y_2)/1000\\ (mod\\ 667)$这种形式，我们需要将输入参数变成$(x\\cdot1000)$和$(y\\cdot1000)$，而不是x和y本身，而$(x\\cdot1000)$和$(y\\cdot1000)$ 其实就是蒙哥马利表示法。</p>\n<p>所以我们先定义几个概念：  </p>\n<ul>\n<li>蒙哥马利参数<br>给定一个N，N在b进制（例如，二进制时，b=2）下共有l位，$gcd(N,b)=1$，先预计算以下几个值(这就是前面提到的特性之一，需要预计算）：</li>\n</ul>\n<ul>\n<li><ul>\n<li>$\\rho = b^k$ 指定一个最小的k，使得$b^k&gt;N$  </li>\n</ul>\n</li>\n<li><ul>\n<li>$\\omega =  -N^{-1} (mod\\ \\rho)$<br>这两个参数是做什么用的呢，你对照前面的演变过程可以猜到$\\rho $ 就是前面演变中的1000，而$\\omega$ 则是用来计算前面提到的u的。</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>蒙哥马利表示法<br>对于x，$0\\leqslant x\\leqslant N-1$，x的蒙哥马利表示法表示为$x=x\\cdot \\rho\\ (mod\\ N)$</li>\n</ul>\n<h3 id=\"蒙哥马利约减\"><a href=\"#蒙哥马利约减\" class=\"headerlink\" title=\"蒙哥马利约减\"></a>蒙哥马利约减</h3><p>蒙哥马利约减的定义如下<br>给定一些整数t，蒙哥马利约减的计算结果是$t\\cdot \\rho^{-1}\\ (mod\\ N)$</p>\n<p>蒙哥马利约减的算法可表示为<br><img src=\"http://img.blog.csdn.net/20161008105605136\" alt=\"这里写图片描述\"></p>\n<p>蒙哥马利约减可以算作是下面要说的蒙哥马利模乘当$x=1$时的一种特殊形式，。同时它又是蒙哥马利乘模要用到的一部分，这在下一部分讲蒙哥马利乘模的时候有讲到。</p>\n<p>蒙哥马利约减可以用来计算某个值得取模操作，比如我们要计算$m(mod\\ N)$，只需要将m<br>的蒙哥马利表示法$m\\cdot \\rho$作为参数，带入蒙哥马利约减，则计算结果就是$m(mod\\ N)$。</p>\n<h3 id=\"蒙哥马利乘模\"><a href=\"#蒙哥马利乘模\" class=\"headerlink\" title=\"蒙哥马利乘模\"></a>蒙哥马利乘模</h3><p>一个蒙哥马利乘模包括整数乘法和蒙哥马利约减，现在我们有蒙哥马利表示法：  </p>\n<p>$ \\hat{x}=x\\cdot\\rho\\ (mod\\ N)$<br>$ \\hat{y}=y\\cdot\\rho\\ (mod\\ N)$  </p>\n<p>它们相乘的结果是  </p>\n<p>$t=\\hat{x}\\cdot\\hat{y}$<br>$\\ =(x\\cdot\\rho)\\cdot(y\\cdot\\rho)$<br>$\\ =(x\\cdot y)\\cdot\\rho^2$</p>\n<p>最后，用一次蒙哥马利约减得到结果</p>\n<p>$ \\hat{t}=(x \\cdot y) \\cdot \\rho\\ (mod\\ N)$</p>\n<p>上面我们可以看出，给出的输入参数是$ \\hat{x}$ 和$ \\hat{y}$， 得到的结果是$(x \\cdot y) \\cdot \\rho\\ (mod\\ N)$，所以蒙哥马利乘法也可以写成如下形式，已知输入参数x和y，蒙哥马利乘法是计算$(x \\cdot y) \\cdot \\rho ^ {-1}\\ (mod\\ N)$</p>\n<p>举个例子：<br>b=10，也就是说在10进制下，N=667<br>让$b^k&gt;N$的最小的k是3，所以$\\rho=b^k=10^3=1000$<br>$\\omega=-N^{-1}\\ (mod\\ \\rho)=-667^{-1}\\ (mod\\ \\rho)=997$</p>\n<p>因为$x=421$，所以$\\hat{x}=x\\cdot\\rho(mod\\ N)=421\\cdot1000(mod\\ 667)=123$<br>因为$y=422$，所以$\\hat{y}=y\\cdot\\rho(mod\\ N)=422\\cdot1000(mod\\ 667)=456$</p>\n<p>所以计算$\\hat{x}$和$\\hat{y}$蒙哥马利乘结果是 </p>\n<p>$\\hat{x}\\cdot\\hat{y}\\cdot\\rho^{-1}=(421\\cdot1000\\cdot422\\cdot1000)\\cdot1000^{-1}\\ (mod\\ 667)$<br>$\\qquad\\qquad(421\\cdot422)\\cdot1000\\ (mod\\ 667)$<br>$\\qquad\\qquad(240)\\cdot1000\\ (mod\\ 667)$<br>$\\qquad\\qquad547\\ (mod\\ 667)$</p>\n<p>然后总结一下蒙哥马利约减和蒙哥马利乘法的伪代码实现，这个算法其实就是从<a href=\"#蒙哥马利预备知识\">蒙哥马利预备知识</a>讲到的算法演变来的。<br><img src=\"http://img.blog.csdn.net/20161008105553673\" alt=\"这里写图片描述\"></p>\n<p>上面的例子用这个算法可以描述为<br><img src=\"http://img.blog.csdn.net/20161008130118944\" alt=\"这里写图片描述\"></p>\n<p>蒙哥马利算法是一套很完美的算法，为什么这么说呢，你看一开始已知$x$，我们要求$\\hat{x}=x \\cdot \\rho$，这个过程可以通过蒙哥马利乘法本身来计算，输入参数$x$和$\\rho^2$，计算结果就是$\\hat{x}=x \\cdot \\rho$。然后在最后，我们知道$\\hat{x}=x \\cdot \\rho$，要求得$x$的时候，同样可以通过蒙哥马利算法本身计算，输入参数$\\hat{x}$和$1$，计算结果就是$x$。有没有一种因就是果，果就是因的感觉，这就是为什么说蒙哥马利算法是一套很完美的算法。</p>\n<h3 id=\"蒙哥马利幂模\"><a href=\"#蒙哥马利幂模\" class=\"headerlink\" title=\"蒙哥马利幂模\"></a>蒙哥马利幂模</h3><p>最后，才说到我们最开始提到的RSA的核心幂模运算，先来看一下普通幂运算的算法是怎么得出来的。  </p>\n<blockquote>\n<p>以下资料来自于百度百科<a href=\"http://baike.baidu.com/link?url=0n8jO-kkk7g7ms-6H2UCJz0sW5BkTB-wEor4aXsmCQ8A3o1u9f5AuAfAiO-PD7R4V7wxzen1AxZpiUkcy7XS0a\">快速模幂运算</a><br>针对快速模幂运算这一课题，西方现代数学家提出了大量的解决方案，通常都是先将幂模运算转化为乘模运算。<br>例如求D=C^15%N<br>由于：a*b % n = (a % n)*(b % n) % n<br>所以令：<br>C1 =C*C % N =C^2 % N<br>C2 =C1*C % N =C^3 % N<br>C3 =C2*C2 % N =C^6 % N<br>C4 =C3*C % N =C^7 % N<br>C5 =C4*C4 % N =C^14 % N<br>C6 =C5*C % N =C^15 % N<br>即：对于E=15的幂模运算可分解为6 个乘模运算，归纳分析以上方法可以发现：<br>对于任意指数E，都可采用以下算法计算D=C**E % N：<br>D=1<br>WHILE E&gt;0<br>IF E%2=0<br>C=C*C % N<br>E=E/2<br>ELSE<br>D=D*C % N<br>E=E-1<br>RETURN D<br>继续分析会发现，要知道E 何时能整除 2，并不需要反复进行减一或除二的操作，只需验证E 的二进制各位是0 还是1 就可以了，从左至右或从右至左验证都可以，从左至右会更简洁，<br>设E=Sum[i=0 to n](E*2**i)，0&lt;=E&lt;=1<br>则：<br>D=1<br>FOR i=n TO 0<br>D=D*D % N<br>IF E=1<br>D=D*C % N<br>RETURN D这样，模幂运算就转化成了一系列的模乘运算。</p>\n</blockquote>\n<p>算法可以写成如下的形式<br><img src=\"http://img.blog.csdn.net/20161008105957718\" alt=\"这里写图片描述\"></p>\n<p>如果我们现在用蒙哥马利样式稍作改变，就可以变成如下的形式：<br><img src=\"http://img.blog.csdn.net/20161008110022926\" alt=\"这里写图片描述\"></p>\n<p>以上就是蒙哥马利算法的全部，通过蒙哥马利算法中的约减运算，我们将大数运算中的模运算变成了移位操作，极大地提高了大数模乘的效率。</p>\n<p>但是在以上的算法，可以发现还有两个变量的计算方式不是很清楚，一个是$\\omega$，前面说过$\\omega =  -N^{-1} (mod N)$ ，其实在算法中，我们看到，$omega$仅仅被用来做$\\mod b$操作，所以事实上，我们只需要计算$\\mod b$即可。</p>\n<p>尽管N有可能是合数（因为两个素数的乘积不一定是素数），但通常N和$\\rho$（也就是N和b）是互质的，也就是说$N^{\\phi(b)}=1(mob\\  b)$(费马定理)，$N^{\\phi(b)-1}=N^{-1}(mob\\  b)$<br>因为$b=2^\\omega$，所以$\\phi(b)=2^{(\\omega-1)}$，写成算法是这样的<br><img src=\"http://img.blog.csdn.net/20161008110739777\" alt=\"这里写图片描述\"></p>\n<p>还有一个参数是$\\rho^2$，还记得前面说过$\\rho$是怎么得出来吗，选定一个最小的$k$，使得$b^k&gt;N$，我们还知道$N$在$b$进制下是$l_N$位，所以当$k=l_N$的时候肯定是符合要求。</p>\n<p>$b=2^{\\omega}$ 所以$\\rho=b^k=({2^{\\omega}})^k$ </p>\n<p>$\\rho^2={({2^w})^k)}^2=2^{2\\cdot k\\cdot \\omega}=2^{2\\cdot l_N\\cdot \\omega}$，算法如下</p>\n<p><img src=\"http://img.blog.csdn.net/20161008111748040\" alt=\"这里写图片描述\"></p>\n<p>至此整个蒙哥马利算法就全部说完了。通过这个算法，我们可以实现快速幂模。</p>\n"},{"title":"记一次android程序反编译并二次打包的过程","date":"2016-09-15T15:40:24.000Z","_content":"\n在安全界有一句话叫不懂攻，焉知防。\n\n前几天看到有一个问题在问Android端目前防止二次打包的方法有哪些？我想从攻击的角度来说这个问题。在分析过程中讲解每一步都有哪些防范手段。下面以一个市面上大公司的app为例，讲一下我是怎么绕过它的防范机制，修改代码（弹出一个提示框），并进行二次打包，重新签名，运行的。在写这篇文的过程中，我也遇到了一些问题，我在文章的最后进行了整理提问，希望这方面经验丰富的开发者可以一起交流。\n\n另外，绕过程序的防二次打包机制毕竟不是一件好事，搞不好做这个程序的程序员要背锅，所以文章中代码都是以图片形式给出，关键识别位置都打了马赛克，但是我想一些有心人还是可以看出这是什么程序，你看出来就看出来吧，就不要说出来了，好吗。\n\n### Contents\n- [Contents](#Contents)\n- [用ApkTool反编译android程序](#用ApkTool反编译android程序)\n- [用dex2jar反编译出java源代码](#用dex2jar反编译出java源代码)\n- [用gui查看代码](#用gui查看代码)\n- [重新打包，签名，运行](#重新打包，签名，运行)\n- [绕过程序防二次打包机制](#绕过程序防二次打包机制)\n\n好，以下是正文\n\n\n工欲善其事，必先利其器。首先准备好工具：\n\n\n反编译工具\n\n\n- apktool 反编译利器\n\n- dex2jar 将dex文件反编译成jar文件（Java代码）工具，用于解读代码\n\n- gui 打开jar文件工具\n\n\n签名工具\n\n\n- apksign给java程序签名的工具\n\n- testkey.pk8 teskkey.x509.pem用于签名的文件\n\n\n首先下载好apk\n\n![](http://img.blog.csdn.net/20160921161047823?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n### 用ApkTool反编译android程序\n用apktool反编译，命令如下\n\n![](http://img.blog.csdn.net/20160921161101489?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n![](http://img.blog.csdn.net/20160921161115411?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n成功后会在同级目录生成一个test文件夹\n\n![](http://img.blog.csdn.net/20160921161129224?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n这就是反编译之后的Android程序了，可以看出，这个目录结构跟我们编写android代码时的目录结构非常相似，除了java代码是以smali的格式呈现之外，其他都基本是原来的代码。其实有很多人抄界面，到这一步就可以抄出完整的界面了。如manifest文件，里面的Activity定义都可以看的很清楚了。然后layout文件，各种res都可以看见了。\n\n![](http://img.blog.csdn.net/20160921161150230?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n其实写到这，我就有个问题了，这一步怎么防？我不知道，愿请教一二。\n\n\n如果我们要参考（chao）一个程序的界面，到这一步已经够了，以为所有的res和layout文件已经能看到了。\n\n\n改代码重新编译也是要在这个文件夹中改smali文件的，所以smali的语法还是要熟悉一点。但是看代码逻辑我们不用去看晦涩难懂的smali语言，这就是下一步要做的工作。反编译出java代码。\n\n\n### 用dex2jar反编译出java源代码\n\n\n第一步做的工作先放在这，我们需要重新操作apk文件，其实apk文件就是一种压缩包，所以我们把后缀名改成rar，用解压缩工具打开。\n\n![](http://img.blog.csdn.net/20160921161216340?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n看到这里，有人会问，为什么不直接解压缩，跟我们刚才用apktool反编译出来的不一样吗，你可以试一下。\n\n\n这里其他文件在apktool那一步已经反编译出来了，我们需要的仅仅是class文件，这是java代码编译后生成的文件，用dex2jar这个工具就可以反编译出原代码（java格式）了。把这个class文件解压出来，放在dex2jar的同级目录下。\n\n![](http://img.blog.csdn.net/20160921161229402?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n命令如上，成功之后就会在同级目录下生成jar文件了。\n\n### 用gui查看代码\n\n\n还记得一开始我们说过的工具gui，通过gui打开jar文件，就能看到java代码了\n\n![](http://img.blog.csdn.net/20160921161255262?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n这里所有的引入的包代码都会有，那么怎么寻找我们要的主程序代码呢，这就要依赖在第一步我们反编译出的manifest文件，熟悉android的朋友知道，在manifest文件中有两个信息比较重要。\n\n\n一是包名，也就是主程序的路径，在manifest的最开始一行。\n\n![](http://img.blog.csdn.net/20160921161314773?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n第二个信息是入口activity，这个很简单，只要找到有launcher标识的activity就是入口activity。\n\n![](http://img.blog.csdn.net/20160921161330367?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n现在你就可以去gui里面找到这个入口类了\n\n![](http://img.blog.csdn.net/20160921161344809?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n代码有混淆，但是混淆只是替换了一些变量名或者类名而已，增加了代码阅读的困难性，并不会修改程序逻辑本身，所以只要静下心来慢慢看，还是看到懂得。\n\n\n至此，反编译的过程就结束了，你想看到一个程序的逻辑或者一个程序的界面逻辑都可以看的到的。\n\n\n### 重新打包，签名，运行\n\n\n下面，开始进行最重要的工作，修改代码，二次打包。其实这里你可以什么代码先都别改，只重新打包一次，看看程序是否能够正常运行，如果不能，看看程序是哪一步阻止了运行，这也方便你后期定位签名验证的位置。目前我见过的签名验证有以下几种：\n\n- 直接抛出异常，禁止运行\n- 弹出提示框提示用户，提示框消失后，退出程序\n- 跟服务器交互传递签名信息，如果不正确则服务器不返回数据\n\n重新打包是这样的，还要用到apktool，记得在第一步反编译出的那个文件夹吗，就是用这些文件再重新打包。打包命令如下：\n\n![](http://img.blog.csdn.net/20160921161400247?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n成功后，在同级目录下会看到test1.apk文件，这里只是打包成功了，程序还没有签名，没有签名的程序是无法安装到手机上的。签名用的的是apksign这个工具，这是java提供给开发者用于程序签名的工具，android的各类IDE也是用这个工具在签名。使用方法如下，将signapk.jar，testkey.pk8，testkey.x509.pem放在一个目录下，写一个signapk.bat文件，如下\n\n```java\njava -jar signapk.jar testkey.x509.pem testkey.pk8 %1 %2\n```\n\n然后运行命令\n\n![](http://img.blog.csdn.net/20160921161418934?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n成功后会在同级目录下生成一个签过名的apk文件，这个文件我们需要的最终文件，只要你改过代码并且签完名后这个apk可以正常安装运行，那么本次的任务就算完成了。现在安装一下，看看会发生什么。\n\n\n程序启动，然后弹出提示框\n\n![](http://img.blog.csdn.net/20160921161435809?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n程序弹出提示，点击确认后退出程序，看来这个app的签名验证是用了我说的上面第二种方法，下面来进行一些尝试来绕过这个签名验证。\n\n\n### 绕过程序防二次打包机制\n\n首先，我建议大家先全局搜一下signatures这个字符串，因为程序要获取app的签名就要通过packageInfo.signatures这种方式，如果在这里我们不让程序获取到真正的签名，而是直接返回给它那个“正确”的签名，岂不是瞒天过海，一步搞定。当然了，你必须要有原来那个程序的“正确”签名，不过这个简单，android系统并不阻止你去获取其他程序的签名，所以我们可以写个小的test程序，然后安装原来的apk，去获取一次正确的签名，记录下来。\n\n\n获取其他程序签名代码如下\n\n\n```java\nprivate static String getSignture(Application paramApplication) {\n    try {\n        String packageName = \"packageName\";\n        List<PackageInfo> packages = paramApplication.getPackageManager().getInstalledPackages(PackageManager.GET_SIGNATURES);\n        for (PackageInfo packageInfo : packages) {\n            Signature[] signs = packageInfo.signatures;\n            Signature sign = signs[0];\n            String signString = sign.toCharsString();\n            System.out.println(signString);\n            return signString;\n        }\n    } catch (Exception e) {\n        return \"\";\n    }\n    return \"\";\n}\n```\n\n先装上原来从正常渠道下载的程序，然后改一下包名，运行这个程序，就能得到正确程序的正确签名了，记录一下签名，然后去我们反编译的代码里面找signatures相关的代码，看在哪里获取了签名并验证。\n\n![](http://img.blog.csdn.net/20160921161456325?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n\n程序中一共有三个地方，MainActivity里是程序用到的，另外两个是第三方库的签名校验，像微信支付这种第三方库都会校验签名，这个可以暂时不管，所以要管的其实就只有MainActivity里这个了，看这个方法：\n\n![](http://img.blog.csdn.net/20160921161518935?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n是不是跟我写的那个方法完全一样，这个方法其实是获取程序的本来的签名的，这就好说了，我们直接返回刚才记录的“正确”签名就可以瞒过程序了。\n\n\n好，第一次尝试，去apktool反编译出的文件中的smali文件夹下找到这个类MainActivity，如下\n\n![](http://img.blog.csdn.net/20160921161536778?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n这是smali的语法，挺复杂的，感兴趣的朋友可以自己再翻阅一下资料。这里我们把这个方法全部注掉，直接返回“正确”的签名。如下\n\n![](http://img.blog.csdn.net/20160921161552497?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n按照前面说的签名的方法，重新打包，签名，安装。\n\n我们会发现，程序第一次进入是不行的，还是会提示，签名验证失败，第二次之后就可以正常进入了，这不是我们要的完美效果，思考一下，为什么会有这个情况，我想到以下几种原因：\n\n\n- 第一次的时候signinfo还没有获取，为空，所以认为是非法的\n- 除了这里，程序在另外的地方做了二次验证，而且这个二次验证并不一定每次都能执行成功，这个很像是一个网络请求方法，跟服务器做验证，所以根据网络情况，并不一定每次都成功。\n\n如果是第一种情况，为什么正常的程序没有问题，我们就只是让返回值变了一下，其他并没有改变逻辑。我推测是时间差，因为原来的方法执行获取签名需要较长的时间，而直接返回正确签名很快，难道是这个时间差的影响？我决定把原来那个方法改回来，只修改返回值。如下：\n\n![](http://img.blog.csdn.net/20160921161607810?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n只修改返回值，原来的逻辑不变，时间差应该也排除了，重新打包签名运行。好吧，很明显不是，而且情况更严重了，前面这些只是我的经验之谈，你在完全不了解逻辑的情况下，可以这样先试一下，我想能绕过30%的app吧。如果是上面说的第二种情况，我们还是来看一下代码逻辑吧。\n\n\n全局搜一下应用签名验证失败这句话，看看什么情况下会触发。\n\n![](http://img.blog.csdn.net/20160921161636309?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n一共有两处，我们先看第一处\n\n\n\n其实混淆后的代码挺恶心的，你看这个逻辑好像是如果LoginActivity的c方法为null就执行，但是你去看c方法就会发现根本就没有返回值，稳稳的null。这里代码其实是这样看的，要跳出前面那个while，所以我们去loginActivity找what值是19的情况。\n\n![](http://img.blog.csdn.net/20160921161648325?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n往前看，可以发现他调用了一个方法\n\n![](http://img.blog.csdn.net/20160921161703341?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n看来验证应该是在这里了，而且是一个网络请求验证，所以这个app的防二次打包的机制已经做的比较好的。研究下这个方法，混淆代码不是很容易看，我先用抓包工具抓了一下包。\n\n\n发现程序在启动的时候发了两个用来验证的请求，第一个请求没有参数，服务器返回如下字段\n\n![](http://img.blog.csdn.net/20160921161725810?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n第二次请求带有如下参数\n\n![](http://img.blog.csdn.net/20160921161740217?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n正常的包服务器返回的是status=1，而我重新打包后服务器返回的是status=0\n\n\n这是一种典型的challenge-response的方法，服务器发来challenge，然后程序用自身特性的一个字符串加密后再返回response，如果正确，则通过验证，反之则阻止运行。\n\n\n这里我想的是，我找的加密challenge的那一段算法，看他是用什么方式加密的，用的是程序的哪一段特征值，然后像前面改签名一样，用“正确”的特征值替换下。\n\n\n但是，恕我愚钝，看不懂代码，这里我贴一下逻辑，有大神对混淆比较了解的可以跟我交流下。\n\n![](http://img.blog.csdn.net/20160921161756327?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n\n首先loginActivity调了这个Post请求，第一次调用参数为空，服务器会返回challenge 四个字符串\n\n![](http://img.blog.csdn.net/20160921161811139?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n程序会把这四个字符串交给一个handler处理\n\n![](http://img.blog.csdn.net/20160921161825717?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n抱歉我追到这就追不下去了，因为中间这几个不管a还是b都因为混淆无法直接找到，我也没想出什么能间接找到的方法。\n\n\n是不是到这就束手无策了呢，其实也不是，前面的分析是希望在最上游解决问题，如果我们能在最上游把问题解决了，下面不管什么逻辑都不用担心了，但是现在最上游无解了，那么我们就往下找一找，前面说过， 签名验证失败弹框是在服务器返回后根据服务器返回信息来判断的，那么我们可以把判断的逻辑改掉。\n\n![](http://img.blog.csdn.net/20160921161841515?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n将这个代码改成永true\n\n我们去smali找到LoginActivity里的f类，smali编译时会把所有的内部类编成一个单独的文件，所有我们去找LoginActivity$f这个文件\n\n![](http://img.blog.csdn.net/20160921161855921?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n\n这段代码是比较status和1，如果为0则跳到cond_2，cond_2就是会给message19的那部分代码，这里我们不让他跳转，所以删掉这一句即可。另外MainActivity里也有一个同样的校验，一起改掉就行了。\n\n\n现在打包，签名，运行\n\n程序正常启动，没有弹出任何异常提醒，试试其他功能，都正常。既然签名验证我们搞定，现在往里面加一句弹toast的代码，轻而易举，我准备加在MainActivity的onCreate的时候，找到这部分代码。\n\n![](http://img.blog.csdn.net/20160921161910031?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n\n注意要加在super.onCreate之后。弹框代码如下\n\n![](http://img.blog.csdn.net/20160921161924110?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n加完代码之后如下\n\n\n打包，签名，运行\n\n![](http://img.blog.csdn.net/20160921161953186?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n效果如上，至此，这篇文章就结束了，我们绕过了这个app的防二次打包机制，并成功的修改了代码。\n\n总结一下\n\n1， 混淆确实是有用处的，虽然混淆后的逻辑仍然可以看懂，但是如果你想去追踪一些细节逻辑，很难，当然，我混淆代码研究的太少，经验太少也是一个方面。\n\n2， App层面上的签名验证基本是无效的的，比如一开始我们说的getSignature这里。\n\n3， 采用challenge-response的方式跟服务器验证，如果使用不恰当，基本也是完全无效的，比如该应用，成功与否只判断服务器返回的一个字符串，而且判断语句是在本地，这个完全是可以绕过的。\n\n至于更好的方法，我查资料的时候，网上看到这样一个方法，同样是跟服务器验证，但是服务器不是返回一个字段，而是返回一段核心代码，然后程序动态执行这段核心代码。我觉得采用这种方法，难度会上升一个层级。但还是无法有效避免二次打包。\n\n[点击打开链接](https://link.zhihu.com/?target=http%3A//bbs.pediy.com/showthread.php%3Ft%3D180655)\n\n几个问题：\n\n\n1， 跟服务器验证的时候，验证的是什么东西，前面讲了因为那段代码没跟出来，所以不知道实现逻辑。以我的经验，二次打包唯一变动的应该就是签名了，但是签名我们已经绕过去了，不知道还有什么可以拿来验证的东西。\n\n\n2， Android资源层面的东西有没有防反编译的方法，我是说res，layout这些。\n\n\n\n\n\nok，洋洋洒洒的终于写完了，我是觉得自己写得已经很详细了，已经到了读者完全可以复制过程的程度。但难免有一些地方我觉得可以省略，但是读者不懂，可以在评论区提问，我会回答的。\n\n\n\n\n另外，再次强调一下，绕过程序的防二次打包机制毕竟不是一件好事，搞不好做这个程序的程序员要背锅，所以文章中代码都是以图片形式给出，关键识别位置都打了马赛克，但是我想一些有心人还是可以看出这是什么程序，你看出来就看出来吧，就不要说出来了，好吗。\n\n\n\n如果这样还有任何侵犯到开发方权利的地方，开发方可以向我提出，我换个程序继续搞，哈哈，开玩笑，我会和你们协商如果处理的。\n","source":"_posts/记一次android程序反编译并二次打包的过程v2.md","raw":"---\ntitle: 记一次android程序反编译并二次打包的过程\ndate: 2016-09-15 23:40:24\ntags:\n  - Android\n  - 移动安全\n  - 逆向\ncategories: Android\n---\n\n在安全界有一句话叫不懂攻，焉知防。\n\n前几天看到有一个问题在问Android端目前防止二次打包的方法有哪些？我想从攻击的角度来说这个问题。在分析过程中讲解每一步都有哪些防范手段。下面以一个市面上大公司的app为例，讲一下我是怎么绕过它的防范机制，修改代码（弹出一个提示框），并进行二次打包，重新签名，运行的。在写这篇文的过程中，我也遇到了一些问题，我在文章的最后进行了整理提问，希望这方面经验丰富的开发者可以一起交流。\n\n另外，绕过程序的防二次打包机制毕竟不是一件好事，搞不好做这个程序的程序员要背锅，所以文章中代码都是以图片形式给出，关键识别位置都打了马赛克，但是我想一些有心人还是可以看出这是什么程序，你看出来就看出来吧，就不要说出来了，好吗。\n\n### Contents\n- [Contents](#Contents)\n- [用ApkTool反编译android程序](#用ApkTool反编译android程序)\n- [用dex2jar反编译出java源代码](#用dex2jar反编译出java源代码)\n- [用gui查看代码](#用gui查看代码)\n- [重新打包，签名，运行](#重新打包，签名，运行)\n- [绕过程序防二次打包机制](#绕过程序防二次打包机制)\n\n好，以下是正文\n\n\n工欲善其事，必先利其器。首先准备好工具：\n\n\n反编译工具\n\n\n- apktool 反编译利器\n\n- dex2jar 将dex文件反编译成jar文件（Java代码）工具，用于解读代码\n\n- gui 打开jar文件工具\n\n\n签名工具\n\n\n- apksign给java程序签名的工具\n\n- testkey.pk8 teskkey.x509.pem用于签名的文件\n\n\n首先下载好apk\n\n![](http://img.blog.csdn.net/20160921161047823?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n### 用ApkTool反编译android程序\n用apktool反编译，命令如下\n\n![](http://img.blog.csdn.net/20160921161101489?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n![](http://img.blog.csdn.net/20160921161115411?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n成功后会在同级目录生成一个test文件夹\n\n![](http://img.blog.csdn.net/20160921161129224?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n这就是反编译之后的Android程序了，可以看出，这个目录结构跟我们编写android代码时的目录结构非常相似，除了java代码是以smali的格式呈现之外，其他都基本是原来的代码。其实有很多人抄界面，到这一步就可以抄出完整的界面了。如manifest文件，里面的Activity定义都可以看的很清楚了。然后layout文件，各种res都可以看见了。\n\n![](http://img.blog.csdn.net/20160921161150230?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n其实写到这，我就有个问题了，这一步怎么防？我不知道，愿请教一二。\n\n\n如果我们要参考（chao）一个程序的界面，到这一步已经够了，以为所有的res和layout文件已经能看到了。\n\n\n改代码重新编译也是要在这个文件夹中改smali文件的，所以smali的语法还是要熟悉一点。但是看代码逻辑我们不用去看晦涩难懂的smali语言，这就是下一步要做的工作。反编译出java代码。\n\n\n### 用dex2jar反编译出java源代码\n\n\n第一步做的工作先放在这，我们需要重新操作apk文件，其实apk文件就是一种压缩包，所以我们把后缀名改成rar，用解压缩工具打开。\n\n![](http://img.blog.csdn.net/20160921161216340?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n看到这里，有人会问，为什么不直接解压缩，跟我们刚才用apktool反编译出来的不一样吗，你可以试一下。\n\n\n这里其他文件在apktool那一步已经反编译出来了，我们需要的仅仅是class文件，这是java代码编译后生成的文件，用dex2jar这个工具就可以反编译出原代码（java格式）了。把这个class文件解压出来，放在dex2jar的同级目录下。\n\n![](http://img.blog.csdn.net/20160921161229402?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n命令如上，成功之后就会在同级目录下生成jar文件了。\n\n### 用gui查看代码\n\n\n还记得一开始我们说过的工具gui，通过gui打开jar文件，就能看到java代码了\n\n![](http://img.blog.csdn.net/20160921161255262?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n这里所有的引入的包代码都会有，那么怎么寻找我们要的主程序代码呢，这就要依赖在第一步我们反编译出的manifest文件，熟悉android的朋友知道，在manifest文件中有两个信息比较重要。\n\n\n一是包名，也就是主程序的路径，在manifest的最开始一行。\n\n![](http://img.blog.csdn.net/20160921161314773?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n第二个信息是入口activity，这个很简单，只要找到有launcher标识的activity就是入口activity。\n\n![](http://img.blog.csdn.net/20160921161330367?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n现在你就可以去gui里面找到这个入口类了\n\n![](http://img.blog.csdn.net/20160921161344809?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n代码有混淆，但是混淆只是替换了一些变量名或者类名而已，增加了代码阅读的困难性，并不会修改程序逻辑本身，所以只要静下心来慢慢看，还是看到懂得。\n\n\n至此，反编译的过程就结束了，你想看到一个程序的逻辑或者一个程序的界面逻辑都可以看的到的。\n\n\n### 重新打包，签名，运行\n\n\n下面，开始进行最重要的工作，修改代码，二次打包。其实这里你可以什么代码先都别改，只重新打包一次，看看程序是否能够正常运行，如果不能，看看程序是哪一步阻止了运行，这也方便你后期定位签名验证的位置。目前我见过的签名验证有以下几种：\n\n- 直接抛出异常，禁止运行\n- 弹出提示框提示用户，提示框消失后，退出程序\n- 跟服务器交互传递签名信息，如果不正确则服务器不返回数据\n\n重新打包是这样的，还要用到apktool，记得在第一步反编译出的那个文件夹吗，就是用这些文件再重新打包。打包命令如下：\n\n![](http://img.blog.csdn.net/20160921161400247?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n成功后，在同级目录下会看到test1.apk文件，这里只是打包成功了，程序还没有签名，没有签名的程序是无法安装到手机上的。签名用的的是apksign这个工具，这是java提供给开发者用于程序签名的工具，android的各类IDE也是用这个工具在签名。使用方法如下，将signapk.jar，testkey.pk8，testkey.x509.pem放在一个目录下，写一个signapk.bat文件，如下\n\n```java\njava -jar signapk.jar testkey.x509.pem testkey.pk8 %1 %2\n```\n\n然后运行命令\n\n![](http://img.blog.csdn.net/20160921161418934?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n成功后会在同级目录下生成一个签过名的apk文件，这个文件我们需要的最终文件，只要你改过代码并且签完名后这个apk可以正常安装运行，那么本次的任务就算完成了。现在安装一下，看看会发生什么。\n\n\n程序启动，然后弹出提示框\n\n![](http://img.blog.csdn.net/20160921161435809?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n程序弹出提示，点击确认后退出程序，看来这个app的签名验证是用了我说的上面第二种方法，下面来进行一些尝试来绕过这个签名验证。\n\n\n### 绕过程序防二次打包机制\n\n首先，我建议大家先全局搜一下signatures这个字符串，因为程序要获取app的签名就要通过packageInfo.signatures这种方式，如果在这里我们不让程序获取到真正的签名，而是直接返回给它那个“正确”的签名，岂不是瞒天过海，一步搞定。当然了，你必须要有原来那个程序的“正确”签名，不过这个简单，android系统并不阻止你去获取其他程序的签名，所以我们可以写个小的test程序，然后安装原来的apk，去获取一次正确的签名，记录下来。\n\n\n获取其他程序签名代码如下\n\n\n```java\nprivate static String getSignture(Application paramApplication) {\n    try {\n        String packageName = \"packageName\";\n        List<PackageInfo> packages = paramApplication.getPackageManager().getInstalledPackages(PackageManager.GET_SIGNATURES);\n        for (PackageInfo packageInfo : packages) {\n            Signature[] signs = packageInfo.signatures;\n            Signature sign = signs[0];\n            String signString = sign.toCharsString();\n            System.out.println(signString);\n            return signString;\n        }\n    } catch (Exception e) {\n        return \"\";\n    }\n    return \"\";\n}\n```\n\n先装上原来从正常渠道下载的程序，然后改一下包名，运行这个程序，就能得到正确程序的正确签名了，记录一下签名，然后去我们反编译的代码里面找signatures相关的代码，看在哪里获取了签名并验证。\n\n![](http://img.blog.csdn.net/20160921161456325?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n\n程序中一共有三个地方，MainActivity里是程序用到的，另外两个是第三方库的签名校验，像微信支付这种第三方库都会校验签名，这个可以暂时不管，所以要管的其实就只有MainActivity里这个了，看这个方法：\n\n![](http://img.blog.csdn.net/20160921161518935?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n是不是跟我写的那个方法完全一样，这个方法其实是获取程序的本来的签名的，这就好说了，我们直接返回刚才记录的“正确”签名就可以瞒过程序了。\n\n\n好，第一次尝试，去apktool反编译出的文件中的smali文件夹下找到这个类MainActivity，如下\n\n![](http://img.blog.csdn.net/20160921161536778?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n这是smali的语法，挺复杂的，感兴趣的朋友可以自己再翻阅一下资料。这里我们把这个方法全部注掉，直接返回“正确”的签名。如下\n\n![](http://img.blog.csdn.net/20160921161552497?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n按照前面说的签名的方法，重新打包，签名，安装。\n\n我们会发现，程序第一次进入是不行的，还是会提示，签名验证失败，第二次之后就可以正常进入了，这不是我们要的完美效果，思考一下，为什么会有这个情况，我想到以下几种原因：\n\n\n- 第一次的时候signinfo还没有获取，为空，所以认为是非法的\n- 除了这里，程序在另外的地方做了二次验证，而且这个二次验证并不一定每次都能执行成功，这个很像是一个网络请求方法，跟服务器做验证，所以根据网络情况，并不一定每次都成功。\n\n如果是第一种情况，为什么正常的程序没有问题，我们就只是让返回值变了一下，其他并没有改变逻辑。我推测是时间差，因为原来的方法执行获取签名需要较长的时间，而直接返回正确签名很快，难道是这个时间差的影响？我决定把原来那个方法改回来，只修改返回值。如下：\n\n![](http://img.blog.csdn.net/20160921161607810?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n只修改返回值，原来的逻辑不变，时间差应该也排除了，重新打包签名运行。好吧，很明显不是，而且情况更严重了，前面这些只是我的经验之谈，你在完全不了解逻辑的情况下，可以这样先试一下，我想能绕过30%的app吧。如果是上面说的第二种情况，我们还是来看一下代码逻辑吧。\n\n\n全局搜一下应用签名验证失败这句话，看看什么情况下会触发。\n\n![](http://img.blog.csdn.net/20160921161636309?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n一共有两处，我们先看第一处\n\n\n\n其实混淆后的代码挺恶心的，你看这个逻辑好像是如果LoginActivity的c方法为null就执行，但是你去看c方法就会发现根本就没有返回值，稳稳的null。这里代码其实是这样看的，要跳出前面那个while，所以我们去loginActivity找what值是19的情况。\n\n![](http://img.blog.csdn.net/20160921161648325?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n往前看，可以发现他调用了一个方法\n\n![](http://img.blog.csdn.net/20160921161703341?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n看来验证应该是在这里了，而且是一个网络请求验证，所以这个app的防二次打包的机制已经做的比较好的。研究下这个方法，混淆代码不是很容易看，我先用抓包工具抓了一下包。\n\n\n发现程序在启动的时候发了两个用来验证的请求，第一个请求没有参数，服务器返回如下字段\n\n![](http://img.blog.csdn.net/20160921161725810?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n第二次请求带有如下参数\n\n![](http://img.blog.csdn.net/20160921161740217?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n正常的包服务器返回的是status=1，而我重新打包后服务器返回的是status=0\n\n\n这是一种典型的challenge-response的方法，服务器发来challenge，然后程序用自身特性的一个字符串加密后再返回response，如果正确，则通过验证，反之则阻止运行。\n\n\n这里我想的是，我找的加密challenge的那一段算法，看他是用什么方式加密的，用的是程序的哪一段特征值，然后像前面改签名一样，用“正确”的特征值替换下。\n\n\n但是，恕我愚钝，看不懂代码，这里我贴一下逻辑，有大神对混淆比较了解的可以跟我交流下。\n\n![](http://img.blog.csdn.net/20160921161756327?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n\n首先loginActivity调了这个Post请求，第一次调用参数为空，服务器会返回challenge 四个字符串\n\n![](http://img.blog.csdn.net/20160921161811139?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n程序会把这四个字符串交给一个handler处理\n\n![](http://img.blog.csdn.net/20160921161825717?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n抱歉我追到这就追不下去了，因为中间这几个不管a还是b都因为混淆无法直接找到，我也没想出什么能间接找到的方法。\n\n\n是不是到这就束手无策了呢，其实也不是，前面的分析是希望在最上游解决问题，如果我们能在最上游把问题解决了，下面不管什么逻辑都不用担心了，但是现在最上游无解了，那么我们就往下找一找，前面说过， 签名验证失败弹框是在服务器返回后根据服务器返回信息来判断的，那么我们可以把判断的逻辑改掉。\n\n![](http://img.blog.csdn.net/20160921161841515?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n将这个代码改成永true\n\n我们去smali找到LoginActivity里的f类，smali编译时会把所有的内部类编成一个单独的文件，所有我们去找LoginActivity$f这个文件\n\n![](http://img.blog.csdn.net/20160921161855921?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n\n这段代码是比较status和1，如果为0则跳到cond_2，cond_2就是会给message19的那部分代码，这里我们不让他跳转，所以删掉这一句即可。另外MainActivity里也有一个同样的校验，一起改掉就行了。\n\n\n现在打包，签名，运行\n\n程序正常启动，没有弹出任何异常提醒，试试其他功能，都正常。既然签名验证我们搞定，现在往里面加一句弹toast的代码，轻而易举，我准备加在MainActivity的onCreate的时候，找到这部分代码。\n\n![](http://img.blog.csdn.net/20160921161910031?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n\n注意要加在super.onCreate之后。弹框代码如下\n\n![](http://img.blog.csdn.net/20160921161924110?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n加完代码之后如下\n\n\n打包，签名，运行\n\n![](http://img.blog.csdn.net/20160921161953186?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n效果如上，至此，这篇文章就结束了，我们绕过了这个app的防二次打包机制，并成功的修改了代码。\n\n总结一下\n\n1， 混淆确实是有用处的，虽然混淆后的逻辑仍然可以看懂，但是如果你想去追踪一些细节逻辑，很难，当然，我混淆代码研究的太少，经验太少也是一个方面。\n\n2， App层面上的签名验证基本是无效的的，比如一开始我们说的getSignature这里。\n\n3， 采用challenge-response的方式跟服务器验证，如果使用不恰当，基本也是完全无效的，比如该应用，成功与否只判断服务器返回的一个字符串，而且判断语句是在本地，这个完全是可以绕过的。\n\n至于更好的方法，我查资料的时候，网上看到这样一个方法，同样是跟服务器验证，但是服务器不是返回一个字段，而是返回一段核心代码，然后程序动态执行这段核心代码。我觉得采用这种方法，难度会上升一个层级。但还是无法有效避免二次打包。\n\n[点击打开链接](https://link.zhihu.com/?target=http%3A//bbs.pediy.com/showthread.php%3Ft%3D180655)\n\n几个问题：\n\n\n1， 跟服务器验证的时候，验证的是什么东西，前面讲了因为那段代码没跟出来，所以不知道实现逻辑。以我的经验，二次打包唯一变动的应该就是签名了，但是签名我们已经绕过去了，不知道还有什么可以拿来验证的东西。\n\n\n2， Android资源层面的东西有没有防反编译的方法，我是说res，layout这些。\n\n\n\n\n\nok，洋洋洒洒的终于写完了，我是觉得自己写得已经很详细了，已经到了读者完全可以复制过程的程度。但难免有一些地方我觉得可以省略，但是读者不懂，可以在评论区提问，我会回答的。\n\n\n\n\n另外，再次强调一下，绕过程序的防二次打包机制毕竟不是一件好事，搞不好做这个程序的程序员要背锅，所以文章中代码都是以图片形式给出，关键识别位置都打了马赛克，但是我想一些有心人还是可以看出这是什么程序，你看出来就看出来吧，就不要说出来了，好吗。\n\n\n\n如果这样还有任何侵犯到开发方权利的地方，开发方可以向我提出，我换个程序继续搞，哈哈，开玩笑，我会和你们协商如果处理的。\n","slug":"记一次android程序反编译并二次打包的过程v2","published":1,"updated":"2024-06-14T09:25:33.681Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clxjsxtwd001jlq6golo6x195","content":"<p>在安全界有一句话叫不懂攻，焉知防。</p>\n<p>前几天看到有一个问题在问Android端目前防止二次打包的方法有哪些？我想从攻击的角度来说这个问题。在分析过程中讲解每一步都有哪些防范手段。下面以一个市面上大公司的app为例，讲一下我是怎么绕过它的防范机制，修改代码（弹出一个提示框），并进行二次打包，重新签名，运行的。在写这篇文的过程中，我也遇到了一些问题，我在文章的最后进行了整理提问，希望这方面经验丰富的开发者可以一起交流。</p>\n<p>另外，绕过程序的防二次打包机制毕竟不是一件好事，搞不好做这个程序的程序员要背锅，所以文章中代码都是以图片形式给出，关键识别位置都打了马赛克，但是我想一些有心人还是可以看出这是什么程序，你看出来就看出来吧，就不要说出来了，好吗。</p>\n<h3 id=\"Contents\"><a href=\"#Contents\" class=\"headerlink\" title=\"Contents\"></a>Contents</h3><ul>\n<li><a href=\"#Contents\">Contents</a></li>\n<li><a href=\"#用ApkTool反编译android程序\">用ApkTool反编译android程序</a></li>\n<li><a href=\"#用dex2jar反编译出java源代码\">用dex2jar反编译出java源代码</a></li>\n<li><a href=\"#用gui查看代码\">用gui查看代码</a></li>\n<li><a href=\"#重新打包，签名，运行\">重新打包，签名，运行</a></li>\n<li><a href=\"#绕过程序防二次打包机制\">绕过程序防二次打包机制</a></li>\n</ul>\n<p>好，以下是正文</p>\n<p>工欲善其事，必先利其器。首先准备好工具：</p>\n<p>反编译工具</p>\n<ul>\n<li><p>apktool 反编译利器</p>\n</li>\n<li><p>dex2jar 将dex文件反编译成jar文件（Java代码）工具，用于解读代码</p>\n</li>\n<li><p>gui 打开jar文件工具</p>\n</li>\n</ul>\n<p>签名工具</p>\n<ul>\n<li><p>apksign给java程序签名的工具</p>\n</li>\n<li><p>testkey.pk8 teskkey.x509.pem用于签名的文件</p>\n</li>\n</ul>\n<p>首先下载好apk</p>\n<p><img src=\"http://img.blog.csdn.net/20160921161047823?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<h3 id=\"用ApkTool反编译android程序\"><a href=\"#用ApkTool反编译android程序\" class=\"headerlink\" title=\"用ApkTool反编译android程序\"></a>用ApkTool反编译android程序</h3><p>用apktool反编译，命令如下</p>\n<p><img src=\"http://img.blog.csdn.net/20160921161101489?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p><img src=\"http://img.blog.csdn.net/20160921161115411?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p>成功后会在同级目录生成一个test文件夹</p>\n<p><img src=\"http://img.blog.csdn.net/20160921161129224?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p>这就是反编译之后的Android程序了，可以看出，这个目录结构跟我们编写android代码时的目录结构非常相似，除了java代码是以smali的格式呈现之外，其他都基本是原来的代码。其实有很多人抄界面，到这一步就可以抄出完整的界面了。如manifest文件，里面的Activity定义都可以看的很清楚了。然后layout文件，各种res都可以看见了。</p>\n<p><img src=\"http://img.blog.csdn.net/20160921161150230?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p>其实写到这，我就有个问题了，这一步怎么防？我不知道，愿请教一二。</p>\n<p>如果我们要参考（chao）一个程序的界面，到这一步已经够了，以为所有的res和layout文件已经能看到了。</p>\n<p>改代码重新编译也是要在这个文件夹中改smali文件的，所以smali的语法还是要熟悉一点。但是看代码逻辑我们不用去看晦涩难懂的smali语言，这就是下一步要做的工作。反编译出java代码。</p>\n<h3 id=\"用dex2jar反编译出java源代码\"><a href=\"#用dex2jar反编译出java源代码\" class=\"headerlink\" title=\"用dex2jar反编译出java源代码\"></a>用dex2jar反编译出java源代码</h3><p>第一步做的工作先放在这，我们需要重新操作apk文件，其实apk文件就是一种压缩包，所以我们把后缀名改成rar，用解压缩工具打开。</p>\n<p><img src=\"http://img.blog.csdn.net/20160921161216340?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p>看到这里，有人会问，为什么不直接解压缩，跟我们刚才用apktool反编译出来的不一样吗，你可以试一下。</p>\n<p>这里其他文件在apktool那一步已经反编译出来了，我们需要的仅仅是class文件，这是java代码编译后生成的文件，用dex2jar这个工具就可以反编译出原代码（java格式）了。把这个class文件解压出来，放在dex2jar的同级目录下。</p>\n<p><img src=\"http://img.blog.csdn.net/20160921161229402?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p>命令如上，成功之后就会在同级目录下生成jar文件了。</p>\n<h3 id=\"用gui查看代码\"><a href=\"#用gui查看代码\" class=\"headerlink\" title=\"用gui查看代码\"></a>用gui查看代码</h3><p>还记得一开始我们说过的工具gui，通过gui打开jar文件，就能看到java代码了</p>\n<p><img src=\"http://img.blog.csdn.net/20160921161255262?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p>这里所有的引入的包代码都会有，那么怎么寻找我们要的主程序代码呢，这就要依赖在第一步我们反编译出的manifest文件，熟悉android的朋友知道，在manifest文件中有两个信息比较重要。</p>\n<p>一是包名，也就是主程序的路径，在manifest的最开始一行。</p>\n<p><img src=\"http://img.blog.csdn.net/20160921161314773?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p>第二个信息是入口activity，这个很简单，只要找到有launcher标识的activity就是入口activity。</p>\n<p><img src=\"http://img.blog.csdn.net/20160921161330367?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p>现在你就可以去gui里面找到这个入口类了</p>\n<p><img src=\"http://img.blog.csdn.net/20160921161344809?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p>代码有混淆，但是混淆只是替换了一些变量名或者类名而已，增加了代码阅读的困难性，并不会修改程序逻辑本身，所以只要静下心来慢慢看，还是看到懂得。</p>\n<p>至此，反编译的过程就结束了，你想看到一个程序的逻辑或者一个程序的界面逻辑都可以看的到的。</p>\n<h3 id=\"重新打包，签名，运行\"><a href=\"#重新打包，签名，运行\" class=\"headerlink\" title=\"重新打包，签名，运行\"></a>重新打包，签名，运行</h3><p>下面，开始进行最重要的工作，修改代码，二次打包。其实这里你可以什么代码先都别改，只重新打包一次，看看程序是否能够正常运行，如果不能，看看程序是哪一步阻止了运行，这也方便你后期定位签名验证的位置。目前我见过的签名验证有以下几种：</p>\n<ul>\n<li>直接抛出异常，禁止运行</li>\n<li>弹出提示框提示用户，提示框消失后，退出程序</li>\n<li>跟服务器交互传递签名信息，如果不正确则服务器不返回数据</li>\n</ul>\n<p>重新打包是这样的，还要用到apktool，记得在第一步反编译出的那个文件夹吗，就是用这些文件再重新打包。打包命令如下：</p>\n<p><img src=\"http://img.blog.csdn.net/20160921161400247?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p>成功后，在同级目录下会看到test1.apk文件，这里只是打包成功了，程序还没有签名，没有签名的程序是无法安装到手机上的。签名用的的是apksign这个工具，这是java提供给开发者用于程序签名的工具，android的各类IDE也是用这个工具在签名。使用方法如下，将signapk.jar，testkey.pk8，testkey.x509.pem放在一个目录下，写一个signapk.bat文件，如下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">java -jar signapk.jar testkey.x509.pem testkey.pk8 %<span class=\"number\">1</span> %<span class=\"number\">2</span></div></pre></td></tr></table></figure>\n<p>然后运行命令</p>\n<p><img src=\"http://img.blog.csdn.net/20160921161418934?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p>成功后会在同级目录下生成一个签过名的apk文件，这个文件我们需要的最终文件，只要你改过代码并且签完名后这个apk可以正常安装运行，那么本次的任务就算完成了。现在安装一下，看看会发生什么。</p>\n<p>程序启动，然后弹出提示框</p>\n<p><img src=\"http://img.blog.csdn.net/20160921161435809?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p>程序弹出提示，点击确认后退出程序，看来这个app的签名验证是用了我说的上面第二种方法，下面来进行一些尝试来绕过这个签名验证。</p>\n<h3 id=\"绕过程序防二次打包机制\"><a href=\"#绕过程序防二次打包机制\" class=\"headerlink\" title=\"绕过程序防二次打包机制\"></a>绕过程序防二次打包机制</h3><p>首先，我建议大家先全局搜一下signatures这个字符串，因为程序要获取app的签名就要通过packageInfo.signatures这种方式，如果在这里我们不让程序获取到真正的签名，而是直接返回给它那个“正确”的签名，岂不是瞒天过海，一步搞定。当然了，你必须要有原来那个程序的“正确”签名，不过这个简单，android系统并不阻止你去获取其他程序的签名，所以我们可以写个小的test程序，然后安装原来的apk，去获取一次正确的签名，记录下来。</p>\n<p>获取其他程序签名代码如下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> String <span class=\"title\">getSignture</span><span class=\"params\">(Application paramApplication)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">        String packageName = <span class=\"string\">\"packageName\"</span>;</div><div class=\"line\">        List&lt;PackageInfo&gt; packages = paramApplication.getPackageManager().getInstalledPackages(PackageManager.GET_SIGNATURES);</div><div class=\"line\">        <span class=\"keyword\">for</span> (PackageInfo packageInfo : packages) &#123;</div><div class=\"line\">            Signature[] signs = packageInfo.signatures;</div><div class=\"line\">            Signature sign = signs[<span class=\"number\">0</span>];</div><div class=\"line\">            String signString = sign.toCharsString();</div><div class=\"line\">            System.out.println(signString);</div><div class=\"line\">            <span class=\"keyword\">return</span> signString;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"\"</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"\"</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>先装上原来从正常渠道下载的程序，然后改一下包名，运行这个程序，就能得到正确程序的正确签名了，记录一下签名，然后去我们反编译的代码里面找signatures相关的代码，看在哪里获取了签名并验证。</p>\n<p><img src=\"http://img.blog.csdn.net/20160921161456325?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p>程序中一共有三个地方，MainActivity里是程序用到的，另外两个是第三方库的签名校验，像微信支付这种第三方库都会校验签名，这个可以暂时不管，所以要管的其实就只有MainActivity里这个了，看这个方法：</p>\n<p><img src=\"http://img.blog.csdn.net/20160921161518935?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p>是不是跟我写的那个方法完全一样，这个方法其实是获取程序的本来的签名的，这就好说了，我们直接返回刚才记录的“正确”签名就可以瞒过程序了。</p>\n<p>好，第一次尝试，去apktool反编译出的文件中的smali文件夹下找到这个类MainActivity，如下</p>\n<p><img src=\"http://img.blog.csdn.net/20160921161536778?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p>这是smali的语法，挺复杂的，感兴趣的朋友可以自己再翻阅一下资料。这里我们把这个方法全部注掉，直接返回“正确”的签名。如下</p>\n<p><img src=\"http://img.blog.csdn.net/20160921161552497?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p>按照前面说的签名的方法，重新打包，签名，安装。</p>\n<p>我们会发现，程序第一次进入是不行的，还是会提示，签名验证失败，第二次之后就可以正常进入了，这不是我们要的完美效果，思考一下，为什么会有这个情况，我想到以下几种原因：</p>\n<ul>\n<li>第一次的时候signinfo还没有获取，为空，所以认为是非法的</li>\n<li>除了这里，程序在另外的地方做了二次验证，而且这个二次验证并不一定每次都能执行成功，这个很像是一个网络请求方法，跟服务器做验证，所以根据网络情况，并不一定每次都成功。</li>\n</ul>\n<p>如果是第一种情况，为什么正常的程序没有问题，我们就只是让返回值变了一下，其他并没有改变逻辑。我推测是时间差，因为原来的方法执行获取签名需要较长的时间，而直接返回正确签名很快，难道是这个时间差的影响？我决定把原来那个方法改回来，只修改返回值。如下：</p>\n<p><img src=\"http://img.blog.csdn.net/20160921161607810?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p>只修改返回值，原来的逻辑不变，时间差应该也排除了，重新打包签名运行。好吧，很明显不是，而且情况更严重了，前面这些只是我的经验之谈，你在完全不了解逻辑的情况下，可以这样先试一下，我想能绕过30%的app吧。如果是上面说的第二种情况，我们还是来看一下代码逻辑吧。</p>\n<p>全局搜一下应用签名验证失败这句话，看看什么情况下会触发。</p>\n<p><img src=\"http://img.blog.csdn.net/20160921161636309?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p>一共有两处，我们先看第一处</p>\n<p>其实混淆后的代码挺恶心的，你看这个逻辑好像是如果LoginActivity的c方法为null就执行，但是你去看c方法就会发现根本就没有返回值，稳稳的null。这里代码其实是这样看的，要跳出前面那个while，所以我们去loginActivity找what值是19的情况。</p>\n<p><img src=\"http://img.blog.csdn.net/20160921161648325?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p>往前看，可以发现他调用了一个方法</p>\n<p><img src=\"http://img.blog.csdn.net/20160921161703341?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p>看来验证应该是在这里了，而且是一个网络请求验证，所以这个app的防二次打包的机制已经做的比较好的。研究下这个方法，混淆代码不是很容易看，我先用抓包工具抓了一下包。</p>\n<p>发现程序在启动的时候发了两个用来验证的请求，第一个请求没有参数，服务器返回如下字段</p>\n<p><img src=\"http://img.blog.csdn.net/20160921161725810?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p>第二次请求带有如下参数</p>\n<p><img src=\"http://img.blog.csdn.net/20160921161740217?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p>正常的包服务器返回的是status=1，而我重新打包后服务器返回的是status=0</p>\n<p>这是一种典型的challenge-response的方法，服务器发来challenge，然后程序用自身特性的一个字符串加密后再返回response，如果正确，则通过验证，反之则阻止运行。</p>\n<p>这里我想的是，我找的加密challenge的那一段算法，看他是用什么方式加密的，用的是程序的哪一段特征值，然后像前面改签名一样，用“正确”的特征值替换下。</p>\n<p>但是，恕我愚钝，看不懂代码，这里我贴一下逻辑，有大神对混淆比较了解的可以跟我交流下。</p>\n<p><img src=\"http://img.blog.csdn.net/20160921161756327?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p>首先loginActivity调了这个Post请求，第一次调用参数为空，服务器会返回challenge 四个字符串</p>\n<p><img src=\"http://img.blog.csdn.net/20160921161811139?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p>程序会把这四个字符串交给一个handler处理</p>\n<p><img src=\"http://img.blog.csdn.net/20160921161825717?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p>抱歉我追到这就追不下去了，因为中间这几个不管a还是b都因为混淆无法直接找到，我也没想出什么能间接找到的方法。</p>\n<p>是不是到这就束手无策了呢，其实也不是，前面的分析是希望在最上游解决问题，如果我们能在最上游把问题解决了，下面不管什么逻辑都不用担心了，但是现在最上游无解了，那么我们就往下找一找，前面说过， 签名验证失败弹框是在服务器返回后根据服务器返回信息来判断的，那么我们可以把判断的逻辑改掉。</p>\n<p><img src=\"http://img.blog.csdn.net/20160921161841515?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p>将这个代码改成永true</p>\n<p>我们去smali找到LoginActivity里的f类，smali编译时会把所有的内部类编成一个单独的文件，所有我们去找LoginActivity$f这个文件</p>\n<p><img src=\"http://img.blog.csdn.net/20160921161855921?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p>这段代码是比较status和1，如果为0则跳到cond_2，cond_2就是会给message19的那部分代码，这里我们不让他跳转，所以删掉这一句即可。另外MainActivity里也有一个同样的校验，一起改掉就行了。</p>\n<p>现在打包，签名，运行</p>\n<p>程序正常启动，没有弹出任何异常提醒，试试其他功能，都正常。既然签名验证我们搞定，现在往里面加一句弹toast的代码，轻而易举，我准备加在MainActivity的onCreate的时候，找到这部分代码。</p>\n<p><img src=\"http://img.blog.csdn.net/20160921161910031?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p>注意要加在super.onCreate之后。弹框代码如下</p>\n<p><img src=\"http://img.blog.csdn.net/20160921161924110?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p>加完代码之后如下</p>\n<p>打包，签名，运行</p>\n<p><img src=\"http://img.blog.csdn.net/20160921161953186?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p>效果如上，至此，这篇文章就结束了，我们绕过了这个app的防二次打包机制，并成功的修改了代码。</p>\n<p>总结一下</p>\n<p>1， 混淆确实是有用处的，虽然混淆后的逻辑仍然可以看懂，但是如果你想去追踪一些细节逻辑，很难，当然，我混淆代码研究的太少，经验太少也是一个方面。</p>\n<p>2， App层面上的签名验证基本是无效的的，比如一开始我们说的getSignature这里。</p>\n<p>3， 采用challenge-response的方式跟服务器验证，如果使用不恰当，基本也是完全无效的，比如该应用，成功与否只判断服务器返回的一个字符串，而且判断语句是在本地，这个完全是可以绕过的。</p>\n<p>至于更好的方法，我查资料的时候，网上看到这样一个方法，同样是跟服务器验证，但是服务器不是返回一个字段，而是返回一段核心代码，然后程序动态执行这段核心代码。我觉得采用这种方法，难度会上升一个层级。但还是无法有效避免二次打包。</p>\n<p><a href=\"https://link.zhihu.com/?target=http%3A//bbs.pediy.com/showthread.php%3Ft%3D180655\" target=\"_blank\" rel=\"external\">点击打开链接</a></p>\n<p>几个问题：</p>\n<p>1， 跟服务器验证的时候，验证的是什么东西，前面讲了因为那段代码没跟出来，所以不知道实现逻辑。以我的经验，二次打包唯一变动的应该就是签名了，但是签名我们已经绕过去了，不知道还有什么可以拿来验证的东西。</p>\n<p>2， Android资源层面的东西有没有防反编译的方法，我是说res，layout这些。</p>\n<p>ok，洋洋洒洒的终于写完了，我是觉得自己写得已经很详细了，已经到了读者完全可以复制过程的程度。但难免有一些地方我觉得可以省略，但是读者不懂，可以在评论区提问，我会回答的。</p>\n<p>另外，再次强调一下，绕过程序的防二次打包机制毕竟不是一件好事，搞不好做这个程序的程序员要背锅，所以文章中代码都是以图片形式给出，关键识别位置都打了马赛克，但是我想一些有心人还是可以看出这是什么程序，你看出来就看出来吧，就不要说出来了，好吗。</p>\n<p>如果这样还有任何侵犯到开发方权利的地方，开发方可以向我提出，我换个程序继续搞，哈哈，开玩笑，我会和你们协商如果处理的。</p>\n","excerpt":"","more":"<p>在安全界有一句话叫不懂攻，焉知防。</p>\n<p>前几天看到有一个问题在问Android端目前防止二次打包的方法有哪些？我想从攻击的角度来说这个问题。在分析过程中讲解每一步都有哪些防范手段。下面以一个市面上大公司的app为例，讲一下我是怎么绕过它的防范机制，修改代码（弹出一个提示框），并进行二次打包，重新签名，运行的。在写这篇文的过程中，我也遇到了一些问题，我在文章的最后进行了整理提问，希望这方面经验丰富的开发者可以一起交流。</p>\n<p>另外，绕过程序的防二次打包机制毕竟不是一件好事，搞不好做这个程序的程序员要背锅，所以文章中代码都是以图片形式给出，关键识别位置都打了马赛克，但是我想一些有心人还是可以看出这是什么程序，你看出来就看出来吧，就不要说出来了，好吗。</p>\n<h3 id=\"Contents\"><a href=\"#Contents\" class=\"headerlink\" title=\"Contents\"></a>Contents</h3><ul>\n<li><a href=\"#Contents\">Contents</a></li>\n<li><a href=\"#用ApkTool反编译android程序\">用ApkTool反编译android程序</a></li>\n<li><a href=\"#用dex2jar反编译出java源代码\">用dex2jar反编译出java源代码</a></li>\n<li><a href=\"#用gui查看代码\">用gui查看代码</a></li>\n<li><a href=\"#重新打包，签名，运行\">重新打包，签名，运行</a></li>\n<li><a href=\"#绕过程序防二次打包机制\">绕过程序防二次打包机制</a></li>\n</ul>\n<p>好，以下是正文</p>\n<p>工欲善其事，必先利其器。首先准备好工具：</p>\n<p>反编译工具</p>\n<ul>\n<li><p>apktool 反编译利器</p>\n</li>\n<li><p>dex2jar 将dex文件反编译成jar文件（Java代码）工具，用于解读代码</p>\n</li>\n<li><p>gui 打开jar文件工具</p>\n</li>\n</ul>\n<p>签名工具</p>\n<ul>\n<li><p>apksign给java程序签名的工具</p>\n</li>\n<li><p>testkey.pk8 teskkey.x509.pem用于签名的文件</p>\n</li>\n</ul>\n<p>首先下载好apk</p>\n<p><img src=\"http://img.blog.csdn.net/20160921161047823?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<h3 id=\"用ApkTool反编译android程序\"><a href=\"#用ApkTool反编译android程序\" class=\"headerlink\" title=\"用ApkTool反编译android程序\"></a>用ApkTool反编译android程序</h3><p>用apktool反编译，命令如下</p>\n<p><img src=\"http://img.blog.csdn.net/20160921161101489?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p><img src=\"http://img.blog.csdn.net/20160921161115411?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p>成功后会在同级目录生成一个test文件夹</p>\n<p><img src=\"http://img.blog.csdn.net/20160921161129224?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p>这就是反编译之后的Android程序了，可以看出，这个目录结构跟我们编写android代码时的目录结构非常相似，除了java代码是以smali的格式呈现之外，其他都基本是原来的代码。其实有很多人抄界面，到这一步就可以抄出完整的界面了。如manifest文件，里面的Activity定义都可以看的很清楚了。然后layout文件，各种res都可以看见了。</p>\n<p><img src=\"http://img.blog.csdn.net/20160921161150230?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p>其实写到这，我就有个问题了，这一步怎么防？我不知道，愿请教一二。</p>\n<p>如果我们要参考（chao）一个程序的界面，到这一步已经够了，以为所有的res和layout文件已经能看到了。</p>\n<p>改代码重新编译也是要在这个文件夹中改smali文件的，所以smali的语法还是要熟悉一点。但是看代码逻辑我们不用去看晦涩难懂的smali语言，这就是下一步要做的工作。反编译出java代码。</p>\n<h3 id=\"用dex2jar反编译出java源代码\"><a href=\"#用dex2jar反编译出java源代码\" class=\"headerlink\" title=\"用dex2jar反编译出java源代码\"></a>用dex2jar反编译出java源代码</h3><p>第一步做的工作先放在这，我们需要重新操作apk文件，其实apk文件就是一种压缩包，所以我们把后缀名改成rar，用解压缩工具打开。</p>\n<p><img src=\"http://img.blog.csdn.net/20160921161216340?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p>看到这里，有人会问，为什么不直接解压缩，跟我们刚才用apktool反编译出来的不一样吗，你可以试一下。</p>\n<p>这里其他文件在apktool那一步已经反编译出来了，我们需要的仅仅是class文件，这是java代码编译后生成的文件，用dex2jar这个工具就可以反编译出原代码（java格式）了。把这个class文件解压出来，放在dex2jar的同级目录下。</p>\n<p><img src=\"http://img.blog.csdn.net/20160921161229402?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p>命令如上，成功之后就会在同级目录下生成jar文件了。</p>\n<h3 id=\"用gui查看代码\"><a href=\"#用gui查看代码\" class=\"headerlink\" title=\"用gui查看代码\"></a>用gui查看代码</h3><p>还记得一开始我们说过的工具gui，通过gui打开jar文件，就能看到java代码了</p>\n<p><img src=\"http://img.blog.csdn.net/20160921161255262?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p>这里所有的引入的包代码都会有，那么怎么寻找我们要的主程序代码呢，这就要依赖在第一步我们反编译出的manifest文件，熟悉android的朋友知道，在manifest文件中有两个信息比较重要。</p>\n<p>一是包名，也就是主程序的路径，在manifest的最开始一行。</p>\n<p><img src=\"http://img.blog.csdn.net/20160921161314773?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p>第二个信息是入口activity，这个很简单，只要找到有launcher标识的activity就是入口activity。</p>\n<p><img src=\"http://img.blog.csdn.net/20160921161330367?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p>现在你就可以去gui里面找到这个入口类了</p>\n<p><img src=\"http://img.blog.csdn.net/20160921161344809?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p>代码有混淆，但是混淆只是替换了一些变量名或者类名而已，增加了代码阅读的困难性，并不会修改程序逻辑本身，所以只要静下心来慢慢看，还是看到懂得。</p>\n<p>至此，反编译的过程就结束了，你想看到一个程序的逻辑或者一个程序的界面逻辑都可以看的到的。</p>\n<h3 id=\"重新打包，签名，运行\"><a href=\"#重新打包，签名，运行\" class=\"headerlink\" title=\"重新打包，签名，运行\"></a>重新打包，签名，运行</h3><p>下面，开始进行最重要的工作，修改代码，二次打包。其实这里你可以什么代码先都别改，只重新打包一次，看看程序是否能够正常运行，如果不能，看看程序是哪一步阻止了运行，这也方便你后期定位签名验证的位置。目前我见过的签名验证有以下几种：</p>\n<ul>\n<li>直接抛出异常，禁止运行</li>\n<li>弹出提示框提示用户，提示框消失后，退出程序</li>\n<li>跟服务器交互传递签名信息，如果不正确则服务器不返回数据</li>\n</ul>\n<p>重新打包是这样的，还要用到apktool，记得在第一步反编译出的那个文件夹吗，就是用这些文件再重新打包。打包命令如下：</p>\n<p><img src=\"http://img.blog.csdn.net/20160921161400247?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p>成功后，在同级目录下会看到test1.apk文件，这里只是打包成功了，程序还没有签名，没有签名的程序是无法安装到手机上的。签名用的的是apksign这个工具，这是java提供给开发者用于程序签名的工具，android的各类IDE也是用这个工具在签名。使用方法如下，将signapk.jar，testkey.pk8，testkey.x509.pem放在一个目录下，写一个signapk.bat文件，如下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">java -jar signapk.jar testkey.x509.pem testkey.pk8 %<span class=\"number\">1</span> %<span class=\"number\">2</span></div></pre></td></tr></table></figure>\n<p>然后运行命令</p>\n<p><img src=\"http://img.blog.csdn.net/20160921161418934?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p>成功后会在同级目录下生成一个签过名的apk文件，这个文件我们需要的最终文件，只要你改过代码并且签完名后这个apk可以正常安装运行，那么本次的任务就算完成了。现在安装一下，看看会发生什么。</p>\n<p>程序启动，然后弹出提示框</p>\n<p><img src=\"http://img.blog.csdn.net/20160921161435809?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p>程序弹出提示，点击确认后退出程序，看来这个app的签名验证是用了我说的上面第二种方法，下面来进行一些尝试来绕过这个签名验证。</p>\n<h3 id=\"绕过程序防二次打包机制\"><a href=\"#绕过程序防二次打包机制\" class=\"headerlink\" title=\"绕过程序防二次打包机制\"></a>绕过程序防二次打包机制</h3><p>首先，我建议大家先全局搜一下signatures这个字符串，因为程序要获取app的签名就要通过packageInfo.signatures这种方式，如果在这里我们不让程序获取到真正的签名，而是直接返回给它那个“正确”的签名，岂不是瞒天过海，一步搞定。当然了，你必须要有原来那个程序的“正确”签名，不过这个简单，android系统并不阻止你去获取其他程序的签名，所以我们可以写个小的test程序，然后安装原来的apk，去获取一次正确的签名，记录下来。</p>\n<p>获取其他程序签名代码如下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> String <span class=\"title\">getSignture</span><span class=\"params\">(Application paramApplication)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">        String packageName = <span class=\"string\">\"packageName\"</span>;</div><div class=\"line\">        List&lt;PackageInfo&gt; packages = paramApplication.getPackageManager().getInstalledPackages(PackageManager.GET_SIGNATURES);</div><div class=\"line\">        <span class=\"keyword\">for</span> (PackageInfo packageInfo : packages) &#123;</div><div class=\"line\">            Signature[] signs = packageInfo.signatures;</div><div class=\"line\">            Signature sign = signs[<span class=\"number\">0</span>];</div><div class=\"line\">            String signString = sign.toCharsString();</div><div class=\"line\">            System.out.println(signString);</div><div class=\"line\">            <span class=\"keyword\">return</span> signString;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"\"</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"\"</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>先装上原来从正常渠道下载的程序，然后改一下包名，运行这个程序，就能得到正确程序的正确签名了，记录一下签名，然后去我们反编译的代码里面找signatures相关的代码，看在哪里获取了签名并验证。</p>\n<p><img src=\"http://img.blog.csdn.net/20160921161456325?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p>程序中一共有三个地方，MainActivity里是程序用到的，另外两个是第三方库的签名校验，像微信支付这种第三方库都会校验签名，这个可以暂时不管，所以要管的其实就只有MainActivity里这个了，看这个方法：</p>\n<p><img src=\"http://img.blog.csdn.net/20160921161518935?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p>是不是跟我写的那个方法完全一样，这个方法其实是获取程序的本来的签名的，这就好说了，我们直接返回刚才记录的“正确”签名就可以瞒过程序了。</p>\n<p>好，第一次尝试，去apktool反编译出的文件中的smali文件夹下找到这个类MainActivity，如下</p>\n<p><img src=\"http://img.blog.csdn.net/20160921161536778?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p>这是smali的语法，挺复杂的，感兴趣的朋友可以自己再翻阅一下资料。这里我们把这个方法全部注掉，直接返回“正确”的签名。如下</p>\n<p><img src=\"http://img.blog.csdn.net/20160921161552497?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p>按照前面说的签名的方法，重新打包，签名，安装。</p>\n<p>我们会发现，程序第一次进入是不行的，还是会提示，签名验证失败，第二次之后就可以正常进入了，这不是我们要的完美效果，思考一下，为什么会有这个情况，我想到以下几种原因：</p>\n<ul>\n<li>第一次的时候signinfo还没有获取，为空，所以认为是非法的</li>\n<li>除了这里，程序在另外的地方做了二次验证，而且这个二次验证并不一定每次都能执行成功，这个很像是一个网络请求方法，跟服务器做验证，所以根据网络情况，并不一定每次都成功。</li>\n</ul>\n<p>如果是第一种情况，为什么正常的程序没有问题，我们就只是让返回值变了一下，其他并没有改变逻辑。我推测是时间差，因为原来的方法执行获取签名需要较长的时间，而直接返回正确签名很快，难道是这个时间差的影响？我决定把原来那个方法改回来，只修改返回值。如下：</p>\n<p><img src=\"http://img.blog.csdn.net/20160921161607810?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p>只修改返回值，原来的逻辑不变，时间差应该也排除了，重新打包签名运行。好吧，很明显不是，而且情况更严重了，前面这些只是我的经验之谈，你在完全不了解逻辑的情况下，可以这样先试一下，我想能绕过30%的app吧。如果是上面说的第二种情况，我们还是来看一下代码逻辑吧。</p>\n<p>全局搜一下应用签名验证失败这句话，看看什么情况下会触发。</p>\n<p><img src=\"http://img.blog.csdn.net/20160921161636309?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p>一共有两处，我们先看第一处</p>\n<p>其实混淆后的代码挺恶心的，你看这个逻辑好像是如果LoginActivity的c方法为null就执行，但是你去看c方法就会发现根本就没有返回值，稳稳的null。这里代码其实是这样看的，要跳出前面那个while，所以我们去loginActivity找what值是19的情况。</p>\n<p><img src=\"http://img.blog.csdn.net/20160921161648325?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p>往前看，可以发现他调用了一个方法</p>\n<p><img src=\"http://img.blog.csdn.net/20160921161703341?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p>看来验证应该是在这里了，而且是一个网络请求验证，所以这个app的防二次打包的机制已经做的比较好的。研究下这个方法，混淆代码不是很容易看，我先用抓包工具抓了一下包。</p>\n<p>发现程序在启动的时候发了两个用来验证的请求，第一个请求没有参数，服务器返回如下字段</p>\n<p><img src=\"http://img.blog.csdn.net/20160921161725810?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p>第二次请求带有如下参数</p>\n<p><img src=\"http://img.blog.csdn.net/20160921161740217?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p>正常的包服务器返回的是status=1，而我重新打包后服务器返回的是status=0</p>\n<p>这是一种典型的challenge-response的方法，服务器发来challenge，然后程序用自身特性的一个字符串加密后再返回response，如果正确，则通过验证，反之则阻止运行。</p>\n<p>这里我想的是，我找的加密challenge的那一段算法，看他是用什么方式加密的，用的是程序的哪一段特征值，然后像前面改签名一样，用“正确”的特征值替换下。</p>\n<p>但是，恕我愚钝，看不懂代码，这里我贴一下逻辑，有大神对混淆比较了解的可以跟我交流下。</p>\n<p><img src=\"http://img.blog.csdn.net/20160921161756327?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p>首先loginActivity调了这个Post请求，第一次调用参数为空，服务器会返回challenge 四个字符串</p>\n<p><img src=\"http://img.blog.csdn.net/20160921161811139?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p>程序会把这四个字符串交给一个handler处理</p>\n<p><img src=\"http://img.blog.csdn.net/20160921161825717?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p>抱歉我追到这就追不下去了，因为中间这几个不管a还是b都因为混淆无法直接找到，我也没想出什么能间接找到的方法。</p>\n<p>是不是到这就束手无策了呢，其实也不是，前面的分析是希望在最上游解决问题，如果我们能在最上游把问题解决了，下面不管什么逻辑都不用担心了，但是现在最上游无解了，那么我们就往下找一找，前面说过， 签名验证失败弹框是在服务器返回后根据服务器返回信息来判断的，那么我们可以把判断的逻辑改掉。</p>\n<p><img src=\"http://img.blog.csdn.net/20160921161841515?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p>将这个代码改成永true</p>\n<p>我们去smali找到LoginActivity里的f类，smali编译时会把所有的内部类编成一个单独的文件，所有我们去找LoginActivity$f这个文件</p>\n<p><img src=\"http://img.blog.csdn.net/20160921161855921?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p>这段代码是比较status和1，如果为0则跳到cond_2，cond_2就是会给message19的那部分代码，这里我们不让他跳转，所以删掉这一句即可。另外MainActivity里也有一个同样的校验，一起改掉就行了。</p>\n<p>现在打包，签名，运行</p>\n<p>程序正常启动，没有弹出任何异常提醒，试试其他功能，都正常。既然签名验证我们搞定，现在往里面加一句弹toast的代码，轻而易举，我准备加在MainActivity的onCreate的时候，找到这部分代码。</p>\n<p><img src=\"http://img.blog.csdn.net/20160921161910031?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p>注意要加在super.onCreate之后。弹框代码如下</p>\n<p><img src=\"http://img.blog.csdn.net/20160921161924110?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p>加完代码之后如下</p>\n<p>打包，签名，运行</p>\n<p><img src=\"http://img.blog.csdn.net/20160921161953186?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p>效果如上，至此，这篇文章就结束了，我们绕过了这个app的防二次打包机制，并成功的修改了代码。</p>\n<p>总结一下</p>\n<p>1， 混淆确实是有用处的，虽然混淆后的逻辑仍然可以看懂，但是如果你想去追踪一些细节逻辑，很难，当然，我混淆代码研究的太少，经验太少也是一个方面。</p>\n<p>2， App层面上的签名验证基本是无效的的，比如一开始我们说的getSignature这里。</p>\n<p>3， 采用challenge-response的方式跟服务器验证，如果使用不恰当，基本也是完全无效的，比如该应用，成功与否只判断服务器返回的一个字符串，而且判断语句是在本地，这个完全是可以绕过的。</p>\n<p>至于更好的方法，我查资料的时候，网上看到这样一个方法，同样是跟服务器验证，但是服务器不是返回一个字段，而是返回一段核心代码，然后程序动态执行这段核心代码。我觉得采用这种方法，难度会上升一个层级。但还是无法有效避免二次打包。</p>\n<p><a href=\"https://link.zhihu.com/?target=http%3A//bbs.pediy.com/showthread.php%3Ft%3D180655\">点击打开链接</a></p>\n<p>几个问题：</p>\n<p>1， 跟服务器验证的时候，验证的是什么东西，前面讲了因为那段代码没跟出来，所以不知道实现逻辑。以我的经验，二次打包唯一变动的应该就是签名了，但是签名我们已经绕过去了，不知道还有什么可以拿来验证的东西。</p>\n<p>2， Android资源层面的东西有没有防反编译的方法，我是说res，layout这些。</p>\n<p>ok，洋洋洒洒的终于写完了，我是觉得自己写得已经很详细了，已经到了读者完全可以复制过程的程度。但难免有一些地方我觉得可以省略，但是读者不懂，可以在评论区提问，我会回答的。</p>\n<p>另外，再次强调一下，绕过程序的防二次打包机制毕竟不是一件好事，搞不好做这个程序的程序员要背锅，所以文章中代码都是以图片形式给出，关键识别位置都打了马赛克，但是我想一些有心人还是可以看出这是什么程序，你看出来就看出来吧，就不要说出来了，好吗。</p>\n<p>如果这样还有任何侵犯到开发方权利的地方，开发方可以向我提出，我换个程序继续搞，哈哈，开玩笑，我会和你们协商如果处理的。</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"clxjsxtvw0008lq6gk73exovt","category_id":"clxjsxtvt0004lq6gzmz08pkq","_id":"clxjsxtvz000dlq6gk4pdurcp"},{"post_id":"clxjsxtvl0000lq6gqxoxdldw","category_id":"clxjsxtvt0004lq6gzmz08pkq","_id":"clxjsxtw0000hlq6g4nk0vdfz"},{"post_id":"clxjsxtvx0009lq6g2u38v1f2","category_id":"clxjsxtvt0004lq6gzmz08pkq","_id":"clxjsxtw1000jlq6gngpi1pun"},{"post_id":"clxjsxtvy000clq6ghqk6xyh2","category_id":"clxjsxtvt0004lq6gzmz08pkq","_id":"clxjsxtw3000nlq6gs3qr9vf4"},{"post_id":"clxjsxtvr0002lq6gsfiyn355","category_id":"clxjsxtvt0004lq6gzmz08pkq","_id":"clxjsxtw4000qlq6ghy128gbp"},{"post_id":"clxjsxtvu0006lq6gwwfn2q22","category_id":"clxjsxtvt0004lq6gzmz08pkq","_id":"clxjsxtw5000vlq6g8r020l03"},{"post_id":"clxjsxtw3000olq6g5qlal9hh","category_id":"clxjsxtvt0004lq6gzmz08pkq","_id":"clxjsxtw6000ylq6gwajrpncs"},{"post_id":"clxjsxtvz000elq6gml657nch","category_id":"clxjsxtw2000llq6g2pz7y2ig","_id":"clxjsxtw70012lq6g12r2bd64"},{"post_id":"clxjsxtw1000ilq6gwxv3djhs","category_id":"clxjsxtw2000llq6g2pz7y2ig","_id":"clxjsxtw90015lq6gvlobs0cr"},{"post_id":"clxjsxtw7000zlq6gik3dkvns","category_id":"clxjsxtw2000llq6g2pz7y2ig","_id":"clxjsxtwa0019lq6gdhqu4bz2"},{"post_id":"clxjsxtw80013lq6gc2ker5mn","category_id":"clxjsxtvt0004lq6gzmz08pkq","_id":"clxjsxtwb001clq6gbg1tscw9"},{"post_id":"clxjsxtw2000klq6gic4px3vs","category_id":"clxjsxtw70010lq6gncf9vrqt","_id":"clxjsxtwc001hlq6gllxlyog8"},{"post_id":"clxjsxtw80014lq6gbxnkycum","category_id":"clxjsxtw2000llq6g2pz7y2ig","_id":"clxjsxtwd001klq6gtly3cjbh"},{"post_id":"clxjsxtw4000rlq6gvz461m9p","category_id":"clxjsxtw70010lq6gncf9vrqt","_id":"clxjsxtwe001nlq6gfcs2y71i"},{"post_id":"clxjsxtwb001blq6gu0l3f4d4","category_id":"clxjsxtw2000llq6g2pz7y2ig","_id":"clxjsxtwe001olq6g6pfbeghq"},{"post_id":"clxjsxtw6000wlq6gf6kg48vd","category_id":"clxjsxtwb001elq6g3xuyx7kw","_id":"clxjsxtwf001rlq6g3k5yhadi"},{"post_id":"clxjsxtwd001jlq6golo6x195","category_id":"clxjsxtvt0004lq6gzmz08pkq","_id":"clxjsxtwf001tlq6gdjf74dyf"},{"post_id":"clxjsxtwa0018lq6gka2w672d","category_id":"clxjsxtwe001mlq6g4rtbiic0","_id":"clxjsxtwg001wlq6gtsmeiqpl"},{"post_id":"clxjsxtwc001glq6gseji55t1","category_id":"clxjsxtwf001qlq6g0rztgrxr","_id":"clxjsxtwg001zlq6gp4fw3g1m"}],"PostTag":[{"post_id":"clxjsxtvl0000lq6gqxoxdldw","tag_id":"clxjsxtvu0005lq6gz1mlpwux","_id":"clxjsxtw4000plq6gpdrq7kb4"},{"post_id":"clxjsxtvl0000lq6gqxoxdldw","tag_id":"clxjsxtvx000blq6gphmvstjj","_id":"clxjsxtw5000tlq6ga7v32pyq"},{"post_id":"clxjsxtvl0000lq6gqxoxdldw","tag_id":"clxjsxtw0000glq6g3ccr3fmq","_id":"clxjsxtw6000xlq6gbfoasedr"},{"post_id":"clxjsxtvr0002lq6gsfiyn355","tag_id":"clxjsxtvu0005lq6gz1mlpwux","_id":"clxjsxtwa001alq6gehh0hcog"},{"post_id":"clxjsxtvr0002lq6gsfiyn355","tag_id":"clxjsxtvx000blq6gphmvstjj","_id":"clxjsxtwb001dlq6g7n6z0dhs"},{"post_id":"clxjsxtvr0002lq6gsfiyn355","tag_id":"clxjsxtw0000glq6g3ccr3fmq","_id":"clxjsxtwd001ilq6gjpdwaj3y"},{"post_id":"clxjsxtvu0006lq6gwwfn2q22","tag_id":"clxjsxtvu0005lq6gz1mlpwux","_id":"clxjsxtwf001slq6gl99bgrtc"},{"post_id":"clxjsxtvu0006lq6gwwfn2q22","tag_id":"clxjsxtvx000blq6gphmvstjj","_id":"clxjsxtwf001ulq6guamd3gbx"},{"post_id":"clxjsxtvu0006lq6gwwfn2q22","tag_id":"clxjsxtw0000glq6g3ccr3fmq","_id":"clxjsxtwg001xlq6gjvr8g1df"},{"post_id":"clxjsxtvw0008lq6gk73exovt","tag_id":"clxjsxtvu0005lq6gz1mlpwux","_id":"clxjsxtwg0020lq6g4hdagn8v"},{"post_id":"clxjsxtvw0008lq6gk73exovt","tag_id":"clxjsxtvx000blq6gphmvstjj","_id":"clxjsxtwg0021lq6g080pq0j8"},{"post_id":"clxjsxtvw0008lq6gk73exovt","tag_id":"clxjsxtw0000glq6g3ccr3fmq","_id":"clxjsxtwh0023lq6gaz4th43i"},{"post_id":"clxjsxtvx0009lq6g2u38v1f2","tag_id":"clxjsxtvu0005lq6gz1mlpwux","_id":"clxjsxtwh0026lq6g7vsttcvg"},{"post_id":"clxjsxtvx0009lq6g2u38v1f2","tag_id":"clxjsxtwg001ylq6gzg5jsb7h","_id":"clxjsxtwh0027lq6gys63zrwa"},{"post_id":"clxjsxtvx0009lq6g2u38v1f2","tag_id":"clxjsxtwg0022lq6g3cqvd2vo","_id":"clxjsxtwh0029lq6gzjmcgy2v"},{"post_id":"clxjsxtvx0009lq6g2u38v1f2","tag_id":"clxjsxtwh0024lq6ganyrhcpf","_id":"clxjsxtwh002alq6gymexe5rm"},{"post_id":"clxjsxtvy000clq6ghqk6xyh2","tag_id":"clxjsxtvu0005lq6gz1mlpwux","_id":"clxjsxtwh002clq6gynmx3p50"},{"post_id":"clxjsxtvy000clq6ghqk6xyh2","tag_id":"clxjsxtwh0025lq6g7poruolt","_id":"clxjsxtwh002dlq6g9tqxh34s"},{"post_id":"clxjsxtvy000clq6ghqk6xyh2","tag_id":"clxjsxtwh0028lq6gjjxds2s7","_id":"clxjsxtwi002flq6gpqlgb1a0"},{"post_id":"clxjsxtvz000elq6gml657nch","tag_id":"clxjsxtwh002blq6gokyblahk","_id":"clxjsxtwi002hlq6glkwvtzpa"},{"post_id":"clxjsxtvz000elq6gml657nch","tag_id":"clxjsxtwh002elq6gp85vgeqt","_id":"clxjsxtwi002ilq6gi4vyb3e9"},{"post_id":"clxjsxtw1000ilq6gwxv3djhs","tag_id":"clxjsxtwh002blq6gokyblahk","_id":"clxjsxtwj002nlq6gd5h1l80i"},{"post_id":"clxjsxtw1000ilq6gwxv3djhs","tag_id":"clxjsxtwi002jlq6gpmha9hen","_id":"clxjsxtwj002olq6gbir395bu"},{"post_id":"clxjsxtw1000ilq6gwxv3djhs","tag_id":"clxjsxtwj002klq6gvlyhr7x1","_id":"clxjsxtwj002qlq6gclcuij50"},{"post_id":"clxjsxtw1000ilq6gwxv3djhs","tag_id":"clxjsxtwj002llq6g5gj35pei","_id":"clxjsxtwj002rlq6gsp9h08d7"},{"post_id":"clxjsxtw2000klq6gic4px3vs","tag_id":"clxjsxtwj002mlq6gl5rpgyfa","_id":"clxjsxtwk002tlq6g2ai13w5x"},{"post_id":"clxjsxtw2000klq6gic4px3vs","tag_id":"clxjsxtwj002plq6gkzlrxpx2","_id":"clxjsxtwk002ulq6giybebdpd"},{"post_id":"clxjsxtw3000olq6g5qlal9hh","tag_id":"clxjsxtwj002slq6gd3qvt03s","_id":"clxjsxtwk002xlq6gmukbkjy5"},{"post_id":"clxjsxtw3000olq6g5qlal9hh","tag_id":"clxjsxtwk002vlq6gg2d0oao3","_id":"clxjsxtwk002ylq6g4fb4pmck"},{"post_id":"clxjsxtw3000olq6g5qlal9hh","tag_id":"clxjsxtvu0005lq6gz1mlpwux","_id":"clxjsxtwl0030lq6gkcqt7ooo"},{"post_id":"clxjsxtw4000rlq6gvz461m9p","tag_id":"clxjsxtwj002mlq6gl5rpgyfa","_id":"clxjsxtwl0032lq6ghovgr3fk"},{"post_id":"clxjsxtw4000rlq6gvz461m9p","tag_id":"clxjsxtwj002plq6gkzlrxpx2","_id":"clxjsxtwl0033lq6g3z942ilf"},{"post_id":"clxjsxtw6000wlq6gf6kg48vd","tag_id":"clxjsxtwl0031lq6gluedc6m1","_id":"clxjsxtwm0037lq6gppn1d2w1"},{"post_id":"clxjsxtw6000wlq6gf6kg48vd","tag_id":"clxjsxtwl0034lq6gi1oqc46b","_id":"clxjsxtwm0038lq6gw1lm1rbr"},{"post_id":"clxjsxtw6000wlq6gf6kg48vd","tag_id":"clxjsxtwl0035lq6gda2q46rw","_id":"clxjsxtwm003alq6ghlrugmaf"},{"post_id":"clxjsxtw7000zlq6gik3dkvns","tag_id":"clxjsxtwl0036lq6g2oldk816","_id":"clxjsxtwm003dlq6g1st77u15"},{"post_id":"clxjsxtw7000zlq6gik3dkvns","tag_id":"clxjsxtwm0039lq6gywm55elw","_id":"clxjsxtwm003elq6g4hn7btra"},{"post_id":"clxjsxtw7000zlq6gik3dkvns","tag_id":"clxjsxtwm003blq6gn1gqbqjo","_id":"clxjsxtwn003glq6gn77z6oae"},{"post_id":"clxjsxtw80013lq6gc2ker5mn","tag_id":"clxjsxtvu0005lq6gz1mlpwux","_id":"clxjsxtwn003jlq6g7vhqzj5a"},{"post_id":"clxjsxtw80013lq6gc2ker5mn","tag_id":"clxjsxtwm003clq6g7ob0fh0a","_id":"clxjsxtwn003klq6gll8x1iiy"},{"post_id":"clxjsxtw80013lq6gc2ker5mn","tag_id":"clxjsxtwn003flq6gmuyy1cea","_id":"clxjsxtwo003mlq6g37b4y29l"},{"post_id":"clxjsxtw80013lq6gc2ker5mn","tag_id":"clxjsxtwn003hlq6gjiiulcfn","_id":"clxjsxtwo003nlq6gfncac043"},{"post_id":"clxjsxtw80014lq6gbxnkycum","tag_id":"clxjsxtwl0036lq6g2oldk816","_id":"clxjsxtwp003slq6gofqhak98"},{"post_id":"clxjsxtw80014lq6gbxnkycum","tag_id":"clxjsxtwm0039lq6gywm55elw","_id":"clxjsxtwp003tlq6gnjakwf56"},{"post_id":"clxjsxtw80014lq6gbxnkycum","tag_id":"clxjsxtwh002blq6gokyblahk","_id":"clxjsxtwp003vlq6gdve805zx"},{"post_id":"clxjsxtw80014lq6gbxnkycum","tag_id":"clxjsxtwo003plq6gqexy9hut","_id":"clxjsxtwp003wlq6gbm04cp33"},{"post_id":"clxjsxtw80014lq6gbxnkycum","tag_id":"clxjsxtwo003qlq6gabc7o7yz","_id":"clxjsxtwp003ylq6gjlyar4u9"},{"post_id":"clxjsxtwa0018lq6gka2w672d","tag_id":"clxjsxtwp003rlq6goaonczfh","_id":"clxjsxtwq0040lq6g7x1yhuyq"},{"post_id":"clxjsxtwa0018lq6gka2w672d","tag_id":"clxjsxtwp003ulq6g7q3bh0ms","_id":"clxjsxtwq0041lq6gqtnh76zf"},{"post_id":"clxjsxtwa0018lq6gka2w672d","tag_id":"clxjsxtwp003xlq6gn0g6dwap","_id":"clxjsxtwq0043lq6gzeh98il1"},{"post_id":"clxjsxtwb001blq6gu0l3f4d4","tag_id":"clxjsxtwl0036lq6g2oldk816","_id":"clxjsxtwr0046lq6gx06pdih0"},{"post_id":"clxjsxtwb001blq6gu0l3f4d4","tag_id":"clxjsxtwm0039lq6gywm55elw","_id":"clxjsxtwr0047lq6gl4vkqbh9"},{"post_id":"clxjsxtwb001blq6gu0l3f4d4","tag_id":"clxjsxtwh002blq6gokyblahk","_id":"clxjsxtwr0049lq6gtci9m8mt"},{"post_id":"clxjsxtwc001glq6gseji55t1","tag_id":"clxjsxtwq0045lq6gpierji3c","_id":"clxjsxtwr004clq6g077rk7h4"},{"post_id":"clxjsxtwc001glq6gseji55t1","tag_id":"clxjsxtwr0048lq6gifr892wm","_id":"clxjsxtwr004dlq6g4hndxc2h"},{"post_id":"clxjsxtwc001glq6gseji55t1","tag_id":"clxjsxtwr004alq6gkdxhxl6e","_id":"clxjsxtws004flq6gsb7ol62p"},{"post_id":"clxjsxtwd001jlq6golo6x195","tag_id":"clxjsxtvu0005lq6gz1mlpwux","_id":"clxjsxtws004glq6gv2ijrl6j"},{"post_id":"clxjsxtwd001jlq6golo6x195","tag_id":"clxjsxtwr004blq6gsn04kvwt","_id":"clxjsxtws004hlq6gmvr4u4ef"},{"post_id":"clxjsxtwd001jlq6golo6x195","tag_id":"clxjsxtwr004elq6gv8tfbh8j","_id":"clxjsxtws004ilq6gl5loutt3"}],"Tag":[{"name":"Android","_id":"clxjsxtvu0005lq6gz1mlpwux"},{"name":"Activity启动","_id":"clxjsxtvx000blq6gphmvstjj"},{"name":"系统","_id":"clxjsxtw0000glq6g3ccr3fmq"},{"name":"Proguard","_id":"clxjsxtwg001ylq6gzg5jsb7h"},{"name":"混淆","_id":"clxjsxtwg0022lq6g3cqvd2vo"},{"name":"译文","_id":"clxjsxtwh0024lq6ganyrhcpf"},{"name":"NDK","_id":"clxjsxtwh0025lq6g7poruolt"},{"name":"Android Sudio","_id":"clxjsxtwh0028lq6gjjxds2s7"},{"name":"SpringMVC","_id":"clxjsxtwh002blq6gokyblahk"},{"name":"请求对象绑定","_id":"clxjsxtwh002elq6gp85vgeqt"},{"name":"request","_id":"clxjsxtwi002jlq6gpmha9hen"},{"name":"controller","_id":"clxjsxtwj002klq6gvlyhr7x1"},{"name":"DispatcherServlet","_id":"clxjsxtwj002llq6g5gj35pei"},{"name":"TensorFlow","_id":"clxjsxtwj002mlq6gl5rpgyfa"},{"name":"CNN","_id":"clxjsxtwj002plq6gkzlrxpx2"},{"name":"FastJson","_id":"clxjsxtwj002slq6gd3qvt03s"},{"name":"Json序列化","_id":"clxjsxtwk002vlq6gg2d0oao3"},{"name":"iOS","_id":"clxjsxtwl0031lq6gluedc6m1"},{"name":"LinkMap","_id":"clxjsxtwl0034lq6gi1oqc46b"},{"name":"Python","_id":"clxjsxtwl0035lq6gda2q46rw"},{"name":"Java Web","_id":"clxjsxtwl0036lq6g2oldk816"},{"name":"服务端","_id":"clxjsxtwm0039lq6gywm55elw"},{"name":"SSH","_id":"clxjsxtwm003blq6gn1gqbqjo"},{"name":"View","_id":"clxjsxtwm003clq6g7ob0fh0a"},{"name":"知乎","_id":"clxjsxtwn003flq6gmuyy1cea"},{"name":"按钮点击","_id":"clxjsxtwn003hlq6gjiiulcfn"},{"name":"MyBatis","_id":"clxjsxtwo003plq6gqexy9hut"},{"name":"SSM","_id":"clxjsxtwo003qlq6gabc7o7yz"},{"name":"python","_id":"clxjsxtwp003rlq6goaonczfh"},{"name":"安全","_id":"clxjsxtwp003ulq6g7q3bh0ms"},{"name":"密码生成","_id":"clxjsxtwp003xlq6gn0g6dwap"},{"name":"蒙哥马利约减","_id":"clxjsxtwq0045lq6gpierji3c"},{"name":"蒙哥马利乘法","_id":"clxjsxtwr0048lq6gifr892wm"},{"name":"蒙哥马利幂乘","_id":"clxjsxtwr004alq6gkdxhxl6e"},{"name":"移动安全","_id":"clxjsxtwr004blq6gsn04kvwt"},{"name":"逆向","_id":"clxjsxtwr004elq6gv8tfbh8j"}]}}